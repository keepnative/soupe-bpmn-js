{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib/Modeler.js","lib/i18n/Translate.js","lib/i18n/zh-cn.js","node_modules/base64-js/index.js","node_modules/bpmn-js-properties-panel/index.js","node_modules/bpmn-js-properties-panel/lib/PropertiesActivator.js","node_modules/bpmn-js-properties-panel/lib/PropertiesPanel.js","node_modules/bpmn-js-properties-panel/lib/Utils.js","node_modules/bpmn-js-properties-panel/lib/cmd/CreateAndReferenceHandler.js","node_modules/bpmn-js-properties-panel/lib/cmd/CreateBusinessObjectListHandler.js","node_modules/bpmn-js-properties-panel/lib/cmd/MultiCommandHandler.js","node_modules/bpmn-js-properties-panel/lib/cmd/UpdateBusinessObjectHandler.js","node_modules/bpmn-js-properties-panel/lib/cmd/UpdateBusinessObjectListHandler.js","node_modules/bpmn-js-properties-panel/lib/cmd/index.js","node_modules/bpmn-js-properties-panel/lib/factory/CheckboxEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/ComboEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/EntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/EntryFieldDescription.js","node_modules/bpmn-js-properties-panel/lib/factory/LabelFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/LinkEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/SelectEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/TableEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/TextBoxEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/TextInputEntryFactory.js","node_modules/bpmn-js-properties-panel/lib/factory/ValidationAwareTextInput.js","node_modules/bpmn-js-properties-panel/lib/helper/CmdHelper.js","node_modules/bpmn-js-properties-panel/lib/helper/ElementHelper.js","node_modules/bpmn-js-properties-panel/lib/helper/EventDefinitionHelper.js","node_modules/bpmn-js-properties-panel/lib/helper/ExtensionElementsHelper.js","node_modules/bpmn-js-properties-panel/lib/helper/ImplementationTypeHelper.js","node_modules/bpmn-js-properties-panel/lib/helper/InputOutputHelper.js","node_modules/bpmn-js-properties-panel/lib/helper/ParticipantHelper.js","node_modules/bpmn-js-properties-panel/lib/index.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/EventProps.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/IdProps.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/LinkProps.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/NameProps.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/ProcessProps.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/CompensateEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/ConditionalEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/ElementReferenceProperty.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/ErrorEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/EscalationEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/EventDefinitionReference.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/MessageEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/Name.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/SignalEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/bpmn/parts/implementation/TimerEventDefinition.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/JBPMPropertiesProvider.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/index.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/CallActivityProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/GatewayProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/GlobalsProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/ImportsProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/InputOutputParameterProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/InputOutputProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/ProcessProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/ScriptTaskProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/SequenceFlowProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/ServiceTaskDelegateProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/UserTaskProps.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/Callable.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/Delegate.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/ExtensionElements.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/External.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/ImplementationType.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/InputOutput.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/InputOutputParameter.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/ResultVariable.js","node_modules/bpmn-js-properties-panel/lib/provider/jbpm/parts/implementation/Script.js","node_modules/bpmn-js-properties-panel/resources/drools.json","node_modules/bpmn-js-properties-panel/resources/jbpm.json","node_modules/bpmn-js/lib/Modeler.js","node_modules/bpmn-js/lib/NavigatedViewer.js","node_modules/bpmn-js/lib/Viewer.js","node_modules/bpmn-js/lib/core/index.js","node_modules/bpmn-js/lib/draw/BpmnRenderer.js","node_modules/bpmn-js/lib/draw/PathMap.js","node_modules/bpmn-js/lib/draw/index.js","node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResize.js","node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResizeProvider.js","node_modules/bpmn-js/lib/features/auto-resize/index.js","node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js","node_modules/bpmn-js/lib/features/context-pad/index.js","node_modules/bpmn-js/lib/features/copy-paste/BpmnCopyPaste.js","node_modules/bpmn-js/lib/features/copy-paste/index.js","node_modules/bpmn-js/lib/features/distribute-elements/BpmnDistributeElements.js","node_modules/bpmn-js/lib/features/distribute-elements/index.js","node_modules/bpmn-js/lib/features/editor-actions/BpmnEditorActions.js","node_modules/bpmn-js/lib/features/editor-actions/index.js","node_modules/bpmn-js/lib/features/global-connect/BpmnGlobalConnect.js","node_modules/bpmn-js/lib/features/global-connect/index.js","node_modules/bpmn-js/lib/features/keyboard/BpmnKeyBindings.js","node_modules/bpmn-js/lib/features/keyboard/index.js","node_modules/bpmn-js/lib/features/label-editing/LabelEditingPreview.js","node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js","node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js","node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js","node_modules/bpmn-js/lib/features/label-editing/index.js","node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js","node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js","node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js","node_modules/bpmn-js/lib/features/modeling/ElementFactory.js","node_modules/bpmn-js/lib/features/modeling/Modeling.js","node_modules/bpmn-js/lib/features/modeling/behavior/AppendBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/CopyPasteBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/CreateBoundaryEventBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/CreateDataObjectBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/CreateParticipantBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/DeleteLaneBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/ImportDockingFix.js","node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/ModelingFeedback.js","node_modules/bpmn-js/lib/features/modeling/behavior/RemoveElementBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/RemoveParticipantBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceConnectionBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceElementBehaviour.js","node_modules/bpmn-js/lib/features/modeling/behavior/ResizeLaneBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/ToggleElementCollapseBehaviour.js","node_modules/bpmn-js/lib/features/modeling/behavior/UnclaimIdBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/UnsetDefaultFlowBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/UpdateFlowNodeRefsBehavior.js","node_modules/bpmn-js/lib/features/modeling/behavior/index.js","node_modules/bpmn-js/lib/features/modeling/behavior/util/GeometricUtil.js","node_modules/bpmn-js/lib/features/modeling/behavior/util/LabelLayoutUtil.js","node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js","node_modules/bpmn-js/lib/features/modeling/behavior/util/LineIntersect.js","node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/IdClaimHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/ResizeLaneHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/SetColorHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js","node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js","node_modules/bpmn-js/lib/features/modeling/index.js","node_modules/bpmn-js/lib/features/modeling/util/LaneUtil.js","node_modules/bpmn-js/lib/features/modeling/util/ModelingUtil.js","node_modules/bpmn-js/lib/features/ordering/BpmnOrderingProvider.js","node_modules/bpmn-js/lib/features/ordering/index.js","node_modules/bpmn-js/lib/features/palette/PaletteProvider.js","node_modules/bpmn-js/lib/features/palette/index.js","node_modules/bpmn-js/lib/features/popup-menu/ReplaceMenuProvider.js","node_modules/bpmn-js/lib/features/popup-menu/index.js","node_modules/bpmn-js/lib/features/popup-menu/util/TypeUtil.js","node_modules/bpmn-js/lib/features/replace-preview/BpmnReplacePreview.js","node_modules/bpmn-js/lib/features/replace-preview/index.js","node_modules/bpmn-js/lib/features/replace/BpmnReplace.js","node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js","node_modules/bpmn-js/lib/features/replace/index.js","node_modules/bpmn-js/lib/features/rules/BpmnRules.js","node_modules/bpmn-js/lib/features/rules/index.js","node_modules/bpmn-js/lib/features/search/BpmnSearchProvider.js","node_modules/bpmn-js/lib/features/search/index.js","node_modules/bpmn-js/lib/features/snapping/BpmnSnapping.js","node_modules/bpmn-js/lib/features/snapping/BpmnSnappingUtil.js","node_modules/bpmn-js/lib/features/snapping/index.js","node_modules/bpmn-js/lib/import/BpmnImporter.js","node_modules/bpmn-js/lib/import/BpmnTreeWalker.js","node_modules/bpmn-js/lib/import/Importer.js","node_modules/bpmn-js/lib/import/Util.js","node_modules/bpmn-js/lib/import/index.js","node_modules/bpmn-js/lib/util/DiUtil.js","node_modules/bpmn-js/lib/util/LabelUtil.js","node_modules/bpmn-js/lib/util/ModelUtil.js","node_modules/bpmn-js/lib/util/PoweredByUtil.js","node_modules/bpmn-js/lib/util/model/ModelCloneHelper.js","node_modules/bpmn-js/lib/util/model/ModelCloneUtils.js","node_modules/bpmn-moddle/index.js","node_modules/bpmn-moddle/lib/bpmn-moddle.js","node_modules/bpmn-moddle/lib/simple.js","node_modules/bpmn-moddle/resources/bpmn-io/json/bioc.json","node_modules/bpmn-moddle/resources/bpmn/json/bpmn.json","node_modules/bpmn-moddle/resources/bpmn/json/bpmndi.json","node_modules/bpmn-moddle/resources/bpmn/json/dc.json","node_modules/bpmn-moddle/resources/bpmn/json/di.json","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/component-classes/index.js","node_modules/component-closest/index.js","node_modules/component-delegate/index.js","node_modules/component-delegate/node_modules/component-closest/index.js","node_modules/component-delegate/node_modules/component-event/index.js","node_modules/component-event/index.js","node_modules/component-indexof/index.js","node_modules/component-matches-selector/index.js","node_modules/component-query/index.js","node_modules/core-util-is/lib/util.js","node_modules/diagram-js-direct-editing/index.js","node_modules/diagram-js-direct-editing/lib/DirectEditing.js","node_modules/diagram-js-direct-editing/lib/TextBox.js","node_modules/diagram-js/index.js","node_modules/diagram-js/lib/Diagram.js","node_modules/diagram-js/lib/command/CommandInterceptor.js","node_modules/diagram-js/lib/command/CommandStack.js","node_modules/diagram-js/lib/command/index.js","node_modules/diagram-js/lib/core/Canvas.js","node_modules/diagram-js/lib/core/ElementFactory.js","node_modules/diagram-js/lib/core/ElementRegistry.js","node_modules/diagram-js/lib/core/EventBus.js","node_modules/diagram-js/lib/core/GraphicsFactory.js","node_modules/diagram-js/lib/core/index.js","node_modules/diagram-js/lib/draw/BaseRenderer.js","node_modules/diagram-js/lib/draw/DefaultRenderer.js","node_modules/diagram-js/lib/draw/Styles.js","node_modules/diagram-js/lib/draw/index.js","node_modules/diagram-js/lib/features/align-elements/AlignElements.js","node_modules/diagram-js/lib/features/align-elements/index.js","node_modules/diagram-js/lib/features/attach-support/AttachSupport.js","node_modules/diagram-js/lib/features/attach-support/index.js","node_modules/diagram-js/lib/features/auto-resize/AutoResize.js","node_modules/diagram-js/lib/features/auto-resize/AutoResizeProvider.js","node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js","node_modules/diagram-js/lib/features/auto-scroll/index.js","node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js","node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js","node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js","node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js","node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js","node_modules/diagram-js/lib/features/bendpoints/index.js","node_modules/diagram-js/lib/features/change-support/ChangeSupport.js","node_modules/diagram-js/lib/features/change-support/index.js","node_modules/diagram-js/lib/features/clipboard/Clipboard.js","node_modules/diagram-js/lib/features/clipboard/index.js","node_modules/diagram-js/lib/features/connect/Connect.js","node_modules/diagram-js/lib/features/connect/index.js","node_modules/diagram-js/lib/features/context-pad/ContextPad.js","node_modules/diagram-js/lib/features/context-pad/index.js","node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js","node_modules/diagram-js/lib/features/copy-paste/index.js","node_modules/diagram-js/lib/features/create/Create.js","node_modules/diagram-js/lib/features/create/index.js","node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js","node_modules/diagram-js/lib/features/distribute-elements/index.js","node_modules/diagram-js/lib/features/dragging/Dragging.js","node_modules/diagram-js/lib/features/dragging/HoverFix.js","node_modules/diagram-js/lib/features/dragging/index.js","node_modules/diagram-js/lib/features/editor-actions/EditorActions.js","node_modules/diagram-js/lib/features/editor-actions/index.js","node_modules/diagram-js/lib/features/global-connect/GlobalConnect.js","node_modules/diagram-js/lib/features/global-connect/index.js","node_modules/diagram-js/lib/features/hand-tool/HandTool.js","node_modules/diagram-js/lib/features/hand-tool/index.js","node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js","node_modules/diagram-js/lib/features/interaction-events/index.js","node_modules/diagram-js/lib/features/keyboard/Keyboard.js","node_modules/diagram-js/lib/features/keyboard/index.js","node_modules/diagram-js/lib/features/label-support/LabelSupport.js","node_modules/diagram-js/lib/features/label-support/index.js","node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js","node_modules/diagram-js/lib/features/lasso-tool/index.js","node_modules/diagram-js/lib/features/modeling/Modeling.js","node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/NoopHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/PasteHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js","node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js","node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js","node_modules/diagram-js/lib/features/mouse-tracking/MouseTracking.js","node_modules/diagram-js/lib/features/mouse-tracking/index.js","node_modules/diagram-js/lib/features/move/Move.js","node_modules/diagram-js/lib/features/move/MovePreview.js","node_modules/diagram-js/lib/features/move/index.js","node_modules/diagram-js/lib/features/ordering/OrderingProvider.js","node_modules/diagram-js/lib/features/outline/Outline.js","node_modules/diagram-js/lib/features/outline/index.js","node_modules/diagram-js/lib/features/overlays/Overlays.js","node_modules/diagram-js/lib/features/overlays/index.js","node_modules/diagram-js/lib/features/palette/Palette.js","node_modules/diagram-js/lib/features/palette/index.js","node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js","node_modules/diagram-js/lib/features/popup-menu/index.js","node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js","node_modules/diagram-js/lib/features/preview-support/index.js","node_modules/diagram-js/lib/features/replace/Replace.js","node_modules/diagram-js/lib/features/replace/index.js","node_modules/diagram-js/lib/features/resize/Resize.js","node_modules/diagram-js/lib/features/resize/ResizeHandles.js","node_modules/diagram-js/lib/features/resize/ResizePreview.js","node_modules/diagram-js/lib/features/resize/ResizeUtil.js","node_modules/diagram-js/lib/features/resize/index.js","node_modules/diagram-js/lib/features/rules/RuleProvider.js","node_modules/diagram-js/lib/features/rules/Rules.js","node_modules/diagram-js/lib/features/rules/index.js","node_modules/diagram-js/lib/features/search-pad/SearchPad.js","node_modules/diagram-js/lib/features/search-pad/index.js","node_modules/diagram-js/lib/features/selection/Selection.js","node_modules/diagram-js/lib/features/selection/SelectionBehavior.js","node_modules/diagram-js/lib/features/selection/SelectionVisuals.js","node_modules/diagram-js/lib/features/selection/index.js","node_modules/diagram-js/lib/features/snapping/SnapContext.js","node_modules/diagram-js/lib/features/snapping/SnapUtil.js","node_modules/diagram-js/lib/features/snapping/Snapping.js","node_modules/diagram-js/lib/features/space-tool/SpaceTool.js","node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js","node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js","node_modules/diagram-js/lib/features/space-tool/index.js","node_modules/diagram-js/lib/features/tool-manager/ToolManager.js","node_modules/diagram-js/lib/features/tool-manager/index.js","node_modules/diagram-js/lib/features/tooltips/Tooltips.js","node_modules/diagram-js/lib/features/tooltips/index.js","node_modules/diagram-js/lib/features/touch/TouchFix.js","node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js","node_modules/diagram-js/lib/features/touch/index.js","node_modules/diagram-js/lib/i18n/translate/index.js","node_modules/diagram-js/lib/i18n/translate/translate.js","node_modules/diagram-js/lib/layout/BaseLayouter.js","node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js","node_modules/diagram-js/lib/layout/LayoutUtil.js","node_modules/diagram-js/lib/layout/ManhattanLayout.js","node_modules/diagram-js/lib/model/index.js","node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js","node_modules/diagram-js/lib/navigation/movecanvas/index.js","node_modules/diagram-js/lib/navigation/touch/index.js","node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js","node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js","node_modules/diagram-js/lib/navigation/zoomscroll/index.js","node_modules/diagram-js/lib/util/AttachUtil.js","node_modules/diagram-js/lib/util/ClickTrap.js","node_modules/diagram-js/lib/util/Collections.js","node_modules/diagram-js/lib/util/CopyPasteUtil.js","node_modules/diagram-js/lib/util/Cursor.js","node_modules/diagram-js/lib/util/Elements.js","node_modules/diagram-js/lib/util/Event.js","node_modules/diagram-js/lib/util/Geometry.js","node_modules/diagram-js/lib/util/GraphicsUtil.js","node_modules/diagram-js/lib/util/IdGenerator.js","node_modules/diagram-js/lib/util/Intersection.js","node_modules/diagram-js/lib/util/LineIntersection.js","node_modules/diagram-js/lib/util/Math.js","node_modules/diagram-js/lib/util/Mouse.js","node_modules/diagram-js/lib/util/Platform.js","node_modules/diagram-js/lib/util/PositionUtil.js","node_modules/diagram-js/lib/util/Removal.js","node_modules/diagram-js/lib/util/RenderUtil.js","node_modules/diagram-js/lib/util/SvgTransformUtil.js","node_modules/diagram-js/lib/util/Text.js","node_modules/didi/lib/annotation.js","node_modules/didi/lib/index.js","node_modules/didi/lib/injector.js","node_modules/didi/lib/module.js","node_modules/domify/index.js","node_modules/events/events.js","node_modules/hammerjs/hammer.js","node_modules/hat/index.js","node_modules/ids/index.js","node_modules/ieee754/index.js","node_modules/inherits/inherits_browser.js","node_modules/is-buffer/index.js","node_modules/isarray/index.js","node_modules/lodash/array/findIndex.js","node_modules/lodash/array/flatten.js","node_modules/lodash/array/flattenDeep.js","node_modules/lodash/array/intersection.js","node_modules/lodash/array/last.js","node_modules/lodash/array/union.js","node_modules/lodash/array/uniq.js","node_modules/lodash/array/unique.js","node_modules/lodash/array/without.js","node_modules/lodash/array/xor.js","node_modules/lodash/chain/lodash.js","node_modules/lodash/collection/any.js","node_modules/lodash/collection/every.js","node_modules/lodash/collection/filter.js","node_modules/lodash/collection/find.js","node_modules/lodash/collection/forEach.js","node_modules/lodash/collection/groupBy.js","node_modules/lodash/collection/indexBy.js","node_modules/lodash/collection/map.js","node_modules/lodash/collection/reduce.js","node_modules/lodash/collection/reject.js","node_modules/lodash/collection/size.js","node_modules/lodash/collection/some.js","node_modules/lodash/collection/sortBy.js","node_modules/lodash/date/now.js","node_modules/lodash/function/bind.js","node_modules/lodash/function/debounce.js","node_modules/lodash/function/defer.js","node_modules/lodash/function/restParam.js","node_modules/lodash/internal/LazyWrapper.js","node_modules/lodash/internal/LodashWrapper.js","node_modules/lodash/internal/SetCache.js","node_modules/lodash/internal/arrayCopy.js","node_modules/lodash/internal/arrayEach.js","node_modules/lodash/internal/arrayEvery.js","node_modules/lodash/internal/arrayFilter.js","node_modules/lodash/internal/arrayMap.js","node_modules/lodash/internal/arrayPush.js","node_modules/lodash/internal/arrayReduce.js","node_modules/lodash/internal/arraySome.js","node_modules/lodash/internal/assignWith.js","node_modules/lodash/internal/baseAssign.js","node_modules/lodash/internal/baseCallback.js","node_modules/lodash/internal/baseClone.js","node_modules/lodash/internal/baseCompareAscending.js","node_modules/lodash/internal/baseCopy.js","node_modules/lodash/internal/baseCreate.js","node_modules/lodash/internal/baseDelay.js","node_modules/lodash/internal/baseDifference.js","node_modules/lodash/internal/baseEach.js","node_modules/lodash/internal/baseEvery.js","node_modules/lodash/internal/baseFilter.js","node_modules/lodash/internal/baseFind.js","node_modules/lodash/internal/baseFindIndex.js","node_modules/lodash/internal/baseFlatten.js","node_modules/lodash/internal/baseFor.js","node_modules/lodash/internal/baseForIn.js","node_modules/lodash/internal/baseForOwn.js","node_modules/lodash/internal/baseGet.js","node_modules/lodash/internal/baseIndexOf.js","node_modules/lodash/internal/baseIsEqual.js","node_modules/lodash/internal/baseIsEqualDeep.js","node_modules/lodash/internal/baseIsMatch.js","node_modules/lodash/internal/baseLodash.js","node_modules/lodash/internal/baseMap.js","node_modules/lodash/internal/baseMatches.js","node_modules/lodash/internal/baseMatchesProperty.js","node_modules/lodash/internal/baseMerge.js","node_modules/lodash/internal/baseMergeDeep.js","node_modules/lodash/internal/baseProperty.js","node_modules/lodash/internal/basePropertyDeep.js","node_modules/lodash/internal/baseReduce.js","node_modules/lodash/internal/baseSetData.js","node_modules/lodash/internal/baseSlice.js","node_modules/lodash/internal/baseSome.js","node_modules/lodash/internal/baseSortBy.js","node_modules/lodash/internal/baseToString.js","node_modules/lodash/internal/baseUniq.js","node_modules/lodash/internal/baseValues.js","node_modules/lodash/internal/bindCallback.js","node_modules/lodash/internal/bufferClone.js","node_modules/lodash/internal/cacheIndexOf.js","node_modules/lodash/internal/cachePush.js","node_modules/lodash/internal/compareAscending.js","node_modules/lodash/internal/composeArgs.js","node_modules/lodash/internal/composeArgsRight.js","node_modules/lodash/internal/createAggregator.js","node_modules/lodash/internal/createAssigner.js","node_modules/lodash/internal/createBaseEach.js","node_modules/lodash/internal/createBaseFor.js","node_modules/lodash/internal/createBindWrapper.js","node_modules/lodash/internal/createCache.js","node_modules/lodash/internal/createCtorWrapper.js","node_modules/lodash/internal/createFind.js","node_modules/lodash/internal/createFindIndex.js","node_modules/lodash/internal/createForEach.js","node_modules/lodash/internal/createHybridWrapper.js","node_modules/lodash/internal/createPartialWrapper.js","node_modules/lodash/internal/createReduce.js","node_modules/lodash/internal/createWrapper.js","node_modules/lodash/internal/equalArrays.js","node_modules/lodash/internal/equalByTag.js","node_modules/lodash/internal/equalObjects.js","node_modules/lodash/internal/getData.js","node_modules/lodash/internal/getFuncName.js","node_modules/lodash/internal/getLength.js","node_modules/lodash/internal/getMatchData.js","node_modules/lodash/internal/getNative.js","node_modules/lodash/internal/indexOfNaN.js","node_modules/lodash/internal/initCloneArray.js","node_modules/lodash/internal/initCloneByTag.js","node_modules/lodash/internal/initCloneObject.js","node_modules/lodash/internal/isArrayLike.js","node_modules/lodash/internal/isIndex.js","node_modules/lodash/internal/isIterateeCall.js","node_modules/lodash/internal/isKey.js","node_modules/lodash/internal/isLaziable.js","node_modules/lodash/internal/isLength.js","node_modules/lodash/internal/isObjectLike.js","node_modules/lodash/internal/isStrictComparable.js","node_modules/lodash/internal/mergeData.js","node_modules/lodash/internal/metaMap.js","node_modules/lodash/internal/pickByArray.js","node_modules/lodash/internal/pickByCallback.js","node_modules/lodash/internal/realNames.js","node_modules/lodash/internal/reorder.js","node_modules/lodash/internal/replaceHolders.js","node_modules/lodash/internal/setData.js","node_modules/lodash/internal/shimKeys.js","node_modules/lodash/internal/sortedUniq.js","node_modules/lodash/internal/toObject.js","node_modules/lodash/internal/toPath.js","node_modules/lodash/internal/wrapperClone.js","node_modules/lodash/lang/clone.js","node_modules/lodash/lang/isArguments.js","node_modules/lodash/lang/isArray.js","node_modules/lodash/lang/isEmpty.js","node_modules/lodash/lang/isFunction.js","node_modules/lodash/lang/isNative.js","node_modules/lodash/lang/isNumber.js","node_modules/lodash/lang/isObject.js","node_modules/lodash/lang/isPlainObject.js","node_modules/lodash/lang/isString.js","node_modules/lodash/lang/isTypedArray.js","node_modules/lodash/lang/toPlainObject.js","node_modules/lodash/object/assign.js","node_modules/lodash/object/get.js","node_modules/lodash/object/has.js","node_modules/lodash/object/keys.js","node_modules/lodash/object/keysIn.js","node_modules/lodash/object/merge.js","node_modules/lodash/object/omit.js","node_modules/lodash/object/pairs.js","node_modules/lodash/object/pick.js","node_modules/lodash/object/transform.js","node_modules/lodash/object/values.js","node_modules/lodash/utility/identity.js","node_modules/lodash/utility/noop.js","node_modules/lodash/utility/property.js","node_modules/min-dom/lib/attr.js","node_modules/min-dom/lib/classes.js","node_modules/min-dom/lib/clear.js","node_modules/min-dom/lib/closest.js","node_modules/min-dom/lib/delegate.js","node_modules/min-dom/lib/domify.js","node_modules/min-dom/lib/event.js","node_modules/min-dom/lib/matches.js","node_modules/min-dom/lib/query.js","node_modules/min-dom/lib/remove.js","node_modules/moddle-xml/lib/common.js","node_modules/moddle-xml/lib/reader.js","node_modules/moddle-xml/lib/writer.js","node_modules/moddle/index.js","node_modules/moddle/lib/base.js","node_modules/moddle/lib/descriptor-builder.js","node_modules/moddle/lib/factory.js","node_modules/moddle/lib/moddle.js","node_modules/moddle/lib/ns.js","node_modules/moddle/lib/properties.js","node_modules/moddle/lib/registry.js","node_modules/moddle/lib/types.js","node_modules/object-refs/index.js","node_modules/object-refs/lib/collection.js","node_modules/object-refs/lib/refs.js","node_modules/process-nextick-args/index.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","node_modules/readable-stream/passthrough.js","node_modules/readable-stream/readable-browser.js","node_modules/readable-stream/transform.js","node_modules/readable-stream/writable-browser.js","node_modules/safe-buffer/index.js","node_modules/sax/lib/sax.js","node_modules/scroll-tabs/index.js","node_modules/selection-update/index.js","node_modules/stream-browserify/index.js","node_modules/string_decoder/index.js","node_modules/tiny-stack/lib/tiny-stack.js","node_modules/tiny-svg/lib/append.js","node_modules/tiny-svg/lib/appendTo.js","node_modules/tiny-svg/lib/attr.js","node_modules/tiny-svg/lib/classes.js","node_modules/tiny-svg/lib/clear.js","node_modules/tiny-svg/lib/clone.js","node_modules/tiny-svg/lib/create.js","node_modules/tiny-svg/lib/geometry.js","node_modules/tiny-svg/lib/innerSVG.js","node_modules/tiny-svg/lib/remove.js","node_modules/tiny-svg/lib/transform.js","node_modules/tiny-svg/lib/util/ensureImported.js","node_modules/tiny-svg/lib/util/ns.js","node_modules/tiny-svg/lib/util/parse.js","node_modules/tiny-svg/lib/util/serialize.js","node_modules/util-deprecate/browser.js"],"names":[],"mappings":";;;;;;;;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClKA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvfA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACn5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9dA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACprBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACx4FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7OA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3GA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzbA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtfA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC79BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACriBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3WA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzUA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;;ACHA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;;ACAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtrBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3CA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/QA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACl4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar inherits = require(368);\n\nvar Modeler = require(73);\n\nfunction SoupeBpmnModeler(options) {\n  Modeler.call(this, options);\n}\n\ninherits(SoupeBpmnModeler, Modeler);\n\n// export\nmodule.exports = SoupeBpmnModeler;\n\nvar customTranslate = {\n  translate: ['value', require(2)]\n};\n\n// load additional modules\n\nvar bpmnPropertiesPanel = require(5);\nvar bpmnPropertiesProvider = require(50);\nvar bpmnModdleDescriptor = require(72);\nvar droolsModdleDescriptor = require(71);\n\nSoupeBpmnModeler.prototype._customizedModules = [\n  bpmnPropertiesPanel,\n  bpmnPropertiesProvider,\n  customTranslate\n];\n\n// add additional (default!) modules to bpmn-js\nSoupeBpmnModeler.prototype._modules = [].concat(\n  SoupeBpmnModeler.prototype._modules,\n  SoupeBpmnModeler.prototype._customizedModules);\n\nSoupeBpmnModeler.prototype._moddleExtensions = {\n  jbpm: bpmnModdleDescriptor,\n  drools: droolsModdleDescriptor\n};\n","'use strict';\n\nvar translations = require(3);\n\nmodule.exports = function customTranslate(template, replacements) {\n  replacements = replacements || {};\n\n  // Translate\n  template = translations[template] || template;\n\n  // Replace\n  return template.replace(/{([^}]+)}/g, function (_, key) {\n    return replacements[key] || '{' + key + '}';\n  });\n};","'use strict';\n\nmodule.exports = {\n\n  // Labels\n  'Append {type}': '追加{type}',\n  'Add Lane above': '在上方添加泳道',\n  'Divide into two Lanes': '拆分为2条泳道',\n  'Divide into three Lanes': '拆分为3条泳道',\n  'Add Lane below': '在下方添加泳道',\n  'Append compensation activity': '追加补偿活动',\n  'Change type': '更改类型',\n  'Connect using Association': '建立关联',\n  'Connect using Sequence/MessageFlow or Association': '建立关联',\n  'Connect using DataInputAssociation': '建立关联',\n  'Remove': '移除',\n  'Activate the hand tool': '激活手型工具 (用于移动画布)',\n  'Activate the lasso tool': '激活选择工具 (用于选择元素)',\n  'Activate the create/remove space tool': '激活工作空间创建或移除工具',\n  'Activate the global connect tool': '激活连接工具',\n  'Create IntermediateThrowEvent/BoundaryEvent': '创建过渡异常抛出事件/边界事件',\n  'Create expanded SubProcess': '创建展开的子流程',\n  'Create Pool/Participant': '创建池/道',\n  'Parallel Multi Instance': '多实例并行',\n  'Sequential Multi Instance': '多实例串行',\n  'Loop': '循环',\n  'Ad-hoc': '特别指定',\n  'Create {type}': '创建{type}',\n  'Task': '任务',\n  'Send Task': '发送性任务',\n  'Receive Task': '接收性任务',\n  'User Task': '用户交互性任务',\n  'Manual Task': '线下手动性任务',\n  'Business Rule Task': '业务规则性任务',\n  'Service Task': '服务性任务',\n  'Script Task': '脚本性任务',\n  'Call Activity': '呼叫性任务',\n  'Sub Process (collapsed)': '子流程 (折叠的)',\n  'Start Event': '启动事件',\n  'StartEvent': '启动事件',\n  'Intermediate Throw Event': '过渡异常抛出事件',\n  'IntermediateThrowEvent': '过渡异常抛出事件',\n  'End Event': '结束事件',\n  'EndEvent': '结束事件',\n  'Message Start Event': '消息性启动事件',\n  'Timer Start Event': '定时启动事件',\n  'Conditional Start Event': '条件性启动事件',\n  'Signal Start Event': '信号性启动事件',\n  'Error Start Event': '错误性启动事件',\n  'Escalation Start Event': '上升性启动事件',\n  'Compensation Start Event': '补偿性启动事件',\n  'Message Start Event (non-interrupting)': '消息性启动事件 (不可中断)',\n  'Timer Start Event (non-interrupting)': '定时启动事件 (不可中断)',\n  'Conditional Start Event (non-interrupting)': '条件性启动事件 (不可中断)',\n  'Signal Start Event (non-interrupting)': '信号性启动事件 (不可中断)',\n  'Escalation Start Event (non-interrupting)': '上升性启动事件 (不可中断)',\n  'Message Intermediate Catch Event': '消息性过渡异常捕捉事件',\n  'Message Intermediate Throw Event': '消息性过渡异常抛出事件',\n  'Timer Intermediate Catch Event': '定时过渡异常捕捉事件',\n  'Escalation Intermediate Throw Event': '上升性过渡异常抛出事件',\n  'Conditional Intermediate Catch Event': '条件性过渡异常捕捉事件',\n  'Link Intermediate Catch Event': '链接性过渡异常捕捉事件',\n  'Link Intermediate Throw Event': '链接性过渡异常抛出事件',\n  'Compensation Intermediate Throw Event': '补偿性过渡异常抛出事件',\n  'Signal Intermediate Catch Event': '信号性过渡异常捕捉事件',\n  'Signal Intermediate Throw Event': '信号性过渡异常抛出事件',\n  'Message End Event': '消息性结束事件',\n  'Escalation End Event': '上升性结束事件',\n  'Error End Event': '错误性结束事件',\n  'Cancel End Event': '撤销性结束事件',\n  'Compensation End Event': '补偿性结束事件',\n  'Signal End Event': '信号性结束事件',\n  'Terminate End Event': '终止性结束事件',\n  'Message Boundary Event': '消息性边界事件',\n  'Message Boundary Event (non-interrupting)': '消息性边界事件 (不可中断)',\n  'Timer Boundary Event': '定时边界事件',\n  'Timer Boundary Event (non-interrupting)': '定时边界 (不可中断)',\n  'Escalation Boundary Event': '上升性边界事件',\n  'Escalation Boundary Event (non-interrupting)': '上升性边界事件 (不可中断)',\n  'Conditional Boundary Event': '条件性边界事件',\n  'Conditional Boundary Event (non-interrupting)': '条件性边界事件 (不可中断)',\n  'Error Boundary Event': '错误性边界事件',\n  'Cancel Boundary Event': '撤销性边界事件',\n  'Signal Boundary Event': '信号性边界事件',\n  'Signal Boundary Event (non-interrupting)': '信号性边界事件 (不可中断)',\n  'Compensation Boundary Event': '补偿性边界事件',\n  'Exclusive Gateway': '排他性关口',\n  'ExclusiveGateway': '排他性关口',\n  'Parallel Gateway': '并行关口',\n  'Inclusive Gateway': '包容性关口',\n  'Complex Gateway': '复合性关口',\n  'Event based Gateway': '基于事件的关口',\n  'Transaction': '事务',\n  'Sub Process': '子流程',\n  'Event Sub Process': '事件子流程',\n  'Collapsed Pool': '折叠的池子',\n  'Expanded Pool': '展开的池子',\n  'DataObjectReference': '数据对象引用',\n  'DataStoreReference': '数据存储引用',\n  'TextAnnotation': '文本注释',\n\n  'Press SHIFT+Enter for line feed': '按下SHIFT+Enter来换行',\n\n  // Errors\n  'no parent for {element} in {parent}': '在{parent}中不存在{element}的父级关系',\n  'no shape type specified': '未指定类型',\n  'flow elements must be children of pools/participants': '流程元素必须在池/道里面',\n  'out of bounds release': '超出边界',\n  'more than {count} child lanes': '超过{count}个子道',\n  'element required': '必需的元素',\n  'diagram not part of bpmn:Definitions': '不是有效的BPMN图表',\n  'no diagram to display': '没有可显示的图表',\n  'no process or collaboration to display': '没有可显示的流程或协作',\n  'element {element} referenced by {referenced}#{property} not yet drawn': '被{referenced}#{property}引用的{element}没有绘制',\n  'already rendered {element}': '已经存在{element}',\n  'failed to import {element}': '{element}导入失败',\n\n  //Properties Provider\n  'General': '通用',\n  'Id': '标识',\n  'Name': '名称',\n  'Value': '值',\n  'ToDo Url': '待办地址',\n  'Yes': '是',\n  'No': '否',\n  \n  'Process Id': '流程标识',\n  'Process Name': '流程名称',\n  'Executable': '可执行',\n\n  'Imports & Globals': '类型与全局变量',\n  'Imports': '类型',\n  'Add Import': '添加类型',\n  'Globals': '全局变量',\n  'Add Global': '添加变量',\n  'Identifier': '标识(必须唯一)',\n  'Type': '变量类型',\n  'Type Name': '类型名称(任意Class Name)',\n  \n  'Actor Id': '分配给',\n  'Actor of the User Task': '指定任务的执行者',\n  'Group Id': '用户组标识',\n  'Content Id': '',\n  'Comment Id': '',\n  'Skippable': '是否可跳过',\n  'Priority': '优先级',\n  'Organization Level': '组织级别',\n  'Role Codes': '角色编码(多个用逗号分开)',\n  'Roles of this User Task': '可执行任务的角色',\n  'Multi-User': '是否会签',\n  \n  'Input/Output Parameters': '输入/输出参数',\n  'Input Parameters': '输入参数',\n  'Output Parameters': '输出参数',\n  'Parameters': '',\n  'Parameter Detail': '参数详情',\n  \n  'Condition Type': '条件类型',\n  'Expression': '表达式',\n  'Script': '脚本',\n  'Script Format': '脚本语言',\n  'Script Type': '脚本类型',\n  'Inline Script': '内嵌脚本',\n  'External Resource': '外部文件',\n  'Resource': '文件路径',\n  \n  'Gateway Direction': '关口方向类型',\n  'Diverging': '分叉',\n  'Converging': '汇聚',\n  'Mixed': '混合',\n  'Unspecified': '未指定'\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","module.exports = require(33);\n","'use strict';\n\nvar DEFAULT_PRIORITY = 1000;\n\n\n/**\n * A component that decides upon the visibility / editable\n * state of properties in the properties panel.\n *\n * Implementors must subclass this component and override\n * {@link PropertiesActivator#isEntryVisible} and\n * {@link PropertiesActivator#isPropertyEditable} to provide\n * custom behavior.\n *\n * @class\n * @constructor\n *\n * @param {EventBus} eventBus\n * @param {Number} [priority] at which priority to hook into the activation\n */\nfunction PropertiesActivator(eventBus, priority) {\n  var self = this;\n\n  priority = priority || DEFAULT_PRIORITY;\n\n  eventBus.on('propertiesPanel.isEntryVisible', priority, function(e) {\n    return self.isEntryVisible(e.entry, e.element);\n  });\n\n  eventBus.on('propertiesPanel.isPropertyEditable', priority, function(e) {\n    return self.isPropertyEditable(e.entry, e.propertyName, e.element);\n  });\n}\n\nPropertiesActivator.$inject = [ 'eventBus', 'translate' ];\n\nmodule.exports = PropertiesActivator;\n\n\n/**\n * Should the given entry be visible for the specified element.\n *\n * @method  PropertiesActivator#isEntryVisible\n *\n * @param {EntryDescriptor} entry\n * @param {ModdleElement} element\n *\n * @returns {Boolean}\n */\nPropertiesActivator.prototype.isEntryVisible = function(entry, element) {\n  return true;\n};\n\n/**\n * Should the given property be editable for the specified element\n *\n * @method  PropertiesActivator#isPropertyEditable\n *\n * @param {EntryDescriptor} entry\n * @param {String} propertyName\n * @param {ModdleElement} element\n *\n * @returns {Boolean}\n */\nPropertiesActivator.prototype.isPropertyEditable = function(entry, propertyName, element) {\n  return true;\n};","'use strict';\n\nvar domify = require(535),\n    domQuery = require(538),\n    domRemove = require(539),\n    domClasses = require(531),\n    domClosest = require(533),\n    domAttr = require(530),\n    domDelegate = require(534),\n    domMatches = require(537);\n\nvar forEach = require(386),\n    filter = require(384),\n    get = require(517),\n    keys = require(519),\n    isEmpty = require(507),\n    isArray = require(506),\n    xor = require(380),\n    debounce = require(397);\n\nvar updateSelection = require(573);\n\nvar scrollTabs = require(572);\n\nvar getBusinessObject = require(167).getBusinessObject;\n\nvar HIDE_CLASS = 'bpp-hidden';\nvar DEBOUNCE_DELAY = 300;\n\n\nfunction isToggle(node) {\n  return node.type === 'checkbox' || node.type === 'radio';\n}\n\nfunction isSelect(node) {\n  return node.type === 'select-one';\n}\n\nfunction isContentEditable(node) {\n  return domAttr(node, 'contenteditable');\n}\n\nfunction getPropertyPlaceholders(node) {\n  var selector = 'input[name], textarea[name], [data-value], [contenteditable]';\n  var placeholders = domQuery.all(selector, node);\n  if ((!placeholders || !placeholders.length) && domMatches(node, selector)) {\n    placeholders = [ node ];\n  }\n  return placeholders;\n}\n\n/**\n * Return all active form controls.\n * This excludes the invisible controls unless all is true\n *\n * @param {Element} node\n * @param {Boolean} [all=false]\n */\nfunction getFormControls(node, all) {\n  var controls = domQuery.all('input[name], textarea[name], select[name], [contenteditable]', node);\n\n  if (!controls || !controls.length) {\n    controls = domMatches(node, 'option') ? [ node ] : controls;\n  }\n\n  if (!all) {\n    controls = filter(controls, function(node) {\n      return !domClosest(node, '.' + HIDE_CLASS);\n    });\n  }\n\n  return controls;\n}\n\nfunction getFormControlValuesInScope(entryNode) {\n  var values = {};\n\n  var controlNodes = getFormControls(entryNode);\n\n  forEach(controlNodes, function(controlNode) {\n    var value = controlNode.value;\n\n    var name = domAttr(controlNode, 'name') || domAttr(controlNode, 'data-name');\n\n    // take toggle state into account for radio / checkboxes\n    if (isToggle(controlNode)) {\n      if (controlNode.checked) {\n        if (!domAttr(controlNode, 'value')) {\n          value = true;\n        } else {\n          value = controlNode.value;\n        }\n      } else {\n        value = null;\n      }\n    } else\n    if (isContentEditable(controlNode)) {\n      value = controlNode.innerText;\n    }\n\n    if (value !== null) {\n      // return the actual value\n      // handle serialization in entry provider\n      // (ie. if empty string should be serialized or not)\n      values[name] = value;\n    }\n  });\n\n  return values;\n\n}\n\n/**\n * Extract input values from entry node\n *\n * @param  {DOMElement} entryNode\n * @returns {Object}\n */\nfunction getFormControlValues(entryNode) {\n\n  var values;\n\n  var listContainer = domQuery('[data-list-entry-container]', entryNode);\n  if (listContainer) {\n    values = [];\n    var listNodes = listContainer.children || [];\n    forEach(listNodes, function(listNode) {\n      values.push(getFormControlValuesInScope(listNode));\n    });\n  } else {\n    values = getFormControlValuesInScope(entryNode);\n  }\n\n  return values;\n}\n\n/**\n * Return true if the given form extracted value equals\n * to an old cached version.\n *\n * @param {Object} value\n * @param {Object} oldValue\n * @return {Boolean}\n */\nfunction valueEqual(value, oldValue) {\n\n  if (value && !oldValue) {\n    return false;\n  }\n\n  var allKeys = keys(value).concat(keys(oldValue));\n\n  return allKeys.every(function(key) {\n    return value[key] === oldValue[key];\n  });\n}\n\n/**\n * Return true if the given form extracted value(s)\n * equal an old cached version.\n *\n * @param {Array<Object>|Object} values\n * @param {Array<Object>|Object} oldValues\n * @return {Boolean}\n */\nfunction valuesEqual(values, oldValues) {\n\n  if (isArray(values)) {\n\n    if (values.length !== oldValues.length) {\n      return false;\n    }\n\n    return values.every(function(v, idx) {\n      return valueEqual(v, oldValues[idx]);\n    });\n  }\n\n  return valueEqual(values, oldValues);\n}\n\n/**\n * Return a mapping of { id: entry } for all entries in the given groups in the given tabs.\n *\n * @param {Object} tabs\n * @return {Object}\n */\nfunction extractEntries(tabs) {\n  return indexBy(flattenDeep(map(flattenDeep(map(tabs, 'groups')), 'entries')), 'id');\n}\n\n/**\n * Return a mapping of { id: group } for all groups in the given tabs.\n *\n * @param {Object} tabs\n * @return {Object}\n */\nfunction extractGroups(tabs) {\n  return indexBy(flattenDeep(map(tabs, 'groups')), 'id');\n}\n\n/**\n * A properties panel implementation.\n *\n * To use it provide a `propertiesProvider` component that knows\n * about which properties to display.\n *\n * Properties edit state / visibility can be intercepted\n * via a custom {@link PropertiesActivator}.\n *\n * @class\n * @constructor\n *\n * @param {Object} config\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {PropertiesProvider} propertiesProvider\n * @param {Canvas} canvas\n * @param {CommandStack} commandStack\n */\nfunction PropertiesPanel(config, eventBus, modeling, propertiesProvider, commandStack, canvas, translate) {\n\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._commandStack = commandStack;\n  this._canvas = canvas;\n  this._propertiesProvider = propertiesProvider;\n  this._translate = translate;\n\n  this._init(config);\n}\n\nPropertiesPanel.$inject = [\n  'config.propertiesPanel',\n  'eventBus',\n  'modeling',\n  'propertiesProvider',\n  'commandStack',\n  'canvas',\n  'translate'];\n\nmodule.exports = PropertiesPanel;\n\n\nPropertiesPanel.prototype._init = function(config) {\n\n  var eventBus = this._eventBus;\n\n  var self = this;\n\n  /**\n   * Select the root element once it is added to the canvas\n   */\n  eventBus.on('root.added', function(e) {\n    self.update(e.element);\n  });\n\n  eventBus.on('selection.changed', function(e) {\n    var newElement = e.newSelection[0];\n\n    self.update(newElement);\n  });\n\n  // add / update tab-bar scrolling\n  eventBus.on([\n    'propertiesPanel.changed',\n    'propertiesPanel.resized'\n  ], function(event) {\n\n    var tabBarNode = domQuery('.bpp-properties-tab-bar', self._container);\n\n    if (!tabBarNode) {\n      return;\n    }\n\n    var scroller = scrollTabs.get(tabBarNode);\n\n    if (!scroller) {\n\n      // we did not initialize yet, do that\n      // now and make sure we select the active\n      // tab on scroll update\n      scroller = scrollTabs(tabBarNode, {\n        selectors: {\n          tabsContainer: '.bpp-properties-tabs-links',\n          tab: '.bpp-properties-tabs-links li',\n          ignore: '.bpp-hidden',\n          active: '.bpp-active'\n        }\n      });\n\n\n      scroller.on('scroll', function(newActiveNode, oldActiveNode, direction) {\n\n        var linkNode = domQuery('[data-tab-target]', newActiveNode);\n\n        var tabId = domAttr(linkNode, 'data-tab-target');\n\n        self.activateTab(tabId);\n      });\n    }\n\n    // react on tab changes and or tabContainer resize\n    // and make sure the active tab is shown completely\n    scroller.update();\n  });\n\n  eventBus.on('elements.changed', function(e) {\n\n    var current = self._current;\n    var element = current && current.element;\n\n    if (element) {\n      if (e.elements.indexOf(element) !== -1) {\n        self.update(element);\n      }\n    }\n  });\n\n  eventBus.on('elementTemplates.changed', function() {\n    var current = self._current;\n    var element = current && current.element;\n\n    if (element) {\n      self.update(element);\n    }\n  });\n\n  eventBus.on('diagram.destroy', function() {\n    self.detach();\n  });\n\n  this._container = domify('<div class=\"bpp-properties-panel\"></div>');\n\n  this._bindListeners(this._container);\n\n  if (config && config.parent) {\n    this.attachTo(config.parent);\n  }\n};\n\n\nPropertiesPanel.prototype.attachTo = function(parentNode) {\n\n  if (!parentNode) {\n    throw new Error('parentNode required');\n  }\n\n  // ensure we detach from the\n  // previous, old parent\n  this.detach();\n\n  // unwrap jQuery if provided\n  if (parentNode.get && parentNode.constructor.prototype.jquery) {\n    parentNode = parentNode.get(0);\n  }\n\n  if (typeof parentNode === 'string') {\n    parentNode = domQuery(parentNode);\n  }\n\n  var container = this._container;\n\n  parentNode.appendChild(container);\n\n  this._emit('attach');\n};\n\nPropertiesPanel.prototype.detach = function() {\n\n  var container = this._container,\n      parentNode = container.parentNode;\n\n  if (!parentNode) {\n    return;\n  }\n\n  this._emit('detach');\n\n  parentNode.removeChild(container);\n};\n\n\n/**\n * Select the given tab within the properties panel.\n *\n * @param {Object|String} tab\n */\nPropertiesPanel.prototype.activateTab = function(tab) {\n\n  var tabId = typeof tab === 'string' ? tab : tab.id;\n\n  var current = this._current;\n\n  var panelNode = current.panel;\n\n  var allTabNodes = domQuery.all('.bpp-properties-tab', panelNode),\n      allTabLinkNodes = domQuery.all('.bpp-properties-tab-link', panelNode);\n\n  forEach(allTabNodes, function(tabNode) {\n\n    var currentTabId = domAttr(tabNode, 'data-tab');\n\n    domClasses(tabNode).toggle('bpp-active', tabId === currentTabId);\n  });\n\n  forEach(allTabLinkNodes, function(tabLinkNode) {\n\n    var tabLink = domQuery('[data-tab-target]', tabLinkNode),\n        currentTabId = domAttr(tabLink, 'data-tab-target');\n\n    domClasses(tabLinkNode).toggle('bpp-active', tabId === currentTabId);\n  });\n};\n\n/**\n * Update the DOM representation of the properties panel\n */\nPropertiesPanel.prototype.update = function(element) {\n  var current = this._current;\n\n  // no actual selection change\n  var needsCreate = true;\n\n  if (typeof element === 'undefined') {\n\n    // use RootElement of BPMN diagram to generate properties panel if no element is selected\n    element = this._canvas.getRootElement();\n  }\n\n  var newTabs = this._propertiesProvider.getTabs(element);\n\n  if (current && current.element === element) {\n    // see if we can reuse the existing panel\n\n    needsCreate = this._entriesChanged(current, newTabs);\n  }\n\n  if (needsCreate) {\n\n    if (current) {\n\n      // get active tab from the existing panel before remove it\n      var activeTabNode = domQuery('.bpp-properties-tab.bpp-active', current.panel);\n\n      var activeTabId;\n      if (activeTabNode) {\n        activeTabId = domAttr(activeTabNode, 'data-tab');\n      }\n\n      // remove old panel\n      domRemove(current.panel);\n    }\n\n    this._current = this._create(element, newTabs);\n\n    // activate the saved active tab from the remove panel or the first tab\n    (activeTabId) ? this.activateTab(activeTabId) : this.activateTab(this._current.tabs[0]);\n\n  }\n\n  if (this._current) {\n    // make sure correct tab contents are visible\n    this._updateActivation(this._current);\n\n  }\n\n  this._emit('changed');\n};\n\n\n/**\n * Returns true if one of two groups has different entries than the other.\n *\n * @param  {Object} current\n * @param  {Object} newTabs\n * @return {Booelan}\n */\nPropertiesPanel.prototype._entriesChanged = function(current, newTabs) {\n\n  var oldEntryIds = keys(current.entries),\n      newEntryIds = keys(extractEntries(newTabs));\n\n  return !isEmpty(xor(oldEntryIds, newEntryIds));\n};\n\nPropertiesPanel.prototype._emit = function(event) {\n  this._eventBus.fire('propertiesPanel.' + event, { panel: this, current: this._current });\n};\n\nPropertiesPanel.prototype._bindListeners = function(container) {\n\n  var self = this;\n\n  // handles a change for a given event\n  var handleChange = function handleChange(event) {\n\n    // see if we handle a change inside a [data-entry] element.\n    // if not, drop out\n    var node = domClosest(event.delegateTarget, '[data-entry]'),\n        entryId, entry;\n\n    // change from outside a [data-entry] element, simply ignore\n    if (!node) {\n      return;\n    }\n\n    entryId = domAttr(node, 'data-entry');\n    entry = self.getEntry(entryId);\n\n    var values = getFormControlValues(node);\n\n    if (event.type === 'change') {\n\n      // - if the \"data-on-change\" attribute is present and a value is changed,\n      //   then the associated action is performed.\n      // - if the associated action returns \"true\" then an update to the business\n      //   object is done\n      // - if it does not return \"true\", then only the DOM content is updated\n      var onChangeAction = event.delegateTarget.getAttribute('data-on-change');\n\n      if (onChangeAction) {\n        var isEntryDirty = self.executeAction(entry, node, onChangeAction, event);\n\n        if (!isEntryDirty) {\n          return self.update(self._current.element);\n        }\n      }\n    }\n    self.applyChanges(entry, values, node);\n    self.updateState(entry, node);\n  };\n\n  // debounce update only elements that are target of key events,\n  // i.e. INPUT and TEXTAREA. SELECTs will trigger an immediate update anyway.\n  domDelegate.bind(container, 'input, textarea, [contenteditable]', 'input', debounce(handleChange, DEBOUNCE_DELAY));\n  domDelegate.bind(container, 'input, textarea, select, [contenteditable]', 'change', handleChange);\n\n  domDelegate.bind(container, '[data-action]', 'click', function onClick(event) {\n\n    // triggers on all inputs\n    var inputNode = event.delegateTarget;\n    var entryNode = domClosest(inputNode, '[data-entry]');\n\n    var actionId = domAttr(inputNode, 'data-action'),\n        entryId = domAttr(entryNode, 'data-entry');\n\n    var entry = self.getEntry(entryId);\n\n    var isEntryDirty = self.executeAction(entry, entryNode, actionId, event);\n\n    if (isEntryDirty) {\n      var values = getFormControlValues(entryNode);\n\n      self.applyChanges(entry, values, entryNode);\n    }\n\n    self.updateState(entry, entryNode);\n  });\n\n  function handleInput(event, element) {\n    // triggers on all inputs\n    var inputNode = event.delegateTarget;\n\n    var entryNode = domClosest(inputNode, '[data-entry]');\n\n    // only work on data entries\n    if (!entryNode) {\n      return;\n    }\n\n    var eventHandlerId = domAttr(inputNode, 'data-blur'),\n        entryId = domAttr(entryNode, 'data-entry');\n\n    var entry = self.getEntry(entryId);\n\n    var isEntryDirty = self.executeAction(entry, entryNode, eventHandlerId, event);\n\n    if (isEntryDirty) {\n      var values = getFormControlValues(entryNode);\n\n      self.applyChanges(entry, values, entryNode);\n    }\n\n    self.updateState(entry, entryNode);\n  }\n\n  domDelegate.bind(container, '[data-blur]', 'blur', handleInput, true);\n\n  // make tab links interactive\n  domDelegate.bind(container, '.bpp-properties-tabs-links [data-tab-target]', 'click', function(event) {\n    event.preventDefault();\n\n    var delegateTarget = event.delegateTarget;\n\n    var tabId = domAttr(delegateTarget, 'data-tab-target');\n\n    // activate tab on link click\n    self.activateTab(tabId);\n  });\n\n};\n\nPropertiesPanel.prototype.updateState = function(entry, entryNode) {\n  this.updateShow(entry, entryNode);\n  this.updateDisable(entry, entryNode);\n};\n\n/**\n * Update the visibility of the entry node in the DOM\n */\nPropertiesPanel.prototype.updateShow = function(entry, node) {\n\n  var current = this._current;\n\n  if (!current) {\n    return;\n  }\n\n  var showNodes = domQuery.all('[data-show]', node) || [];\n\n  forEach(showNodes, function(showNode) {\n\n    var expr = domAttr(showNode, 'data-show');\n    var fn = get(entry, expr);\n    if (fn) {\n      var scope = domClosest(showNode, '[data-scope]') || node;\n      var shouldShow = fn(current.element, node, showNode, scope) || false;\n      if (shouldShow) {\n        domClasses(showNode).remove(HIDE_CLASS);\n      } else {\n        domClasses(showNode).add(HIDE_CLASS);\n      }\n    }\n  });\n};\n\n/**\n * Evaluates a given function. If it returns true, then the\n * node is marked as \"disabled\".\n */\nPropertiesPanel.prototype.updateDisable = function(entry, node) {\n  var current = this._current;\n\n  if (!current) {\n    return;\n  }\n\n  var nodes = domQuery.all('[data-disable]', node) || [];\n\n  forEach(nodes, function(currentNode) {\n    var expr = domAttr(currentNode, 'data-disable');\n    var fn = get(entry, expr);\n    if (fn) {\n      var scope = domClosest(currentNode, '[data-scope]') || node;\n      var shouldDisable = fn(current.element, node, currentNode, scope) || false;\n      domAttr(currentNode, 'disabled', shouldDisable ? '' : null);\n    }\n  });\n};\n\nPropertiesPanel.prototype.executeAction = function(entry, entryNode, actionId, event) {\n  var current = this._current;\n\n  if (!current) {\n    return;\n  }\n\n  var fn = get(entry, actionId);\n  if (fn) {\n    var scopeNode = domClosest(event.target, '[data-scope]') || entryNode;\n    return fn.apply(entry, [ current.element, entryNode, event, scopeNode ]);\n  }\n};\n\n/**\n * Apply changes to the business object by executing a command\n */\nPropertiesPanel.prototype.applyChanges = function(entry, values, containerElement) {\n\n  var element = this._current.element;\n\n  // ensure we only update the model if we got dirty changes\n  if (valuesEqual(values, entry.oldValues)) {\n    return;\n  }\n\n  var command = entry.set(element, values, containerElement);\n\n  var commandToExecute;\n\n  if (isArray(command)) {\n    if (command.length) {\n      commandToExecute = {\n        cmd: 'properties-panel.multi-command-executor',\n        context: flattenDeep(command)\n      };\n    }\n  } else {\n    commandToExecute = command;\n  }\n\n  if (commandToExecute) {\n    this._commandStack.execute(commandToExecute.cmd, commandToExecute.context || { element : element });\n  } else {\n    this.update(element);\n  }\n};\n\n\n/**\n * apply validation errors in the DOM and show or remove an error message near the entry node.\n */\nPropertiesPanel.prototype.applyValidationErrors = function(validationErrors, entryNode) {\n\n  var valid = true;\n\n  var controlNodes = getFormControls(entryNode, true);\n\n  forEach(controlNodes, function(controlNode) {\n\n    var name = domAttr(controlNode, 'name') || domAttr(controlNode, 'data-name');\n\n    var error = validationErrors && validationErrors[name];\n\n    var errorMessageNode = domQuery('.bpp-error-message', controlNode.parentNode);\n\n    if (error) {\n      valid = false;\n\n      if (!errorMessageNode) {\n        errorMessageNode = domify('<div></div>');\n\n        domClasses(errorMessageNode).add('bpp-error-message');\n\n        // insert errorMessageNode after controlNode\n        controlNode.parentNode.insertBefore(errorMessageNode, controlNode.nextSibling);\n      }\n\n      errorMessageNode.innerHTML = error;\n\n      domClasses(controlNode).add('invalid');\n    } else {\n      domClasses(controlNode).remove('invalid');\n\n      if (errorMessageNode) {\n        controlNode.parentNode.removeChild(errorMessageNode);\n      }\n    }\n  });\n\n  return valid;\n};\n\n\n/**\n * Check if the entry contains valid input\n */\nPropertiesPanel.prototype.validate = function(entry, values, entryNode) {\n  var self = this;\n\n  var current = this._current;\n\n  var valid = true;\n\n  entryNode = entryNode || domQuery('[data-entry=\"' + entry.id + '\"]', current.panel);\n\n  if (values instanceof Array) {\n    var listContainer = domQuery('[data-list-entry-container]', entryNode),\n        listEntryNodes = listContainer.children || [];\n\n    // create new elements\n    for (var i = 0; i < values.length; i++) {\n      var listValue = values[i];\n\n      if (entry.validateListItem) {\n\n        var validationErrors = entry.validateListItem(current.element, listValue, entryNode, i),\n            listEntryNode = listEntryNodes[i];\n\n        valid = self.applyValidationErrors(validationErrors, listEntryNode) && valid;\n      }\n    }\n  } else {\n    if (entry.validate) {\n      this.validationErrors = entry.validate(current.element, values, entryNode);\n\n      valid = self.applyValidationErrors(this.validationErrors, entryNode) && valid;\n    }\n  }\n\n  return valid;\n};\n\nPropertiesPanel.prototype.getEntry = function(id) {\n  return this._current && this._current.entries[id];\n};\n\nvar flattenDeep = require(373),\n    indexBy = require(388),\n    map = require(389);\n\nPropertiesPanel.prototype._create = function(element, tabs) {\n\n  if (!element) {\n    return null;\n  }\n\n  var containerNode = this._container;\n\n  var panelNode = this._createPanel(element, tabs);\n\n  containerNode.appendChild(panelNode);\n\n  var entries = extractEntries(tabs);\n  var groups = extractGroups(tabs);\n\n  return {\n    tabs: tabs,\n    groups: groups,\n    entries: entries,\n    element: element,\n    panel: panelNode\n  };\n};\n\n/**\n * Update variable parts of the entry node on element changes.\n *\n * @param {djs.model.Base} element\n * @param {EntryDescriptor} entry\n * @param {Object} values\n * @param {HTMLElement} entryNode\n * @param {Number} idx\n */\nPropertiesPanel.prototype._bindTemplate = function(element, entry, values, entryNode, idx) {\n\n  var eventBus = this._eventBus;\n\n  function isPropertyEditable(entry, propertyName) {\n    return eventBus.fire('propertiesPanel.isPropertyEditable', {\n      entry: entry,\n      propertyName: propertyName,\n      element: element\n    });\n  }\n\n  var inputNodes = getPropertyPlaceholders(entryNode);\n\n  forEach(inputNodes, function(node) {\n\n    var name,\n        newValue,\n        editable;\n\n    // we deal with an input element\n    if ('value' in node || isContentEditable(node) === 'true') {\n      name = domAttr(node, 'name') || domAttr(node, 'data-name');\n      newValue = values[name];\n\n      editable = isPropertyEditable(entry, name);\n      if (editable && entry.editable) {\n        editable = entry.editable(element, entryNode, node, name, newValue, idx);\n      }\n\n      domAttr(node, 'readonly', editable ? null : '');\n      domAttr(node, 'disabled', editable ? null : '');\n\n      // take full control over setting the value\n      // and possibly updating the input in entry#setControlValue\n      if (entry.setControlValue) {\n        entry.setControlValue(element, entryNode, node, name, newValue, idx);\n      } else if (isToggle(node)) {\n        setToggleValue(node, newValue);\n      } else if (isSelect(node)) {\n        setSelectValue(node, newValue);\n      } else {\n        setInputValue(node, newValue);\n      }\n    }\n\n    // we deal with some non-editable html element\n    else {\n      name = domAttr(node, 'data-value');\n      newValue = values[name];\n      if (entry.setControlValue) {\n        entry.setControlValue(element, entryNode, node, name, newValue, idx);\n      } else {\n        setTextValue(node, newValue);\n      }\n    }\n  });\n};\n\n// TODO(nikku): WTF freaking name? Change / clarify.\nPropertiesPanel.prototype._updateActivation = function(current) {\n  var self = this;\n\n  var eventBus = this._eventBus;\n\n  var element = current.element;\n\n  function isEntryVisible(entry) {\n    return eventBus.fire('propertiesPanel.isEntryVisible', {\n      entry: entry,\n      element: element\n    });\n  }\n\n  function isGroupVisible(group, element, groupNode) {\n    if (typeof group.enabled === 'function') {\n      return group.enabled(element, groupNode);\n    } else {\n      return true;\n    }\n  }\n\n  function isTabVisible(tab, element) {\n    if (typeof tab.enabled === 'function') {\n      return tab.enabled(element);\n    } else {\n      return true;\n    }\n  }\n\n  function toggleVisible(node, visible) {\n    domClasses(node).toggle(HIDE_CLASS, !visible);\n  }\n\n  // check whether the active tab is visible\n  // if not: set the first tab as active tab\n  function checkActiveTabVisibility(node, visible) {\n    var isActive = domClasses(node).has('bpp-active');\n    if (!visible && isActive) {\n      self.activateTab(current.tabs[0]);\n    }\n  }\n\n  function updateLabel(element, selector, text) {\n    var labelNode = domQuery(selector, element);\n\n    if (!labelNode) {\n      return;\n    }\n\n    labelNode.textContent = text;\n  }\n\n  var panelNode = current.panel;\n\n  forEach(current.tabs, function(tab) {\n\n    var tabNode = domQuery('[data-tab=' + tab.id + ']', panelNode);\n    var tabLinkNode = domQuery('[data-tab-target=' + tab.id + ']', panelNode).parentNode;\n\n    var tabVisible = false;\n\n    forEach(tab.groups, function(group) {\n\n      var groupVisible = false;\n\n      var groupNode = domQuery('[data-group=' + group.id + ']', tabNode);\n\n      forEach(group.entries, function(entry) {\n\n        var entryNode = domQuery('[data-entry=\"' + entry.id + '\"]', groupNode);\n\n        var entryVisible = isEntryVisible(entry);\n\n        groupVisible = groupVisible || entryVisible;\n\n        toggleVisible(entryNode, entryVisible);\n\n        var values = 'get' in entry ? entry.get(element, entryNode) : {};\n\n        if (values instanceof Array) {\n          var listEntryContainer = domQuery('[data-list-entry-container]', entryNode);\n          var existingElements = listEntryContainer.children || [];\n\n          for (var i = 0; i < values.length; i++) {\n            var listValue = values[i];\n            var listItemNode = existingElements[i];\n            if (!listItemNode) {\n              listItemNode = domify(entry.createListEntryTemplate(listValue, i, listEntryContainer));\n              listEntryContainer.appendChild(listItemNode);\n            }\n            domAttr(listItemNode, 'data-index', i);\n\n            self._bindTemplate(element, entry, listValue, listItemNode, i);\n          }\n\n          var entriesToRemove = existingElements.length - values.length;\n\n          for (var j = 0; j < entriesToRemove; j++) {\n            // remove orphaned element\n            listEntryContainer.removeChild(listEntryContainer.lastChild);\n          }\n\n        } else {\n          self._bindTemplate(element, entry, values, entryNode);\n        }\n\n        // update conditionally visible elements\n        self.updateState(entry, entryNode);\n        self.validate(entry, values, entryNode);\n\n        // remember initial state for later dirty checking\n        entry.oldValues = getFormControlValues(entryNode);\n      });\n\n      if (typeof group.label === 'function') {\n        updateLabel(groupNode, '.group-label', group.label(element, groupNode));\n      }\n\n      groupVisible = groupVisible && isGroupVisible(group, element, groupNode);\n\n      tabVisible = tabVisible || groupVisible;\n\n      toggleVisible(groupNode, groupVisible);\n    });\n\n    tabVisible = tabVisible && isTabVisible(tab, element);\n\n    toggleVisible(tabNode, tabVisible);\n    toggleVisible(tabLinkNode, tabVisible);\n\n    checkActiveTabVisibility(tabNode, tabVisible);\n  });\n\n  // inject elements id into header\n  updateLabel(panelNode, '[data-label-id]', getBusinessObject(element).id || '');\n};\n\nPropertiesPanel.prototype._createPanel = function(element, tabs) {\n  var self = this;\n\n  var panelNode = domify('<div class=\"bpp-properties\"></div>'),\n      headerNode = domify('<div class=\"bpp-properties-header\">' +\n        '<div class=\"label\" data-label-id></div>' +\n        '<div class=\"search\">' +\n          '<input type=\"search\" placeholder=\"Search for property\" />' +\n          '<button><span>Search</span></button>' +\n        '</div>' +\n      '</div>'),\n      tabBarNode = domify('<div class=\"bpp-properties-tab-bar\"></div>'),\n      tabLinksNode = domify('<ul class=\"bpp-properties-tabs-links\"></ul>'),\n      tabContainerNode = domify('<div class=\"bpp-properties-tabs-container\"></div>');\n\n  panelNode.appendChild(headerNode);\n\n  forEach(tabs, function(tab, tabIndex) {\n\n    if (!tab.id) {\n      throw new Error('tab must have an id');\n    }\n\n    var tabNode = domify('<div class=\"bpp-properties-tab\" data-tab=\"' + tab.id + '\"></div>'),\n        tabLinkNode = domify('<li class=\"bpp-properties-tab-link\">' +\n          '<a href data-tab-target=\"' + tab.id + '\">' + tab.label + '</a>' +\n        '</li>');\n\n    var groups = tab.groups;\n\n    forEach(groups, function(group) {\n\n      if (!group.id) {\n        throw new Error('group must have an id');\n      }\n\n      var groupNode = domify('<div class=\"bpp-properties-group\" data-group=\"' + group.id + '\">' +\n          '<span class=\"group-toggle\"></span>' +\n          '<span class=\"group-label\">' + group.label + '</span>' +\n        '</div>');\n\n      // TODO(nre): use event delegation to handle that...\n      groupNode.querySelector('.group-toggle').addEventListener('click', function(evt) {\n        domClasses(groupNode).toggle('group-closed');\n        evt.preventDefault();\n        evt.stopPropagation();\n      });\n      groupNode.addEventListener('click', function(evt) {\n        if (!evt.defaultPrevented && domClasses(groupNode).has('group-closed')) {\n          domClasses(groupNode).remove('group-closed');\n        }\n      });\n\n      forEach(group.entries, function(entry) {\n\n        if (!entry.id) {\n          throw new Error('entry must have an id');\n        }\n\n        var html = entry.html;\n\n        if (typeof html === 'string') {\n          html = domify(html);\n        }\n\n        // unwrap jquery\n        if (html.get && html.constructor.prototype.jquery) {\n          html = html.get(0);\n        }\n\n        var entryNode = domify('<div class=\"bpp-properties-entry\" data-entry=\"' + entry.id + '\"></div>');\n\n        forEach(entry.cssClasses || [], function(cssClass) {\n          domClasses(entryNode).add(cssClass);\n        });\n\n        entryNode.appendChild(html);\n\n        groupNode.appendChild(entryNode);\n\n        // update conditionally visible elements\n        self.updateState(entry, entryNode);\n      });\n\n      tabNode.appendChild(groupNode);\n    });\n\n    tabLinksNode.appendChild(tabLinkNode);\n    tabContainerNode.appendChild(tabNode);\n  });\n\n  tabBarNode.appendChild(tabLinksNode);\n\n  panelNode.appendChild(tabBarNode);\n  panelNode.appendChild(tabContainerNode);\n\n  return panelNode;\n};\n\n\n\nfunction setInputValue(node, value) {\n\n  var contentEditable = isContentEditable(node);\n\n  var oldValue = contentEditable ? node.innerText : node.value;\n\n  var selection;\n\n  // prevents input fields from having the value 'undefined'\n  if (value === undefined) {\n    value = '';\n  }\n\n  if (oldValue === value) {\n    return;\n  }\n\n  // update selection on undo/redo\n  if (document.activeElement === node) {\n    selection = updateSelection(getSelection(node), oldValue, value);\n  }\n\n  if (contentEditable) {\n    node.innerText = value;\n  } else {\n    node.value = value;\n  }\n\n  if (selection) {\n    setSelection(node, selection);\n  }\n}\n\nfunction setSelectValue(node, value) {\n  if (value !== undefined) {\n    node.value = value;\n  }\n}\n\nfunction setToggleValue(node, value) {\n  var nodeValue = node.value;\n\n  node.checked = (value === nodeValue) || (!domAttr(node, 'value') && value);\n}\n\nfunction setTextValue(node, value) {\n  node.textContent = value;\n}\n\nfunction getSelection(node) {\n\n  return isContentEditable(node) ? getContentEditableSelection(node) : {\n    start: node.selectionStart,\n    end: node.selectionEnd\n  };\n}\n\nfunction getContentEditableSelection(node) {\n\n  var selection = window.getSelection();\n\n  var focusNode = selection.focusNode,\n      focusOffset = selection.focusOffset,\n      anchorOffset = selection.anchorOffset;\n\n  if (!focusNode) {\n    throw new Error('not selected');\n  }\n\n  // verify we have selection on the current element\n  if (!node.contains(focusNode)) {\n    throw new Error('not selected');\n  }\n\n  return {\n    start: Math.min(focusOffset, anchorOffset),\n    end: Math.max(focusOffset, anchorOffset)\n  };\n}\n\nfunction setSelection(node, selection) {\n\n  if (isContentEditable(node)) {\n    setContentEditableSelection(node, selection);\n  } else {\n    node.selectionStart = selection.start;\n    node.selectionEnd = selection.end;\n  }\n}\n\nfunction setContentEditableSelection(node, selection) {\n\n  var focusNode,\n      domRange,\n      domSelection;\n\n  focusNode = node.firstChild || node,\n  domRange = document.createRange();\n  domRange.setStart(focusNode, selection.start);\n  domRange.setEnd(focusNode, selection.end);\n\n  domSelection = window.getSelection();\n  domSelection.removeAllRanges();\n  domSelection.addRange(domRange);\n}\n","'use strict';\n\nvar domQuery = require(538),\n    domClear = require(532),\n    is = require(167).is,\n    forEach = require(386),\n    domify = require(535),\n    Ids = require(366);\n\nvar SPACE_REGEX = //s/;\n\n// for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\nvar QNAME_REGEX = /^([a-z][/w-.]*:)?[a-z_][/w-.]*$/i;\n\n// for ID validation as per BPMN Schema (QName - Namespace)\nvar ID_REGEX = /^[a-z_][/w-.]*$/i;\n\nvar PLACEHOLDER_REGEX = //$/{([^/}]*)/}/g;\n\nfunction selectedOption(selectBox) {\n  if (selectBox.selectedIndex >= 0) {\n    return selectBox.options[selectBox.selectedIndex].value;\n  }\n}\n\nmodule.exports.selectedOption = selectedOption;\n\n\nfunction selectedType(elementSyntax, inputNode) {\n  var typeSelect = domQuery(elementSyntax, inputNode);\n  return selectedOption(typeSelect);\n}\n\nmodule.exports.selectedType = selectedType;\n\n\n/**\n * Retrieve the root element the document this\n * business object is contained in.\n *\n * @return {ModdleElement}\n */\nfunction getRoot(businessObject) {\n  var parent = businessObject;\n  while (parent.$parent) {\n    parent = parent.$parent;\n  }\n  return parent;\n}\n\nmodule.exports.getRoot = getRoot;\n\n\n/**\n * filters all elements in the list which have a given type.\n * removes a new list\n */\nfunction filterElementsByType(objectList, type) {\n  var list = objectList || [];\n  var result = [];\n  forEach(list, function(obj) {\n    if (is(obj, type)) {\n      result.push(obj);\n    }\n  });\n  return result;\n}\n\nmodule.exports.filterElementsByType = filterElementsByType;\n\n\nfunction findRootElementsByType(businessObject, referencedType) {\n  var root = getRoot(businessObject);\n\n  return filterElementsByType(root.rootElements, referencedType);\n}\n\nmodule.exports.findRootElementsByType = findRootElementsByType;\n\n\nfunction removeAllChildren(domElement) {\n  while (domElement.firstChild) {\n    domElement.removeChild(domElement.firstChild);\n  }\n}\n\nmodule.exports.removeAllChildren = removeAllChildren;\n\n\n/**\n * adds an empty option to the list\n */\nfunction addEmptyParameter(list) {\n  return list.push({ 'label': '', 'value': '', 'name': '' });\n}\n\nmodule.exports.addEmptyParameter = addEmptyParameter;\n\n\n/**\n * returns a list with all root elements for the given parameter 'referencedType'\n */\nfunction refreshOptionsModel(businessObject, referencedType) {\n  var model = [];\n  var referableObjects = findRootElementsByType(businessObject, referencedType);\n  forEach(referableObjects, function(obj) {\n    model.push({\n      label: (obj.name || '')  + ' (id='+obj.id+')',\n      value: obj.id,\n      name: obj.name\n    });\n  });\n  return model;\n}\n\nmodule.exports.refreshOptionsModel = refreshOptionsModel;\n\n\n/**\n * fills the drop down with options\n */\nfunction updateOptionsDropDown(domSelector, businessObject, referencedType, entryNode) {\n  var options = refreshOptionsModel(businessObject, referencedType);\n  addEmptyParameter(options);\n  var selectBox = domQuery(domSelector, entryNode);\n  domClear(selectBox);\n\n  forEach(options, function(option) {\n    var optionEntry = domify('<option value=\"' + option.value + '\">' + option.label + '</option>');\n    selectBox.appendChild(optionEntry);\n  });\n  return options;\n}\n\nmodule.exports.updateOptionsDropDown = updateOptionsDropDown;\n\n\n/**\n * checks whether the id value is valid\n *\n * @param {ModdleElement} bo\n * @param {String} idValue\n *\n * @return {String} error message\n */\nfunction isIdValid(bo, idValue) {\n  var assigned = bo.$model.ids.assigned(idValue);\n\n  var idExists = assigned && assigned !== bo;\n\n  if (!idValue || idExists) {\n    return 'Element must have an unique id.';\n  }\n\n  return validateId(idValue);\n}\n\nmodule.exports.isIdValid = isIdValid;\n\n\nfunction validateId(idValue) {\n\n  idValue = stripPlaceholders(idValue);\n\n  if (containsSpace(idValue)) {\n    return 'Id must not contain spaces.';\n  }\n\n  if (!ID_REGEX.test(idValue)) {\n\n    if (QNAME_REGEX.test(idValue)) {\n      return 'Id must not contain prefix.';\n    }\n\n    return 'Id must be a valid QName.';\n  }\n}\n\nmodule.exports.validateId = validateId;\n\n\nfunction containsSpace(value) {\n  return SPACE_REGEX.test(value);\n}\n\nmodule.exports.containsSpace = containsSpace;\n\n\nfunction stripPlaceholders(idValue) {\n\n  // replace expression e.g. ${VERSION_TAG}\n  // use only the content between ${}\n  // for the REGEX check\n  return idValue.replace(PLACEHOLDER_REGEX, '$1');\n}\n\n/**\n * generate a semantic id with given prefix\n */\nfunction nextId(prefix) {\n  var ids = new Ids([32,32,1]);\n\n  return ids.nextPrefixed(prefix);\n}\n\nmodule.exports.nextId = nextId;\n\n\nfunction triggerClickEvent(element) {\n  var evt;\n  var eventType = 'click';\n\n  if (document.createEvent) {\n    try {\n      // Chrome, Safari, Firefox\n      evt = new MouseEvent((eventType), { view: window, bubbles: true, cancelable: true });\n    } catch (e) {\n      // IE 11, PhantomJS (wat!)\n      evt = document.createEvent('MouseEvent');\n\n      evt.initEvent((eventType), true, true);\n    }\n    return element.dispatchEvent(evt);\n  } else {\n    // Welcome IE\n    evt = document.createEventObject();\n\n    return element.fireEvent('on' + eventType, evt);\n  }\n}\n\nmodule.exports.triggerClickEvent = triggerClickEvent;\n","'use strict';\n\nvar elementHelper = require(27);\n\n/**\n * A handler capable of creating a new element under a provided parent\n * and updating / creating a reference to it in one atomic action.\n *\n * @class\n * @constructor\n */\nfunction CreateAndReferenceElementHandler(elementRegistry, bpmnFactory) {\n  this._elementRegistry = elementRegistry;\n  this._bpmnFactory = bpmnFactory;\n}\n\nCreateAndReferenceElementHandler.$inject = [ 'elementRegistry', 'bpmnFactory' ];\n\nmodule.exports = CreateAndReferenceElementHandler;\n\nfunction ensureNotNull(prop, name) {\n  if (!prop) {\n    throw new Error(name + ' required');\n  }\n  return prop;\n}\n\n////// api /////////////////////////////////////////////\n\n/**\n * Creates a new element under a provided parent and updates / creates a reference to it in\n * one atomic action.\n *\n * @method  CreateAndReferenceElementHandler#execute\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element which is the context for the reference\n * @param {moddle.referencingObject} context.referencingObject the object which creates the reference\n * @param {String} context.referenceProperty the property of the referencingObject which makes the reference\n * @param {moddle.newObject} context.newObject the new object to add\n * @param {moddle.newObjectContainer} context.newObjectContainer the container for the new object\n *\n * @returns {Array<djs.mode.Base>} the updated element\n */\nCreateAndReferenceElementHandler.prototype.execute = function(context) {\n\n  var referencingObject = ensureNotNull(context.referencingObject, 'referencingObject'),\n      referenceProperty = ensureNotNull(context.referenceProperty, 'referenceProperty'),\n      newObject = ensureNotNull(context.newObject, 'newObject'),\n      newObjectContainer = ensureNotNull(context.newObjectContainer, 'newObjectContainer'),\n      newObjectParent = ensureNotNull(context.newObjectParent, 'newObjectParent'),\n      changed = [ context.element ]; // this will not change any diagram-js elements\n\n  // create new object\n  var referencedObject = elementHelper\n                          .createElement(newObject.type, newObject.properties, newObjectParent, this._bpmnFactory);\n  context.referencedObject = referencedObject;\n\n  // add to containing list\n  newObjectContainer.push(referencedObject);\n\n  // adjust reference attribute\n  context.previousReference = referencingObject[referenceProperty];\n  referencingObject[referenceProperty] = referencedObject;\n\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};\n\n/**\n * Reverts the update\n *\n * @method  CreateAndReferenceElementHandler#revert\n *\n * @param {Object} context\n *\n * @returns {djs.mode.Base} the updated element\n */\nCreateAndReferenceElementHandler.prototype.revert = function(context) {\n\n  var referencingObject = context.referencingObject,\n      referenceProperty = context.referenceProperty,\n      previousReference = context.previousReference,\n      referencedObject = context.referencedObject,\n      newObjectContainer = context.newObjectContainer;\n\n  // reset reference\n  referencingObject.set(referenceProperty, previousReference);\n\n  // remove new element\n  newObjectContainer.splice(newObjectContainer.indexOf(referencedObject), 1);\n\n  return context.changed;\n};\n","'use strict';\n\nvar forEach = require(386);\n\nvar elementHelper = require(27);\n\n/**\n * A handler that implements a BPMN 2.0 property update\n * for business objects which are not represented in the\n * diagram.\n *\n * This is useful in the context of the properties panel in\n * order to update child elements of elements visible in\n * the diagram.\n *\n * Example: perform an update of a specific event definition\n * of an intermediate event.\n *\n * @class\n * @constructor\n */\nfunction CreateBusinessObjectListHandler(elementRegistry, bpmnFactory) {\n  this._elementRegistry = elementRegistry;\n  this._bpmnFactory = bpmnFactory;\n}\n\nCreateBusinessObjectListHandler.$inject = [ 'elementRegistry', 'bpmnFactory' ];\n\nmodule.exports = CreateBusinessObjectListHandler;\n\nfunction ensureNotNull(prop, name) {\n  if (!prop) {\n    throw new Error(name + ' required');\n  }\n  return prop;\n\n}\nfunction ensureList(prop, name) {\n  if (!prop || Object.prototype.toString.call(prop) !== '[object Array]' ) {\n    throw new Error(name + ' needs to be a list');\n  }\n  return prop;\n}\n\n////// api /////////////////////////////////////////////\n\n/**\n * Creates a new element under a provided parent and updates / creates a reference to it in\n * one atomic action.\n *\n * @method  CreateBusinessObjectListHandler#execute\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element which is the context for the reference\n * @param {moddle.referencingObject} context.referencingObject the object which creates the reference\n * @param {String} context.referenceProperty the property of the referencingObject which makes the reference\n * @param {moddle.newObject} context.newObject the new object to add\n * @param {moddle.newObjectContainer} context.newObjectContainer the container for the new object\n *\n * @return {Array<djs.mode.Base>} the updated element\n */\nCreateBusinessObjectListHandler.prototype.execute = function(context) {\n\n  var currentObject = ensureNotNull(context.currentObject, 'currentObject'),\n      propertyName = ensureNotNull(context.propertyName, 'propertyName'),\n      newObjects = ensureList(context.newObjects, 'newObjects'),\n      changed = [ context.element ]; // this will not change any diagram-js elements\n\n\n  var childObjects = [];\n  var self = this;\n\n  // create new array of business objects\n  forEach(newObjects, function(obj) {\n    var element = elementHelper.createElement(obj.type, obj.properties, currentObject, self._bpmnFactory);\n\n    childObjects.push(element);\n  });\n  context.childObject = childObjects;\n\n  // adjust array reference in the parent business object\n  context.previousChilds = currentObject[propertyName];\n  currentObject[propertyName] = childObjects;\n\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};\n\n/**\n * Reverts the update\n *\n * @method  CreateBusinessObjectListHandler#revert\n *\n * @param {Object} context\n *\n * @return {djs.mode.Base} the updated element\n */\nCreateBusinessObjectListHandler.prototype.revert = function(context) {\n\n  var currentObject = context.currentObject,\n      propertyName = context.propertyName,\n      previousChilds = context.previousChilds;\n\n  // remove new element\n  currentObject.set(propertyName, previousChilds);\n\n  return context.changed;\n};\n","'use strict';\n\nvar forEach = require(386);\n\n/**\n * A handler that combines and executes multiple commands.\n *\n * All updates are bundled on the command stack and executed in one step.\n * This also makes it possible to revert the changes in one step.\n *\n * Example use case: remove the camunda:formKey attribute and in addition\n * add all form fields needed for the camunda:formData property.\n *\n * @class\n * @constructor\n */\nfunction MultiCommandHandler(commandStack) {\n  this._commandStack = commandStack;\n}\n\nMultiCommandHandler.$inject = [ 'commandStack' ];\n\nmodule.exports = MultiCommandHandler;\n\nMultiCommandHandler.prototype.preExecute = function(context) {\n\n  var commandStack = this._commandStack;\n\n  forEach(context, function(command) {\n    commandStack.execute(command.cmd, command.context);\n  });\n};","'use strict';\n\nvar reduce = require(525),\n    is = require(167).is,\n    keys = require(519),\n    forEach = require(386);\n\n/**\n * A handler that implements a BPMN 2.0 property update\n * for business objects which are not represented in the\n * diagram.\n *\n * This is useful in the context of the properties panel in\n * order to update child elements of elements visible in\n * the diagram.\n *\n * Example: perform an update of a specific event definition\n * of an intermediate event.\n *\n * @class\n * @constructor\n */\nfunction UpdateBusinessObjectHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\n\nUpdateBusinessObjectHandler.$inject = [ 'elementRegistry' ];\n\nmodule.exports = UpdateBusinessObjectHandler;\n\n/**\n * returns the root element\n */\nfunction getRoot(businessObject) {\n  var parent = businessObject;\n  while (parent.$parent) {\n    parent = parent.$parent;\n  }\n  return parent;\n}\n\nfunction getProperties(businessObject, propertyNames) {\n  return reduce(propertyNames, function(result, key) {\n    result[key] = businessObject.get(key);\n    return result;\n  }, {});\n}\n\n\nfunction setProperties(businessObject, properties) {\n  forEach(properties, function(value, key) {\n    businessObject.set(key, value);\n  });\n}\n\n\n////// api /////////////////////////////////////////////\n\n/**\n * Updates a business object with a list of new properties\n *\n * @method  UpdateBusinessObjectHandler#execute\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element the element which has a child business object updated\n * @param {moddle.businessObject} context.businessObject the businessObject to update\n * @param {Object} context.properties a list of properties to set on the businessObject\n *\n * @return {Array<djs.mode.Base>} the updated element\n */\nUpdateBusinessObjectHandler.prototype.execute = function(context) {\n\n  var element = context.element,\n      businessObject = context.businessObject,\n      rootElements = getRoot(businessObject).rootElements,\n      referenceType = context.referenceType,\n      referenceProperty = context.referenceProperty,\n      changed = [ element ]; // this will not change any diagram-js elements\n\n  if (!element) {\n    throw new Error('element required');\n  }\n\n  if (!businessObject) {\n    throw new Error('businessObject required');\n  }\n\n  var properties = context.properties,\n      oldProperties = context.oldProperties || getProperties(businessObject, keys(properties));\n\n  // check if there the update needs an external element for reference\n  if (typeof referenceType !== 'undefined' && typeof referenceProperty !== 'undefined') {\n    forEach(rootElements, function(rootElement) {\n      if (is(rootElement, referenceType)) {\n        if (rootElement.id === properties[referenceProperty]) {\n          properties[referenceProperty] = rootElement;\n        }\n      }\n    });\n  }\n\n  // update properties\n  setProperties(businessObject, properties);\n\n  // store old values\n  context.oldProperties = oldProperties;\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};\n\n/**\n * Reverts the update\n *\n * @method  UpdateBusinessObjectHandler#revert\n *\n * @param {Object} context\n *\n * @return {djs.mode.Base} the updated element\n */\nUpdateBusinessObjectHandler.prototype.revert = function(context) {\n\n  var oldProperties = context.oldProperties,\n      businessObject = context.businessObject;\n\n  // update properties\n  setProperties(businessObject, oldProperties);\n\n  return context.changed;\n};\n","'use strict';\n\nvar forEach = require(386);\n\n/**\n * A handler that implements a BPMN 2.0 property update\n * for business object lists which are not represented in the\n * diagram.\n *\n * This is useful in the context of the properties panel in\n * order to update child elements of elements visible in\n * the diagram.\n *\n * Example: perform an update of a specific event definition\n * of an intermediate event.\n *\n * @class\n * @constructor\n */\nfunction UpdateBusinessObjectListHandler(elementRegistry, bpmnFactory) {\n  this._elementRegistry = elementRegistry;\n  this._bpmnFactory = bpmnFactory;\n}\n\nUpdateBusinessObjectListHandler.$inject = [ 'elementRegistry', 'bpmnFactory' ];\n\nmodule.exports = UpdateBusinessObjectListHandler;\n\nfunction ensureNotNull(prop, name) {\n  if (!prop) {\n    throw new Error(name + 'required');\n  }\n  return prop;\n}\n\n////// api /////////////////////////////////////////////\n\n/**\n * Updates a element under a provided parent.\n */\nUpdateBusinessObjectListHandler.prototype.execute = function(context) {\n\n  var currentObject = ensureNotNull(context.currentObject, 'currentObject'),\n      propertyName = ensureNotNull(context.propertyName, 'propertyName'),\n      updatedObjectList = context.updatedObjectList,\n      objectsToRemove = context.objectsToRemove || [],\n      objectsToAdd = context.objectsToAdd || [],\n      changed = [ context.element], // this will not change any diagram-js elements\n      referencePropertyName;\n\n  if (context.referencePropertyName) {\n    referencePropertyName = context.referencePropertyName;\n  }\n\n  var objectList = currentObject[propertyName];\n  // adjust array reference in the parent business object\n  context.previousList = currentObject[propertyName];\n\n  if (updatedObjectList) {\n    currentObject[propertyName] = updatedObjectList;\n  } else {\n    var listCopy = [];\n    // remove all objects which should be removed\n    forEach(objectList, function(object) {\n      if (objectsToRemove.indexOf(object) == -1) {\n        listCopy.push(object);\n      }\n    });\n    // add all objects which should be added\n    listCopy = listCopy.concat(objectsToAdd);\n\n    // set property to new list\n    if (listCopy.length > 0 || !referencePropertyName) {\n\n      // as long as there are elements in the list update the list\n      currentObject[propertyName] = listCopy;\n    } else if (referencePropertyName) {\n\n      // remove the list when it is empty\n      var parentObject = currentObject.$parent;\n      parentObject.set(referencePropertyName, undefined);\n    }\n  }\n\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};\n\n/**\n * Reverts the update\n *\n * @method  CreateBusinessObjectListHandler#revert\n *\n * @param {Object} context\n *\n * @return {djs.mode.Base} the updated element\n */\nUpdateBusinessObjectListHandler.prototype.revert = function(context) {\n\n  var currentObject = context.currentObject,\n      propertyName = context.propertyName,\n      previousList = context.previousList,\n      parentObject = currentObject.$parent;\n\n  if (context.referencePropertyName) {\n    parentObject.set(context.referencePropertyName, currentObject);\n  }\n\n  // remove new element\n  currentObject.set(propertyName, previousList);\n\n  return context.changed;\n};\n","'use strict';\n\nvar forEach = require(386);\n\nvar HANDLERS = {\n  'properties-panel.update-businessobject': require(12),\n  'properties-panel.create-and-reference': require(9),\n  'properties-panel.create-businessobject-list': require(10),\n  'properties-panel.update-businessobject-list': require(13),\n  'properties-panel.multi-command-executor': require(11)\n};\n\n\nfunction CommandInitializer(eventBus, commandStack) {\n\n  eventBus.on('diagram.init', function() {\n    forEach(HANDLERS, function(handler, id) {\n      commandStack.registerHandler(id, handler);\n    });\n  });\n}\n\nCommandInitializer.$inject = [ 'eventBus', 'commandStack' ];\n\nmodule.exports = {\n  __init__: [ CommandInitializer ]\n};","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject,\n    cmdHelper = require(26);\n\nvar entryFieldDescription = require(18);\n\n\nvar checkbox = function(options, defaultParameters) {\n  var resource      = defaultParameters,\n      label         = options.label || resource.id,\n      canBeDisabled = !!options.disabled && typeof options.disabled === 'function',\n      canBeHidden   = !!options.hidden && typeof options.hidden === 'function',\n      description   = options.description;\n\n  resource.html =\n    '<input id=\"camunda-' + resource.id + '\" ' +\n         'type=\"checkbox\" ' +\n         'name=\"' + options.modelProperty + '\" ' +\n         (canBeDisabled ? 'data-disable=\"isDisabled\"' : '') +\n         (canBeHidden ? 'data-show=\"isHidden\"' : '') +\n         ' />' +\n    '<label for=\"camunda-' + resource.id + '\" ' +\n         (canBeDisabled ? 'data-disable=\"isDisabled\"' : '') +\n         (canBeHidden ? 'data-show=\"isHidden\"' : '') +\n         '>' + label + '</label>';\n\n  // add description below checkbox entry field\n  if (description) {\n    resource.html += entryFieldDescription(description);\n  }\n\n  resource.get = function(element) {\n    var bo = getBusinessObject(element),\n        res = {};\n\n    res[options.modelProperty] = bo.get(options.modelProperty);\n\n    return res;\n  };\n  resource.set = function(element, values) {\n    var res = {};\n\n    res[options.modelProperty] = !!values[options.modelProperty];\n\n    return cmdHelper.updateProperties(element, res);\n  };\n\n  if (typeof options.set === 'function') {\n    resource.set = options.set;\n  }\n\n  if (typeof options.get === 'function') {\n    resource.get = options.get;\n  }\n\n  if (canBeDisabled) {\n    resource.isDisabled = function() {\n      return options.disabled.apply(resource, arguments);\n    };\n  }\n\n  if (canBeHidden) {\n    resource.isHidden = function() {\n      return !options.hidden.apply(resource, arguments);\n    };\n  }\n\n  resource.cssClasses = ['bpp-checkbox'];\n\n  return resource;\n};\n\nmodule.exports = checkbox;\n","'use strict';\n\nvar assign = require(516),\n    find = require(385);\n\nvar domQuery = require(538);\n\nvar selectEntryFactory = require(21),\n    entryFieldDescription = require(18);\n\n\n/**\n * The combo box is a special implementation of the select entry and adds the option 'custom' to the\n * select box. If 'custom' is selected, an additional text input field is shown which allows to define\n * a custom value.\n *\n * @param  {Object} options\n * @param  {string} options.id\n * @param  {string} options.label\n * @param  {Array<Object>} options.selectOptions list of name/value pairs\n * @param  {string} options.modelProperty\n * @param  {function} options.get\n * @param  {function} options.set\n * @param  {string} [options.customValue] custom select option value (default: 'custom')\n * @param  {string} [options.customName] custom select option name visible in the select box (default: 'custom')\n *\n * @return {Object}\n */\nvar comboBox = function(options) {\n\n  var selectOptions = options.selectOptions,\n      modelProperty = options.modelProperty,\n      customValue   = options.customValue || 'custom',\n      customName    = options.customName || 'custom ' + modelProperty,\n      description   = options.description;\n\n  // check if a value is not a built in value\n  var isCustomValue = function(value) {\n    if (typeof value[modelProperty] === 'undefined') {\n      return false;\n    }\n\n    var isCustom = !find(selectOptions, function(option) {\n      return value[modelProperty] === option.value;\n    });\n\n    return isCustom;\n  };\n\n  var comboOptions = assign({}, options);\n\n  // true if the selected value in the select box is customValue\n  comboOptions.showCustomInput = function(element, node) {\n    var selectBox = domQuery('[data-entry=\"'+ options.id +'\"] select', node.parentNode);\n\n    if (selectBox) {\n      return selectBox.value === customValue;\n    }\n\n    return false;\n  };\n\n  comboOptions.get = function(element, node) {\n    var value = options.get(element, node);\n\n    var modifiedValues = {};\n\n    if (!isCustomValue(value)) {\n      modifiedValues[modelProperty] = value[modelProperty] || '';\n\n      return modifiedValues;\n    }\n\n    modifiedValues[modelProperty] = customValue;\n    modifiedValues['custom-'+modelProperty] = value[modelProperty];\n\n    return modifiedValues;\n  };\n\n  comboOptions.set = function(element, values, node) {\n    var modifiedValues = {};\n\n    // if the custom select option has been selected\n    // take the value from the text input field\n    if (values[modelProperty] === customValue) {\n      modifiedValues[modelProperty] = values['custom-' + modelProperty] || '';\n    }\n    else if (options.emptyParameter && values[modelProperty] === '') {\n      modifiedValues[modelProperty] = undefined;\n    } else {\n      modifiedValues[modelProperty] = values[modelProperty];\n    }\n    return options.set(element, modifiedValues, node);\n  };\n\n  comboOptions.selectOptions.push({ name: customName, value: customValue });\n\n  var comboBoxEntry = assign({}, selectEntryFactory(comboOptions, comboOptions));\n\n  comboBoxEntry.html += '<div class=\"bpp-field-wrapper bpp-combo-input\" ' +\n    'data-show=\"showCustomInput\"' +\n    '>' +\n    '<input id=\"camunda-' + options.id + '-input\" type=\"text\" name=\"custom-' + modelProperty+'\" ' +\n      ' />' +\n  '</div>';\n\n  // add description below combo box entry field\n  if (description) {\n    comboBoxEntry.html += entryFieldDescription(description);\n  }\n\n  return comboBoxEntry;\n};\n\nmodule.exports = comboBox;\n","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject;\n\n// input entities\nvar textInputField = require(24),\n    checkboxField = require(15),\n    selectBoxField = require(21),\n    comboBoxField = require(16),\n    textBoxField = require(23),\n    validationAwareTextInputField = require(25),\n    tableField = require(22),\n    labelEntry = require(19),\n    link = require(20);\n\nvar cmdHelper = require(26);\n\n// helpers ////////////////////////////////////////\n\nfunction ensureNotNull(prop) {\n  if (!prop) {\n    throw new Error(prop + ' must be set.');\n  }\n\n  return prop;\n}\n\n/**\n * sets the default parameters which are needed to create an entry\n *\n * @param options\n * @returns {{id: *, description: (*|string), get: (*|Function), set: (*|Function),\n *            validate: (*|Function), html: string}}\n */\nvar setDefaultParameters = function( options ) {\n\n  // default method to fetch the current value of the input field\n  var defaultGet = function(element) {\n    var bo = getBusinessObject(element),\n        res = {},\n        prop = ensureNotNull(options.modelProperty);\n    res[prop] = bo.get(prop);\n\n    return res;\n  };\n\n// default method to set a new value to the input field\n  var defaultSet = function(element, values) {\n    var res = {},\n        prop = ensureNotNull(options.modelProperty);\n    if (values[prop] !== '') {\n      res[prop] = values[prop];\n    } else {\n      res[prop] = undefined;\n    }\n\n    return cmdHelper.updateProperties(element, res);\n  };\n\n// default validation method\n  var defaultValidate = function() {\n    return {};\n  };\n\n  return {\n    id : options.id,\n    description : ( options.description || '' ),\n    get : ( options.get || defaultGet ),\n    set : ( options.set || defaultSet ),\n    validate : ( options.validate || defaultValidate ),\n    html: ''\n  };\n};\n\nfunction EntryFactory() {\n\n}\n\n/**\n * Generates an text input entry object for a property panel.\n * options are:\n * - id: id of the entry - String\n *\n * - description: description of the property - String\n *\n * - label: label for the input field - String\n *\n * - set: setter method - Function\n *\n * - get: getter method - Function\n *\n * - validate: validation mehtod - Function\n *\n * - modelProperty: name of the model property - String\n *\n * - buttonAction: Object which contains the following properties: - Object\n * ---- name: name of the [data-action] callback - String\n * ---- method: callback function for [data-action] - Function\n *\n * - buttonShow: Object which contains the following properties: - Object\n * ---- name: name of the [data-show] callback - String\n * ---- method: callback function for [data-show] - Function\n *\n * @param options\n * @returns the propertyPanel entry resource object\n */\nEntryFactory.textField = function(options) {\n  return textInputField(options, setDefaultParameters(options));\n};\n\nEntryFactory.validationAwareTextField = function(options) {\n  return validationAwareTextInputField(options, setDefaultParameters(options));\n};\n\n/**\n * Generates a checkbox input entry object for a property panel.\n * options are:\n * - id: id of the entry - String\n *\n * - description: description of the property - String\n *\n * - label: label for the input field - String\n *\n * - set: setter method - Function\n *\n * - get: getter method - Function\n *\n * - validate: validation mehtod - Function\n *\n * - modelProperty: name of the model property - String\n *\n * @param options\n * @returns the propertyPanel entry resource object\n */\nEntryFactory.checkbox = function(options) {\n  return checkboxField(options, setDefaultParameters(options));\n};\n\nEntryFactory.textBox = function(options) {\n  return textBoxField(options, setDefaultParameters(options));\n};\n\nEntryFactory.selectBox = function(options) {\n  return selectBoxField(options, setDefaultParameters(options));\n};\n\nEntryFactory.comboBox = function(options) {\n  return comboBoxField(options);\n};\n\nEntryFactory.table = function(options) {\n  return tableField(options);\n};\n\nEntryFactory.label = function(options) {\n  return labelEntry(options);\n};\n\nEntryFactory.link = function(options) {\n  return link(options);\n};\n\nmodule.exports = EntryFactory;\n","'use strict';\n\nvar MARKDOWN_LINK_REGEX = //[([^/)]+)/]/(([^/]]+)/)/g;\n\n/**\n * Replace MarkDown Link Syntax with HTML Link Syntax\n * [myLink](http://www.myLink.de) -> <a href=http://www.myLink.de>myLink</a>\n *\n * @param {String} value\n *\n * @return {String}\n */\nfunction linkify(text) {\n  return text.replace(MARKDOWN_LINK_REGEX, '<a href=\"$2\" target=\"_blank\">$1</a>');\n}\n\nmodule.exports = function entryFieldDescription(description) {\n  description = linkify(description);\n\n  return '<div class=\"bpp-field-description\">' + description + '</div>';\n};\n","'use strict';\n\n/**\n * The label factory provides a label entry. For the label text\n * it expects either a string provided by the options.labelText\n * parameter or it could be generated programmatically using a\n * function passed as the options.get parameter.\n *\n * @param  {Object} options\n * @param  {string} options.id\n * @param  {string} [options.labelText]\n * @param  {Function} [options.get]\n * @param  {Function} [options.showLabel]\n * @param  {Boolean} [options.divider] adds a divider at the top of the label if true; default: false\n */\nvar label = function(options) {\n  return {\n    id: options.id,\n    html: '<label data-value=\"label\" ' +\n            'data-show=\"showLabel\" ' +\n            'class=\"entry-label' + (options.divider ? ' divider' : '') + '\">' +\n          '</label>',\n    get: function(element, node) {\n      if (typeof options.get === 'function') {\n        return options.get(element, node);\n      }\n      return { label: options.labelText };\n    },\n    showLabel: function(element, node) {\n      if (typeof options.showLabel === 'function') {\n        return options.showLabel(element, node);\n      }\n      return true;\n    }\n  };\n};\n\nmodule.exports = label;\n","'use strict';\n\nvar utils = require(8);\n\nvar entryFieldDescription = require(18);\n\nvar link = function(options, defaultParameters) {\n\n  var id                  = options.id,\n      label               = options.label || id,\n      hideLink            = options.hideLink,\n      canBeHidden         = typeof hideLink === 'function',\n      getClickableElement = options.getClickableElement,\n      description         = options.description;\n\n  var resource = { id: id };\n\n  resource.html =\n    '<a data-action=\"linkSelected\" ' +\n    (canBeHidden ? 'data-show=\"hideLink\" ' : '') +\n    'class=\"bpp-entry-link' + (options.cssClasses ? ' ' + options.cssClasses : '') +\n    '\">' + label + '</a>';\n\n  // add description below link entry field\n  if (description) {\n    resource.html += entryFieldDescription(description);\n  }\n\n  resource.linkSelected = function(element, node, event, scopeNode) {\n    if (typeof getClickableElement === 'function') {\n\n      var link = getClickableElement.apply(resource, [ element, node, event, scopeNode ]);\n      link && utils.triggerClickEvent(link);\n    }\n\n    return false;\n  };\n\n  if (canBeHidden) {\n    resource.hideLink = function() {\n      return !hideLink.apply(resource, arguments);\n    };\n  }\n\n  return resource;\n};\n\nmodule.exports = link;\n","'use strict';\n\nvar domify = require(535);\n\nvar forEach = require(386);\n\nvar entryFieldDescription = require(18);\n\n\nvar isList = function(list) {\n  return !(!list || Object.prototype.toString.call(list) !== '[object Array]');\n};\n\nvar addEmptyParameter = function(list) {\n  return list.concat([ { name: '', value: '' } ]);\n};\n\nvar createOption = function(option) {\n  return '<option value=\"' + option.value + '\">' + option.name + '</option>';\n};\n\n/**\n * @param  {Object} options\n * @param  {string} options.id\n * @param  {string} [options.label]\n * @param  {Array<Object>} options.selectOptions\n * @param  {string} options.modelProperty\n * @param  {boolean} options.emptyParameter\n * @param  {function} options.disabled\n * @param  {function} options.hidden\n * @param  {Object} defaultParameters\n *\n * @return {Object}\n */\nvar selectbox = function(options, defaultParameters) {\n  var resource = defaultParameters,\n      label = options.label || resource.id,\n      selectOptions = options.selectOptions || [ { name: '', value: '' } ],\n      modelProperty = options.modelProperty,\n      emptyParameter = options.emptyParameter,\n      canBeDisabled = !!options.disabled && typeof options.disabled === 'function',\n      canBeHidden = !!options.hidden && typeof options.hidden === 'function',\n      description = options.description;\n\n\n  if (emptyParameter) {\n    selectOptions = addEmptyParameter(selectOptions);\n  }\n\n\n  resource.html =\n    '<label for=\"camunda-' + resource.id + '\"' +\n    (canBeDisabled ? 'data-disable=\"isDisabled\" ' : '') +\n    (canBeHidden ? 'data-show=\"isHidden\" ' : '') +\n    '>' + label + '</label>' +\n    '<select id=\"camunda-' + resource.id + '-select\" name=\"' + modelProperty + '\"' +\n    (canBeDisabled ? 'data-disable=\"isDisabled\" ' : '') +\n    (canBeHidden ? 'data-show=\"isHidden\" ' : '') +\n    ' data-value>';\n\n  if (isList(selectOptions)) {\n    forEach(selectOptions, function(option) {\n      resource.html += '<option value=\"' + option.value + '\">' + (option.name || '') + '</option>';\n    });\n  }\n\n  resource.html += '</select>';\n\n  // add description below select box entry field\n  if (description && !typeof options.showCustomInput === 'function') {\n    resource.html += entryFieldDescription(description);\n  }\n\n  /**\n   * Fill the select box options dynamically.\n   *\n   * Calls the defined function #selectOptions in the entry to get the\n   * values for the options and set the value to the inputNode.\n   *\n   * @param {djs.model.Base} element\n   * @param {HTMLElement} entryNode\n   * @param {EntryDescriptor} inputNode\n   * @param {Object} inputName\n   * @param {Object} newValue\n   */\n  resource.setControlValue = function(element, entryNode, inputNode, inputName, newValue) {\n    if (typeof selectOptions === 'function') {\n\n      var options = selectOptions(element, inputNode);\n\n      if (options) {\n\n        // remove existing options\n        while (inputNode.firstChild) {\n          inputNode.removeChild(inputNode.firstChild);\n        }\n\n        // add options\n        forEach(options, function(option) {\n          var template = domify(createOption(option));\n\n          inputNode.appendChild(template);\n        });\n\n\n      }\n    }\n\n    // set select value\n    if (newValue !== undefined) {\n      inputNode.value = newValue;\n    }\n\n  };\n\n  if (canBeDisabled) {\n    resource.isDisabled = function() {\n      return options.disabled.apply(resource, arguments);\n    };\n  }\n\n  if (canBeHidden) {\n    resource.isHidden = function() {\n      return !options.hidden.apply(resource, arguments);\n    };\n  }\n\n  resource.cssClasses = ['dropdown'];\n\n  return resource;\n};\n\nmodule.exports = selectbox;\n","'use strict';\n\nvar cmdHelper = require(26);\n\nvar domQuery = require(538),\n    domAttr = require(530),\n    domClosest = require(533);\n\nvar filter = require(384),\n    forEach = require(386),\n    keys = require(519);\n\nvar domify = require(535);\n\nvar entryFieldDescription = require(18);\n\nvar updateSelection = require(573);\n\nvar TABLE_ROW_DIV_SNIPPET = '<div class=\"bpp-field-wrapper bpp-table-row\">';\nvar DELETE_ROW_BUTTON_SNIPPET = '<button class=\"clear\" data-action=\"deleteElement\">' +\n                                  '<span>X</span>' +\n                                '</button>';\n\nfunction createInputRowTemplate(properties, canRemove) {\n  var template = TABLE_ROW_DIV_SNIPPET;\n  template += createInputTemplate(properties, canRemove);\n  template += canRemove ? DELETE_ROW_BUTTON_SNIPPET : '';\n  template += '</div>';\n\n  return template;\n}\n\nfunction createInputTemplate(properties, canRemove) {\n  var columns = properties.length;\n  var template = '';\n  forEach(properties, function(prop) {\n    template += '<input class=\"bpp-table-row-columns-' + columns + ' ' +\n                               (canRemove ? 'bpp-table-row-removable' : '') + '\" ' +\n                       'id=\"camunda-table-row-cell-input-value\" ' +\n                       'type=\"text\" ' +\n                       'name=\"' + prop + '\" />';\n  });\n  return template;\n}\n\nfunction createLabelRowTemplate(labels) {\n  var template = TABLE_ROW_DIV_SNIPPET;\n  template += createLabelTemplate(labels);\n  template += '</div>';\n\n  return template;\n}\n\nfunction createLabelTemplate(labels) {\n  var columns = labels.length;\n  var template = '';\n  forEach(labels, function(label) {\n    template += '<label class=\"bpp-table-row-columns-' + columns + '\">' + label + '</label>';\n  });\n  return template;\n}\n\nfunction pick(elements, properties) {\n  return (elements || []).map(function(elem) {\n    var newElement = {};\n    forEach(properties, function(prop) {\n      newElement[prop] = elem[prop] || '';\n    });\n    return newElement;\n  });\n}\n\nfunction diff(element, node, values, oldValues, editable) {\n  return filter(values, function(value, idx) {\n    return !valueEqual(element, node, value, oldValues[idx], editable, idx);\n  });\n}\n\nfunction valueEqual(element, node, value, oldValue, editable, idx) {\n  if (value && !oldValue) {\n    return false;\n  }\n  var allKeys = keys(value).concat(keys(oldValue));\n\n  return allKeys.every(function(key) {\n    var n = value[key] || undefined;\n    var o = oldValue[key] || undefined;\n    return !editable(element, node, key, idx) || n === o;\n  });\n}\n\nfunction getEntryNode(node) {\n  return domClosest(node, '[data-entry]', true);\n}\n\nfunction getContainer(node) {\n  return domQuery('div[data-list-entry-container]', node);\n}\n\nfunction getSelection(node) {\n  return {\n    start: node.selectionStart,\n    end: node.selectionEnd\n  };\n}\n\nfunction setSelection(node, selection) {\n  node.selectionStart = selection.start;\n  node.selectionEnd = selection.end;\n}\n\n/**\n * @param  {Object} options\n * @param  {string} options.id\n * @param  {string} options.description\n * @param  {Array<string>} options.modelProperties\n * @param  {Array<string>} options.labels\n * @param  {Function} options.getElements - this callback function must return a list of business object items\n * @param  {Function} options.removeElement\n * @param  {Function} options.addElement\n * @param  {Function} options.updateElement\n * @param  {Function} options.editable\n * @param  {Function} options.setControlValue\n * @param  {Function} options.show\n *\n * @return {Object}\n */\nmodule.exports = function(options) {\n\n  var id              = options.id,\n      modelProperties = options.modelProperties,\n      labels          = options.labels,\n      description     = options.description;\n\n  var labelRow = createLabelRowTemplate(labels);\n\n  var getElements   = options.getElements;\n\n  var removeElement = options.removeElement,\n      canRemove     = typeof removeElement === 'function';\n\n  var addElement = options.addElement,\n      canAdd     = typeof addElement === 'function',\n      addLabel   = options.addLabel || 'Add Value';\n\n  var updateElement = options.updateElement,\n      canUpdate     = typeof updateElement === 'function';\n\n  var editable        = options.editable || function() { return true; },\n      setControlValue = options.setControlValue;\n\n  var show       = options.show,\n      canBeShown = typeof show === 'function';\n\n  var elements = function(element, node) {\n    return pick(getElements(element, node), modelProperties);\n  };\n\n  var factory = {\n    id: id,\n    html: ( canAdd ?\n          '<div class=\"bpp-table-add-row\" ' + (canBeShown ? 'data-show=\"show\"' : '') + '>' +\n            '<label>' + addLabel + '</label>' +\n            '<button class=\"add\" data-action=\"addElement\"><span>+</span></button>' +\n          '</div>' : '') +\n          '<div class=\"bpp-table\" data-show=\"showTable\">' +\n            '<div class=\"bpp-field-wrapper bpp-table-row\">' +\n               labelRow +\n            '</div>' +\n            '<div data-list-entry-container>' +\n            '</div>' +\n          '</div>' +\n\n          // add description below table entry field\n          ( description ? entryFieldDescription(description) : ''),\n\n    get: function(element, node) {\n      var boElements = elements(element, node, this.__invalidValues);\n\n      var invalidValues = this.__invalidValues;\n\n      delete this.__invalidValues;\n\n      forEach(invalidValues, function(value, idx) {\n        var element = boElements[idx];\n\n        forEach(modelProperties, function(prop) {\n          element[prop] = value[prop];\n        });\n      });\n\n      return boElements;\n    },\n\n    set: function(element, values, node) {\n      var action = this.__action || {};\n      delete this.__action;\n\n      if (action.id === 'delete-element') {\n        return removeElement(element, node, action.idx);\n      }\n      else if (action.id === 'add-element') {\n        return addElement(element, node);\n      }\n      else if (canUpdate) {\n        var commands = [],\n            valuesToValidate = values;\n\n        if (typeof options.validate !== 'function') {\n          valuesToValidate = diff(element, node, values, elements(element, node), editable);\n        }\n\n        var self = this;\n\n        forEach(valuesToValidate, function(value) {\n          var validationError,\n              idx = values.indexOf(value);\n\n          if (typeof options.validate === 'function') {\n            validationError = options.validate(element, value, node, idx);\n          }\n\n          if (!validationError) {\n            var cmd = updateElement(element, value, node, idx);\n\n            if (cmd) {\n              commands.push(cmd);\n            }\n          } else {\n            // cache invalid value in an object by index as key\n            self.__invalidValues = self.__invalidValues || {};\n            self.__invalidValues[idx] = value;\n\n            // execute a command, which does not do anything\n            commands.push(cmdHelper.updateProperties(element, {}));\n          }\n        });\n\n        return commands;\n      }\n    },\n    createListEntryTemplate: function(value, index, selectBox) {\n      return createInputRowTemplate(modelProperties, canRemove);\n    },\n\n    addElement: function(element, node, event, scopeNode) {\n      var template = domify(createInputRowTemplate(modelProperties, canRemove));\n\n      var container = getContainer(node);\n      container.appendChild(template);\n\n      this.__action = {\n        id: 'add-element'\n      };\n\n      return true;\n    },\n\n    deleteElement: function(element, node, event, scopeNode) {\n      var container = getContainer(node);\n      var rowToDelete = event.delegateTarget.parentNode;\n      var idx = parseInt(domAttr(rowToDelete, 'data-index'), 10);\n\n      container.removeChild(rowToDelete);\n\n      this.__action = {\n        id: 'delete-element',\n        idx: idx\n      };\n\n      return true;\n    },\n\n    editable: function(element, rowNode, input, prop, value, idx) {\n      var entryNode = domClosest(rowNode, '[data-entry]');\n      return editable(element, entryNode, prop, idx);\n    },\n\n    show: function(element, entryNode, node, scopeNode) {\n      entryNode = getEntryNode(entryNode);\n      return show(element, entryNode, node, scopeNode);\n    },\n\n    showTable: function(element, entryNode, node, scopeNode) {\n      entryNode = getEntryNode(entryNode);\n      var elems = elements(element, entryNode);\n      return elems && elems.length && (!canBeShown || show(element, entryNode, node, scopeNode));\n    },\n\n    validateListItem: function(element, value, node, idx) {\n      if (typeof options.validate === 'function') {\n        return options.validate(element, value, node, idx);\n      }\n    }\n\n  };\n\n  // Update/set the selection on the correct position.\n  // It's the same code like for an input value in the PropertiesPanel.js.\n  if (setControlValue) {\n    factory.setControlValue = function(element, rowNode, input, prop, value, idx) {\n      var entryNode = getEntryNode(rowNode);\n\n      var isReadOnly = domAttr(input, 'readonly');\n      var oldValue = input.value;\n\n      var selection;\n\n      // prevents input fields from having the value 'undefined'\n      if (value === undefined) {\n        value = '';\n      }\n\n      // when the attribute 'readonly' exists, ignore the comparison\n      // with 'oldValue' and 'value'\n      if (!!isReadOnly && oldValue === value) {\n        return;\n      }\n\n      // update selection on undo/redo\n      if (document.activeElement === input) {\n        selection = updateSelection(getSelection(input), oldValue, value);\n      }\n\n      setControlValue(element, entryNode, input, prop, value, idx);\n\n      if (selection) {\n        setSelection(input, selection);\n      }\n\n    };\n  }\n\n  return factory;\n\n};\n","'use strict';\n\nvar entryFieldDescription = require(18);\n\n\nvar textBox = function(options, defaultParameters) {\n\n  var resource    = defaultParameters,\n      label       = options.label || resource.id,\n      canBeShown  = !!options.show && typeof options.show === 'function',\n      description = options.description;\n\n  resource.html =\n    '<label for=\"camunda-' + resource.id + '\" ' +\n    (canBeShown ? 'data-show=\"isShown\"' : '') +\n    '>' + label + '</label>' +\n    '<div class=\"bpp-field-wrapper\" ' +\n    (canBeShown ? 'data-show=\"isShown\"' : '') +\n    '>' +\n      '<div contenteditable=\"true\" id=\"camunda-' + resource.id + '\" ' +\n            'name=\"' + options.modelProperty + '\" />' +\n    '</div>';\n\n  // add description below text box entry field\n  if (description) {\n    resource.html += entryFieldDescription(description);\n  }\n\n  if (canBeShown) {\n    resource.isShown = function() {\n      return options.show.apply(resource, arguments);\n    };\n  }\n\n  resource.cssClasses = ['bpp-textbox'];\n\n  return resource;\n};\n\nmodule.exports = textBox;\n","'use strict';\n\nvar domQuery = require(538);\n\nvar entryFieldDescription = require(18);\n\n\nvar textField = function(options, defaultParameters) {\n\n  // Default action for the button next to the input-field\n  var defaultButtonAction = function(element, inputNode) {\n    var input = domQuery('input[name=\"' + options.modelProperty + '\"]', inputNode);\n    input.value = '';\n\n    return true;\n  };\n\n  // default method to determine if the button should be visible\n  var defaultButtonShow = function(element, inputNode) {\n    var input = domQuery('input[name=\"' + options.modelProperty + '\"]', inputNode);\n\n    return input.value !== '';\n  };\n\n\n  var resource       = defaultParameters,\n      label          = options.label || resource.id,\n      dataValueLabel = options.dataValueLabel,\n      buttonLabel    = ( options.buttonLabel || 'X' ),\n      actionName     = ( typeof options.buttonAction != 'undefined' ) ? options.buttonAction.name : 'clear',\n      actionMethod   = ( typeof options.buttonAction != 'undefined' ) ? options.buttonAction.method : defaultButtonAction,\n      showName       = ( typeof options.buttonShow != 'undefined' ) ? options.buttonShow.name : 'canClear',\n      showMethod     = ( typeof options.buttonShow != 'undefined' ) ? options.buttonShow.method : defaultButtonShow,\n      canBeDisabled  = !!options.disabled && typeof options.disabled === 'function',\n      canBeHidden    = !!options.hidden && typeof options.hidden === 'function',\n      description    = options.description;\n\n  resource.html =\n    '<label for=\"camunda-' + resource.id + '\" ' +\n      (canBeDisabled ? 'data-disable=\"isDisabled\" ' : '') +\n      (canBeHidden ? 'data-show=\"isHidden\" ' : '') +\n      (dataValueLabel ? 'data-value=\"' + dataValueLabel + '\"' : '') + '>'+ label +'</label>' +\n    '<div class=\"bpp-field-wrapper\" ' +\n      (canBeDisabled ? 'data-disable=\"isDisabled\"' : '') +\n      (canBeHidden ? 'data-show=\"isHidden\"' : '') +\n      '>' +\n      '<input id=\"camunda-' + resource.id + '\" type=\"text\" name=\"' + options.modelProperty+'\" ' +\n        (canBeDisabled ? 'data-disable=\"isDisabled\"' : '') +\n        (canBeHidden ? 'data-show=\"isHidden\"' : '') +\n        ' />' +\n      '<button class=\"' + actionName + '\" data-action=\"' + actionName + '\" data-show=\"' + showName + '\" ' +\n        (canBeDisabled ? 'data-disabled=\"isDisabled\"' : '') +\n        (canBeHidden ? ' data-show=\"isHidden\"' : '') + '>' +\n        '<span>' + buttonLabel + '</span>' +\n      '</button>' +\n    '</div>';\n\n  // add description below text input entry field\n  if (description) {\n    resource.html += entryFieldDescription(description);\n  }\n\n  resource[actionName] = actionMethod;\n  resource[showName] = showMethod;\n\n  if (canBeDisabled) {\n    resource.isDisabled = function() {\n      return options.disabled.apply(resource, arguments);\n    };\n  }\n\n  if (canBeHidden) {\n    resource.isHidden = function() {\n      return !options.hidden.apply(resource, arguments);\n    };\n  }\n\n  resource.cssClasses = ['bpp-textfield'];\n\n  return resource;\n};\n\nmodule.exports = textField;\n","'use strict';\n\nvar textField = require(24);\n\n/**\n * This function is a wrapper around TextInputEntryFactory.\n * It adds functionality to cache an invalid value entered in the\n * text input, instead of setting it on the business object.\n */\nvar validationAwareTextField = function(options, defaultParameters) {\n\n  var modelProperty = options.modelProperty;\n\n  defaultParameters.get = function(element, node) {\n    var value = this.__lastInvalidValue;\n\n    delete this.__lastInvalidValue;\n\n    var properties = {};\n\n    properties[modelProperty] = value !== undefined ? value : options.getProperty(element, node);\n\n    return properties;\n  };\n\n  defaultParameters.set = function(element, values, node) {\n    var validationErrors = validate.apply(this, [ element, values, node ]),\n        propertyValue = values[modelProperty];\n\n    // make sure we do not update the id\n    if (validationErrors && validationErrors[modelProperty]) {\n      this.__lastInvalidValue = propertyValue;\n\n      return options.setProperty(element, {}, node);\n    } else {\n      var properties = {};\n\n      properties[modelProperty] = propertyValue;\n\n      return options.setProperty(element, properties, node);\n    }\n  };\n\n  var validate = defaultParameters.validate = function(element, values, node) {\n    var value = values[modelProperty] || this.__lastInvalidValue;\n\n    var property = {};\n    property[modelProperty] = value;\n\n    return options.validate(element, property, node);\n  };\n\n  return textField(options, defaultParameters);\n};\n\nmodule.exports = validationAwareTextField;\n","'use strict';\n\nvar CmdHelper = {};\nmodule.exports = CmdHelper;\n\nCmdHelper.updateProperties = function(element, properties) {\n  return {\n    cmd: 'element.updateProperties',\n    context: { element: element, properties: properties }\n  };\n};\n\nCmdHelper.updateBusinessObject = function(element, businessObject, newProperties) {\n  return {\n    cmd: 'properties-panel.update-businessobject',\n    context: {\n      element: element,\n      businessObject: businessObject,\n      properties: newProperties\n    }\n  };\n};\n\nCmdHelper.addElementsTolist = function(element, businessObject, listPropertyName, objectsToAdd) {\n  return {\n    cmd: 'properties-panel.update-businessobject-list',\n    context: {\n      element: element,\n      currentObject: businessObject,\n      propertyName: listPropertyName,\n      objectsToAdd: objectsToAdd\n    }\n  };\n};\n\nCmdHelper.removeElementsFromList = function(element, businessObject, listPropertyName, referencePropertyName, objectsToRemove) {\n\n  return {\n    cmd: 'properties-panel.update-businessobject-list',\n    context: {\n      element: element,\n      currentObject: businessObject,\n      propertyName: listPropertyName,\n      referencePropertyName: referencePropertyName,\n      objectsToRemove: objectsToRemove\n    }\n  };\n};\n\n\nCmdHelper.addAndRemoveElementsFromList = function(element, businessObject, listPropertyName, referencePropertyName, objectsToAdd, objectsToRemove) {\n\n  return {\n    cmd: 'properties-panel.update-businessobject-list',\n    context: {\n      element: element,\n      currentObject: businessObject,\n      propertyName: listPropertyName,\n      referencePropertyName: referencePropertyName,\n      objectsToAdd: objectsToAdd,\n      objectsToRemove: objectsToRemove\n    }\n  };\n};\n\n\nCmdHelper.setList = function(element, businessObject, listPropertyName, updatedObjectList) {\n  return {\n    cmd: 'properties-panel.update-businessobject-list',\n    context: {\n      element: element,\n      currentObject: businessObject,\n      propertyName: listPropertyName,\n      updatedObjectList: updatedObjectList\n    }\n  };\n};\n","'use strict';\n\nvar ElementHelper = {};\nmodule.exports = ElementHelper;\n\n/**\n * Creates a new element and set the parent to it\n *\n * @method ElementHelper#createElement\n *\n * @param {String} elementType of the new element\n * @param {Object} properties of the new element in key-value pairs\n * @param {moddle.object} parent of the new element\n * @param {BpmnFactory} factory which creates the new element\n *\n * @returns {djs.model.Base} element which is created\n */\nElementHelper.createElement = function(elementType, properties, parent, factory) {\n  var element = factory.create(elementType, properties);\n  element.$parent = parent;\n\n  return element;\n};\n","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is,\n    forEach = require(386);\n\nvar EventDefinitionHelper = {};\n\nmodule.exports = EventDefinitionHelper;\n\nEventDefinitionHelper.getEventDefinition = function(element, eventType) {\n\n  var bo = getBusinessObject(element),\n      eventDefinition = null;\n\n  if (bo.eventDefinitions) {\n    forEach(bo.eventDefinitions, function(event) {\n      if (is(event, eventType)) {\n        eventDefinition = event;\n      }\n    });\n  }\n\n  return eventDefinition;\n};\n\nEventDefinitionHelper.getTimerEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:TimerEventDefinition');\n};\n\nEventDefinitionHelper.getMessageEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:MessageEventDefinition');\n};\n\nEventDefinitionHelper.getSignalEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:SignalEventDefinition');\n};\n\nEventDefinitionHelper.getErrorEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:ErrorEventDefinition');\n};\n\nEventDefinitionHelper.getEscalationEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:EscalationEventDefinition');\n};\n\nEventDefinitionHelper.getCompensateEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:CompensateEventDefinition');\n};\n\nEventDefinitionHelper.getLinkEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:LinkEventDefinition');\n};\n\nEventDefinitionHelper.getConditionalEventDefinition = function(element) {\n  return this.getEventDefinition(element, 'bpmn:ConditionalEventDefinition');\n};\n","'use strict';\n\nvar cmdHelper = require(26),\n    elementHelper = require(27);\n\nvar is = require(167).is;\n\nvar ExtensionElementsHelper = {};\n\nvar getExtensionElements = function(bo) {\n  return bo.get('extensionElements');\n};\n\nExtensionElementsHelper.getExtensionElements = function(bo, type) {\n  var extensionElements = getExtensionElements(bo);\n  if (typeof extensionElements !== 'undefined') {\n    var extensionValues = extensionElements.get('values');\n    if (typeof extensionValues !== 'undefined') {\n      var elements = extensionValues.filter(function(value) {\n        return is(value, type);\n      });\n      if (elements.length) {\n        return elements;\n      }\n    }\n  }\n};\n\nExtensionElementsHelper.addEntry = function(bo, element, entry, bpmnFactory) {\n  var extensionElements = bo.get('extensionElements');\n\n  // if there is no extensionElements list, create one\n  if (!extensionElements) {\n    // TODO: Ask Daniel which operation costs more\n    extensionElements = elementHelper.createElement('bpmn:ExtensionElements', { values: [entry] }, bo, bpmnFactory);\n    return { extensionElements : extensionElements };\n  } else {\n    // add new failedJobRetryExtensionElement to existing extensionElements list\n    return cmdHelper.addElementsTolist(element, extensionElements, 'values', [entry]);\n  }\n};\n\nExtensionElementsHelper.removeEntry = function(bo, element, entry) {\n  var extensionElements = bo.get('extensionElements');\n\n  if ( !extensionElements ) {\n    // return an empty command when there is no extensionElements list\n    return {};\n  }\n\n  return cmdHelper.removeElementsFromList(element, extensionElements, 'values', 'extensionElements', [entry]);\n};\n\nmodule.exports = ExtensionElementsHelper;\n","'use strict';\n\nvar ModelUtil         = require(167),\n    is                = ModelUtil.is,\n    getBusinessObject = ModelUtil.getBusinessObject;\n\nvar eventDefinitionHelper = require(28);\nvar extensionsElementHelper = require(29);\n\nvar ImplementationTypeHelper = {};\n\nmodule.exports = ImplementationTypeHelper;\n\n/**\n * Returns 'true' if the given element is 'camunda:ServiceTaskLike'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isServiceTaskLike = function(element) {\n  return is(element, 'camunda:ServiceTaskLike');\n};\n\n/**\n * Returns 'true' if the given element is 'camunda:DmnCapable'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isDmnCapable = function(element) {\n  return is(element, 'camunda:DmnCapable');\n};\n\n/**\n * Returns 'true' if the given element is 'camunda:ExternalCapable'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isExternalCapable = function(element) {\n  return is(element, 'camunda:ExternalCapable');\n};\n\n/**\n * Returns 'true' if the given element is 'camunda:TaskListener'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isTaskListener = function(element) {\n  return is(element, 'camunda:TaskListener');\n};\n\n/**\n * Returns 'true' if the given element is 'camunda:ExecutionListener'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isExecutionListener = function(element) {\n  return is(element, 'camunda:ExecutionListener');\n};\n\n/**\n * Returns 'true' if the given element is 'camunda:ExecutionListener' or\n * 'camunda:TaskListener'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isListener = function(element) {\n  return this.isTaskListener(element) || this.isExecutionListener(element);\n};\n\n/**\n * Returns 'true' if the given element is 'bpmn:SequenceFlow'\n *\n * @param {djs.model.Base} element\n *\n * @return {boolean} a boolean value\n */\nImplementationTypeHelper.isSequenceFlow = function(element) {\n  return is(element, 'bpmn:SequenceFlow');\n};\n\n/**\n * Get a 'camunda:ServiceTaskLike' business object.\n *\n * If the given element is not a 'camunda:ServiceTaskLike', then 'false'\n * is returned.\n *\n * @param {djs.model.Base} element\n *\n * @return {ModdleElement} the 'camunda:ServiceTaskLike' business object\n */\nImplementationTypeHelper.getServiceTaskLikeBusinessObject = function(element) {\n\n  if (is(element, 'bpmn:IntermediateThrowEvent') || is(element, 'bpmn:EndEvent')) {\n     /**\n      * change business object to 'messageEventDefinition' when\n      * the element is a message intermediate throw event or message end event\n      * because the camunda extensions (e.g. camunda:class) are in the message\n      * event definition tag and not in the intermediate throw event or end event tag\n      */\n    var messageEventDefinition = eventDefinitionHelper.getMessageEventDefinition(element);\n    if (messageEventDefinition) {\n      element = messageEventDefinition;\n    }\n  }\n\n  return this.isServiceTaskLike(element) && getBusinessObject(element);\n\n};\n\n/**\n * Returns the implementation type of the given element.\n *\n * Possible implementation types are:\n * - dmn\n * - connector\n * - external\n * - class\n * - expression\n * - delegateExpression\n * - script\n * - or undefined, when no matching implementation type is found\n *\n * @param  {djs.model.Base} element\n *\n * @return {String} the implementation type\n */\nImplementationTypeHelper.getImplementationType = function(element) {\n\n  var bo = this.getServiceTaskLikeBusinessObject(element);\n\n  if (!bo) {\n    if (this.isListener(element)) {\n      bo = element;\n    } else {\n      return;\n    }\n  }\n\n  if (this.isDmnCapable(bo)) {\n    var decisionRef = bo.get('camunda:decisionRef');\n    if (typeof decisionRef !== 'undefined') {\n      return 'dmn';\n    }\n  }\n\n  if (this.isServiceTaskLike(bo)) {\n    var connectors = extensionsElementHelper.getExtensionElements(bo, 'camunda:Connector');\n    if (typeof connectors !== 'undefined') {\n      return 'connector';\n    }\n  }\n\n  if (this.isExternalCapable(bo)) {\n    var type = bo.get('camunda:type');\n    if (type === 'external') {\n      return 'external';\n    }\n  }\n\n  var cls = bo.get('camunda:class');\n  if (typeof cls !== 'undefined') {\n    return 'class';\n  }\n\n  var expression = bo.get('camunda:expression');\n  if (typeof expression !== 'undefined') {\n    return 'expression';\n  }\n\n  var delegateExpression = bo.get('camunda:delegateExpression');\n  if (typeof delegateExpression !== 'undefined') {\n    return 'delegateExpression';\n  }\n\n  if (this.isListener(bo)) {\n    var script = bo.get('script');\n    if (typeof script !== 'undefined') {\n      return 'script';\n    }\n  }\n\n};\n","'use strict';\n\nvar ModelUtil         = require(167),\n    is                = ModelUtil.is,\n    getBusinessObject = ModelUtil.getBusinessObject;\n\nvar extensionElementsHelper = require(29),\n    implementationTypeHelper = require(30);\n\nvar InputOutputHelper = {};\n\nmodule.exports = InputOutputHelper;\n\nfunction getElements(bo, type, prop) {\n  var elems = extensionElementsHelper.getExtensionElements(bo, type) || [];\n  return !prop ? elems : (elems[0] || {})[prop] || [];\n}\n\nfunction getParameters(element, prop, insideConnector) {\n  var inputOutput = InputOutputHelper.getInputOutput(element, insideConnector);\n  return (inputOutput && inputOutput.get(prop)) || [];\n}\n\n/**\n * Get a inputOutput from the business object\n *\n * @param {djs.model.Base} element\n * @param  {boolean} insideConnector\n *\n * @return {ModdleElement} the inputOutput object\n */\nInputOutputHelper.getInputOutput = function(element, insideConnector) {\n  if (!insideConnector) {\n    var bo = getBusinessObject(element);\n    return (getElements(bo, 'camunda:InputOutput') || [])[0];\n  }\n  var connector = this.getConnector(element);\n  return connector && connector.get('inputOutput');\n};\n\n/**\n * Get a connector from the business object\n *\n * @param {djs.model.Base} element\n *\n * @return {ModdleElement} the connector object\n */\nInputOutputHelper.getConnector = function(element) {\n  var bo = implementationTypeHelper.getServiceTaskLikeBusinessObject(element);\n  return bo && (getElements(bo, 'camunda:Connector') || [])[0];  \n};\n\n/**\n * Return all input parameters existing in the business object, and\n * an empty array if none exist.\n *\n * @param  {djs.model.Base} element\n * @param  {boolean} insideConnector\n *\n * @return {Array} a list of input parameter objects\n */\nInputOutputHelper.getInputParameters = function(element, insideConnector) {\n  return getParameters.apply(this, [ element, 'inputParameters', insideConnector ]);\n};\n\n/**\n * Return all output parameters existing in the business object, and\n * an empty array if none exist.\n *\n * @param  {djs.model.Base} element\n * @param  {boolean} insideConnector\n *\n * @return {Array} a list of output parameter objects\n */\nInputOutputHelper.getOutputParameters = function(element, insideConnector) {\n  return getParameters.apply(this, [ element, 'outputParameters', insideConnector ]);\n};\n\n/**\n * Get a input parameter from the business object at given index\n *\n * @param {djs.model.Base} element\n * @param  {boolean} insideConnector\n * @param {number} idx\n *\n * @return {ModdleElement} input parameter\n */\nInputOutputHelper.getInputParameter = function(element, insideConnector, idx) {\n  return this.getInputParameters(element, insideConnector)[idx];\n};\n\n/**\n * Get a output parameter from the business object at given index\n *\n * @param {djs.model.Base} element\n * @param  {boolean} insideConnector\n * @param {number} idx\n *\n * @return {ModdleElement} output parameter\n */\nInputOutputHelper.getOutputParameter = function(element, insideConnector, idx) {\n  return this.getOutputParameters(element, insideConnector)[idx];\n};\n\n/**\n * Returns 'true' if the given element supports inputOutput\n *\n * @param {djs.model.Base} element\n * @param  {boolean} insideConnector\n *\n * @return {boolean} a boolean value\n */\nInputOutputHelper.isInputOutputSupported = function(element, insideConnector) {\n  var bo = getBusinessObject(element);\n  return insideConnector ||\n         (is(bo, 'bpmn:FlowNode') &&\n         !is(bo, 'bpmn:StartEvent') &&\n         !is(bo, 'bpmn:BoundaryEvent') &&\n         !(is(bo, 'bpmn:SubProcess') && bo.get('triggeredByEvent')));\n};\n\n/**\n * Returns 'true' if the given element supports output parameters\n *\n * @param {djs.model.Base} element\n * @param  {boolean} insideConnector\n *\n * @return {boolean} a boolean value\n */\nInputOutputHelper.areOutputParametersSupported = function(element, insideConnector) {\n  var bo = getBusinessObject(element);\n  return insideConnector || (!is(bo, 'bpmn:EndEvent') && !bo.loopCharacteristics);\n};\n","'use strict';\n\nvar is = require(167).is,\n    getBusinessObject = require(167).getBusinessObject,\n    cmdHelper = require(26);\n\n\nvar ParticipantHelper = {};\n\nmodule.exports = ParticipantHelper;\n\nParticipantHelper.modifyProcessBusinessObject = function(element, property, values) {\n  if ( !is(element, 'bpmn:Participant') ) {\n    return {};\n  }\n\n  var bo = getBusinessObject(element).get('processRef'),\n      properties = {};\n\n  properties[property] = values[property];\n\n  return cmdHelper.updateBusinessObject(element, bo, properties);\n};\n\nParticipantHelper.getProcessBusinessObject = function(element, propertyName) {\n  if ( !is(element, 'bpmn:Participant') ) {\n    return {};\n  }\n\n  var bo = getBusinessObject(element).get('processRef'),\n      properties = {};\n\n  properties[propertyName] = bo.get(propertyName);\n\n  return properties;\n};","module.exports = {\n  __depends__: [\n    require(14),\n    require(325)\n  ],\n  __init__: [ 'propertiesPanel' ],\n  propertiesPanel: [ 'type', require(7) ]\n};\n","'use strict';\n\nvar is = require(167).is,\n    isAny = require(140).isAny,\n    isEventSubProcess = require(165).isEventSubProcess,\n    getBusinessObject = require(167).getBusinessObject,\n    eventDefinitionHelper = require(28);\n\nvar forEach = require(386);\n\nvar message = require(45),\n    signal = require(47),\n    error = require(42),\n    escalation = require(43),\n    timer = require(48),\n    compensation = require(39),\n    condition = require(40);\n\n\nmodule.exports = function(group, element, bpmnFactory, elementRegistry, translate) {\n  var events = [\n    'bpmn:StartEvent',\n    'bpmn:EndEvent',\n    'bpmn:IntermediateThrowEvent',\n    'bpmn:BoundaryEvent',\n    'bpmn:IntermediateCatchEvent'\n  ];\n\n  // Message and Signal Event Definition\n  forEach(events, function(event) {\n    if (is(element, event)) {\n\n      var messageEventDefinition = eventDefinitionHelper.getMessageEventDefinition(element),\n          signalEventDefinition = eventDefinitionHelper.getSignalEventDefinition(element);\n\n      if (messageEventDefinition) {\n        message(group, element, bpmnFactory, messageEventDefinition);\n      }\n\n      if (signalEventDefinition) {\n        signal(group, element, bpmnFactory, signalEventDefinition);\n      }\n\n    }\n  });\n\n  // Special Case: Receive Task\n  if (is(element, 'bpmn:ReceiveTask')) {\n    message(group, element, bpmnFactory, getBusinessObject(element));\n  }\n\n  // Error Event Definition\n  var errorEvents = [\n    'bpmn:StartEvent',\n    'bpmn:BoundaryEvent',\n    'bpmn:EndEvent'\n  ];\n\n  forEach(errorEvents, function(event) {\n    if (is(element, event)) {\n\n      var errorEventDefinition = eventDefinitionHelper.getErrorEventDefinition(element);\n\n      if (errorEventDefinition) {\n        var isCatchingErrorEvent = is(element, 'bpmn:StartEvent') || is (element, 'bpmn:BoundaryEvent');\n\n        var showErrorCodeVariable = isCatchingErrorEvent,\n            showErrorMessageVariable = isCatchingErrorEvent;\n\n        error(group, element, bpmnFactory, errorEventDefinition, showErrorCodeVariable, showErrorMessageVariable);\n      }\n    }\n  });\n\n  // Escalation Event Definition\n  var escalationEvents = [\n    'bpmn:StartEvent',\n    'bpmn:BoundaryEvent',\n    'bpmn:IntermediateThrowEvent',\n    'bpmn:EndEvent'\n  ];\n\n  forEach(escalationEvents, function(event) {\n    if (is(element, event)) {\n\n      var showEscalationCodeVariable = is(element, 'bpmn:StartEvent') || is(element, 'bpmn:BoundaryEvent');\n\n      // get business object\n      var escalationEventDefinition = eventDefinitionHelper.getEscalationEventDefinition(element);\n\n      if (escalationEventDefinition) {\n        escalation(group, element, bpmnFactory, escalationEventDefinition, showEscalationCodeVariable);\n      }\n    }\n\n  });\n\n  // Timer Event Definition\n  var timerEvents = [\n    'bpmn:StartEvent',\n    'bpmn:BoundaryEvent',\n    'bpmn:IntermediateCatchEvent'\n  ];\n\n  forEach(timerEvents, function(event) {\n    if (is(element, event)) {\n\n      // get business object\n      var timerEventDefinition = eventDefinitionHelper.getTimerEventDefinition(element);\n\n      if (timerEventDefinition) {\n        timer(group, element, bpmnFactory, timerEventDefinition);\n      }\n    }\n  });\n\n  // Compensate Event Definition\n  var compensationEvents = [\n    'bpmn:EndEvent',\n    'bpmn:IntermediateThrowEvent'\n  ];\n\n  forEach(compensationEvents, function(event) {\n    if (is(element, event)) {\n\n      // get business object\n      var compensateEventDefinition = eventDefinitionHelper.getCompensateEventDefinition(element);\n\n      if (compensateEventDefinition) {\n        compensation(group, element, bpmnFactory, compensateEventDefinition, elementRegistry);\n      }\n    }\n  });\n\n\n  // Conditional Event Defintion\n  var conditionalEvents = [\n    'bpmn:BoundaryEvent',\n    'bpmn:IntermediateThrowEvent',\n    'bpmn:IntermediateCatchEvent'\n  ];\n\n  if (isAny(element, conditionalEvents) ||\n      (is(element, 'bpmn:StartEvent') && isEventSubProcess(element.parent))) {\n\n    // get business object\n    var conditionalEventDefinition = eventDefinitionHelper.getConditionalEventDefinition(element);\n\n    if (conditionalEventDefinition) {\n      condition(group, element, bpmnFactory, conditionalEventDefinition, elementRegistry);\n    }\n  }\n\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    getBusinessObject = require(167).getBusinessObject,\n    utils = require(8),\n    cmdHelper = require(26);\n\nmodule.exports = function(group, element, translate) {\n\n  // Id\n  group.entries.push(entryFactory.validationAwareTextField({\n    id: 'id',\n    label: translate('Id'),\n    modelProperty: 'id',\n    getProperty: function(element) {\n      return getBusinessObject(element).id;\n    },\n    setProperty: function(element, properties) {\n\n      element = element.labelTarget || element;\n\n      return cmdHelper.updateProperties(element, properties);\n    },\n    validate: function(element, values) {\n      var idValue = values.id;\n\n      var bo = getBusinessObject(element);\n\n      var idError = utils.isIdValid(bo, idValue);\n\n      return idError ? { id: idError } : {};\n    }\n  }));\n\n};\n","'use strict';\n\nvar is = require(167).is,\n    getBusinessObject = require(167).getBusinessObject,\n    entryFactory = require(17),\n    cmdHelper = require(26);\n\nvar forEach = require(386);\n\nfunction getLinkEventDefinition(element) {\n\n  var bo = getBusinessObject(element);\n\n  var linkEventDefinition = null;\n  if (bo.eventDefinitions) {\n    forEach(bo.eventDefinitions, function(eventDefinition) {\n      if (is(eventDefinition, 'bpmn:LinkEventDefinition')) {\n        linkEventDefinition = eventDefinition;\n      }\n    });\n  }\n\n  return linkEventDefinition;\n}\n\nmodule.exports = function(group, element, translate) {\n  var linkEvents = [ 'bpmn:IntermediateThrowEvent', 'bpmn:IntermediateCatchEvent' ];\n\n  forEach(linkEvents, function(event) {\n    if (is(element, event)) {\n\n      var linkEventDefinition = getLinkEventDefinition(element);\n\n      if (linkEventDefinition) {\n        var entry = entryFactory.textField({\n          id: 'link-event',\n          label: translate('Link Name'),\n          modelProperty: 'link-name'\n        });\n\n        entry.get = function() {\n          return { 'link-name': linkEventDefinition.get('name') };\n        };\n\n        entry.set = function(element, values) {\n          var newProperties = {\n            name: values['link-name']\n          };\n          return cmdHelper.updateBusinessObject(element, linkEventDefinition, newProperties);\n        };\n\n        group.entries.push(entry);\n      }\n    }\n  });\n};\n\n","'use strict';\n\nvar nameEntryFactory = require(46),\n    is = require(167).is;\n\nmodule.exports = function(group, element, translate) {\n\n  if (!is(element, 'bpmn:Collaboration')) {\n\n    var options;\n    if (is(element, 'bpmn:TextAnnotation')) {\n      options = { modelProperty: 'text' };\n    }\n\n    // name\n    group.entries = group.entries.concat(nameEntryFactory(element, options, translate));\n\n  }\n\n};\n","'use strict';\n\nvar is = require(167).is,\n    entryFactory = require(17),\n    participantHelper = require(32),\n    getBusinessObject = require(167).getBusinessObject,\n    nameEntryFactory = require(46),\n    utils = require(8);\n\nmodule.exports = function(group, element, translate) {\n  var businessObject = getBusinessObject(element);\n\n  if (is(element, 'bpmn:Process') || (is(element, 'bpmn:Participant') && businessObject.get('processRef'))) {\n\n    /**\n     * processId\n     */\n    if (is(element, 'bpmn:Participant')) {\n      var idEntry = entryFactory.validationAwareTextField({\n        id: 'process-id',\n        label: translate('Process Id'),\n        modelProperty: 'processId'\n      });\n\n      // in participants we have to change the default behavior of set and get\n      idEntry.get = function(element) {\n        var properties = participantHelper.getProcessBusinessObject(element, 'id');\n        return { processId: properties.id };\n      };\n\n      idEntry.set = function(element, values) {\n        return participantHelper.modifyProcessBusinessObject(element, 'id', { id: values.processId });\n      };\n\n      idEntry.validate = function(element, values) {\n        var idValue = values.processId;\n\n        var bo = getBusinessObject(element);\n\n        var processIdError = utils.isIdValid(bo.processRef, idValue);\n\n        return processIdError ? { processId: processIdError } : {};\n      };\n\n      group.entries.push(idEntry);\n\n\n      /**\n       * process name\n       */\n      var processNameEntry = nameEntryFactory(element, {\n        id: 'process-name',\n        label: translate('Process Name')\n      })[0];\n\n      // in participants we have to change the default behavior of set and get\n      processNameEntry.get = function(element) {\n        return participantHelper.getProcessBusinessObject(element, 'name');\n      };\n\n      processNameEntry.set = function(element, values) {\n        return participantHelper.modifyProcessBusinessObject(element, 'name', values);\n      };\n\n      group.entries.push(processNameEntry);\n    }\n  }\n};\n","'use strict';\n\nvar entryFactory = require(17);\n\nvar cmdHelper = require(26),\n    eventDefinitionHelper = require(28),\n    utils = require(8);\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is;\n\nvar forEach = require(386),\n    find = require(385),\n    filter = require(384);\n\n\nfunction getContainedActivities(element) {\n  return getFlowElements(element, 'bpmn:Activity');\n}\n\nfunction getContainedBoundaryEvents(element) {\n  return getFlowElements(element, 'bpmn:BoundaryEvent');\n}\n\nfunction getFlowElements(element, type) {\n  return utils.filterElementsByType(element.flowElements, type);\n}\n\nfunction isCompensationEventAttachedToActivity(activity, boundaryEvents) {\n  var activityId = activity.id;\n  var boundaryEvent = find(boundaryEvents, function(boundaryEvent) {\n    var compensateEventDefinition = eventDefinitionHelper.getCompensateEventDefinition(boundaryEvent);\n    var attachedToRef = boundaryEvent.attachedToRef;\n    return compensateEventDefinition && attachedToRef && attachedToRef.id === activityId;\n  });\n  return !!boundaryEvent;\n}\n\n// subprocess: only when it is not triggeredByEvent\n// activity: only when it attach a compensation boundary event\n// callActivity: no limitation\nfunction canActivityBeCompensated(activity, boundaryEvents) {\n  return (is(activity, 'bpmn:SubProcess') && !activity.triggeredByEvent) ||\n          is(activity, 'bpmn:CallActivity') ||\n          isCompensationEventAttachedToActivity(activity, boundaryEvents);\n}\n\nfunction getActivitiesForCompensation(element) {\n  var boundaryEvents = getContainedBoundaryEvents(element);\n  return filter(getContainedActivities(element), function(activity) {\n    return canActivityBeCompensated(activity, boundaryEvents);\n  });\n}\n\nfunction getActivitiesForActivityRef(element) {\n  var bo = getBusinessObject(element);\n  var parent = bo.$parent;\n\n  var activitiesForActivityRef = getActivitiesForCompensation(parent);\n\n  // if throwing compensation event is in an event sub process:\n  // get also all activities outside of the event sub process\n  if (is(parent, 'bpmn:SubProcess') && parent.triggeredByEvent) {\n    parent = parent.$parent;\n    if (parent) {\n      activitiesForActivityRef = activitiesForActivityRef.concat(getActivitiesForCompensation(parent));\n    }\n\n  }\n\n  return activitiesForActivityRef;\n}\n\nfunction createActivityRefOptions(element) {\n  var options = [ { value: '' } ];\n\n  var activities = getActivitiesForActivityRef(element);\n  forEach(activities, function(activity) {\n    var activityId = activity.id;\n    var name = (activity.name ? (activity.name + ' ') : '') + '(id=' + activityId + ')';\n    options.push({ value: activityId, name: name });\n  });\n\n  return options;\n}\n\n\nmodule.exports = function(group, element, bpmnFactory, compensateEventDefinition, elementRegistry) {\n\n  group.entries.push(entryFactory.checkbox({\n    id: 'wait-for-completion',\n    label: 'Wait for Completion',\n    modelProperty: 'waitForCompletion',\n\n    get: function(element, node) {\n      return {\n        waitForCompletion: compensateEventDefinition.waitForCompletion\n      };\n    },\n\n    set: function(element, values) {\n      values.waitForCompletion = values.waitForCompletion || undefined;\n      return cmdHelper.updateBusinessObject(element, compensateEventDefinition, values);\n    }\n  }));\n\n  group.entries.push(entryFactory.selectBox({\n    id: 'activity-ref',\n    label: 'Activity Ref',\n    selectOptions: createActivityRefOptions(element),\n    modelProperty: 'activityRef',\n\n    get: function(element, node) {\n      var activityRef = compensateEventDefinition.activityRef;\n      activityRef = activityRef && activityRef.id;\n      return {\n        activityRef: activityRef || ''\n      };\n    },\n\n    set: function(element, values) {\n      var activityRef = values.activityRef || undefined;\n      activityRef = activityRef && getBusinessObject(elementRegistry.get(activityRef));\n      return cmdHelper.updateBusinessObject(element, compensateEventDefinition, {\n        activityRef: activityRef\n      });\n    }\n  }));\n\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    elementHelper = require(27),\n    cmdHelper = require(26);\n\nfunction createFormalExpression(parent, body, bpmnFactory) {\n  body = body || undefined;\n  return elementHelper.createElement('bpmn:FormalExpression', { body: body }, parent, bpmnFactory);\n}\n\nmodule.exports = function(group, element, bpmnFactory, conditionalEventDefinition) {\n\n  var getValue = function(modelProperty) {\n    return function(element) {\n      var modelPropertyValue = conditionalEventDefinition.get('camunda:' + modelProperty);\n      var value = {};\n\n      value[modelProperty] = modelPropertyValue;\n      return value;\n    };\n  };\n\n  var setValue = function(modelProperty) {\n    return function(element, values) {\n      var props = {};\n\n      props['camunda:' + modelProperty] = values[modelProperty] || undefined;\n\n      return cmdHelper.updateBusinessObject(element, conditionalEventDefinition, props);\n    };\n  };\n\n  group.entries.push(entryFactory.textField({\n    id: 'condition',\n    label: 'Condition',\n    modelProperty: 'condition',\n    get: function(element) {\n      var condition = conditionalEventDefinition.get('condition'),\n          body = condition && condition.get('body');\n\n      return { condition: body || '' };\n    },\n    set: function(element, values) {\n      var condition = conditionalEventDefinition.get('condition');\n\n      // remove condition expression from the business object when text field is empty\n      if (values.condition === '') {\n        return cmdHelper.updateBusinessObject(element, conditionalEventDefinition, { condition: undefined });\n      }\n\n      // if no condition expression is set yet, create one\n      if (!condition) {\n        condition = createFormalExpression(conditionalEventDefinition, values.condition, bpmnFactory);\n\n        return cmdHelper.updateBusinessObject(element, conditionalEventDefinition, { condition: condition });\n\n      // if a condition expression and a text field value exists, update business object\n      } else {\n        return cmdHelper.updateBusinessObject(element, condition, {\n          body: values.condition || undefined\n        });\n      }\n    },\n    validate: function(element, values) {\n      if (values['condition'] === '') {\n        return { condition: 'Must provide a value' };\n      }\n    }\n  }));\n\n  group.entries.push(entryFactory.textField({\n    id : 'variableName',\n    label : 'Variable Name',\n    modelProperty : 'variableName',\n\n    get: getValue('variableName'),\n    set: setValue('variableName')\n  }));\n\n  group.entries.push(entryFactory.textField({\n    id : 'variableEvent',\n    label : 'Variable Event',\n    description: 'Specify more than one variable change event as a comma separated list.',\n    modelProperty : 'variableEvent',\n\n    get: getValue('variableEvent'),\n    set: setValue('variableEvent')\n  }));\n\n};\n","'use strict';\n\nvar entryFactory = require(17);\n\nvar cmdHelper = require(26);\n\n/**\n * Create an entry to modify a property of an element which\n * is referenced by a event definition.\n *\n * @param  {djs.model.Base} element\n * @param  {ModdleElement} definition\n * @param  {BpmnFactory} bpmnFactory\n * @param  {Object} options\n * @param  {string} options.id the id of the entry\n * @param  {string} options.label the label of the entry\n * @param  {string} options.referenceProperty the name of referencing property\n * @param  {string} options.modelProperty the name of property to modify\n * @param  {string} options.shouldValidate a flag indicate whether to validate or not\n *\n * @return {Array<Object>} return an array containing the entries\n */\nmodule.exports = function(element, definition, bpmnFactory, options) {\n\n  var id = options.id || 'element-property';\n  var label = options.label;\n  var referenceProperty = options.referenceProperty;\n  var modelProperty = options.modelProperty || 'name';\n  var shouldValidate = options.shouldValidate || false;\n\n  var entry = entryFactory.textField({\n    id: id,\n    label: label,\n    modelProperty: modelProperty,\n\n    get: function(element, node) {\n      var reference = definition.get(referenceProperty);\n      var props = {};\n      props[modelProperty] = reference && reference.get(modelProperty);\n      return props;\n    },\n\n    set: function(element, values, node) {\n      var reference = definition.get(referenceProperty);\n      var props = {};\n      props[modelProperty] = values[modelProperty] || undefined;\n      return cmdHelper.updateBusinessObject(element, reference, props);\n    },\n\n    hidden: function(element, node) {\n      return !definition.get(referenceProperty);\n    }\n  });\n\n  if (shouldValidate) {\n    entry.validate = function(element, values, node) {\n      var reference = definition.get(referenceProperty);\n      if (reference && !values[modelProperty]) {\n        var validationErrors = {};\n        validationErrors[modelProperty] = 'Must provide a value';\n        return validationErrors;\n      }\n    };\n  }\n\n  return [ entry ];\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    cmdHelper = require(26);\n\nvar eventDefinitionReference = require(44),\n    elementReferenceProperty = require(41);\n\n\nmodule.exports = function(group, element, bpmnFactory, errorEventDefinition, showErrorCodeVariable,\n  showErrorMessageVariable) {\n\n\n  var getValue = function(modelProperty) {\n    return function(element) {\n      var modelPropertyValue = errorEventDefinition.get('camunda:' + modelProperty);\n      var value = {};\n\n      value[modelProperty] = modelPropertyValue;\n      return value;\n    };\n  };\n\n  var setValue = function(modelProperty) {\n    return function(element, values) {\n      var props = {};\n\n      props['camunda:' + modelProperty] = values[modelProperty] || undefined;\n\n      return cmdHelper.updateBusinessObject(element, errorEventDefinition, props);\n    };\n  };\n\n\n  group.entries = group.entries.concat(eventDefinitionReference(element, errorEventDefinition, bpmnFactory, {\n    label: 'Error',\n    elementName: 'error',\n    elementType: 'bpmn:Error',\n    referenceProperty: 'errorRef',\n    newElementIdPrefix: 'Error_'\n  }));\n\n\n  group.entries = group.entries.concat(elementReferenceProperty(element, errorEventDefinition, bpmnFactory, {\n    id: 'error-element-name',\n    label: 'Error Name',\n    referenceProperty: 'errorRef',\n    modelProperty: 'name',\n    shouldValidate: true\n  }));\n\n\n  group.entries = group.entries.concat(elementReferenceProperty(element, errorEventDefinition, bpmnFactory, {\n    id: 'error-element-code',\n    label: 'Error Code',\n    referenceProperty: 'errorRef',\n    modelProperty: 'errorCode'\n  }));\n\n\n  if (showErrorCodeVariable) {\n    group.entries.push(entryFactory.textField({\n      id : 'errorCodeVariable',\n      label : 'Error Code Variable',\n      modelProperty : 'errorCodeVariable',\n\n      get: getValue('errorCodeVariable'),\n      set: setValue('errorCodeVariable')\n    }));\n  }\n\n  if (showErrorMessageVariable) {\n    group.entries.push(entryFactory.textField({\n      id : 'errorMessageVariable',\n      label : 'Error Message Variable',\n      modelProperty : 'errorMessageVariable',\n\n      get: getValue('errorMessageVariable'),\n      set: setValue('errorMessageVariable')\n    }));\n  }\n\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    cmdHelper = require(26);\n\nvar eventDefinitionReference = require(44),\n    elementReferenceProperty = require(41);\n\n\nmodule.exports = function(group, element, bpmnFactory, escalationEventDefinition, showEscalationCodeVariable) {\n\n  group.entries = group.entries.concat(eventDefinitionReference(element, escalationEventDefinition, bpmnFactory, {\n    label: 'Escalation',\n    elementName: 'escalation',\n    elementType: 'bpmn:Escalation',\n    referenceProperty: 'escalationRef',\n    newElementIdPrefix: 'Escalation_'\n  }));\n\n\n  group.entries = group.entries.concat(elementReferenceProperty(element, escalationEventDefinition, bpmnFactory, {\n    id: 'escalation-element-name',\n    label: 'Escalation Name',\n    referenceProperty: 'escalationRef',\n    modelProperty: 'name',\n    shouldValidate: true\n  }));\n\n\n  group.entries = group.entries.concat(elementReferenceProperty(element, escalationEventDefinition, bpmnFactory, {\n    id: 'escalation-element-code',\n    label: 'Escalation Code',\n    referenceProperty: 'escalationRef',\n    modelProperty: 'escalationCode'\n  }));\n\n\n  if (showEscalationCodeVariable) {\n    group.entries.push(entryFactory.textField({\n      id : 'escalationCodeVariable',\n      label : 'Escalation Code Variable',\n      modelProperty : 'escalationCodeVariable',\n\n      get: function(element) {\n        var codeVariable = escalationEventDefinition.get('camunda:escalationCodeVariable');\n        return {\n          escalationCodeVariable: codeVariable\n        };\n      },\n\n      set: function(element, values) {\n        return cmdHelper.updateBusinessObject(element, escalationEventDefinition, {\n          'camunda:escalationCodeVariable': values.escalationCodeVariable || undefined\n        });\n      }\n    }));\n  }\n};\n","'use strict';\n\nvar cmdHelper = require(26);\n\nvar domQuery = require(538),\n    domify = require(535),\n    domAttr = require(530);\n\nvar forEach = require(386),\n    find = require(385);\n\nvar elementHelper = require(27);\nvar utils = require(8);\n\nvar selector = 'select[name=selectedElement]';\n\n/**\n * Get select box containing all elements.\n *\n * @param {DOMElement} node\n *\n * @return {DOMElement} the select box\n */\nfunction getSelectBox(node) {\n  return domQuery(selector, node.parentElement);\n}\n\n/**\n * Find element by given id.\n *\n * @param {ModdleElement} eventDefinition\n *\n * @return {ModdleElement} an element\n */\nfunction findElementById(eventDefinition, type, id) {\n  var elements = utils.findRootElementsByType(eventDefinition, type);\n  return find(elements, function(element) {\n    return element.id === id;\n  });\n}\n\n/**\n * Create an entry to modify the reference to an element from an\n * event definition.\n *\n * @param  {djs.model.Base} element\n * @param  {ModdleElement} definition\n * @param  {BpmnFactory} bpmnFactory\n * @param  {Object} options\n * @param  {string} options.label the label of the entry\n * @param  {string} options.description the description of the entry\n * @param  {string} options.elementName the name of the element\n * @param  {string} options.elementType the type of the element\n * @param  {string} options.referenceProperty the name of referencing property\n * @param  {string} options.newElementIdPrefix the prefix of a new created element\n *\n * @return {Array<Object>} return an array containing the entries\n */\nmodule.exports = function(element, definition, bpmnFactory, options) {\n\n  var elementName       = options.elementName || '',\n      elementType       = options.elementType,\n      referenceProperty = options.referenceProperty;\n\n  var newElementIdPrefix = options.newElementIdPrefix || 'elem_';\n\n  var label       = options.label || '',\n      description = options.description || '';\n\n  var entries = [];\n\n  entries.push({\n\n    id: 'event-definitions-' + elementName,\n    description: description,\n    html: '<div class=\"bpp-row bpp-select\">' +\n             '<label for=\"camunda-' + elementName + '\">' + label + '</label>' +\n             '<div class=\"bpp-field-wrapper\">' +\n               '<select id=\"camunda-' + elementName + '\" name=\"selectedElement\" data-value>' +\n               '</select>' +\n               '<button class=\"add\" id=\"addElement\" data-action=\"addElement\"><span>+</span></button>' +\n             '</div>' +\n          '</div>',\n\n    get: function(element, entryNode) {\n      utils.updateOptionsDropDown(selector, definition, elementType, entryNode);\n      var reference = definition.get(referenceProperty);\n      return {\n        selectedElement: (reference && reference.id) || ''\n      };\n    },\n\n    set: function(element, values) {\n      var selection = values.selectedElement;\n\n      var props = {};\n\n      if (!selection || typeof selection === 'undefined') {\n        // remove reference to element\n        props[referenceProperty] = undefined;\n        return cmdHelper.updateBusinessObject(element, definition, props);\n      }\n\n      var commands = [];\n\n      var selectedElement = findElementById(definition, elementType, selection);\n      if (!selectedElement) {\n        var root = utils.getRoot(definition);\n\n        // create a new element\n        selectedElement = elementHelper.createElement(elementType, { name: selection }, root, bpmnFactory);\n        commands.push(cmdHelper.addAndRemoveElementsFromList(element, root, 'rootElements', null, [ selectedElement ]));\n      }\n\n      // update reference to element\n      props[referenceProperty] = selectedElement;\n      commands.push(cmdHelper.updateBusinessObject(element, definition, props));\n\n      return commands;\n    },\n\n    addElement: function(element, inputNode) {\n      // note: this generated id will be used as name\n      // of the element and not as id\n      var id = utils.nextId(newElementIdPrefix);\n\n      var optionTemplate = domify('<option value=\"' + id + '\"> (id='+id+')' + '</option>');\n\n      // add new option\n      var selectBox = getSelectBox(inputNode);\n      selectBox.insertBefore(optionTemplate, selectBox.firstChild);\n\n      // select new element in the select box\n      forEach(selectBox, function(option) {\n        if (option.value === id) {\n          domAttr(option, 'selected', 'selected');\n        } else {\n          domAttr(option, 'selected', null);\n        }\n      });\n\n      return true;\n    }\n\n  });\n\n  return entries;\n\n};\n","'use strict';\n\nvar eventDefinitionReference = require(44),\n    elementReferenceProperty = require(41);\n\n\nmodule.exports = function(group, element, bpmnFactory, messageEventDefinition) {\n\n  group.entries = group.entries.concat(eventDefinitionReference(element, messageEventDefinition, bpmnFactory, {\n    label: 'Message',\n    elementName: 'message',\n    elementType: 'bpmn:Message',\n    referenceProperty: 'messageRef',\n    newElementIdPrefix: 'Message_'\n  }));\n\n\n  group.entries = group.entries.concat(elementReferenceProperty(element, messageEventDefinition, bpmnFactory, {\n    id: 'message-element-name',\n    label: 'Message Name',\n    referenceProperty: 'messageRef',\n    modelProperty: 'name',\n    shouldValidate: true\n  }));\n\n};\n","'use strict';\n\nvar entryFactory = require(17);\n\n/**\n * Create an entry to modify the name of an an element.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} options\n * @param  {string} options.id the id of the entry\n * @param  {string} options.label the label of the entry\n *\n * @return {Array<Object>} return an array containing\n *                         the entry to modify the name\n */\nmodule.exports = function(element, options, translate) {\n\n  options = options || {};\n  var id = options.id || 'name',\n      label = options.label || translate('Name'),\n      modelProperty = options.modelProperty || 'name';\n\n  var nameEntry = entryFactory.textBox({\n    id: id,\n    label: label,\n    modelProperty: modelProperty\n  });\n\n  return [ nameEntry ];\n\n};\n","'use strict';\n\nvar eventDefinitionReference = require(44),\n    elementReferenceProperty = require(41);\n\n\nmodule.exports = function(group, element, bpmnFactory, signalEventDefinition) {\n\n  group.entries = group.entries.concat(eventDefinitionReference(element, signalEventDefinition, bpmnFactory, {\n    label: 'Signal',\n    elementName: 'signal',\n    elementType: 'bpmn:Signal',\n    referenceProperty: 'signalRef',\n    newElementIdPrefix: 'Signal_'\n  }));\n\n\n  group.entries = group.entries.concat(elementReferenceProperty(element, signalEventDefinition, bpmnFactory, {\n    id: 'signal-element-name',\n    label: 'Signal Name',\n    referenceProperty: 'signalRef',\n    modelProperty: 'name',\n    shouldValidate: true\n  }));\n\n};\n","'use strict';\n\nvar elementHelper = require(27),\n    cmdHelper = require(26);\n\nvar entryFactory = require(17);\n\n/**\n * Get the timer definition type for a given timer event definition.\n *\n * @param {ModdleElement<bpmn:TimerEventDefinition>} timer\n *\n * @return {string|undefined} the timer definition type\n */\nfunction getTimerDefinitionType(timer) {\n  var timeDate = timer.get('timeDate');\n  if (typeof timeDate !== 'undefined') {\n    return 'timeDate';\n  }\n\n  var timeCycle = timer.get('timeCycle');\n  if (typeof timeCycle !== 'undefined') {\n    return 'timeCycle';\n  }\n\n  var timeDuration = timer.get('timeDuration');\n  if (typeof timeDuration !== 'undefined') {\n    return 'timeDuration';\n  }\n}\n\n/**\n * Creates 'bpmn:FormalExpression' element.\n *\n * @param {ModdleElement} parent\n * @param {string} body\n * @param {BpmnFactory} bpmnFactory\n *\n * @return {ModdleElement<bpmn:FormalExpression>} a formal expression\n */\nfunction createFormalExpression(parent, body, bpmnFactory) {\n  body = body || undefined;\n  return elementHelper.createElement('bpmn:FormalExpression', { body: body }, parent, bpmnFactory);\n}\n\nfunction TimerEventDefinition(group, element, bpmnFactory, timerEventDefinition) {\n\n  var selectOptions = [\n    { value: 'timeDate', name: 'Date' },\n    { value: 'timeDuration', name: 'Duration' },\n    { value: 'timeCycle', name: 'Cycle' }\n  ];\n\n  group.entries.push(entryFactory.selectBox({\n    id: 'timer-event-definition-type',\n    label: 'Timer Definition Type',\n    selectOptions: selectOptions,\n    emptyParameter: true,\n    modelProperty: 'timerDefinitionType',\n\n    get: function(element, node) {\n      return {\n        timerDefinitionType: getTimerDefinitionType(timerEventDefinition) || ''\n      };\n    },\n\n    set: function(element, values) {\n      var props = {\n        timeDuration: undefined,\n        timeDate: undefined,\n        timeCycle: undefined\n      };\n\n      var newType = values.timerDefinitionType;\n      if (values.timerDefinitionType) {\n        var oldType = getTimerDefinitionType(timerEventDefinition);\n\n        var value;\n        if (oldType) {\n          var definition = timerEventDefinition.get(oldType);\n          value = definition.get('body');\n        }\n\n        props[newType] = createFormalExpression(timerEventDefinition, value, bpmnFactory);\n      }\n\n      return cmdHelper.updateBusinessObject(element, timerEventDefinition, props);\n    }\n\n  }));\n\n\n  group.entries.push(entryFactory.textField({\n    id: 'timer-event-definition',\n    label: 'Timer Definition',\n    modelProperty: 'timerDefinition',\n\n    get: function(element, node) {\n      var type = getTimerDefinitionType(timerEventDefinition);\n      var definition = type && timerEventDefinition.get(type);\n      var value = definition && definition.get('body');\n      return {\n        timerDefinition: value\n      };\n    },\n\n    set: function(element, values) {\n      var type = getTimerDefinitionType(timerEventDefinition);\n      var definition = type && timerEventDefinition.get(type);\n\n      if (definition) {\n        return cmdHelper.updateBusinessObject(element, definition, {\n          body: values.timerDefinition || undefined\n        });\n      }\n    },\n\n    validate: function(element) {\n      var type = getTimerDefinitionType(timerEventDefinition);\n      var definition = type && timerEventDefinition.get(type);\n      if (definition) {\n        var value = definition.get('body');\n        if (!value) {\n          return {\n            timerDefinition: 'Must provide a value'\n          };\n        }\n      }\n    },\n\n    hidden: function(element) {\n      return !getTimerDefinitionType(timerEventDefinition);\n    }\n\n  }));\n\n}\n\nmodule.exports = TimerEventDefinition;\n","'use strict';\n\nvar inherits = require(368);\n\nvar PropertiesActivator = require(6);\n\n// bpmn properties\nvar processProps = require(38),\n  eventProps = require(34),\n  linkProps = require(36),\n  idProps = require(35),\n  nameProps = require(37);\n\n// jbpm properties\nvar jbpmProcessProps = require(57),\n  serviceTaskDelegateProps = require(60),\n  userTaskProps = require(61),\n  callActivityProps = require(51),\n  sequenceFlowProps = require(59),\n  gatewayProps = require(52),\n  scriptProps = require(58),\n  globalsProps = require(53),\n  importsProps = require(54);\n\n// Input/Output\nvar inputOutput = require(56),\n  inputOutputParameter = require(55);\n\nfunction createGeneralTabGroups(element, bpmnFactory, elementRegistry, translate) {\n\n  var generalGroup = {\n    id: 'general',\n    label: '',\n    entries: []\n  };\n  idProps(generalGroup, element, translate);\n  nameProps(generalGroup, element, translate);\n  processProps(generalGroup, element, translate);\n  jbpmProcessProps(generalGroup, element, translate);\n  serviceTaskDelegateProps(generalGroup, element, bpmnFactory);\n  userTaskProps(generalGroup, element, translate);\n  scriptProps(generalGroup, element, bpmnFactory, translate);\n  linkProps(generalGroup, element);\n  callActivityProps(generalGroup, element, bpmnFactory);\n  eventProps(generalGroup, element, bpmnFactory, elementRegistry);\n  sequenceFlowProps(generalGroup, element, bpmnFactory, translate);\n  gatewayProps(generalGroup, element, translate);\n\n  return [\n    generalGroup\n  ];\n\n}\n\nfunction createInputOutputParametersTabGroups(element, bpmnFactory, translate) {\n\n  var inputOutputParametersGroup = {\n    id: 'input-output',\n    label: '',\n    entries: []\n  };\n\n  var options = inputOutput(inputOutputParametersGroup, element, bpmnFactory, null, translate);\n\n  var inputOutputParameterGroup = {\n    id: 'input-output-parameter',\n    entries: [],\n    enabled: function (element, node) {\n      return options.getSelectedParameter(element, node);\n    },\n    label: translate('Parameter Detail')\n  };\n\n  inputOutputParameter(inputOutputParameterGroup, element, bpmnFactory, options, translate);\n\n  return [\n    inputOutputParametersGroup,\n    inputOutputParameterGroup\n  ];\n}\n\nfunction createImportsAndGlobalsTabGroups(element, bpmnFactory, translate) {\n\n  var importsGroup = {\n    id : 'imports',\n    label: translate('Imports'),\n    entries: []\n  };\n  importsProps(importsGroup, element, bpmnFactory, translate);\n\n  var globalsGroup = {\n    id : 'globals',\n    label: translate('Globals'),\n    entries: []\n  };\n  globalsProps(globalsGroup, element, bpmnFactory, translate);\n\n  return [\n    importsGroup,\n    globalsGroup\n  ];\n}\n\n\n\n// JBPM Properties Provider /////////////////////////////////////\n\n\n/**\n * A properties provider for Jbpm related properties.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n * @param {ElementRegistry} elementRegistry\n * @param {ElementTemplates} elementTemplates\n * @param {Translate} translate\n */\nfunction JBPMPropertiesProvider(eventBus, bpmnFactory, elementRegistry, translate) {\n\n  PropertiesActivator.call(this, eventBus);\n\n  this.getTabs = function (element) {\n\n    var generalTab = {\n      id: 'general',\n      label: translate('General'),\n      groups: createGeneralTabGroups(\n        element, bpmnFactory,\n        elementRegistry, translate)\n    };\n\n    var inputOutputParametersTab = {\n      id: 'input-output-paramters',\n      label: translate('Input/Output Parameters'),\n      groups: createInputOutputParametersTabGroups(element, bpmnFactory, translate)\n    };\n\n    var importsAndGlobalsTab = {\n      id: \"imports\",\n      label: translate('Imports & Globals'),\n      groups: createImportsAndGlobalsTabGroups(element, bpmnFactory, translate)\n    }\n\n    return [\n      generalTab,\n      inputOutputParametersTab,\n      importsAndGlobalsTab\n    ];\n  };\n\n}\n\nJBPMPropertiesProvider.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'elementRegistry',\n  'translate'\n];\n\ninherits(JBPMPropertiesProvider, PropertiesActivator);\n\nmodule.exports = JBPMPropertiesProvider;\n","module.exports = {\n  __init__: [ 'propertiesProvider' ],\n  propertiesProvider: [ 'type', require(49) ]\n};","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is;\n\nvar entryFactory = require(17);\n\nvar callable = require(62);\n\nvar cmdHelper = require(26);\n\nvar flattenDeep = require(373);\nvar assign = require(516);\n\nfunction getCallableType(element) {\n  var bo = getBusinessObject(element);\n\n  var boCalledElement = bo.get('calledElement'),\n      boCaseRef = bo.get('jbpm:caseRef');\n\n  var callActivityType = '';\n  if (typeof boCalledElement !== 'undefined') {\n    callActivityType = 'bpmn';\n  } else\n\n  if (typeof boCaseRef !== 'undefined') {\n    callActivityType = 'cmmn';\n  }\n\n  return callActivityType;\n}\n\nvar DEFAULT_PROPS = {\n  calledElement: undefined,\n  'jbpm:calledElementBinding': 'latest',\n  'jbpm:calledElementVersion': undefined,\n  'jbpm:caseRef': undefined,\n  'jbpm:caseBinding': 'latest',\n  'jbpm:caseVersion': undefined\n};\n\nmodule.exports = function(group, element, bpmnFactory) {\n\n  if (!is(element, 'jbpm:CallActivity')) {\n    return;\n  }\n\n  group.entries.push(entryFactory.selectBox({\n    id : 'callActivity',\n    label: 'CallActivity Type',\n    selectOptions: [ { name: 'BPMN', value: 'bpmn' }, { name: 'CMMN', value: 'cmmn' } ],\n    emptyParameter: true,\n    modelProperty: 'callActivityType',\n\n    get: function(element, node) {\n      return {\n        callActivityType: getCallableType(element)\n      };\n    },\n\n    set: function(element, values, node) {\n      var type = values.callActivityType;\n\n      var props = assign({}, DEFAULT_PROPS);\n\n      if (type === 'bpmn') {\n        props.calledElement = '';\n      }\n      else if (type === 'cmmn') {\n        props['jbpm:caseRef'] = '';\n      }\n\n      return cmdHelper.updateProperties(element, props);\n    }\n\n  }));\n\n  group.entries.push(callable(element, bpmnFactory, {\n    getCallableType: getCallableType\n  }));\n\n  group.entries = flattenDeep(group.entries);\n};\n","'use strict';\n\nvar is = require(167).is,\n  getBusinessObject = require(167).getBusinessObject,\n  entryFactory = require(17);\n\n\nmodule.exports = function(group, element, translate) {\n  if (is(element, 'bpmn:EventBasedGateway')\n    || is(element, 'bpmn:ComplexGateway')\n    || is(element, 'bpmn:ExclusiveGateway')\n    || is(element, 'bpmn:InclusiveGateway')\n    || is(element, 'bpmn:ParallelGateway')) {\n\n    group.entries.push(entryFactory.selectBox({\n      id : 'gatewayDirection',\n      description : translate('Gateway Direction'),\n      label : translate('Gateway Direction'),\n      modelProperty : 'gatewayDirection',\n      selectOptions : [\n        {name: translate('Diverging'), value: 'Diverging'},\n        {name: translate('Converging'), value: 'Converging'},\n        {name: translate('Mixed'), value: 'Mixed'},\n        {name: translate('Unspecified'), value: 'Unspecified'}\n      ]\n    }));\n\n  }\n\n};\n","'use strict';\n\nvar is = require(167).is,\n  getBusinessObject = require(167).getBusinessObject,\n  extensionElementsHelper = require(29),\n  elementHelper = require(27),\n  cmdHelper = require(26),\n  entryfactory = require(17),\n  forEach = require(386);\n\nmodule.exports = function (group, element, bpmnFactory, translate) {\n  var bo;\n\n  if (is(element, 'bpmn:Process')) {\n    bo = getBusinessObject(element);\n  }\n\n  if (!bo) {\n    return;\n  }\n\n  function getParent(element, node) {\n    var bo = getBusinessObject(element);\n    return bo.extensionElements;\n  }\n\n  function createParent(element) {\n    var bo = getBusinessObject(element);\n    var parent = elementHelper.createElement('bpmn:ExtensionElements', {values: []}, bo, bpmnFactory);\n    var cmd = cmdHelper.updateProperties(element, {extensionElements: parent});\n    return {\n      cmd: cmd,\n      parent: parent\n    };\n  }\n\n  var DEFAULT_PROPERTIES = [\n    'identifier',\n    'type'\n  ];\n\n  group.entries.push(entryfactory.table({\n    id: 'globals',\n    modelProperties: DEFAULT_PROPERTIES,\n    labels: [translate('Identifier'), translate('Type')],\n    addLabel: translate('Add Global'),\n    getElements: function (element, node) {\n      return extensionElementsHelper.getExtensionElements(bo, 'drools:Global');\n    },\n    addElement: function (element, node) {\n      var commands = [],\n        parent = getParent(element, node);\n\n      if (!parent) {\n        var result = createParent(element);\n        parent = result.parent;\n        commands.push(result.cmd);\n      }\n\n      var propertyProps = {};\n      forEach(DEFAULT_PROPERTIES, function (prop) {\n        propertyProps[prop] = undefined;\n      });\n\n      var globalElement = elementHelper.createElement('drools:Global', propertyProps, parent, bpmnFactory);\n      commands.push(cmdHelper.addElementsTolist(element, parent, 'values', [globalElement]));\n\n      return commands;\n    },\n    updateElement: function (element, value, node, idx) {\n      var property = extensionElementsHelper.getExtensionElements(bo, 'drools:Global')[idx];\n\n      forEach(DEFAULT_PROPERTIES, function (prop) {\n        value[prop] = value[prop] || undefined;\n      });\n\n      return cmdHelper.updateBusinessObject(element, property, value);\n    },\n    validate: function (element, value, node, idx) {\n      var validationError = {};\n      var hasError = false;\n      forEach(DEFAULT_PROPERTIES, function (prop) {\n        if (!value[prop]) {\n          validationError[prop] = translate('Value of [' + prop + '] must be not empty and unique.');\n          hasError = true;\n        }\n      });\n      \n      if (hasError) {\n        // return validationError;\n      }\n    },\n    removeElement: function (element, node, idx) {\n      var commands = [],\n        parent = getParent(element, node),\n        currentProperty = extensionElementsHelper.getExtensionElements(bo, 'drools:Global')[idx];\n\n      commands.push(cmdHelper.removeElementsFromList(element, parent, 'values', null, [currentProperty]));\n\n      return commands;\n    }\n  }));\n}\n","'use strict';\n\nvar is = require(167).is,\n  getBusinessObject = require(167).getBusinessObject,\n  extensionElementsHelper = require(29),\n  elementHelper = require(27),\n  cmdHelper = require(26),\n  entryfactory = require(17),\n  forEach = require(386);\n\nmodule.exports = function (group, element, bpmnFactory, translate) {\n  var bo;\n\n  if (is(element, 'bpmn:Process')) {\n    bo = getBusinessObject(element);\n  }\n\n  if (!bo) {\n    return;\n  }\n\n  function getParent(element, node) {\n    var bo = getBusinessObject(element);\n    return bo.extensionElements;\n  }\n\n  function createParent(element) {\n    var bo = getBusinessObject(element);\n    var parent = elementHelper.createElement('bpmn:ExtensionElements', {values: []}, bo, bpmnFactory);\n    var cmd = cmdHelper.updateProperties(element, {extensionElements: parent});\n    return {\n      cmd: cmd,\n      parent: parent\n    };\n  }\n\n  var DEFAULT_PROPERTIES = [\n    'name'\n  ]\n\n  group.entries.push(entryfactory.table({\n    id: 'imports',\n    modelProperties: DEFAULT_PROPERTIES,\n    labels: [translate('Type Name')],\n    addLabel: translate('Add Import'),\n    getElements: function (element, node) {\n      return extensionElementsHelper.getExtensionElements(bo, 'drools:Import');\n    },\n    addElement: function (element, node) {\n      var commands = [],\n        parent = getParent(element, node);\n\n      if (!parent) {\n        var result = createParent(element);\n        parent = result.parent;\n        commands.push(result.cmd);\n      }\n\n      var propertyProps = {};\n      forEach(DEFAULT_PROPERTIES, function (prop) {\n        propertyProps[prop] = undefined;\n      });\n\n      var importElement = elementHelper.createElement('drools:Import', propertyProps, parent, bpmnFactory);\n      commands.push(cmdHelper.addElementsTolist(element, parent, 'values', [importElement]));\n\n      return commands;\n    },\n    updateElement: function (element, value, node, idx) {\n      var property = extensionElementsHelper.getExtensionElements(bo, 'drools:Import')[idx];\n\n      forEach(DEFAULT_PROPERTIES, function (prop) {\n        value[prop] = value[prop] || undefined;\n      });\n\n      return cmdHelper.updateBusinessObject(element, property, value);\n    },\n    validate: function (element, value, node, idx) {\n      var validationError = {};\n      var hasError = false;\n      forEach(DEFAULT_PROPERTIES, function (prop) {\n        if (!value[prop]) {\n          validationError[prop] = translate('Value of [' + prop + '] must be not empty and unique.');\n          hasError = true;\n        }\n      });\n\n      if (hasError) {\n        // return validationError;\n      }\n    },\n    removeElement: function (element, node, idx) {\n      var commands = [],\n        parent = getParent(element, node),\n        currentProperty = extensionElementsHelper.getExtensionElements(bo, 'drools:Import')[idx];\n\n      commands.push(cmdHelper.removeElementsFromList(element, parent, 'values', null, [currentProperty]));\n\n      return commands;\n    }\n  }));\n}\n","'use strict';\n\nvar inputOutputParameter = require(68);\n\nvar assign = require(516);\n\nmodule.exports = function(group, element, bpmnFactory, options, translate) {\n\n  group.entries = group.entries.concat(inputOutputParameter(element, bpmnFactory, assign({}, options), translate));\n\n};\n","'use strict';\n\nvar inputOutput = require(67);\n\nmodule.exports = function(group, element, bpmnFactory, options, translate) {\n\n  var inputOutputEntry = inputOutput(element, bpmnFactory, options, translate);\n\n  group.entries = group.entries.concat(inputOutputEntry.entries);\n\n  return {\n    getSelectedParameter: inputOutputEntry.getSelectedParameter\n  };\n\n};\n","'use strict';\n\nvar is = require(167).is,\n  entryFactory = require(17);\n\n\nmodule.exports = function(group, element, translate) {\n  if(is(element, 'jbpm:Process')) {\n\n    group.entries.push(entryFactory.textField({\n      id : 'toDoUrl',\n      description : translate('ToDo url for this user task'),\n      label : translate('ToDo Url'),\n      modelProperty : 'toDoUrl'\n    }));\n\n  }\n};\n","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is,\n    entryFactory = require(17),\n    cmdHelper = require(26),\n    scriptlib = require(70);\n\n\nmodule.exports = function(group, element, bpmnFactory, translate) {\n  var bo;\n\n  if (is(element, 'bpmn:ScriptTask')) {\n    bo = getBusinessObject(element);\n  }\n\n  if (!bo) {\n    return;\n  }\n\n  var script = scriptlib('scriptFormat', 'script', false, translate);\n\n  group.entries.push({\n    id: 'script-implementation',\n    description: 'Implementation for a Script.',\n    label: translate('Script'),\n    html: script.template,\n\n    get: function (element) {\n      return script.get(element, bo);\n    },\n\n    set: function(element, values, containerElement) {\n      var properties = script.set(element, values, containerElement);\n\n      return cmdHelper.updateProperties(element, properties);\n    },\n\n    validate: function(element, values) {\n      return script.validate(element, values);\n    },\n\n    script : script,\n\n    cssClasses: ['pp-textfield']\n\n  });\n\n  group.entries.push(entryFactory.textField({\n    id : 'scriptResultVariable',\n    description : 'Result Variable of a Service Task Script',\n    label : translate('Result Variable'),\n    modelProperty : 'scriptResultVariable',\n\n    get: function(element, propertyName) {\n      var boResultVariable = bo.get('jbpm:resultVariable');\n\n      return { scriptResultVariable : boResultVariable };\n    },\n\n    set: function(element, values, containerElement) {\n      return cmdHelper.updateProperties(element, {\n        'jbpm:resultVariable': values.scriptResultVariable\n      });\n    }\n\n  }));\n\n};\n","'use strict';\n\nvar is = require(167).is,\n  getBusinessObject = require(167).getBusinessObject,\n  domQuery = require(538),\n  cmdHelper = require(26),\n  elementHelper = require(27),\n  scriptlib = require(70);\n\n\nmodule.exports = function(group, element, bpmnFactory, translate) {\n  var bo;\n\n  if (is(element, 'bpmn:SequenceFlow')) {\n    bo = getBusinessObject(element);\n  }\n\n  if (!bo) {\n    return;\n  }\n\n  var script = scriptlib('language', 'body', true, translate);\n\n  group.entries.push({\n    id: 'condition',\n    description: translate('Configure the implementation of the task.'),\n    label: translate('Condition'),\n    html: '<div class=\"pp-row\">' +\n              '<label for=\"cam-condition-type\">' + translate('Condition Type') + '</label>' +\n              '<div class=\"pp-field-wrapper\">' +\n                '<select id=\"cam-condition-type\" name=\"conditionType\" data-value>' +\n                  '<option value=\"expression\">' + translate('Expression') + '</option>' +\n                  '<option value=\"script\">' + translate('Script') + '</option>' +\n                  '<option value=\"\" selected></option>' +\n                '</select>' +\n              '</div>' +\n            '</div>' +\n\n            // expression\n            '<div class=\"pp-row\">' +\n              '<label for=\"cam-condition\" data-show=\"isExpression\">' + translate('Expression') + '</label>' +\n              '<div class=\"pp-field-wrapper\" data-show=\"isExpression\">' +\n                '<input id=\"cam-condition\" type=\"text\" name=\"condition\" />' +\n                '<button class=\"clear\" data-action=\"clear\" data-show=\"canClear\">' +\n                  '<span>X</span>' +\n                '</button>' +\n              '</div>' +\n              '<div data-show=\"isScript\">' +\n                script.template +\n              '</div>' +\n            '</div>',\n\n    get: function (element, propertyName) {\n\n      // read values from xml:\n      var conditionExpression = bo.conditionExpression;\n\n      var values = {},\n        conditionType = '';\n\n      if(conditionExpression) {\n        var conditionLanguage = conditionExpression.language;\n        if(typeof conditionLanguage !== 'undefined') {\n          conditionType = 'script';\n          values = script.get(element, conditionExpression);\n        }\n        else {\n          conditionType = 'expression';\n          values.condition = conditionExpression.get('body');\n        }\n      }\n\n      values.conditionType = conditionType;\n\n      return values;\n\n    },\n\n    set: function (element, values, containerElement) {\n      var conditionType = values.conditionType;\n\n      var conditionProps = {\n        body: undefined\n      };\n\n      if(conditionType === 'script') {\n        conditionProps = script.set(element, values, containerElement);\n      }\n      else {\n        var condition = values.condition;\n        conditionProps.body = condition;\n      }\n\n      var update = {\n        \"conditionExpression\": undefined\n      };\n\n      if (conditionType) {\n        update.conditionExpression = elementHelper.createElement\n          (\n            'bpmn:FormalExpression',\n            conditionProps,\n            bo,\n            bpmnFactory\n          );\n      }\n\n      return cmdHelper.updateBusinessObject(element, bo, update);\n    },\n\n    validate: function(element, values) {\n      var validationResult = {};\n\n      if(!values.condition && values.conditionType === 'expression') {\n        validationResult.condition = \"Must provide a value\";\n      }\n      else if(values.conditionType === 'script') {\n        validationResult = script.validate(element, values);\n      }\n\n      return validationResult;\n    },\n\n    isExpression: function(element, inputNode) {\n      var conditionType = domQuery('select[name=conditionType]', inputNode);\n      if(conditionType.selectedIndex >= 0) {\n        return conditionType.options[conditionType.selectedIndex].value === 'expression';\n      }\n    },\n\n    isScript: function(element, inputNode) {\n      var conditionType = domQuery('select[name=conditionType]', inputNode);\n      if(conditionType.selectedIndex >= 0) {\n        return conditionType.options[conditionType.selectedIndex].value === 'script';\n      }\n    },\n\n    clear: function(element, inputNode) {\n      // clear text input\n      domQuery('input[name=condition]', inputNode).value='';\n\n      return true;\n    },\n\n    canClear: function(element, inputNode) {\n      var input = domQuery('input[name=condition]', inputNode);\n\n      return input.value !== '';\n    },\n\n    script : script,\n\n    cssClasses: [ 'pp-textfield' ]\n  });\n};\n","'use strict';\n\nvar ImplementationTypeHelper = require(30),\n    InputOutputHelper        = require(31);\n\nvar implementationType = require(66),\n    delegate           = require(63),\n    external           = require(65),\n    callable           = require(62),\n    resultVariable     = require(69);\n\nvar entryFactory = require(17);\n\nvar domQuery   = require(538),\n    domClosest = require(533),\n    domClasses = require(531);\n\nfunction getImplementationType(element) {\n  return ImplementationTypeHelper.getImplementationType(element);\n}\n\nfunction getBusinessObject(element) {\n  return ImplementationTypeHelper.getServiceTaskLikeBusinessObject(element);\n}\n\nfunction isDmnCapable(element) {\n  return ImplementationTypeHelper.isDmnCapable(element);\n}\n\nfunction isExternalCapable(element) {\n  return ImplementationTypeHelper.isExternalCapable(element);\n}\n\nfunction isServiceTaskLike(element) {\n  return ImplementationTypeHelper.isServiceTaskLike(element);\n}\n\nmodule.exports = function(group, element, bpmnFactory) {\n\n  if (!isServiceTaskLike(getBusinessObject(element))) {\n    return;\n  }\n\n  var hasDmnSupport = isDmnCapable(element);\n  var hasExternalSupport = isExternalCapable(getBusinessObject(element));\n\n  // implementation type ////////////////////////////////////\n\n  group.entries = group.entries.concat(implementationType(element, bpmnFactory, {\n    getBusinessObject: getBusinessObject,\n    getImplementationType: getImplementationType,\n    hasDmnSupport: hasDmnSupport,\n    hasExternalSupport: hasExternalSupport,\n    hasServiceTaskLikeSupport: true\n  }));\n\n\n  // delegate (class, expression, delegateExpression) //////////\n\n  group.entries = group.entries.concat(delegate(element, bpmnFactory, {\n    getBusinessObject: getBusinessObject,\n    getImplementationType: getImplementationType\n  }));\n\n\n  // result variable /////////////////////////////////////////\n\n  group.entries = group.entries.concat(resultVariable(element, bpmnFactory, {\n    getBusinessObject: getBusinessObject,\n    getImplementationType: getImplementationType,\n    hideResultVariable: function(element, node) {\n      return getImplementationType(element) !== 'expression';\n    }\n  }));\n\n  // external //////////////////////////////////////////////////\n\n  if (hasExternalSupport) {\n    group.entries = group.entries.concat(external(element, bpmnFactory, {\n      getBusinessObject: getBusinessObject,\n      getImplementationType: getImplementationType\n    }));\n  }\n\n\n  // dmn ////////////////////////////////////////////////////////\n\n  if (hasDmnSupport) {\n    group.entries = group.entries.concat(callable(element, bpmnFactory, {\n      getCallableType: getImplementationType\n    }));\n  }\n\n\n  // connector ////////////////////////////////////////////////\n\n  var isConnector = function(element) {\n    return getImplementationType(element) === 'connector';\n  };\n\n  group.entries.push(entryFactory.link({\n    id: 'configureConnectorLink',\n    label: 'Configure Connector',\n    getClickableElement: function(element, node) {\n      var panel = domClosest(node, 'div.djs-properties-panel');\n      return domQuery('a[data-tab-target=\"connector\"]', panel);\n    },\n    hideLink: function(element, node) {\n      var link = domQuery('a', node);\n      link.innerHTML = link.textContent = '';\n      domClasses(link).remove('pp-error-message');\n\n      if (isConnector(element)) {\n        var connectorId = InputOutputHelper.getConnector(element).get('connectorId');\n        if (connectorId) {\n          link.textContent = 'Configure Connector';\n        }\n        else {\n          link.innerHTML = '<span class=\"pp-icon-warning\"></span> Must configure Connector';\n          domClasses(link).add('pp-error-message');\n        }\n\n        return false;\n      }\n      return true;\n    }\n  }));\n\n};\n","'use strict';\n\nvar is = require(167).is,\n  entryFactory = require(17);\n\n\nmodule.exports = function(group, element, translate) {\n  if(is(element, 'jbpm:UserTask')) {\n\n    group.entries.push(entryFactory.textField({\n      id : 'ActorId',\n      description : translate('Actor of the User Task'),\n      label : translate('Actor Id'),\n      modelProperty : 'ActorId'\n    }));\n\n    group.entries.push(entryFactory.textField({\n      id : 'RoleCodes',\n      description : translate('Roles of this User Task'),\n      label : translate('Role Codes'),\n      modelProperty : 'RoleCodes'\n    }));\n\n    group.entries.push(entryFactory.textField({\n      id : 'OrganizationLevel',\n      description : translate('Organization Level'),\n      label : translate('Organization Level'),\n      modelProperty : 'OrganizationLevel'\n    }));\n\n    var booleanSelectOptions = [\n      { value: 'false', name: translate('No') },\n      { value: 'true', name: translate('Yes') }\n    ];\n\n    group.entries.push(entryFactory.selectBox({\n      id : 'Multi-User',\n      description : translate('Multi-User'),\n      label : translate('Multi-User'),\n      modelProperty : 'Multi-User',\n      selectOptions: booleanSelectOptions\n    }));\n\n    group.entries.push(entryFactory.selectBox({\n      id : 'Skippable',\n      description : translate('Skippable'),\n      label : translate('Skippable'),\n      modelProperty : 'Skippable',\n      selectOptions: booleanSelectOptions\n    }));\n\n    group.entries.push(entryFactory.textField({\n      id : 'Priority',\n      description : translate('Priority'),\n      label : translate('Priority'),\n      modelProperty : 'Priority'\n    }));\n\n    group.entries.push(entryFactory.textField({\n      id : 'toDoUrl',\n      description : translate('ToDo url for this user task'),\n      label : translate('ToDo Url'),\n      modelProperty : 'toDoUrl'\n    }));\n\n  }\n};\n","'use strict';\n\nvar cmdHelper = require(26),\n    entryFactory = require(17),\n    elementHelper = require(27),\n    extensionElementsHelper = require(29);\n\n\nvar resultVariable = require(69);\n\nvar getBusinessObject = require(167).getBusinessObject;\nvar is = require(167).is;\n\nvar forEach = require(386);\n\nvar attributeInfo = {\n  bpmn: {\n    element: 'calledElement',\n    binding: 'jbpm:calledElementBinding',\n    version: 'jbpm:calledElementVersion'\n  },\n\n  cmmn: {\n    element: 'jbpm:caseRef',\n    binding: 'jbpm:caseBinding',\n    version: 'jbpm:caseVersion'\n  },\n\n  dmn: {\n    element: 'jbpm:decisionRef',\n    binding: 'jbpm:decisionRefBinding',\n    version: 'jbpm:decisionRefVersion'\n  }\n};\n\nvar bindingOptions = [\n  {\n    name: 'latest',\n    value: 'latest'\n  },\n  {\n    name: 'deployment',\n    value: 'deployment'\n  },\n  {\n    name: 'version',\n    value: 'version'\n  }\n];\n\nvar mapDecisionResultOptions = [\n  {\n    name: 'singleEntry',\n    value: 'singleEntry'\n  },\n  {\n    name:'singleResult',\n    value:'singleResult'\n  },\n  {\n    name:'collectEntries',\n    value:'collectEntries'\n  },\n  {\n    name:'resultList',\n    value:'resultList'\n  }\n];\n\nfunction getJbpmInWithBusinessKey(element) {\n  var jbpmIn = [],\n      bo = getBusinessObject(element);\n\n  var jbpmInParams = extensionElementsHelper.getExtensionElements(bo, 'jbpm:In');\n  if (jbpmInParams) {\n    forEach(jbpmInParams, function(param) {\n      if (param.businessKey) {\n        jbpmIn.push(param);\n      }\n    });\n  }\n  return jbpmIn;\n}\n\nfunction setBusinessKey(element, bpmnFactory) {\n  var bo = getBusinessObject(element);\n  var commands = [];\n\n  var extensionElements = bo.extensionElements;\n  if (!extensionElements) {\n    extensionElements = elementHelper.createElement('bpmn:ExtensionElements', { values: [] }, bo, bpmnFactory);\n    commands.push(cmdHelper.updateProperties(element, { extensionElements: extensionElements }));\n  }\n\n  var jbpmIn = elementHelper.createElement(\n    'jbpm:In',\n    { 'businessKey': '#{execution.processBusinessKey}' },\n    extensionElements,\n    bpmnFactory\n  );\n\n  commands.push(cmdHelper.addAndRemoveElementsFromList(\n    element,\n    extensionElements,\n    'values',\n    'extensionElements',\n    [ jbpmIn ],[]\n  ));\n\n  return commands;\n}\n\nfunction deleteBusinessKey(element) {\n  var jbpmInExtensions = getJbpmInWithBusinessKey(element);\n  var commands = [];\n  forEach(jbpmInExtensions, function(elem) {\n    commands.push(extensionElementsHelper.removeEntry(getBusinessObject(element), element, elem));\n  });\n  return commands;\n}\n\nfunction isSupportedCallableType(type) {\n  return [ 'bpmn', 'cmmn', 'dmn' ].indexOf(type) !== -1;\n}\n\nmodule.exports = function (element, bpmnFactory, options) {\n\n  var getCallableType = options.getCallableType;\n\n  var entries = [];\n\n  function getAttribute(element, prop) {\n    var type = getCallableType(element);\n    return (attributeInfo[type] || {})[prop];\n  }\n\n  function getCallActivityBindingValue(element) {\n    var type = getCallableType(element);\n    var bo = getBusinessObject(element);\n    var attr = (attributeInfo[type] || {}).binding;\n    return bo.get(attr);\n  }\n\n  entries.push(entryFactory.textField({\n    id: 'callable-element-ref',\n    dataValueLabel: 'callableElementLabel',\n    modelProperty: 'callableElementRef',\n\n    get: function(element, node) {\n      var callableElementRef;\n\n      var attr = getAttribute(element, 'element');\n      if (attr) {\n        var bo = getBusinessObject(element);\n        callableElementRef = bo.get(attr);\n      }\n\n      var label = '';\n      var type = getCallableType(element);\n      if (type === 'bpmn') {\n        label = 'Called Element';\n      }\n      else if (type === 'cmmn') {\n        label = 'Case Ref';\n      }\n      else if (type === 'dmn') {\n        label = 'Decision Ref';\n      }\n\n      return {\n        callableElementRef: callableElementRef,\n        callableElementLabel: label\n      };\n    },\n\n    set: function(element, values, node) {\n      var newCallableElementRef = values.callableElementRef;\n      var attr = getAttribute(element, 'element');\n\n      var props = {};\n      props[attr] = newCallableElementRef || '';\n\n      return cmdHelper.updateProperties(element, props);\n    },\n\n    validate: function(element, values, node) {\n      var elementRef = values.callableElementRef;\n      var type = getCallableType(element);\n      return isSupportedCallableType(type) && !elementRef ? { callableElementRef: 'Value must provide a value.' } : {};\n    },\n\n    disabled: function(element, node) {\n      return !isSupportedCallableType(getCallableType(element));\n    }\n\n  }));\n\n\n  entries.push(entryFactory.selectBox({\n    id: 'callable-binding',\n    label: 'Binding',\n    selectOptions: bindingOptions,\n    modelProperty: 'callableBinding',\n\n    get: function(element, node) {\n      var callableBinding;\n\n      var attr = getAttribute(element, 'binding');\n      if (attr) {\n        var bo = getBusinessObject(element);\n        callableBinding = bo.get(attr) || 'latest';\n      }\n\n      return {\n        callableBinding: callableBinding,\n      };\n    },\n\n    set: function(element, values, node) {\n      var binding = values.callableBinding;\n      var attr = getAttribute(element, 'binding'),\n          attrVer = getAttribute(element, 'version');\n\n      var props = {};\n      props[attr] = binding;\n      // set version value always on undefined to delete the existing value\n      props[attrVer] = undefined;\n\n      return cmdHelper.updateProperties(element, props);\n    },\n\n    disabled: function(element, node) {\n      return !isSupportedCallableType(getCallableType(element));\n    }\n\n  }));\n\n\n  entries.push(entryFactory.textField({\n    id: 'callable-version',\n    label: 'Version',\n    modelProperty: 'callableVersion',\n\n    get: function(element, node) {\n      var callableVersion;\n\n      var attr = getAttribute(element, 'version');\n      if (attr) {\n        var bo = getBusinessObject(element);\n        callableVersion = bo.get(attr);\n      }\n\n      return {\n        callableVersion: callableVersion,\n      };\n    },\n\n    set: function(element, values, node) {\n      var version = values.callableVersion;\n      var attr = getAttribute(element, 'version');\n\n      var props = {};\n      props[attr] = version || undefined;\n\n      return cmdHelper.updateProperties(element, props);\n    },\n\n    validate: function(element, values, node) {\n      var version = values.callableVersion;\n\n      var type = getCallableType(element);\n      return isSupportedCallableType(type) && (getCallActivityBindingValue(element) === 'version') && !version ?\n             { callableVersion: 'Value must provide a value.' } : {};\n    },\n\n    disabled: function(element, node) {\n      var type = getCallableType(element);\n      return !isSupportedCallableType(type) || getCallActivityBindingValue(element) !== 'version';\n    }\n\n  }));\n\n\n  if (is(getBusinessObject(element), 'bpmn:CallActivity')) {\n    entries.push(entryFactory.checkbox({\n      id: 'callable-business-key',\n      label: 'Business Key',\n      modelProperty: 'callableBusinessKey',\n\n      get: function(element, node) {\n        var jbpmIn = getJbpmInWithBusinessKey(element);\n        return {\n          callableBusinessKey: !!(jbpmIn && jbpmIn.length > 0)\n        };\n      },\n\n      set: function(element, values, node) {\n        if (values.callableBusinessKey) {\n          return setBusinessKey(element, bpmnFactory);\n        } else {\n          return deleteBusinessKey(element);\n        }\n      }\n    }));\n  }\n\n\n  entries = entries.concat(resultVariable(element, bpmnFactory, {\n    id: 'dmn-resultVariable',\n    getBusinessObject: getBusinessObject,\n    getImplementationType: getCallableType,\n    hideResultVariable: function(element, node) {\n      return getCallableType(element) !== 'dmn';\n    }\n  }));\n\n\n  entries.push(entryFactory.selectBox({\n    id: 'dmn-map-decision-result',\n    label: 'Map Decision Result',\n    selectOptions: mapDecisionResultOptions,\n    modelProperty: 'mapDecisionResult',\n\n    get: function(element, node) {\n      var bo = getBusinessObject(element);\n      return {\n        mapDecisionResult: bo.get('jbpm:mapDecisionResult') || 'resultList'\n      };\n    },\n\n    set: function(element, values, node) {\n      return cmdHelper.updateProperties(element, {\n        'jbpm:mapDecisionResult': values.mapDecisionResult || 'resultList'\n      });\n    },\n\n    disabled: function(element, node) {\n      var bo = getBusinessObject(element);\n      var resultVariable = bo.get('jbpm:resultVariable');\n      return !(getCallableType(element) === 'dmn' && typeof resultVariable !== 'undefined');\n    }\n\n  }));\n\n  return entries;\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    cmdHelper    = require(26);\n\nvar DELEGATE_TYPES = [\n  'class',\n  'expression',\n  'delegateExpression'\n];\n\nvar PROPERTIES = {\n  class: 'jbpm:class',\n  expression: 'jbpm:expression',\n  delegateExpression: 'jbpm:delegateExpression'\n};\n\nfunction isDelegate(type) {\n  return DELEGATE_TYPES.indexOf(type) !== -1;\n}\n\nfunction getAttribute(type) {\n  return PROPERTIES[type];\n}\n\nfunction getDelegationLabel(type) {\n  switch(type) {\n    case 'class':\n        return 'Java Class';\n    case 'expression':\n        return 'Expression';\n    case 'delegateExpression':\n        return 'Delegate Expression';\n    default:\n        return '';\n  }\n}\n\nmodule.exports = function(element, bpmnFactory, options) {\n\n  var getImplementationType = options.getImplementationType,\n      getBusinessObject     = options.getBusinessObject;\n\n  var delegateEntry = entryFactory.textField({\n    id: 'delegate',\n    label: 'Value',\n    dataValueLabel: 'delegationLabel',\n    modelProperty: 'delegate',\n\n    get: function(element, node) {\n      var bo = getBusinessObject(element);\n      var type = getImplementationType(element);\n      var attr = getAttribute(type);\n      var label = getDelegationLabel(type);\n      return {\n        delegate: bo.get(attr),\n        delegationLabel: label\n      };\n    },\n\n    set: function(element, values, node) {\n      var bo = getBusinessObject(element);\n      var type = getImplementationType(element);\n      var attr = getAttribute(type);\n      var prop = {};\n      prop[attr] = values.delegate || '';\n      return cmdHelper.updateBusinessObject(element, bo, prop);\n    },\n\n    validate: function(element, values, node) {\n      return isDelegate(getImplementationType(element)) && !values.delegate ? { delegate: 'Must provide a value'} : {};\n    },\n\n    disabled: function(element, node) {\n      return !isDelegate(getImplementationType(element));\n    }\n\n  });\n\n  return [ delegateEntry ];\n\n};\n","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject;\n\nvar domQuery = require(538),\n    domClosest = require(533),\n    domify = require(535),\n    forEach = require(386);\n\nvar elementHelper = require(27),\n    cmdHelper = require(26),\n    utils = require(8);\n\nfunction getSelectBox(node, id) {\n  var currentTab = domClosest(node, 'div.djs-properties-tab');\n  var query = 'select[name=selectedExtensionElement]' + (id ? '[id=cam-extensionElements-' + id + ']' : '');\n  return domQuery(query, currentTab);\n}\n\nfunction getSelected(node, id) {\n  var selectBox = getSelectBox(node, id);\n  return {\n    value: (selectBox || {}).value,\n    idx: (selectBox || {}).selectedIndex\n  };\n}\n\nfunction generateElementId(prefix) {\n  prefix = prefix + '_';\n  return utils.nextId(prefix);\n}\n\nvar CREATE_EXTENSION_ELEMENT_ACTION = 'create-extension-element',\n    REMOVE_EXTENSION_ELEMENT_ACTION = 'remove-extension-element';\n\nmodule.exports = function (element, bpmnFactory, options) {\n\n  var id     = options.id,\n      prefix = options.prefix || 'elem',\n      label  = options.label || id,\n      idGeneration = (options.idGeneration === false) ? options.idGeneration : true;\n\n  var modelProperty = options.modelProperty || 'id';\n\n  var getElements = options.getExtensionElements;\n\n  var createElement = options.createExtensionElement,\n      canCreate     = typeof createElement === 'function';\n\n  var removeElement = options.removeExtensionElement,\n      canRemove     = typeof removeElement === 'function';\n\n  var onSelectionChange = options.onSelectionChange;\n\n  var hideElements = options.hideExtensionElements,\n      canBeHidden  = typeof hideElements === 'function';\n\n  var setOptionLabelValue = options.setOptionLabelValue;\n\n  var defaultSize = options.size || 5,\n      resizable   = options.resizable;\n\n  var selectionChanged = function(element, node, event, scope) {\n    if (typeof onSelectionChange === 'function') {\n      return onSelectionChange(element, node, event, scope);\n    }\n  };\n\n  var createOption = function(value) {\n    return '<option value=\"' + value + '\" data-value data-name=\"extensionElementValue\">' + value + '</option>';\n  };\n\n  var initSelectionSize = function(selectBox, optionsLength) {\n    if (resizable) {\n      selectBox.size = optionsLength > defaultSize ? optionsLength : defaultSize;\n    }\n  };\n\n  return {\n    id: id,\n    html: '<div class=\"pp-row pp-element-list\" ' +\n            (canBeHidden ? 'data-show=\"hideElements\"' : '') + '>' +\n            '<label for=\"cam-extensionElements-' + id + '\">' + label + '</label>' +\n            '<div class=\"pp-field-wrapper\">' +\n              '<select id=\"cam-extensionElements-' + id + '\"' +\n                      'name=\"selectedExtensionElement\" ' +\n                      'size=\"' + defaultSize + '\" ' +\n                      'data-list-entry-container ' +\n                      'data-on-change=\"selectElement\">' +\n              '</select>' +\n              (canCreate ? '<button class=\"add\" ' +\n                                   'id=\"cam-extensionElements-create-' + id + '\" ' +\n                                   'data-action=\"createElement\">' +\n                             '<span>+</span>' +\n                           '</button>' : '') +\n              (canRemove ? '<button class=\"clear\" ' +\n                                   'id=\"cam-extensionElements-remove-' + id + '\" ' +\n                                   'data-action=\"removeElement\" ' +\n                                   'data-disable=\"disableRemove\">' +\n                             '<span>-</span>' +\n                           '</button>' : '') +\n            '</div>' +\n          '</div>',\n\n    get: function(element, node) {\n      var elements = getElements(element);\n\n      var result = [];\n      forEach(elements, function(elem) {\n        result.push({\n          extensionElementValue: elem.get(modelProperty)\n        });\n      });\n\n      var selectBox = getSelectBox(node.parentNode, id);\n      initSelectionSize(selectBox, result.length);\n\n      return result;\n    },\n\n    set: function(element, values, node) {\n      var action = this.__action;\n      delete this.__action;\n\n      var bo = getBusinessObject(element);\n      var extensionElements = bo.get('extensionElements');\n\n      if (action.id === CREATE_EXTENSION_ELEMENT_ACTION) {\n        var commands = [];\n        if (!extensionElements) {\n          extensionElements = elementHelper.createElement('bpmn:ExtensionElements', { values: [] }, bo, bpmnFactory);\n          commands.push(cmdHelper.updateProperties(element, { extensionElements: extensionElements }));\n        }\n        commands.push(createElement(element, extensionElements, action.value));\n        return commands;\n\n      }\n      else if (action.id === REMOVE_EXTENSION_ELEMENT_ACTION) {\n        return removeElement(element, extensionElements, action.value, action.idx);\n      }\n\n    },\n\n    createListEntryTemplate: function(value, index, selectBox) {\n      initSelectionSize(selectBox, selectBox.options.length + 1);\n      return createOption(value.extensionElementValue);\n    },\n\n    deselect: function(element, node) {\n      var selectBox = getSelectBox(node, id);\n      selectBox.selectedIndex = -1;\n    },\n\n    getSelected: function(element, node) {\n      return getSelected(node, id);\n    },\n\n    setControlValue: function(element, node, option, property, value, idx) {\n      node.value = value;\n\n      if (!setOptionLabelValue) {\n        node.text = value;\n      }\n      else {\n        setOptionLabelValue(element, node, option, property, value, idx);\n      }\n    },\n\n    createElement: function(element, node) {\n      // create option template\n      var generatedId;\n      if (idGeneration) {\n        generatedId = generateElementId(prefix);\n      }\n\n      var selectBox = getSelectBox(node, id);\n      var template = domify(createOption(generatedId));\n\n      // add new empty option as last child element\n      selectBox.appendChild(template);\n\n      // select last child element\n      selectBox.lastChild.selected = 'selected';\n      selectionChanged(element, node);\n\n      // update select box size\n      initSelectionSize(selectBox, selectBox.options.length);\n\n      this.__action = {\n        id: CREATE_EXTENSION_ELEMENT_ACTION,\n        value: generatedId\n      };\n\n      return true;\n    },\n\n    removeElement: function(element, node) {\n      var selection = getSelected(node, id);\n\n      var selectBox = getSelectBox(node, id);\n      selectBox.removeChild(selectBox.options[selection.idx]);\n\n      // update select box size\n      initSelectionSize(selectBox, selectBox.options.length);\n\n      this.__action = {\n        id: REMOVE_EXTENSION_ELEMENT_ACTION,\n        value: selection.value,\n        idx: selection.idx\n      };\n\n      return true;\n    },\n\n    hideElements: function(element, entryNode, node, scopeNode) {\n      return !hideElements(element, entryNode, node, scopeNode);\n    },\n\n    disableRemove: function(element, entryNode, node, scopeNode) {\n      return (getSelected(entryNode, id) || {}).idx < 0;\n    },\n\n    selectElement: selectionChanged\n  };\n\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    cmdHelper    = require(26);\n\nmodule.exports = function(element, bpmnFactory, options) {\n\n  var getImplementationType = options.getImplementationType,\n      getBusinessObject     = options.getBusinessObject;\n\n  function isExternal(element) {\n    return getImplementationType(element) === 'external';\n  }\n\n  var topicEntry = entryFactory.textField({\n    id: 'externalTopic',\n    label: 'Topic',\n    modelProperty: 'externalTopic',\n\n    get: function(element, node) {\n      var bo = getBusinessObject(element);\n      return { externalTopic: bo.get('jbpm:topic') };\n    },\n\n    set: function(element, values, node) {\n      var bo = getBusinessObject(element);\n      return cmdHelper.updateBusinessObject(element, bo, {\n        'jbpm:topic': values.externalTopic\n      });\n    },\n\n    validate: function(element, values, node) {\n      return isExternal(element) && !values.externalTopic ? { externalTopic: 'Must provide a value'} : {};\n    },\n\n    disabled: function(element, node) {\n      return !isExternal(element);\n    }\n\n  });\n\n  return [ topicEntry ];\n\n};\n","'use strict';\n\nvar entryFactory = require(17),\n    cmdHelper = require(26),\n    extensionElementsHelper = require(29),\n    elementHelper = require(27);\n\nvar assign = require(516);\nvar map = require(389);\n\nvar DEFAULT_DELEGATE_PROPS = [ 'class', 'expression', 'delegateExpression' ];\n\nvar DELEGATE_PROPS = {\n  'jbpm:class': undefined,\n  'jbpm:expression': undefined,\n  'jbpm:delegateExpression': undefined,\n  'jbpm:resultVariable': undefined\n};\n\nvar DMN_CAPABLE_PROPS = {\n  'jbpm:decisionRef': undefined,\n  'jbpm:decisionRefBinding': 'latest',\n  'jbpm:decisionRefVersion': undefined,\n  'jbpm:mapDecisionResult': 'resultList'\n};\n\n\nvar EXTERNAL_CAPABLE_PROPS = {\n  'jbpm:type': undefined,\n  'jbpm:topic': undefined\n};\n\nvar DEFAULT_OPTIONS = [\n  { value: 'class', name: 'Java Class'},\n  { value: 'expression', name: 'Expression'},\n  { value: 'delegateExpression', name: 'Delegate Expression'}\n];\n\nvar DMN_OPTION = [\n  { value: 'dmn', name: 'DMN'}\n];\n\nvar EXTERNAL_OPTION = [\n  { value: 'external', name: 'External'}\n];\n\nvar CONNECTOR_OPTION = [\n  { value: 'connector', name: 'Connector'}\n];\n\nvar SCRIPT_OPTION = [\n  { value: 'script', name: 'Script'}\n];\n\nmodule.exports = function(element, bpmnFactory, options) {\n\n  var getType           = options.getImplementationType,\n      getBusinessObject = options.getBusinessObject;\n\n  var hasDmnSupport             = options.hasDmnSupport,\n      hasExternalSupport        = options.hasExternalSupport,\n      hasServiceTaskLikeSupport = options.hasServiceTaskLikeSupport,\n      hasScriptSupport          = options.hasScriptSupport;\n\n  var entries = [];\n\n  var selectOptions = DEFAULT_OPTIONS.concat([]);\n\n  if (hasDmnSupport) {\n    selectOptions = selectOptions.concat(DMN_OPTION);\n  }\n\n  if (hasExternalSupport) {\n    selectOptions = selectOptions.concat(EXTERNAL_OPTION);\n  }\n\n  if (hasServiceTaskLikeSupport) {\n    selectOptions = selectOptions.concat(CONNECTOR_OPTION);\n  }\n\n  if (hasScriptSupport) {\n    selectOptions = selectOptions.concat(SCRIPT_OPTION);\n  }\n\n  selectOptions.push({ value: '' });\n\n  entries.push(entryFactory.selectBox({\n    id : 'implementation',\n    description: 'Configure the implementation of the task.',\n    label: 'Implementation',\n    selectOptions: selectOptions,\n    modelProperty: 'implType',\n\n    get: function (element, node) {\n      return {\n        implType: getType(element) || ''\n      };\n    },\n\n    set: function (element, values, node) {\n      var bo = getBusinessObject(element);\n      var oldType = getType(element);\n      var newType = values.implType;\n\n      var props = assign({}, DELEGATE_PROPS);\n\n      if (DEFAULT_DELEGATE_PROPS.indexOf(newType) !== -1) {\n\n        var newValue = '';\n        if (DEFAULT_DELEGATE_PROPS.indexOf(oldType) !== -1) {\n          newValue = bo.get('jbpm:' + oldType);\n        }\n        props['jbpm:' + newType] = newValue;\n      }\n\n      if (hasDmnSupport) {\n        props = assign(props, DMN_CAPABLE_PROPS);\n        if (newType === 'dmn') {\n          props['jbpm:decisionRef'] = '';\n        }\n      }\n\n      if (hasExternalSupport) {\n        props = assign(props, EXTERNAL_CAPABLE_PROPS);\n        if (newType === 'external') {\n          props['jbpm:type'] = 'external';\n          props['jbpm:topic'] = '';\n        }\n      }\n\n      if (hasScriptSupport) {      \n        props['jbpm:script'] = undefined;\n\n        if (newType === 'script') {\n          props['jbpm:script'] = elementHelper.createElement('jbpm:Script', {}, bo, bpmnFactory);\n        }\n      }\n\n      var commands = [];\n      commands.push(cmdHelper.updateBusinessObject(element, bo, props));\n\n      if (hasServiceTaskLikeSupport) {\n        var connectors = extensionElementsHelper.getExtensionElements(bo, 'jbpm:Connector');\n        commands.push(map(connectors, function(connector) {\n          return extensionElementsHelper.removeEntry(bo, element, connector);\n        }));\n\n        if (newType === 'connector') {\n          var extensionElements = bo.get('extensionElements');\n          if (!extensionElements) {\n            extensionElements = elementHelper.createElement('bpmn:ExtensionElements', { values: [] }, bo, bpmnFactory);\n            commands.push(cmdHelper.updateBusinessObject(element, bo, { extensionElements: extensionElements }));\n          }\n          var connector = elementHelper.createElement('jbpm:Connector', {}, extensionElements, bpmnFactory);\n          commands.push(cmdHelper.addAndRemoveElementsFromList(\n            element,\n            extensionElements,\n            'values',\n            'extensionElements',\n            [ connector ],\n            []\n          ));\n        }\n      }\n\n      return commands;\n\n    }\n  }));\n\n  return entries;\n\n};\n","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject;\n\nvar elementHelper = require(27),\n    extensionElementsHelper = require(29),\n    inputOutputHelper = require(31),\n    cmdHelper = require(26);\n\nvar extensionElementsEntry = require(64);\n\n\nfunction getInputOutput(element, insideConnector) {\n  return inputOutputHelper.getInputOutput(element, insideConnector, 'jbpm:InputOutput');\n}\n\nfunction getConnector(element) {\n  return inputOutputHelper.getConnector(element, 'jbpm:InputOutput');\n}\n\nfunction getInputParameters(element, insideConnector) {\n  return inputOutputHelper.getInputParameters(element, insideConnector, 'jbpm:InputOutput');\n}\n\nfunction getOutputParameters(element, insideConnector) {\n  return inputOutputHelper.getOutputParameters(element, insideConnector, 'jbpm:InputOutput');\n}\n\nfunction getInputParameter(element, insideConnector, idx) {\n  return inputOutputHelper.getInputParameter(element, insideConnector, idx, 'jbpm:InputOutput');\n}\n\nfunction getOutputParameter(element, insideConnector, idx) {\n  return inputOutputHelper.getOutputParameter(element, insideConnector, idx, 'jbpm:InputOutput');\n}\n\n\nfunction createElement(type, parent, factory, properties) {\n  return elementHelper.createElement(type, properties, parent, factory);\n}\n\nfunction createInputOutput(parent, bpmnFactory, properties) {\n  return createElement('jbpm:InputOutput', parent, bpmnFactory, properties);\n}\n\nfunction createParameter(type, parent, bpmnFactory, properties) {\n  return createElement(type, parent, bpmnFactory, properties);\n}\n\n\nfunction ensureInputOutputSupported(element, insideConnector) {\n  return inputOutputHelper.isInputOutputSupported(element, insideConnector);\n}\n\nfunction ensureOutparameterSupported(element, insideConnector) {\n  return inputOutputHelper.areOutputParametersSupported(element, insideConnector);\n}\n\nmodule.exports = function(element, bpmnFactory, options, translate) {\n\n  options = options || {};\n\n  var insideConnector = !!options.insideConnector,\n      idPrefix        = options.idPrefix || '';\n\n  var getSelected = function(element, node) {\n    var selection = (inputEntry && inputEntry.getSelected(element, node)) || { idx: -1 };\n\n    var parameter = getInputParameter(element, insideConnector, selection.idx);\n    if (!parameter && outputEntry) {\n      selection = outputEntry.getSelected(element, node);\n      parameter = getOutputParameter(element, insideConnector, selection.idx);\n    }\n    return parameter;\n  };\n\n  var result = {\n    getSelectedParameter: getSelected\n  };\n\n  var entries = result.entries = [];\n\n  if (!ensureInputOutputSupported(element)) {\n    return result;\n  }\n\n  var newElement = function(type, prop, factory) {\n\n    return function(element, extensionElements, value) {\n      var commands = [];\n\n      var inputOutput = getInputOutput(element, insideConnector);\n      if (!inputOutput) {\n        var parent = !insideConnector ? extensionElements : getConnector(element);\n        inputOutput = createInputOutput(parent, bpmnFactory, {\n          inputParameters: [],\n          outputParameters: []\n        });\n\n        if (!insideConnector) {\n          commands.push(cmdHelper.addAndRemoveElementsFromList(\n            element,\n            extensionElements,\n            'values',\n            'extensionElements',\n            [ inputOutput ],\n            []\n          ));\n        }\n        else {\n          commands.push(cmdHelper.updateBusinessObject(element, parent, { inputOutput: inputOutput }));\n        }\n      }\n\n      var newElem = createParameter(type, inputOutput, bpmnFactory, { name: value });\n      commands.push(cmdHelper.addElementsTolist(element, inputOutput, prop, [ newElem ]));\n\n      return commands;\n    };\n  };\n\n  var removeElement = function(getter, prop, otherProp) {\n    return function(element, extensionElements, value, idx) {\n      var inputOutput = getInputOutput(element, insideConnector);\n      var parameter = getter(element, insideConnector, idx);\n\n      var commands = [];\n      commands.push(cmdHelper.removeElementsFromList(element, inputOutput, prop, null, [ parameter ]));\n\n      var firstLength = inputOutput.get(prop).length-1;\n      var secondLength = (inputOutput.get(otherProp) || []).length;\n\n      if (!firstLength && !secondLength) {\n\n        if (!insideConnector) {\n          commands.push(extensionElementsHelper.removeEntry(getBusinessObject(element), element, inputOutput));\n        }\n        else {\n          var connector = getConnector(element);\n          commands.push(cmdHelper.updateBusinessObject(element, connector, { inputOutput: undefined }));\n        }\n\n      }\n\n      return commands;\n    };\n  };\n\n  var setOptionLabelValue = function(getter) {\n    return function(element, node, option, property, value, idx) {\n      var parameter = getter(element, insideConnector, idx);\n\n      option.text = (value || '') + (parameter.value ? ' : ' + parameter.value : '');\n    };\n  };\n\n\n  // input parameters ///////////////////////////////////////////////////////////////\n\n  var inputEntry = extensionElementsEntry(element, bpmnFactory, {\n    id: idPrefix + 'inputs',\n    label: translate('Input Parameters'),\n    modelProperty: 'name',\n    prefix: 'Input',\n    resizable: true,\n\n    createExtensionElement: newElement('jbpm:InputParameter', 'inputParameters'),\n    removeExtensionElement: removeElement(getInputParameter, 'inputParameters', 'outputParameters'),\n\n    getExtensionElements: function(element) {\n      return getInputParameters(element, insideConnector);\n    },\n\n    onSelectionChange: function(element, node, event, scope) {\n      outputEntry && outputEntry.deselect(element, node);\n    },\n\n    setOptionLabelValue: setOptionLabelValue(getInputParameter)\n\n  });\n  entries.push(inputEntry);\n\n\n  // output parameters ///////////////////////////////////////////////////////\n\n  if (ensureOutparameterSupported(element, insideConnector)) {\n    var outputEntry = extensionElementsEntry(element, bpmnFactory, {\n      id: idPrefix + 'outputs',\n      label: translate('Output Parameters'),\n      modelProperty: 'name',\n      prefix: 'Output',\n      resizable: true,\n\n      createExtensionElement: newElement('jbpm:OutputParameter', 'outputParameters'),\n      removeExtensionElement: removeElement(getOutputParameter, 'outputParameters', 'inputParameters'),\n\n      getExtensionElements: function(element) {\n        return getOutputParameters(element, insideConnector);\n      },\n\n      onSelectionChange: function(element, node, event, scope) {\n        inputEntry.deselect(element, node);\n      },\n\n      setOptionLabelValue: setOptionLabelValue(getOutputParameter)\n\n    });\n    entries.push(outputEntry);\n  }\n\n  return result;\n\n};\n","'use strict';\n\nvar inputOutputHelper = require(31),\n    cmdHelper = require(26),\n    utils = require(8);\n\nvar entryFactory = require(17);\n\nfunction ensureInputOutputSupported(element, insideConnector) {\n  return inputOutputHelper.isInputOutputSupported(element, insideConnector);\n}\n\nmodule.exports = function(element, bpmnFactory, options, translate) {\n\n  options = options || {};\n\n  var insideConnector = !!options.insideConnector,\n      idPrefix        = options.idPrefix || '';\n\n  var getSelected = options.getSelectedParameter;\n\n  if (!ensureInputOutputSupported(element, insideConnector)) {\n    return [];\n  }\n\n  var entries = [];\n\n  var isSelected = function(element, node) {\n    return getSelected(element, node);\n  };\n\n\n  // parameter name ////////////////////////////////////////////////////////\n\n  entries.push(entryFactory.validationAwareTextField({\n    id: idPrefix + 'parameterName',\n    label: translate('Name'),\n    modelProperty: 'name',\n\n    getProperty: function(element, node) {\n      return (getSelected(element, node) || {}).name;\n    },\n\n    setProperty: function(element, values, node) {\n      var param = getSelected(element, node);\n      return cmdHelper.updateBusinessObject(element, param, values);\n    },\n\n    validate: function(element, values, node) {\n      var bo = getSelected(element, node);\n\n      var validation = {};\n      if (bo) {\n        var nameValue = values.name;\n\n        if (nameValue) {\n          if (utils.containsSpace(nameValue)) {\n            validation.name = 'Name must not contain spaces';\n          }\n        }\n        else {\n          validation.name = 'Parameter must have a name';\n        }\n      }\n\n      return validation;\n    },\n\n    disabled: function(element, node) {\n      return !isSelected(element, node);\n    }\n  }));\n\n  // parameter value ///////////////////////////////////////////////////////\n\n  entries.push(entryFactory.textArea({\n    id : idPrefix + 'parameterType-text',\n    label : translate('Value'),\n    modelProperty: 'value',\n    get: function(element, node) {\n      return {\n        value: (getSelected(element, node) || {}).value\n      };\n    },\n\n    set: function(element, values, node) {\n      var param = getSelected(element, node);\n      values.value = values.value || undefined;\n      return cmdHelper.updateBusinessObject(element, param, values);\n    },\n\n    show: function(element, node) {\n      var bo = getSelected(element, node);\n      return bo && !bo.definition;\n    }\n\n  }));\n\n  return entries;\n\n};\n","'use strict';\n\nvar is = require(167).is;\n\nvar assign = require(516);\n\nvar entryFactory = require(17),\n    cmdHelper    = require(26);\n\nmodule.exports = function(element, bpmnFactory, options) {\n\n  var getBusinessObject     = options.getBusinessObject,\n      hideResultVariable    = options.hideResultVariable,\n      id                    = options.id || 'resultVariable';\n\n\n  var resultVariableEntry = entryFactory.textField({\n    id: id,\n    label: 'Result Variable',\n    modelProperty: 'resultVariable',\n\n    get: function(element, node) {\n      var bo = getBusinessObject(element);\n      return { resultVariable: bo.get('jbpm:resultVariable') };\n    },\n\n    set: function(element, values, node) {\n      var bo = getBusinessObject(element);\n\n      var resultVariable = values.resultVariable || undefined;\n\n      var props = {\n        'jbpm:resultVariable': resultVariable\n      };\n\n      if (is(bo, 'jbpm:DmnCapable') && !resultVariable) {\n        props = assign({ 'jbpm:mapDecisionResult': 'resultList' }, props);\n      }\n\n      return cmdHelper.updateBusinessObject(element, bo, props);\n    },\n\n    disabled: function(element, node) {\n      if (typeof hideResultVariable === 'function') {\n        return hideResultVariable.apply(resultVariableEntry, arguments);\n      }\n    }\n\n  });\n\n  return [ resultVariableEntry ];\n\n};\n","'use strict';\n\nvar domQuery = require(538),\n\n    utils = require(8);\n\n\nfunction getScriptType(node) {\n  return utils.selectedType('select[name=scriptType]', node.parentElement);\n}\n\n\nmodule.exports = function(scriptLanguagePropName, scriptValuePropName, isFormatRequired, translate) {\n\nreturn {\n  template:\n    '<div class=\"pp-row pp-textfield\">' +\n      '<label for=\"cam-script-format\">' + translate('Script Format') + '</label>' +\n      '<div class=\"pp-field-wrapper\">' +\n        '<select id=\"cam-script-format\" name=\"scriptFormat\" data-value>' +\n          '<option value=\"http://www.w3.org/1999/XPath\" selected>' + translate('XPath 1.0') + '</option>' +\n          '<option value=\"http://www.java.com/java\">' + translate('Java') + '</option>' +\n          '<option value=\"http://www.mvel.org/2.0\">' + translate('MVEL 2.0') + '</option>' +\n          '<option value=\"http://www.javascript.com/javascript\">' + translate('JavaScript') + '</option>' +\n        '</select>' +\n        '<button class=\"clear\" data-action=\"script.clearScriptFormat\" data-show=\"script.canClearScriptFormat\">' +\n          '<span>X</span>' +\n        '</button>' +\n      '</div>' +\n    '</div>' +\n\n    '<div class=\"pp-row\">' +\n      '<label for=\"cam-script-type\">' + translate('Script Type') + '</label>' +\n      '<div class=\"pp-field-wrapper\">' +\n        '<select id=\"cam-script-type\" name=\"scriptType\" data-value>' +\n          '<option value=\"script\" selected>' + translate('Inline Script') + '</option>' +\n          '<option value=\"scriptResource\">' + translate('External Resource') + '</option>' +\n        '</select>' +\n      '</div>' +\n    '</div>' +\n\n    '<div class=\"pp-row pp-textfield\">' +\n      '<label for=\"cam-script-resource-val\" data-show=\"script.isScriptResource\">' + translate('Resource') + '</label>' +\n      '<div class=\"pp-field-wrapper\" data-show=\"script.isScriptResource\">' +\n        '<input id=\"cam-script-resource-val\" type=\"text\" name=\"scriptResourceValue\" />' +\n        '<button class=\"clear\" data-action=\"script.clearScriptResource\" data-show=\"script.canClearScriptResource\">' +\n          '<span>X</span>' +\n        '</button>' +\n      '</div>' +\n    '</div>' +\n\n    '<div class=\"pp-row\">' +\n      '<label for=\"cam-script-val\" data-show=\"script.isScript\">' + translate('Script') + '</label>' +\n      '<div class=\"pp-field-wrapper\" data-show=\"script.isScript\">' +\n        '<textarea id=\"cam-script-val\" type=\"text\" name=\"scriptValue\"></textarea>' +\n      '</div>'+\n    '</div>',\n\n    get: function (element, bo) {\n      var values = {};\n\n      // read values from xml:\n      var boScriptResource = bo.get('jbpm:resource'),\n          boScript = bo.get(scriptValuePropName),\n          boScriptFormat = bo.get(scriptLanguagePropName);\n\n      if (typeof boScriptResource !== 'undefined') {\n        values.scriptResourceValue = boScriptResource;\n        values.scriptType = 'scriptResource';\n      }\n      else {\n        values.scriptValue = boScript;\n        values.scriptType = 'script';\n      }\n\n      values.scriptFormat = boScriptFormat;\n\n      return values;\n    },\n\n    set: function(element, values, containerElement) {\n      var scriptFormat = values.scriptFormat,\n          scriptType = values.scriptType,\n          scriptResourceValue = values.scriptResourceValue,\n          scriptValue = values.scriptValue;\n\n      // init update\n      var update = {\n        \"jbpm:resource\": undefined,\n      };\n      update[scriptValuePropName] = undefined;\n      update[scriptLanguagePropName] = undefined;\n\n      if (isFormatRequired) {\n        // always set language\n        update[scriptLanguagePropName] = scriptFormat || '';\n      } else\n        // set language only when scriptFormat has a value\n        if (scriptFormat !== '') {\n          update[scriptLanguagePropName] = scriptFormat;\n      }\n\n      // set either inline script or resource\n      if('scriptResource' === scriptType) {\n         update['jbpm:resource'] = scriptResourceValue || '';\n      }\n      else {\n         update[scriptValuePropName] = scriptValue || '';\n      }\n\n      return update;\n    },\n\n    validate: function(element, values) {\n      var validationResult = {};\n\n      if (values.scriptType === 'script' && !values.scriptValue) {\n        validationResult.scriptValue = \"Must provide a value\";\n      }\n\n      if (values.scriptType === 'scriptResource' && !values.scriptResourceValue) {\n        validationResult.scriptResourceValue = \"Must provide a value\";\n      }\n\n      if(isFormatRequired && (!values.scriptFormat || values.scriptFormat.length === 0)) {\n        validationResult.scriptFormat = \"Must provide a value\";\n      }\n\n      return validationResult;\n    },\n\n    clearScriptFormat: function(element, inputNode, btnNode, scopeNode) {\n      domQuery('select[name=scriptFormat]', scopeNode).value='';\n\n      return true;\n    },\n\n    canClearScriptFormat: function(element, inputNode, btnNode, scopeNode) {\n      var input = domQuery('select[name=scriptFormat]', scopeNode);\n\n      return input.value !== '';\n    },\n\n    clearScriptResource: function(element, inputNode, btnNode, scopeNode) {\n      domQuery('input[name=scriptResourceValue]', scopeNode).value='';\n\n      return true;\n    },\n\n    canClearScriptResource: function(element, inputNode, btnNode, scopeNode) {\n      var input = domQuery('input[name=scriptResourceValue]', scopeNode);\n\n      return input.value !== '';\n    },\n\n    clearScript: function(element, inputNode, btnNode, scopeNode) {\n      domQuery('textarea[name=scriptValue]', scopeNode).value='';\n\n      return true;\n    },\n\n    canClearScript: function(element, inputNode, btnNode, scopeNode) {\n      var input = domQuery('textarea[name=scriptValue]', scopeNode);\n\n      return input.value !== '';\n    },\n\n    isScriptResource: function(element, inputNode, btnNode, scopeNode) {\n      var scriptType = getScriptType(scopeNode);\n      return scriptType === 'scriptResource';\n    },\n\n    isScript: function(element, inputNode,  btnNode, scopeNode) {\n      var scriptType = getScriptType(scopeNode);\n      return scriptType === 'script';\n    }\n\n  };\n\n};\n","module.exports={\n  \"name\": \"Soupe Workflow BPMN Extension Model for Drools\",\n  \"uri\": \"http://www.jboss.org/drools\",\n  \"prefix\": \"drools\",\n  \"xml\": {\n    \"tagAlias\": \"lowerCase\"\n  },\n  \"associations\": [],\n  \"types\": [\n    {\n      \"name\": \"Global\",\n      \"superClass\": [\n        \"Element\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"identifier\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"type\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Import\",\n      \"superClass\": [\n        \"Element\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        }\n      ]\n    }\n  ]\n}\n\n","module.exports={\n  \"name\": \"Soupe Workflow BPMN Extension Model for jBPM\",\n  \"uri\": \"http://www.jboss.org/jbpm\",\n  \"prefix\": \"jbpm\",\n  \"xml\": {\n    \"tagAlias\": \"lowerCase\"\n  },\n  \"associations\": [],\n  \"types\": [\n    {\n      \"name\": \"Initiator\",\n      \"isAbstract\": true,\n      \"extends\": [ \"bpmn:StartEvent\" ],\n      \"properties\": [\n        {\n          \"name\": \"initiator\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ScriptTask\",\n      \"isAbstract\": true,\n      \"extends\": [\n        \"bpmn:ScriptTask\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"resultVariable\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"resource\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Process\",\n      \"isAbstract\": true,\n      \"extends\": [\n        \"bpmn:Process\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"toDoUrl\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FormalExpression\",\n      \"isAbstract\": true,\n      \"extends\": [\n        \"bpmn:FormalExpression\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"resource\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UserTask\",\n      \"extends\": [ \"bpmn:UserTask\" ],\n      \"properties\": [\n        {\n          \"name\": \"RoleCodes\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"OrganizationLevel\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"Multi-User\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"ActorId\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"Skippable\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"Priority\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"toDoUrl\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallActivity\",\n      \"extends\": [ \"bpmn:CallActivity\" ],\n      \"properties\": [\n        {\n          \"name\": \"calledElementBinding\",\n          \"isAttr\": true,\n          \"type\": \"String\",\n          \"default\": \"latest\"\n        },\n        {\n          \"name\": \"calledElementVersion\",\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        },\n        {\n          \"name\": \"caseRef\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"caseBinding\",\n          \"isAttr\": true,\n          \"type\": \"String\",\n          \"default\": \"latest\"\n        },\n        {\n          \"name\": \"caseVersion\",\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Properties\",\n      \"superClass\": [\n        \"Element\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"values\",\n          \"type\": \"Property\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Property\",\n      \"superClass\": [\n        \"Element\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"name\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"value\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"InputOutput\",\n      \"superClass\": [\n        \"Element\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"inputOutput\",\n          \"type\": \"InputOutput\"\n        },\n        {\n          \"name\": \"connectorId\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"inputParameters\",\n          \"isMany\": true,\n          \"type\": \"InputParameter\"\n        },\n        {\n          \"name\": \"outputParameters\",\n          \"isMany\": true,\n          \"type\": \"OutputParameter\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InputOutputParameter\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"value\",\n          \"isBody\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"definition\",\n          \"type\": \"InputOutputParameterDefinition\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InputOutputParameterDefinition\",\n      \"isAbstract\": true\n    },\n    {\n      \"name\": \"List\",\n      \"superClass\": [ \"InputOutputParameterDefinition\" ],\n      \"properties\": [\n        {\n          \"name\": \"items\",\n          \"isMany\": true,\n          \"type\": \"InputOutputParameterDefinition\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Map\",\n      \"superClass\": [ \"InputOutputParameterDefinition\" ],\n      \"properties\": [\n        {\n          \"name\": \"entries\",\n          \"isMany\": true,\n          \"type\": \"Entry\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Entry\",\n      \"properties\": [\n        {\n          \"name\": \"key\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"value\",\n          \"isBody\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"definition\",\n          \"type\": \"InputOutputParameterDefinition\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Value\",\n      \"superClass\": [\n        \"InputOutputParameterDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"value\",\n          \"isBody\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Script\",\n      \"superClass\": [ \"InputOutputParameterDefinition\" ],\n      \"properties\": [\n        {\n          \"name\": \"scriptFormat\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"resource\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"value\",\n          \"isBody\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InputParameter\",\n      \"superClass\": [ \"InputOutputParameter\" ]\n    },\n    {\n      \"name\": \"OutputParameter\",\n      \"superClass\": [ \"InputOutputParameter\" ]\n    }\n  ],\n  \"emumerations\": [ ]\n}","'use strict';\n\nvar inherits = require(368);\n\nvar Ids = require(366);\n\nvar Viewer = require(75);\n\nvar NavigatedViewer = require(74);\n\nvar initialDiagram =\n  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n  '<bpmn:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' +\n                    'xmlns:bpmn=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" ' +\n                    'xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" ' +\n                    'xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" ' +\n                    'targetNamespace=\"http://bpmn.io/schema/bpmn\" ' +\n                    'id=\"Definitions_1\">' +\n    '<bpmn:process id=\"Process_1\" isExecutable=\"false\">' +\n      '<bpmn:startEvent id=\"StartEvent_1\"/>' +\n    '</bpmn:process>' +\n    '<bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">' +\n      '<bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">' +\n        '<bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">' +\n          '<dc:Bounds height=\"36.0\" width=\"36.0\" x=\"173.0\" y=\"102.0\"/>' +\n        '</bpmndi:BPMNShape>' +\n      '</bpmndi:BPMNPlane>' +\n    '</bpmndi:BPMNDiagram>' +\n  '</bpmn:definitions>';\n\n\n/**\n * A modeler for BPMN 2.0 diagrams.\n *\n *\n * ## Extending the Modeler\n *\n * In order to extend the viewer pass extension modules to bootstrap via the\n * `additionalModules` option. An extension module is an object that exposes\n * named services.\n *\n * The following example depicts the integration of a simple\n * logging component that integrates with interaction events:\n *\n *\n * ```javascript\n *\n * // logging component\n * function InteractionLogger(eventBus) {\n *   eventBus.on('element.hover', function(event) {\n *     console.log()\n *   })\n * }\n *\n * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\n *\n * // extension module\n * var extensionModule = {\n *   __init__: [ 'interactionLogger' ],\n *   interactionLogger: [ 'type', InteractionLogger ]\n * };\n *\n * // extend the viewer\n * var bpmnModeler = new Modeler({ additionalModules: [ extensionModule ] });\n * bpmnModeler.importXML(...);\n * ```\n *\n *\n * ## Customizing / Replacing Components\n *\n * You can replace individual diagram components by redefining them in override modules.\n * This works for all components, including those defined in the core.\n *\n * Pass in override modules via the `options.additionalModules` flag like this:\n *\n * ```javascript\n * function CustomContextPadProvider(contextPad) {\n *\n *   contextPad.registerProvider(this);\n *\n *   this.getContextPadEntries = function(element) {\n *     // no entries, effectively disable the context pad\n *     return {};\n *   };\n * }\n *\n * CustomContextPadProvider.$inject = [ 'contextPad' ];\n *\n * var overrideModule = {\n *   contextPadProvider: [ 'type', CustomContextPadProvider ]\n * };\n *\n * var bpmnModeler = new Modeler({ additionalModules: [ overrideModule ]});\n * ```\n *\n * @param {Object} [options] configuration options to pass to the viewer\n * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\n * @param {String|Number} [options.width] the width of the viewer\n * @param {String|Number} [options.height] the height of the viewer\n * @param {Object} [options.moddleExtensions] extension packages to provide\n * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\n * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\n */\nfunction Modeler(options) {\n  Viewer.call(this, options);\n\n  // hook ID collection into the modeler\n  this.on('import.parse.complete', function(event) {\n    if (!event.error) {\n      this._collectIds(event.definitions, event.context);\n    }\n  }, this);\n\n  this.on('diagram.destroy', function() {\n    this.moddle.ids.clear();\n  }, this);\n}\n\ninherits(Modeler, Viewer);\n\nmodule.exports = Modeler;\n\nmodule.exports.Viewer = Viewer;\n\nmodule.exports.NavigatedViewer = NavigatedViewer;\n\n/**\n * Create a new diagram to start modeling.\n *\n * @param {Function} [done]\n */\nModeler.prototype.createDiagram = function(done) {\n  return this.importXML(initialDiagram, done);\n};\n\n/**\n * Create a moddle instance, attaching ids to it.\n *\n * @param {Object} options\n */\nModeler.prototype._createModdle = function(options) {\n  var moddle = Viewer.prototype._createModdle.call(this, options);\n\n  // attach ids to moddle to be able to track\n  // and validated ids in the BPMN 2.0 XML document\n  // tree\n  moddle.ids = new Ids([ 32, 36, 1 ]);\n\n  return moddle;\n};\n\n/**\n * Collect ids processed during parsing of the\n * definitions object.\n *\n * @param {ModdleElement} definitions\n * @param {Context} context\n */\nModeler.prototype._collectIds = function(definitions, context) {\n\n  var moddle = definitions.$model,\n      ids = moddle.ids,\n      id;\n\n  // remove references from previous import\n  ids.clear();\n\n  for (id in context.elementsById) {\n    ids.claim(id, context.elementsById[id]);\n  }\n};\n\n\nModeler.prototype._interactionModules = [\n  // non-modeling components\n  require(333),\n  require(334),\n  require(337)\n];\n\nModeler.prototype._modelingModules = [\n  // modeling components\n  require(216),\n  require(222),\n  require(283),\n  require(301),\n  require(82),\n  require(90),\n  require(84),\n  require(94),\n  require(99),\n  require(138),\n  require(144),\n  require(149),\n  require(159)\n];\n\n\n// modules the modeler is composed of\n//\n// - viewer modules\n// - interaction modules\n// - modeling modules\n\nModeler.prototype._modules = [].concat(\n  Modeler.prototype._modules,\n  Modeler.prototype._interactionModules,\n  Modeler.prototype._modelingModules);\n","'use strict';\n\nvar inherits = require(368);\n\nvar Viewer = require(75);\n\n\n/**\n * A viewer that includes mouse navigation facilities\n *\n * @param {Object} options\n */\nfunction NavigatedViewer(options) {\n  Viewer.call(this, options);\n}\n\ninherits(NavigatedViewer, Viewer);\n\nmodule.exports = NavigatedViewer;\n\nNavigatedViewer.prototype._navigationModules = [\n  require(337),\n  require(333)\n];\n\nNavigatedViewer.prototype._modules = [].concat(\n  NavigatedViewer.prototype._modules,\n  NavigatedViewer.prototype._navigationModules);","/**\n * The code in the <project-logo></project-logo> area\n * must not be changed.\n *\n * @see http://bpmn.io/license for more information.\n */\n'use strict';\n\nvar assign = require(516),\n    omit = require(522),\n    isNumber = require(510);\n\nvar domify = require(535),\n    domQuery = require(538),\n    domRemove = require(539);\n\nvar innerSVG = require(585);\n\nvar Diagram = require(194),\n    BpmnModdle = require(171);\n\n\nvar inherits = require(368);\n\nvar Importer = require(162);\n\n\nfunction checkValidationError(err) {\n\n  // check if we can help the user by indicating wrong BPMN 2.0 xml\n  // (in case he or the exporting tool did not get that right)\n\n  var pattern = /unparsable content <([^>]+)> detected([/s/S]*)$/;\n  var match = pattern.exec(err.message);\n\n  if (match) {\n    err.message =\n      'unparsable content <' + match[1] + '> detected; ' +\n      'this may indicate an invalid BPMN 2.0 diagram file' + match[2];\n  }\n\n  return err;\n}\n\nvar DEFAULT_OPTIONS = {\n  width: '100%',\n  height: '100%',\n  position: 'relative'\n};\n\n\n/**\n * Ensure the passed argument is a proper unit (defaulting to px)\n */\nfunction ensureUnit(val) {\n  return val + (isNumber(val) ? 'px' : '');\n}\n\n/**\n * A viewer for BPMN 2.0 diagrams.\n *\n * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include\n * additional features.\n *\n *\n * ## Extending the Viewer\n *\n * In order to extend the viewer pass extension modules to bootstrap via the\n * `additionalModules` option. An extension module is an object that exposes\n * named services.\n *\n * The following example depicts the integration of a simple\n * logging component that integrates with interaction events:\n *\n *\n * ```javascript\n *\n * // logging component\n * function InteractionLogger(eventBus) {\n *   eventBus.on('element.hover', function(event) {\n *     console.log()\n *   })\n * }\n *\n * InteractionLogger.$inject = [ 'eventBus' ]; // minification save\n *\n * // extension module\n * var extensionModule = {\n *   __init__: [ 'interactionLogger' ],\n *   interactionLogger: [ 'type', InteractionLogger ]\n * };\n *\n * // extend the viewer\n * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });\n * bpmnViewer.importXML(...);\n * ```\n *\n * @param {Object} [options] configuration options to pass to the viewer\n * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\n * @param {String|Number} [options.width] the width of the viewer\n * @param {String|Number} [options.height] the height of the viewer\n * @param {Object} [options.moddleExtensions] extension packages to provide\n * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\n * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\n */\nfunction Viewer(options) {\n\n  options = assign({}, DEFAULT_OPTIONS, options);\n\n  this.moddle = this._createModdle(options);\n\n  this.container = this._createContainer(options);\n\n  /* <project-logo> */\n\n  addProjectLogo(this.container);\n\n  /* </project-logo> */\n\n  this._init(this.container, this.moddle, options);\n}\n\ninherits(Viewer, Diagram);\n\nmodule.exports = Viewer;\n\n\n/**\n * Parse and render a BPMN 2.0 diagram.\n *\n * Once finished the viewer reports back the result to the\n * provided callback function with (err, warnings).\n *\n * ## Life-Cycle Events\n *\n * During import the viewer will fire life-cycle events:\n *\n *   * import.parse.start (about to read model from xml)\n *   * import.parse.complete (model read; may have worked or not)\n *   * import.render.start (graphical import start)\n *   * import.render.complete (graphical import finished)\n *   * import.done (everything done)\n *\n * You can use these events to hook into the life-cycle.\n *\n * @param {String} xml the BPMN 2.0 xml\n * @param {Function} [done] invoked with (err, warnings=[])\n */\nViewer.prototype.importXML = function(xml, done) {\n\n  // done is optional\n  done = done || function() {};\n\n  var self = this;\n\n  // hook in pre-parse listeners +\n  // allow xml manipulation\n  xml = this._emit('import.parse.start', { xml: xml }) || xml;\n\n  this.moddle.fromXML(xml, 'bpmn:Definitions', function(err, definitions, context) {\n\n    // hook in post parse listeners +\n    // allow definitions manipulation\n    definitions = self._emit('import.parse.complete', {\n      error: err,\n      definitions: definitions,\n      context: context\n    }) || definitions;\n\n    if (err) {\n      err = checkValidationError(err);\n\n      self._emit('import.done', { error: err });\n\n      return done(err);\n    }\n\n    var parseWarnings = context.warnings;\n\n    self.importDefinitions(definitions, function(err, importWarnings) {\n      var allWarnings = [].concat(parseWarnings, importWarnings || []);\n\n      self._emit('import.done', { error: err, warnings: allWarnings });\n\n      done(err, allWarnings);\n    });\n  });\n};\n\n/**\n * Export the currently displayed BPMN 2.0 diagram as\n * a BPMN 2.0 XML document.\n *\n * @param {Object} [options] export options\n * @param {Boolean} [options.format=false] output formated XML\n * @param {Boolean} [options.preamble=true] output preamble\n *\n * @param {Function} done invoked with (err, xml)\n */\nViewer.prototype.saveXML = function(options, done) {\n\n  if (!done) {\n    done = options;\n    options = {};\n  }\n\n  var definitions = this.definitions;\n\n  if (!definitions) {\n    return done(new Error('no definitions loaded'));\n  }\n\n  this.moddle.toXML(definitions, options, done);\n};\n\n/**\n * Export the currently displayed BPMN 2.0 diagram as\n * an SVG image.\n *\n * @param {Object} [options]\n * @param {Function} done invoked with (err, svgStr)\n */\nViewer.prototype.saveSVG = function(options, done) {\n\n  if (!done) {\n    done = options;\n    options = {};\n  }\n\n  var canvas = this.get('canvas');\n\n  var contentNode = canvas.getDefaultLayer(),\n      defsNode = domQuery('defs', canvas._svg);\n\n  var contents = innerSVG(contentNode),\n      defs = defsNode ? '<defs>' + innerSVG(defsNode) + '</defs>' : '';\n\n  var bbox = contentNode.getBBox();\n\n  var svg =\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>/n' +\n    '<!-- created with bpmn-js / http://bpmn.io -->/n' +\n    '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">/n' +\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n         'width=\"' + bbox.width + '\" height=\"' + bbox.height + '\" ' +\n         'viewBox=\"' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '\" version=\"1.1\">' +\n      defs + contents +\n    '</svg>';\n\n  done(null, svg);\n};\n\n/**\n * Get a named diagram service.\n *\n * @example\n *\n * var elementRegistry = viewer.get('elementRegistry');\n * var startEventShape = elementRegistry.get('StartEvent_1');\n *\n * @param {String} name\n *\n * @return {Object} diagram service instance\n *\n * @method Viewer#get\n */\n\n/**\n * Invoke a function in the context of this viewer.\n *\n * @example\n *\n * viewer.invoke(function(elementRegistry) {\n *   var startEventShape = elementRegistry.get('StartEvent_1');\n * });\n *\n * @param {Function} fn to be invoked\n *\n * @return {Object} the functions return value\n *\n * @method Viewer#invoke\n */\n\n/**\n * Remove all drawn elements from the viewer.\n *\n * After calling this method the viewer can still\n * be reused for opening another diagram.\n *\n * @method Viewer#clear\n */\n\nViewer.prototype.importDefinitions = function(definitions, done) {\n\n  // use try/catch to not swallow synchronous exceptions\n  // that may be raised during model parsing\n  try {\n\n    if (this.definitions) {\n      // clear existing rendered diagram\n      this.clear();\n    }\n\n    // update definitions\n    this.definitions = definitions;\n\n    // perform graphical import\n    Importer.importBpmnDiagram(this, definitions, done);\n  } catch (e) {\n\n    // handle synchronous errors\n    done(e);\n  }\n};\n\nViewer.prototype.getModules = function() {\n  return this._modules;\n};\n\n/**\n * Destroy the viewer instance and remove all its\n * remainders from the document tree.\n */\nViewer.prototype.destroy = function() {\n\n  // diagram destroy\n  Diagram.prototype.destroy.call(this);\n\n  // dom detach\n  domRemove(this.container);\n};\n\n/**\n * Register an event listener\n *\n * Remove a previously added listener via {@link #off(event, callback)}.\n *\n * @param {String} event\n * @param {Number} [priority]\n * @param {Function} callback\n * @param {Object} [that]\n */\nViewer.prototype.on = function(event, priority, callback, target) {\n  return this.get('eventBus').on(event, priority, callback, target);\n};\n\n/**\n * De-register an event listener\n *\n * @param {String} event\n * @param {Function} callback\n */\nViewer.prototype.off = function(event, callback) {\n  this.get('eventBus').off(event, callback);\n};\n\nViewer.prototype.attachTo = function(parentNode) {\n\n  if (!parentNode) {\n    throw new Error('parentNode required');\n  }\n\n  // ensure we detach from the\n  // previous, old parent\n  this.detach();\n\n  // unwrap jQuery if provided\n  if (parentNode.get && parentNode.constructor.prototype.jquery) {\n    parentNode = parentNode.get(0);\n  }\n\n  if (typeof parentNode === 'string') {\n    parentNode = domQuery(parentNode);\n  }\n\n  var container = this._container;\n\n  parentNode.appendChild(container);\n\n  this._emit('attach', {});\n};\n\nViewer.prototype.detach = function() {\n\n  var container = this._container,\n      parentNode = container.parentNode;\n\n  if (!parentNode) {\n    return;\n  }\n\n  this._emit('detach', {});\n\n  parentNode.removeChild(container);\n};\n\nViewer.prototype._init = function(container, moddle, options) {\n\n  this._container = container;\n  var baseModules = options.modules || this.getModules(),\n      additionalModules = options.additionalModules || [],\n      staticModules = [\n        {\n          bpmnjs: [ 'value', this ],\n          moddle: [ 'value', moddle ]\n        }\n      ];\n\n  var diagramModules = [].concat(staticModules, baseModules, additionalModules);\n\n  var diagramOptions = assign(omit(options, 'additionalModules'), {\n    canvas: assign({}, options.canvas, { container: container }),\n    modules: diagramModules\n  });\n\n  // invoke diagram constructor\n  Diagram.call(this, diagramOptions);\n\n  if (options && options.container) {\n    this.attachTo(options.container);\n  }\n};\n\n/**\n * Emit an event on the underlying {@link EventBus}\n *\n * @param  {String} type\n * @param  {Object} event\n *\n * @return {Object} event processing result (if any)\n */\nViewer.prototype._emit = function(type, event) {\n  return this.get('eventBus').fire(type, event);\n};\n\nViewer.prototype._createContainer = function(options) {\n\n  var container = domify('<div class=\"bjs-container\"></div>');\n\n  assign(container.style, {\n    width: ensureUnit(options.width),\n    height: ensureUnit(options.height),\n    position: options.position\n  });\n\n  return container;\n};\n\nViewer.prototype._createModdle = function(options) {\n  var moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);\n\n  return new BpmnModdle(moddleOptions);\n};\n\n\n// modules the viewer is composed of\nViewer.prototype._modules = [\n  require(76),\n  require(325),\n  require(310),\n  require(288)\n];\n\n// default moddle extensions the viewer is composed of\nViewer.prototype._moddleExtensions = {};\n\n/* <project-logo> */\n\nvar PoweredBy = require(168),\n    domEvent = require(536);\n\n/**\n * Adds the project logo to the diagram container as\n * required by the bpmn.io license.\n *\n * @see http://bpmn.io/license\n *\n * @param {Element} container\n */\nfunction addProjectLogo(container) {\n  var logoData = PoweredBy.BPMNIO_LOGO;\n\n  var linkMarkup =\n    '<a href=\"http://bpmn.io\" ' +\n       'target=\"_blank\" ' +\n       'class=\"bjs-powered-by\" ' +\n       'title=\"Powered by bpmn.io\" ' +\n       'style=\"position: absolute; bottom: 15px; right: 15px; z-index: 100\">' +\n        '<img src=\"data:image/png;base64,' + logoData + '\">' +\n    '</a>';\n\n  var linkElement = domify(linkMarkup);\n\n  container.appendChild(linkElement);\n\n  domEvent.bind(linkElement, 'click', function(event) {\n    PoweredBy.open();\n\n    event.preventDefault();\n  });\n}\n\n/* </project-logo> */\n","module.exports = {\n  __depends__: [\n    require(79),\n    require(164)\n  ]\n};","'use strict';\n\nvar inherits = require(368),\n    isObject = require(511),\n    assign = require(516),\n    forEach = require(386),\n    every = require(383),\n    some = require(393);\n\nvar BaseRenderer = require(205),\n    TextUtil = require(357),\n    DiUtil = require(165);\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is;\n\nvar RenderUtil = require(355);\n\nvar componentsToPath = RenderUtil.componentsToPath,\n    createLine = RenderUtil.createLine;\n\nvar domQuery = require(538);\n\nvar svgAppend = require(577),\n    svgAttr = require(579),\n    svgCreate = require(583),\n    svgClasses = require(580);\n\nvar rotate = require(356).rotate,\n    transform = require(356).transform,\n    translate = require(356).translate;\n\nvar Ids = require(366),\n    RENDERER_IDS = new Ids();\n\nvar TASK_BORDER_RADIUS = 10;\nvar INNER_OUTER_DIST = 3;\n\nvar LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: 12\n};\n\n\nfunction BpmnRenderer(eventBus, styles, pathMap, canvas, priority) {\n\n  BaseRenderer.call(this, eventBus, priority);\n\n  var rendererId = RENDERER_IDS.next();\n\n  var textUtil = new TextUtil({\n    style: LABEL_STYLE,\n    size: { width: 100 }\n  });\n\n  var markers = {};\n\n  var computeStyle = styles.computeStyle;\n\n  function addMarker(id, options) {\n    var attrs = assign({\n      fill: 'black',\n      strokeWidth: 1,\n      strokeLinecap: 'round',\n      strokeDasharray: 'none'\n    }, options.attrs);\n\n    var ref = options.ref || { x: 0, y: 0 };\n\n    var scale = options.scale || 1;\n\n    // fix for safari / chrome / firefox bug not correctly\n    // resetting stroke dash array\n    if (attrs.strokeDasharray === 'none') {\n      attrs.strokeDasharray = [10000, 1];\n    }\n\n    var marker = svgCreate('marker');\n\n    svgAttr(options.element, attrs);\n\n    svgAppend(marker, options.element);\n\n    svgAttr(marker, {\n      id: id,\n      viewBox: '0 0 20 20',\n      refX: ref.x,\n      refY: ref.y,\n      markerWidth: 20 * scale,\n      markerHeight: 20 * scale,\n      orient: 'auto'\n    });\n\n    var defs = domQuery('defs', canvas._svg);\n\n    if (!defs) {\n      defs = svgCreate('defs');\n\n      svgAppend(canvas._svg, defs);\n    }\n\n    svgAppend(defs, marker);\n\n    markers[id] = marker;\n  }\n\n  function marker(type, fill, stroke) {\n    var id = type + '-' + fill + '-' + stroke + '-' + rendererId;\n\n    if (!markers[id]) {\n      createMarker(type, fill, stroke);\n    }\n\n    return 'url(#' + id +  ')';\n  }\n\n  function createMarker(type, fill, stroke) {\n    var id = type + '-' + fill + '-' + stroke + '-' + rendererId;\n\n    if (type === 'sequenceflow-end') {\n      var sequenceflowEnd = svgCreate('path');\n      svgAttr(sequenceflowEnd, { d: 'M 1 5 L 11 10 L 1 15 Z' });\n\n      addMarker(id, {\n        element: sequenceflowEnd,\n        ref: { x: 11, y: 10 },\n        scale: 0.5,\n        attrs: {\n          fill: stroke,\n          stroke: stroke\n        }\n      });\n    }\n\n    if (type === 'messageflow-start') {\n      var messageflowStart = svgCreate('circle');\n      svgAttr(messageflowStart, { cx: 6, cy: 6, r: 3.5 });\n\n      addMarker(id, {\n        element: messageflowStart,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: { x: 6, y: 6 }\n      });\n    }\n\n    if (type === 'messageflow-end') {\n      var messageflowEnd = svgCreate('path');\n      svgAttr(messageflowEnd, { d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z' });\n\n      addMarker(id, {\n        element: messageflowEnd,\n        attrs: {\n          fill: fill,\n          stroke: stroke,\n          strokeLinecap: 'butt'\n        },\n        ref: { x: 8.5, y: 5 }\n      });\n    }\n\n    if (type === 'association-start') {\n      var associationStart = svgCreate('path');\n      svgAttr(associationStart, { d: 'M 11 5 L 1 10 L 11 15' });\n\n      addMarker(id, {\n        element: associationStart,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: { x: 1, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'association-end') {\n      var associationEnd = svgCreate('path');\n      svgAttr(associationEnd, { d: 'M 1 5 L 11 10 L 1 15' });\n\n      addMarker(id, {\n        element: associationEnd,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: { x: 12, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'conditional-flow-marker') {\n      var conditionalflowMarker = svgCreate('path');\n      svgAttr(conditionalflowMarker, { d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z' });\n\n      addMarker(id, {\n        element: conditionalflowMarker,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: { x: -1, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'conditional-default-flow-marker') {\n      var conditionaldefaultflowMarker = svgCreate('path');\n      svgAttr(conditionaldefaultflowMarker, { d: 'M 6 4 L 10 16' });\n\n      addMarker(id, {\n        element: conditionaldefaultflowMarker,\n        attrs: {\n          stroke: stroke\n        },\n        ref: { x: 0, y: 10 },\n        scale: 0.5\n      });\n    }\n  }\n\n  function drawCircle(parentGfx, width, height, offset, attrs) {\n\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n\n    offset = offset || 0;\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var cx = width / 2,\n        cy = height / 2;\n\n    var circle = svgCreate('circle');\n    svgAttr(circle, {\n      cx: cx,\n      cy: cy,\n      r: Math.round((width + height) / 4 - offset)\n    });\n    svgAttr(circle, attrs);\n\n    svgAppend(parentGfx, circle);\n\n    return circle;\n  }\n\n  function drawRect(parentGfx, width, height, r, offset, attrs) {\n\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n\n    offset = offset || 0;\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var rect = svgCreate('rect');\n    svgAttr(rect, {\n      x: offset,\n      y: offset,\n      width: width - offset * 2,\n      height: height - offset * 2,\n      rx: r,\n      ry: r\n    });\n    svgAttr(rect, attrs);\n\n    svgAppend(parentGfx, rect);\n\n    return rect;\n  }\n\n  function drawDiamond(parentGfx, width, height, attrs) {\n\n    var x_2 = width / 2;\n    var y_2 = height / 2;\n\n    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];\n\n    var pointsString = points.map(function(point) {\n      return point.x + ',' + point.y;\n    }).join(' ');\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var polygon = svgCreate('polygon');\n    svgAttr(polygon, {\n      points: pointsString\n    });\n    svgAttr(polygon, attrs);\n\n    svgAppend(parentGfx, polygon);\n\n    return polygon;\n  }\n\n  function drawLine(parentGfx, waypoints, attrs) {\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'none'\n    });\n\n    var line = createLine(waypoints, attrs);\n\n    svgAppend(parentGfx, line);\n\n    return line;\n  }\n\n  function drawPath(parentGfx, d, attrs) {\n\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\n      strokeWidth: 2,\n      stroke: 'black'\n    });\n\n    var path = svgCreate('path');\n    svgAttr(path, { d: d });\n    svgAttr(path, attrs);\n\n    svgAppend(parentGfx, path);\n\n    return path;\n  }\n\n  function drawMarker(type, parentGfx, path, attrs) {\n    return drawPath(parentGfx, path, assign({ 'data-marker': type }, attrs));\n  }\n\n  function as(type) {\n    return function(parentGfx, element) {\n      return handlers[type](parentGfx, element);\n    };\n  }\n\n  function renderer(type) {\n    return handlers[type];\n  }\n\n  function renderEventContent(element, parentGfx) {\n\n    var event = getSemantic(element);\n    var isThrowing = isThrowEvent(event);\n\n    if (isTypedEvent(event, 'bpmn:MessageEventDefinition')) {\n      return renderer('bpmn:MessageEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:TimerEventDefinition')) {\n      return renderer('bpmn:TimerEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:ConditionalEventDefinition')) {\n      return renderer('bpmn:ConditionalEventDefinition')(parentGfx, element);\n    }\n\n    if (isTypedEvent(event, 'bpmn:SignalEventDefinition')) {\n      return renderer('bpmn:SignalEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&\n      isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: false })) {\n      return renderer('bpmn:MultipleEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&\n      isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: true })) {\n      return renderer('bpmn:ParallelMultipleEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:EscalationEventDefinition')) {\n      return renderer('bpmn:EscalationEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:LinkEventDefinition')) {\n      return renderer('bpmn:LinkEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:ErrorEventDefinition')) {\n      return renderer('bpmn:ErrorEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition')) {\n      return renderer('bpmn:CancelEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CompensateEventDefinition')) {\n      return renderer('bpmn:CompensateEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:TerminateEventDefinition')) {\n      return renderer('bpmn:TerminateEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    return null;\n  }\n\n  function renderLabel(parentGfx, label, options) {\n    var text = textUtil.createText(label || '', options);\n    svgClasses(text).add('djs-label');\n    svgAppend(parentGfx, text);\n\n    return text;\n  }\n\n  function renderEmbeddedLabel(parentGfx, element, align) {\n    var semantic = getSemantic(element);\n\n    return renderLabel(parentGfx, semantic.name, {\n      box: element,\n      align: align,\n      padding: 5,\n      style: {\n        fill: getStrokeColor(element)\n      }\n    });\n  }\n\n  function renderExternalLabel(parentGfx, element) {\n    var semantic = getSemantic(element);\n    var box = {\n      width: 90,\n      height: 30,\n      x: element.width / 2 + element.x,\n      y: element.height / 2 + element.y\n    };\n\n    return renderLabel(parentGfx, semantic.name, {\n      box: box,\n      fitBox: true,\n      style: { fontSize: '11px' }\n    });\n  }\n\n  function renderLaneLabel(parentGfx, text, element) {\n    var textBox = renderLabel(parentGfx, text, {\n      box: { height: 30, width: element.height },\n      align: 'center-middle',\n      style: {\n        fill: getStrokeColor(element)\n      }\n    });\n\n    var top = -1 * element.height;\n\n    transform(textBox, 0, -top, 270);\n  }\n\n  function createPathFromConnection(connection) {\n    var waypoints = connection.waypoints;\n\n    var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;\n    for (var i = 1; i < waypoints.length; i++) {\n      pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';\n    }\n    return pathData;\n  }\n\n  var handlers = this.handlers = {\n    'bpmn:Event': function(parentGfx, element, attrs) {\n      return drawCircle(parentGfx, element.width, element.height, attrs);\n    },\n    'bpmn:StartEvent': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var semantic = getSemantic(element);\n\n      if (!semantic.isInterrupting) {\n        attrs = {\n          strokeDasharray: '6',\n          strokeLinecap: 'round'\n        };\n      }\n\n      var circle = renderer('bpmn:Event')(parentGfx, element, attrs);\n\n      renderEventContent(element, parentGfx);\n\n      return circle;\n    },\n    'bpmn:MessageEventDefinition': function(parentGfx, element, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.235,\n          my: 0.315\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(element) : getFillColor(element);\n      var stroke = isThrowing ? getFillColor(element) : getStrokeColor(element);\n\n      var messagePath = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: stroke\n      });\n\n      return messagePath;\n    },\n    'bpmn:TimerEventDefinition': function(parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {\n        strokeWidth: 2,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {\n        xScaleFactor: 0.75,\n        yScaleFactor: 0.75,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.5,\n          my: 0.5\n        }\n      });\n\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 2,\n        strokeLinecap: 'square',\n        stroke: getStrokeColor(element)\n      });\n\n      for (var i = 0;i < 12;i++) {\n\n        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {\n          xScaleFactor: 0.75,\n          yScaleFactor: 0.75,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.5,\n            my: 0.5\n          }\n        });\n\n        var width = element.width / 2;\n        var height = element.height / 2;\n\n        drawPath(parentGfx, linePathData, {\n          strokeWidth: 1,\n          strokeLinecap: 'square',\n          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')',\n          stroke: getStrokeColor(element)\n        });\n      }\n\n      return circle;\n    },\n    'bpmn:EscalationEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:ConditionalEventDefinition': function(parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.222\n        }\n      });\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:LinkEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_LINK', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.57,\n          my: 0.263\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:ErrorEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ERROR', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.2,\n          my: 0.722\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:CancelEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {\n        xScaleFactor: 1.0,\n        yScaleFactor: 1.0,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.638,\n          my: -0.055\n        }\n      });\n\n      var fill = isThrowing ? 'black' : 'none';\n\n      var path = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill\n      });\n\n      rotate(path, 45);\n\n      return path;\n    },\n    'bpmn:CompensateEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.22,\n          my: 0.5\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:SignalEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:MultipleEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.222,\n          my: 0.36\n        }\n      });\n\n      var fill = isThrowing ? 'black' : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill\n      });\n    },\n    'bpmn:ParallelMultipleEventDefinition': function(parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {\n        xScaleFactor: 1.2,\n        yScaleFactor: 1.2,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.458,\n          my: 0.194\n        }\n      });\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(event),\n        stroke: getStrokeColor(event)\n      });\n    },\n    'bpmn:EndEvent': function(parentGfx, element) {\n      var circle = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 4,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      renderEventContent(element, parentGfx, true);\n\n      return circle;\n    },\n    'bpmn:TerminateEventDefinition': function(parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 8, {\n        strokeWidth: 4,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return circle;\n    },\n    'bpmn:IntermediateEvent': function(parentGfx, element) {\n      var outer = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      /* inner */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {\n        strokeWidth: 1,\n        fill: getFillColor(element, 'none'),\n        stroke: getStrokeColor(element)\n      });\n\n      renderEventContent(element, parentGfx);\n\n      return outer;\n    },\n    'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),\n    'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),\n\n    'bpmn:Activity': function(parentGfx, element, attrs) {\n      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);\n    },\n\n    'bpmn:Task': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n\n      renderEmbeddedLabel(parentGfx, element, 'center-middle');\n      attachTaskMarkers(parentGfx, element);\n\n      return rect;\n    },\n    'bpmn:ServiceTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 12,\n          y: 18\n        }\n      });\n\n      /* service bg */ drawPath(parentGfx, pathDataBG, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {\n        abspos: {\n          x: 17.2,\n          y: 18\n        }\n      });\n\n      /* service fill */ drawPath(parentGfx, fillPathData, {\n        strokeWidth: 0,\n        fill: getFillColor(element)\n      });\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 17,\n          y: 22\n        }\n      });\n\n      /* service */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:UserTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var x = 15;\n      var y = 12;\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user2 path */ drawPath(parentGfx, pathData2, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user3 path */ drawPath(parentGfx, pathData3, {\n        strokeWidth: 0.5,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:ManualTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {\n        abspos: {\n          x: 17,\n          y: 15\n        }\n      });\n\n      /* manual path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5, // 0.25,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:SendTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: 21,\n        containerHeight: 14,\n        position: {\n          mx: 0.285,\n          my: 0.357\n        }\n      });\n\n      /* send path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element),\n        stroke: getFillColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:ReceiveTask' : function(parentGfx, element) {\n      var semantic = getSemantic(element);\n\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData;\n\n      if (semantic.instantiate) {\n        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });\n\n        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {\n          abspos: {\n            x: 7.77,\n            y: 9.52\n          }\n        });\n      } else {\n\n        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n          xScaleFactor: 0.9,\n          yScaleFactor: 0.9,\n          containerWidth: 21,\n          containerHeight: 14,\n          position: {\n            mx: 0.3,\n            my: 0.4\n          }\n        });\n      }\n\n      /* receive path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:ScriptTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {\n        abspos: {\n          x: 15,\n          y: 20\n        }\n      });\n\n      /* script path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:BusinessRuleTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n\n      var businessHeaderPath = drawPath(parentGfx, headerPathData);\n      svgAttr(businessHeaderPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, '#aaaaaa'),\n        stroke: getStrokeColor(element)\n      });\n\n      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n\n      var businessPath = drawPath(parentGfx, headerData);\n      svgAttr(businessPath, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element)\n      });\n\n      return task;\n    },\n    'bpmn:SubProcess': function(parentGfx, element, attrs) {\n      attrs = assign({\n        fillOpacity: 0.95,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      }, attrs);\n\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n\n      var expanded = DiUtil.isExpanded(element);\n\n      var isEventSubProcess = DiUtil.isEventSubProcess(element);\n\n      if (isEventSubProcess) {\n        svgAttr(rect, {\n          strokeDasharray: '1,2'\n        });\n      }\n\n      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle');\n\n      if (expanded) {\n        attachTaskMarkers(parentGfx, element);\n      } else {\n        attachTaskMarkers(parentGfx, element, ['SubProcessMarker']);\n      }\n\n      return rect;\n    },\n    'bpmn:AdHocSubProcess': function(parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element);\n    },\n    'bpmn:Transaction': function(parentGfx, element) {\n      var outer = renderer('bpmn:SubProcess')(parentGfx, element);\n\n      var innerAttrs = styles.style([ 'no-fill', 'no-events' ], {\n        stroke: getStrokeColor(element)\n      });\n\n      /* inner path */ drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);\n\n      return outer;\n    },\n    'bpmn:CallActivity': function(parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element, {\n        strokeWidth: 5\n      });\n    },\n    'bpmn:Participant': function(parentGfx, element) {\n\n      var attrs = {\n        fillOpacity: 0.95,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var lane = renderer('bpmn:Lane')(parentGfx, element, attrs);\n\n      var expandedPool = DiUtil.isExpanded(element);\n\n      if (expandedPool) {\n        drawLine(parentGfx, [\n          { x: 30, y: 0 },\n          { x: 30, y: element.height }\n        ], {\n          stroke: getStrokeColor(element)\n        });\n        var text = getSemantic(element).name;\n        renderLaneLabel(parentGfx, text, element);\n      } else {\n        // Collapsed pool draw text inline\n        var text2 = getSemantic(element).name;\n        renderLabel(parentGfx, text2, {\n          box: element, align: 'center-middle',\n          style: {\n            fill: getStrokeColor(element)\n          }\n        });\n      }\n\n      var participantMultiplicity = !!(getSemantic(element).participantMultiplicity);\n\n      if (participantMultiplicity) {\n        renderer('ParticipantMultiplicityMarker')(parentGfx, element);\n      }\n\n      return lane;\n    },\n    'bpmn:Lane': function(parentGfx, element, attrs) {\n      var rect = drawRect(parentGfx, element.width, element.height, 0, assign({\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      }, attrs));\n\n      var semantic = getSemantic(element);\n\n      if (semantic.$type === 'bpmn:Lane') {\n        var text = semantic.name;\n        renderLaneLabel(parentGfx, text, element);\n      }\n\n      return rect;\n    },\n    'bpmn:InclusiveGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      /* circle path */\n      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {\n        strokeWidth: 2.5,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return diamond;\n    },\n    'bpmn:ExclusiveGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {\n        xScaleFactor: 0.4,\n        yScaleFactor: 0.4,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.32,\n          my: 0.3\n        }\n      });\n\n      if ((getDi(element).isMarkerVisible)) {\n        drawPath(parentGfx, pathData, {\n          strokeWidth: 1,\n          fill: getStrokeColor(element),\n          stroke: getStrokeColor(element)\n        });\n      }\n\n      return diamond;\n    },\n    'bpmn:ComplexGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {\n        xScaleFactor: 0.5,\n        yScaleFactor:0.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.26\n        }\n      });\n\n      /* complex path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return diamond;\n    },\n    'bpmn:ParallelGateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n        xScaleFactor: 0.6,\n        yScaleFactor:0.6,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.2\n        }\n      });\n\n      /* parallel path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return diamond;\n    },\n    'bpmn:EventBasedGateway': function(parentGfx, element) {\n\n      var semantic = getSemantic(element);\n\n      var attrs = {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);\n\n      /* outer circle path */ drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {\n        strokeWidth: 1,\n        fill: 'none',\n        stroke: getStrokeColor(element)\n      });\n\n      var type = semantic.eventGatewayType;\n      var instantiate = !!semantic.instantiate;\n\n      function drawEvent() {\n\n        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {\n          xScaleFactor: 0.18,\n          yScaleFactor: 0.18,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.36,\n            my: 0.44\n          }\n        });\n\n        var attrs = {\n          strokeWidth: 2,\n          fill: getFillColor(element, 'none'),\n          stroke: getStrokeColor(element)\n        };\n\n        /* event path */ drawPath(parentGfx, pathData, attrs);\n      }\n\n      if (type === 'Parallel') {\n\n        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n          xScaleFactor: 0.4,\n          yScaleFactor:0.4,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.474,\n            my: 0.296\n          }\n        });\n\n        var parallelPath = drawPath(parentGfx, pathData);\n        svgAttr(parallelPath, {\n          strokeWidth: 1,\n          fill: 'none'\n        });\n      } else if (type === 'Exclusive') {\n\n        if (!instantiate) {\n          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);\n          svgAttr(innerCircle, {\n            strokeWidth: 1,\n            fill: 'none',\n            stroke: getStrokeColor(element)\n          });\n        }\n\n        drawEvent();\n      }\n\n\n      return diamond;\n    },\n    'bpmn:Gateway': function(parentGfx, element) {\n      return drawDiamond(parentGfx, element.width, element.height);\n    },\n    'bpmn:SequenceFlow': function(parentGfx, element) {\n      var pathData = createPathFromConnection(element);\n\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      var attrs = {\n        strokeLinejoin: 'round',\n        markerEnd: marker('sequenceflow-end', fill, stroke),\n        stroke: getStrokeColor(element)\n      };\n\n      var path = drawPath(parentGfx, pathData, attrs);\n\n      var sequenceFlow = getSemantic(element);\n      var source = element.source.businessObject;\n\n      // conditional flow marker\n      if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Activity')) {\n        svgAttr(path, {\n          markerStart: marker('conditional-flow-marker', fill, stroke)\n        });\n      }\n\n      // default marker\n      if (source.default && (source.$instanceOf('bpmn:Gateway') || source.$instanceOf('bpmn:Activity')) &&\n          source.default === sequenceFlow) {\n        svgAttr(path, {\n          markerStart: marker('conditional-default-flow-marker', fill, stroke)\n        });\n      }\n\n      return path;\n    },\n    'bpmn:Association': function(parentGfx, element, attrs) {\n\n      var semantic = getSemantic(element);\n\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      attrs = assign({\n        strokeDasharray: '0.5, 5',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        stroke: getStrokeColor(element)\n      }, attrs || {});\n\n      if (semantic.associationDirection === 'One' ||\n          semantic.associationDirection === 'Both') {\n        attrs.markerEnd = marker('association-end', fill, stroke);\n      }\n\n      if (semantic.associationDirection === 'Both') {\n        attrs.markerStart = marker('association-start', fill, stroke);\n      }\n\n      return drawLine(parentGfx, element.waypoints, attrs);\n    },\n    'bpmn:DataInputAssociation': function(parentGfx, element) {\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:DataOutputAssociation': function(parentGfx, element) {\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:MessageFlow': function(parentGfx, element) {\n\n      var semantic = getSemantic(element),\n          di = getDi(element);\n\n      var fill = getFillColor(element),\n          stroke = getStrokeColor(element);\n\n      var pathData = createPathFromConnection(element);\n\n      var attrs = {\n        markerEnd: marker('messageflow-end', fill, stroke),\n        markerStart: marker('messageflow-start', fill, stroke),\n        strokeDasharray: '10, 12',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        strokeWidth: '1.5px',\n        stroke: getStrokeColor(element)\n      };\n\n      var path = drawPath(parentGfx, pathData, attrs);\n\n      if (semantic.messageRef) {\n        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);\n\n        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {\n          abspos: {\n            x: midPoint.x,\n            y: midPoint.y\n          }\n        });\n\n        var messageAttrs = { strokeWidth: 1 };\n\n        if (di.messageVisibleKind === 'initiating') {\n          messageAttrs.fill = 'white';\n          messageAttrs.stroke = 'black';\n        } else {\n          messageAttrs.fill = '#888';\n          messageAttrs.stroke = 'white';\n        }\n\n        drawPath(parentGfx, markerPathData, messageAttrs);\n      }\n\n      return path;\n    },\n    'bpmn:DataObject': function(parentGfx, element) {\n      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.474,\n          my: 0.296\n        }\n      });\n\n      var elementObject = drawPath(parentGfx, pathData, {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      var semantic = getSemantic(element);\n\n      if (isCollection(semantic)) {\n        renderDataItemCollection(parentGfx, element);\n      }\n\n      return elementObject;\n    },\n    'bpmn:DataObjectReference': as('bpmn:DataObject'),\n    'bpmn:DataInput': function(parentGfx, element) {\n\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* input arrow path */ drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });\n\n      return elementObject;\n    },\n    'bpmn:DataOutput': function(parentGfx, element) {\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* output arrow path */ drawPath(parentGfx, arrowPathData, {\n        strokeWidth: 1,\n        fill: 'black'\n      });\n\n      return elementObject;\n    },\n    'bpmn:DataStoreReference': function(parentGfx, element) {\n      var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0,\n          my: 0.133\n        }\n      });\n\n      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {\n        strokeWidth: 2,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      return elementStore;\n    },\n    'bpmn:BoundaryEvent': function(parentGfx, element) {\n\n      var semantic = getSemantic(element),\n          cancel = semantic.cancelActivity;\n\n      var attrs = {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      };\n\n      if (!cancel) {\n        attrs.strokeDasharray = '6';\n        attrs.strokeLinecap = 'round';\n      }\n\n      var outer = renderer('bpmn:Event')(parentGfx, element, attrs);\n      /* inner path */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, assign(attrs, { fill: 'none' }));\n\n      renderEventContent(element, parentGfx);\n\n      return outer;\n    },\n    'bpmn:Group': function(parentGfx, element) {\n      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {\n        strokeWidth: 1,\n        strokeDasharray: '8,3,1,3',\n        fill: 'none',\n        pointerEvents: 'none'\n      });\n    },\n    'label': function(parentGfx, element) {\n      return renderExternalLabel(parentGfx, element);\n    },\n    'bpmn:TextAnnotation': function(parentGfx, element) {\n      var style = {\n        'fill': 'none',\n        'stroke': 'none'\n      };\n\n      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n      drawPath(parentGfx, textPathData, {\n        stroke: getStrokeColor(element)\n      });\n\n      var text = getSemantic(element).text || '';\n      renderLabel(parentGfx, text, { box: element, align: 'left-top', padding: 5 });\n\n      return textElement;\n    },\n    'ParticipantMultiplicityMarker': function(parentGfx, element) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2) / element.width),\n          my: (element.height - 15) / element.height\n        }\n      });\n\n      drawMarker('participant-multiplicity', parentGfx, markerPath);\n    },\n    'SubProcessMarker': function(parentGfx, element) {\n      var markerRect = drawRect(parentGfx, 14, 14, 0, {\n        strokeWidth: 1,\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n\n      // Process marker is placed in the middle of the box\n      // therefore fixed values can be used here\n      translate(markerRect, element.width / 2 - 7.5, element.height - 20);\n\n      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {\n        xScaleFactor: 1.5,\n        yScaleFactor: 1.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 - 7.5) / element.width,\n          my: (element.height - 20) / element.height\n        }\n      });\n\n      drawMarker('sub-process', parentGfx, markerPath, {\n        fill: getFillColor(element),\n        stroke: getStrokeColor(element)\n      });\n    },\n    'ParallelMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.parallel) / element.width),\n          my: (element.height - 20) / element.height\n        }\n      });\n\n      drawMarker('parallel', parentGfx, markerPath);\n    },\n    'SequentialMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.seq) / element.width),\n          my: (element.height - 19) / element.height\n        }\n      });\n\n      drawMarker('sequential', parentGfx, markerPath);\n    },\n    'CompensationMarker': function(parentGfx, element, position) {\n      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.compensation) / element.width),\n          my: (element.height - 13) / element.height\n        }\n      });\n\n      drawMarker('compensation', parentGfx, markerMath, { strokeWidth: 1 });\n    },\n    'LoopMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.loop) / element.width),\n          my: (element.height - 7) / element.height\n        }\n      });\n\n      drawMarker('loop', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: 'none',\n        strokeLinecap: 'round',\n        strokeMiterlimit: 0.5\n      });\n    },\n    'AdhocMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.adhoc) / element.width),\n          my: (element.height - 15) / element.height\n        }\n      });\n\n      drawMarker('adhoc', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: 'black'\n      });\n    }\n  };\n\n  function attachTaskMarkers(parentGfx, element, taskMarkers) {\n    var obj = getSemantic(element);\n\n    var subprocess = taskMarkers && taskMarkers.indexOf('SubProcessMarker') !== -1;\n    var position;\n\n    if (subprocess) {\n      position = {\n        seq: -21,\n        parallel: -22,\n        compensation: -42,\n        loop: -18,\n        adhoc: 10\n      };\n    } else {\n      position = {\n        seq: -3,\n        parallel: -6,\n        compensation: -27,\n        loop: 0,\n        adhoc: 10\n      };\n    }\n\n    forEach(taskMarkers, function(marker) {\n      renderer(marker)(parentGfx, element, position);\n    });\n\n    if (obj.isForCompensation) {\n      renderer('CompensationMarker')(parentGfx, element, position);\n    }\n\n    if (obj.$type === 'bpmn:AdHocSubProcess') {\n      renderer('AdhocMarker')(parentGfx, element, position);\n    }\n\n    var loopCharacteristics = obj.loopCharacteristics,\n        isSequential = loopCharacteristics && loopCharacteristics.isSequential;\n\n    if (loopCharacteristics) {\n\n      if (isSequential === undefined) {\n        renderer('LoopMarker')(parentGfx, element, position);\n      }\n\n      if (isSequential === false) {\n        renderer('ParallelMarker')(parentGfx, element, position);\n      }\n\n      if (isSequential === true) {\n        renderer('SequentialMarker')(parentGfx, element, position);\n      }\n    }\n  }\n\n  function renderDataItemCollection(parentGfx, element) {\n\n    var yPosition = (element.height - 16) / element.height;\n\n    var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {\n      xScaleFactor: 1,\n      yScaleFactor: 1,\n      containerWidth: element.width,\n      containerHeight: element.height,\n      position: {\n        mx: 0.451,\n        my: yPosition\n      }\n    });\n\n    /* collection path */ drawPath(parentGfx, pathData, {\n      strokeWidth: 2\n    });\n  }\n}\n\n\ninherits(BpmnRenderer, BaseRenderer);\n\nBpmnRenderer.$inject = [ 'eventBus', 'styles', 'pathMap', 'canvas' ];\n\nmodule.exports = BpmnRenderer;\n\n\nBpmnRenderer.prototype.canRender = function(element) {\n  return is(element, 'bpmn:BaseElement');\n};\n\nBpmnRenderer.prototype.drawShape = function(parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};\n\nBpmnRenderer.prototype.drawConnection = function(parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};\n\nBpmnRenderer.prototype.getShapePath = function(element) {\n\n  if (is(element, 'bpmn:Event')) {\n    return getCirclePath(element);\n  }\n\n  if (is(element, 'bpmn:Activity')) {\n    return getRoundRectPath(element, TASK_BORDER_RADIUS);\n  }\n\n  if (is(element, 'bpmn:Gateway')) {\n    return getDiamondPath(element);\n  }\n\n  return getRectPath(element);\n};\n\n\n///////// helper functions /////////////////////////////\n\n/**\n * Checks if eventDefinition of the given element matches with semantic type.\n *\n * @return {boolean} true if element is of the given semantic type\n */\nfunction isTypedEvent(event, eventDefinitionType, filter) {\n\n  function matches(definition, filter) {\n    return every(filter, function(val, key) {\n\n      // we want a == conversion here, to be able to catch\n      // undefined == false and friends\n      /* jshint -W116 */\n      return definition[key] == val;\n    });\n  }\n\n  return some(event.eventDefinitions, function(definition) {\n    return definition.$type === eventDefinitionType && matches(event, filter);\n  });\n}\n\nfunction isThrowEvent(event) {\n  return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');\n}\n\nfunction isCollection(element) {\n  var dataObject = element.dataObjectRef;\n\n  return element.isCollection || (dataObject && dataObject.isCollection);\n}\n\nfunction getDi(element) {\n  return element.businessObject.di;\n}\n\nfunction getSemantic(element) {\n  return element.businessObject;\n}\n\n\n\n/////// cropping path customizations /////////////////////////\n\nfunction getCirclePath(shape) {\n\n  var cx = shape.x + shape.width / 2,\n      cy = shape.y + shape.height / 2,\n      radius = shape.width / 2;\n\n  var circlePath = [\n    ['M', cx, cy],\n    ['m', 0, -radius],\n    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],\n    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],\n    ['z']\n  ];\n\n  return componentsToPath(circlePath);\n}\n\nfunction getRoundRectPath(shape, borderRadius) {\n\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var roundRectPath = [\n    ['M', x + borderRadius, y],\n    ['l', width - borderRadius * 2, 0],\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],\n    ['l', 0, height - borderRadius * 2],\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],\n    ['l', borderRadius * 2 - width, 0],\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],\n    ['l', 0, borderRadius * 2 - height],\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],\n    ['z']\n  ];\n\n  return componentsToPath(roundRectPath);\n}\n\nfunction getDiamondPath(shape) {\n\n  var width = shape.width,\n      height = shape.height,\n      x = shape.x,\n      y = shape.y,\n      halfWidth = width / 2,\n      halfHeight = height / 2;\n\n  var diamondPath = [\n    ['M', x + halfWidth, y],\n    ['l', halfWidth, halfHeight],\n    ['l', -halfWidth, halfHeight],\n    ['l', -halfWidth, -halfHeight],\n    ['z']\n  ];\n\n  return componentsToPath(diamondPath);\n}\n\nfunction getRectPath(shape) {\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var rectPath = [\n    ['M', x, y],\n    ['l', width, 0],\n    ['l', 0, height],\n    ['l', -width, 0],\n    ['z']\n  ];\n\n  return componentsToPath(rectPath);\n}\n\nfunction getFillColor(element, defaultColor) {\n  var bo = getBusinessObject(element);\n\n  return bo.di.get('fill') || defaultColor || 'white';\n}\n\nfunction getStrokeColor(element, defaultColor) {\n  var bo = getBusinessObject(element);\n\n  return bo.di.get('stroke') || defaultColor || 'black';\n}\n","'use strict';\n\n/**\n * Map containing SVG paths needed by BpmnRenderer.\n */\n\nfunction PathMap() {\n\n  /**\n   * Contains a map of path elements\n   *\n   * <h1>Path definition</h1>\n   * A parameterized path is defined like this:\n   * <pre>\n   * 'GATEWAY_PARALLEL': {\n   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\n          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\n   *   height: 17.5,\n   *   width:  17.5,\n   *   heightElements: [2.5, 7.5],\n   *   widthElements: [2.5, 7.5]\n   * }\n   * </pre>\n   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling\n   * is based on the ratio between the specified height and width in this object and the\n   * height and width that is set as scale target (Note x,y coordinates will be scaled with\n   * individual ratios).</p>\n   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.\n   * The scaling is based on the computed ratios.\n   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using\n   * the computed ratio coefficient.\n   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.\n   *   <ul>\n   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>\n   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>\n   *   </ul>\n   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.\n   * </p>\n   */\n  this.pathMap = {\n    'EVENT_MESSAGE': {\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\n      height: 36,\n      width:  36,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'EVENT_SIGNAL': {\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',\n      height: 36,\n      width: 36,\n      heightElements: [18],\n      widthElements: [10, 20]\n    },\n    'EVENT_ESCALATION': {\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',\n      height: 36,\n      width: 36,\n      heightElements: [20, 7],\n      widthElements: [8]\n    },\n    'EVENT_CONDITIONAL': {\n      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +\n         'M {e.x2},{e.y3} l {e.x0},0 ' +\n         'M {e.x2},{e.y4} l {e.x0},0 ' +\n         'M {e.x2},{e.y5} l {e.x0},0 ' +\n         'M {e.x2},{e.y6} l {e.x0},0 ' +\n         'M {e.x2},{e.y7} l {e.x0},0 ' +\n         'M {e.x2},{e.y8} l {e.x0},0 ',\n      height: 36,\n      width:  36,\n      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],\n      widthElements:  [10.5, 14.5, 12.5]\n    },\n    'EVENT_LINK': {\n      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',\n      height: 36,\n      width: 36,\n      heightElements: [4.4375, 6.75, 7.8125],\n      widthElements: [9.84375, 13.5]\n    },\n    'EVENT_ERROR': {\n      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',\n      height: 36,\n      width: 36,\n      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],\n      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]\n    },\n    'EVENT_CANCEL_45': {\n      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\n      height: 36,\n      width: 36,\n      heightElements: [4.75, 8.5],\n      widthElements: [4.75, 8.5]\n    },\n    'EVENT_COMPENSATION': {\n      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',\n      height: 36,\n      width: 36,\n      heightElements: [6.5, 13, 0.4, 6.1],\n      widthElements: [9, 9.3, 8.7]\n    },\n    'EVENT_TIMER_WH': {\n      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',\n      height: 36,\n      width:  36,\n      heightElements: [10, 2],\n      widthElements: [3, 7]\n    },\n    'EVENT_TIMER_LINE': {\n      d:  'M {mx},{my} ' +\n          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',\n      height: 36,\n      width:  36,\n      heightElements: [10, 3],\n      widthElements: [0, 0]\n    },\n    'EVENT_MULTIPLE': {\n      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',\n      height: 36,\n      width:  36,\n      heightElements: [6.28099, 12.56199],\n      widthElements: [3.1405, 9.42149, 12.56198]\n    },\n    'EVENT_PARALLEL_MULTIPLE': {\n      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\n        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\n      height: 36,\n      width:  36,\n      heightElements: [2.56228, 7.68683],\n      widthElements: [2.56228, 7.68683]\n    },\n    'GATEWAY_EXCLUSIVE': {\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +\n                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +\n                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',\n      height: 17.5,\n      width:  17.5,\n      heightElements: [8.5, 6.5312, -6.5312, -8.5],\n      widthElements:  [6.5, -6.5, 3, -3, 5, -5]\n    },\n    'GATEWAY_PARALLEL': {\n      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\n      height: 30,\n      width:  30,\n      heightElements: [5, 12.5],\n      widthElements: [5, 12.5]\n    },\n    'GATEWAY_EVENT_BASED': {\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',\n      height: 11,\n      width:  11,\n      heightElements: [-6, 6, 12, -12],\n      widthElements: [9, -3, -12]\n    },\n    'GATEWAY_COMPLEX': {\n      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +\n        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +\n        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +\n        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',\n      height: 17.125,\n      width:  17.125,\n      heightElements: [4.875, 3.4375, 2.125, 3],\n      widthElements: [3.4375, 2.125, 4.875, 3]\n    },\n    'DATA_OBJECT_PATH': {\n      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',\n      height: 61,\n      width:  51,\n      heightElements: [10, 50, 60],\n      widthElements: [10, 40, 50, 60]\n    },\n    'DATA_OBJECT_COLLECTION_PATH': {\n      d:'m {mx}, {my} ' +\n        'm  0 15  l 0 -15 ' +\n        'm  4 15  l 0 -15 ' +\n        'm  4 15  l 0 -15 ',\n      height: 61,\n      width:  51,\n      heightElements: [12],\n      widthElements: [1, 6, 12, 15]\n    },\n    'DATA_ARROW': {\n      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',\n      height: 61,\n      width:  51,\n      heightElements: [],\n      widthElements: []\n    },\n    'DATA_STORE': {\n      d:'m  {mx},{my} ' +\n        'l  0,{e.y2} ' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\n        'l  0,-{e.y2} ' +\n        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\n        'm  -{e.x2},{e.y0}' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +\n        'm  -{e.x2},{e.y0}' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',\n      height: 61,\n      width:  61,\n      heightElements: [7, 10, 45],\n      widthElements:  [2, 58, 60]\n    },\n    'TEXT_ANNOTATION': {\n      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',\n      height: 30,\n      width: 10,\n      heightElements: [30],\n      widthElements: [10]\n    },\n    'MARKER_SUB_PROCESS': {\n      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_PARALLEL': {\n      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_SEQUENTIAL': {\n      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_COMPENSATION': {\n      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',\n      height: 10,\n      width: 21,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_LOOP': {\n      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +\n        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +\n        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +\n        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',\n      height: 13.9,\n      width: 13.7,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_ADHOC': {\n      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +\n        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +\n        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +\n        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +\n        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',\n      height: 4,\n      width: 15,\n      heightElements: [],\n      widthElements: []\n    },\n    'TASK_TYPE_SEND': {\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\n      height: 14,\n      width:  21,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'TASK_TYPE_SCRIPT': {\n      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +\n        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +\n        'm -7,-12 l 5,0 ' +\n        'm -4.5,3 l 4.5,0 ' +\n        'm -3,3 l 5,0' +\n        'm -4,3 l 5,0',\n      height: 15,\n      width:  12.6,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'TASK_TYPE_USER_1': {\n      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +\n        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +\n        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +\n        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +\n        'm -8,6 l 0,5.5 m 11,0 l 0,-5'\n    },\n    'TASK_TYPE_USER_2': {\n      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +\n        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '\n    },\n    'TASK_TYPE_USER_3': {\n      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +\n        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +\n        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'\n    },\n    'TASK_TYPE_MANUAL': {\n      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +\n        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +\n        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +\n        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +\n        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +\n        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +\n        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +\n        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +\n        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +\n        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +\n        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +\n        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'\n    },\n    'TASK_TYPE_INSTANTIATING_SEND': {\n      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'\n    },\n    'TASK_TYPE_SERVICE': {\n      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +\n        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +\n        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +\n        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +\n        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +\n        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +\n        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +\n        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +\n        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +\n        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +\n        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +\n        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +\n        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\n    },\n    'TASK_TYPE_SERVICE_FILL': {\n      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\n    },\n    'TASK_TYPE_BUSINESS_RULE_HEADER': {\n      d: 'm {mx},{my} 0,4 20,0 0,-4 z'\n    },\n    'TASK_TYPE_BUSINESS_RULE_MAIN': {\n      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +\n        'm 0,8 l 20,0 ' +\n        'm -13,-4 l 0,8'\n    },\n    'MESSAGE_FLOW_MARKER': {\n      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'\n    }\n  };\n\n  this.getRawPath = function getRawPath(pathId) {\n    return this.pathMap[pathId].d;\n  };\n\n  /**\n   * Scales the path to the given height and width.\n   * <h1>Use case</h1>\n   * <p>Use case is to scale the content of elements (event, gateways) based\n   * on the element bounding box's size.\n   * </p>\n   * <h1>Why not transform</h1>\n   * <p>Scaling a path with transform() will also scale the stroke and IE does not support\n   * the option 'non-scaling-stroke' to prevent this.\n   * Also there are use cases where only some parts of a path should be\n   * scaled.</p>\n   *\n   * @param {String} pathId The ID of the path.\n   * @param {Object} param <p>\n   *   Example param object scales the path to 60% size of the container (data.width, data.height).\n   *   <pre>\n   *   {\n   *     xScaleFactor: 0.6,\n   *     yScaleFactor:0.6,\n   *     containerWidth: data.width,\n   *     containerHeight: data.height,\n   *     position: {\n   *       mx: 0.46,\n   *       my: 0.2,\n   *     }\n   *   }\n   *   </pre>\n   *   <ul>\n   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>\n   *    <li>targetpathheight = yScaleFactor * containerHeight</li>\n   *    <li>Position is used to set the starting coordinate of the path. M is computed:\n    *    <ul>\n    *      <li>position.x * containerWidth</li>\n    *      <li>position.y * containerHeight</li>\n    *    </ul>\n    *    Center of the container <pre> position: {\n   *       mx: 0.5,\n   *       my: 0.5,\n   *     }</pre>\n   *     Upper left corner of the container\n   *     <pre> position: {\n   *       mx: 0.0,\n   *       my: 0.0,\n   *     }</pre>\n   *    </li>\n   *   </ul>\n   * </p>\n   *\n   */\n  this.getScaledPath = function getScaledPath(pathId, param) {\n    var rawPath = this.pathMap[pathId];\n\n    // positioning\n    // compute the start point of the path\n    var mx, my;\n\n    if (param.abspos) {\n      mx = param.abspos.x;\n      my = param.abspos.y;\n    } else {\n      mx = param.containerWidth * param.position.mx;\n      my = param.containerHeight * param.position.my;\n    }\n\n    var coordinates = {}; //map for the scaled coordinates\n    if (param.position) {\n\n      // path\n      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;\n      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;\n\n\n      //Apply height ratio\n      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {\n        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;\n      }\n\n      //Apply width ratio\n      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {\n        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;\n      }\n    }\n\n    //Apply value to raw path\n    var path = format(\n      rawPath.d, {\n        mx: mx,\n        my: my,\n        e: coordinates\n      }\n    );\n    return path;\n  };\n}\n\nmodule.exports = PathMap;\n\n////////// helpers //////////\n\n// copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js\nvar tokenRegex = //{([^/}]+)/}/g,\n    objNotationRegex = /(?:(?:^|/.)(.+?)(?=/[|/.|$|/()|/[('|\")(.+?)/2/])(/(/))?/g; // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\nfunction replacer(all, key, obj) {\n  var res = obj;\n  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {\n    name = name || quotedName;\n    if (res) {\n      if (name in res) {\n        res = res[name];\n      }\n      typeof res == 'function' && isFunc && (res = res());\n    }\n  });\n  res = (res == null || res == obj ? all : res) + '';\n\n  return res;\n}\n\nfunction format(str, obj) {\n  return String(str).replace(tokenRegex, function(all, key) {\n    return replacer(all, key, obj);\n  });\n}\n","module.exports = {\n  __init__: [ 'bpmnRenderer' ],\n  bpmnRenderer: [ 'type', require(77) ],\n  pathMap: [ 'type', require(78) ]\n};\n","var AutoResize = require(213);\n\nvar inherits = require(368);\n\nvar is = require(167).is;\n\n/**\n * Sub class of the AutoResize module which implements a BPMN\n * specific resize function.\n */\nfunction BpmnAutoResize(eventBus, elementRegistry, modeling, rules) {\n  AutoResize.call(this, eventBus, elementRegistry, modeling, rules);\n}\n\nBpmnAutoResize.$inject = [ 'eventBus', 'elementRegistry', 'modeling', 'rules' ];\n\ninherits(BpmnAutoResize, AutoResize);\n\nmodule.exports = BpmnAutoResize;\n\n\n/**\n * Resize shapes and lanes\n *\n * @param  {djs.model.Shape} target\n * @param  {Object} newBounds\n */\nBpmnAutoResize.prototype.resize = function(target, newBounds) {\n\n  if (is(target, 'bpmn:Participant')) {\n    this._modeling.resizeLane(target, newBounds);\n  } else {\n    this._modeling.resizeShape(target, newBounds);\n  }\n};","'use strict';\n\nvar is = require(167).is;\n\nvar inherits = require(368);\n\nvar forEach = require(386);\n\nvar AutoResizeProvider = require(214);\n\n/**\n * This module is a provider for automatically resizing parent BPMN elements\n */\nfunction BpmnAutoResizeProvider(eventBus, modeling) {\n  AutoResizeProvider.call(this, eventBus);\n\n  this._modeling = modeling;\n}\n\ninherits(BpmnAutoResizeProvider, AutoResizeProvider);\n\nBpmnAutoResizeProvider.$inject = [ 'eventBus', 'modeling' ];\n\nmodule.exports = BpmnAutoResizeProvider;\n\n\n/**\n * Check if the given target can be expanded\n *\n * @param  {djs.model.Shape} target\n *\n * @return {boolean}\n */\nBpmnAutoResizeProvider.prototype.canResize = function(elements, target) {\n\n  if (!is(target, 'bpmn:Participant') && !is(target, 'bpmn:Lane') && !(is(target, 'bpmn:SubProcess'))) {\n    return false;\n  }\n\n  var canResize = true;\n\n  forEach(elements, function(element) {\n\n    if (is(element, 'bpmn:Lane') || element.labelTarget) {\n      canResize = false;\n      return;\n    }\n  });\n\n  return canResize;\n};\n","module.exports = {\n  __init__: [ 'bpmnAutoResize', 'bpmnAutoResizeProvider' ],\n  bpmnAutoResize: [ 'type', require(80) ],\n  bpmnAutoResizeProvider: [ 'type', require(81) ]\n};\n","'use strict';\n\n\nvar assign = require(516),\n    forEach = require(386),\n    isArray = require(506),\n    is = require(167).is,\n    isExpanded = require(165).isExpanded,\n    isAny = require(140).isAny,\n    getChildLanes = require(139).getChildLanes,\n    isEventSubProcess = require(165).isEventSubProcess,\n    hasPrimaryModifier = require(351).hasPrimaryModifier;\n\n/**\n * A provider for BPMN 2.0 elements context pad\n */\nfunction ContextPadProvider(eventBus, contextPad, modeling, elementFactory,\n                            connect, create, popupMenu,\n                            canvas, rules, translate) {\n\n  contextPad.registerProvider(this);\n\n  this._contextPad = contextPad;\n\n  this._modeling = modeling;\n\n  this._elementFactory = elementFactory;\n  this._connect = connect;\n  this._create = create;\n  this._popupMenu = popupMenu;\n  this._canvas  = canvas;\n  this._rules = rules;\n  this._translate = translate;\n\n\n  eventBus.on('create.end', 250, function(event) {\n    var shape = event.context.shape;\n\n    if (!hasPrimaryModifier(event)) {\n      return;\n    }\n\n    var entries = contextPad.getEntries(shape);\n\n    if (entries.replace) {\n      entries.replace.action.click(event, shape);\n    }\n  });\n}\n\nContextPadProvider.$inject = [\n  'eventBus',\n  'contextPad',\n  'modeling',\n  'elementFactory',\n  'connect',\n  'create',\n  'popupMenu',\n  'canvas',\n  'rules',\n  'translate'\n];\n\nmodule.exports = ContextPadProvider;\n\n\nContextPadProvider.prototype.getContextPadEntries = function(element) {\n\n  var contextPad = this._contextPad,\n      modeling = this._modeling,\n\n      elementFactory = this._elementFactory,\n      connect = this._connect,\n      create = this._create,\n      popupMenu = this._popupMenu,\n      canvas = this._canvas,\n      rules = this._rules,\n\n      translate = this._translate;\n\n  var actions = {};\n\n  if (element.type === 'label') {\n    return actions;\n  }\n\n  var businessObject = element.businessObject;\n\n  function startConnect(event, element, autoActivate) {\n    connect.start(event, element, autoActivate);\n  }\n\n  function removeElement(e) {\n    modeling.removeElements([ element ]);\n  }\n\n  function getReplaceMenuPosition(element) {\n\n    var Y_OFFSET = 5;\n\n    var diagramContainer = canvas.getContainer(),\n        pad = contextPad.getPad(element).html;\n\n    var diagramRect = diagramContainer.getBoundingClientRect(),\n        padRect = pad.getBoundingClientRect();\n\n    var top = padRect.top - diagramRect.top;\n    var left = padRect.left - diagramRect.left;\n\n    var pos = {\n      x: left,\n      y: top + padRect.height + Y_OFFSET\n    };\n\n    return pos;\n  }\n\n\n  /**\n   * Create an append action\n   *\n   * @param {String} type\n   * @param {String} className\n   * @param {String} [title]\n   * @param {Object} [options]\n   *\n   * @return {Object} descriptor\n   */\n  function appendAction(type, className, title, options) {\n\n    if (typeof title !== 'string') {\n      options = title;\n      title = translate('Append {type}', { type: translate(type.replace(/^bpmn/:/, '')) });\n    }\n\n    function appendListener(event, element) {\n\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n      create.start(event, shape, element);\n    }\n\n    return {\n      group: 'model',\n      className: className,\n      title: title,\n      action: {\n        dragstart: appendListener,\n        click: appendListener\n      }\n    };\n  }\n\n  function splitLaneHandler(count) {\n\n    return function(event, element) {\n      // actual split\n      modeling.splitLane(element, count);\n\n      // refresh context pad after split to\n      // get rid of split icons\n      contextPad.open(element, true);\n    };\n  }\n\n\n  if (isAny(businessObject, [ 'bpmn:Lane', 'bpmn:Participant' ]) && isExpanded(businessObject)) {\n\n    var childLanes = getChildLanes(element);\n\n    assign(actions, {\n      'lane-insert-above': {\n        group: 'lane-insert-above',\n        className: 'bpmn-icon-lane-insert-above',\n        title: translate('Add Lane above'),\n        action: {\n          click: function(event, element) {\n            modeling.addLane(element, 'top');\n          }\n        }\n      }\n    });\n\n    if (childLanes.length < 2) {\n\n      if (element.height >= 120) {\n        assign(actions, {\n          'lane-divide-two': {\n            group: 'lane-divide',\n            className: 'bpmn-icon-lane-divide-two',\n            title: translate('Divide into two Lanes'),\n            action: {\n              click: splitLaneHandler(2)\n            }\n          }\n        });\n      }\n\n      if (element.height >= 180) {\n        assign(actions, {\n          'lane-divide-three': {\n            group: 'lane-divide',\n            className: 'bpmn-icon-lane-divide-three',\n            title: translate('Divide into three Lanes'),\n            action: {\n              click: splitLaneHandler(3)\n            }\n          }\n        });\n      }\n    }\n\n    assign(actions, {\n      'lane-insert-below': {\n        group: 'lane-insert-below',\n        className: 'bpmn-icon-lane-insert-below',\n        title: translate('Add Lane below'),\n        action: {\n          click: function(event, element) {\n            modeling.addLane(element, 'bottom');\n          }\n        }\n      }\n    });\n\n  }\n\n  if (is(businessObject, 'bpmn:FlowNode')) {\n\n    if (is(businessObject, 'bpmn:EventBasedGateway')) {\n\n      assign(actions, {\n        'append.receive-task': appendAction('bpmn:ReceiveTask', 'bpmn-icon-receive-task'),\n        'append.message-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-message',\n                                                  { eventDefinitionType: 'bpmn:MessageEventDefinition' }),\n        'append.timer-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-timer',\n                                                  { eventDefinitionType: 'bpmn:TimerEventDefinition' }),\n        'append.condtion-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-condition',\n                                                  { eventDefinitionType: 'bpmn:ConditionalEventDefinition' }),\n        'append.signal-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',\n                                                  'bpmn-icon-intermediate-event-catch-signal',\n                                                  { eventDefinitionType: 'bpmn:SignalEventDefinition' })\n      });\n    } else\n\n    if (isEventType(businessObject, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')) {\n\n      assign(actions, {\n        'append.compensation-activity':\n            appendAction('bpmn:Task', 'bpmn-icon-task', translate('Append compensation activity'), {\n              isForCompensation: true\n            })\n      });\n    } else\n\n    if (!is(businessObject, 'bpmn:EndEvent') &&\n        !businessObject.isForCompensation &&\n        !isEventType(businessObject, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') &&\n        !isEventSubProcess(businessObject)) {\n\n      assign(actions, {\n        'append.end-event': appendAction('bpmn:EndEvent', 'bpmn-icon-end-event-none'),\n        'append.gateway': appendAction('bpmn:ExclusiveGateway', 'bpmn-icon-gateway-xor'),\n        'append.append-task': appendAction('bpmn:Task', 'bpmn-icon-task'),\n        'append.intermediate-event': appendAction('bpmn:IntermediateThrowEvent',\n                                                  'bpmn-icon-intermediate-event-none')\n      });\n    }\n  }\n\n  var replaceMenu;\n\n  if (popupMenu._providers['bpmn-replace']) {\n    replaceMenu = popupMenu.create('bpmn-replace', element);\n  }\n\n  if (replaceMenu && !replaceMenu.isEmpty()) {\n\n    // Replace menu entry\n    assign(actions, {\n      'replace': {\n        group: 'edit',\n        className: 'bpmn-icon-screw-wrench',\n        title: translate('Change type'),\n        action: {\n          click: function(event, element) {\n            replaceMenu.open(assign(getReplaceMenuPosition(element), {\n              cursor: { x: event.x, y: event.y }\n            }), element);\n          }\n        }\n      }\n    });\n  }\n\n  if (isAny(businessObject, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]) ) {\n\n    assign(actions, {\n      'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation'),\n\n      'connect': {\n        group: 'connect',\n        className: 'bpmn-icon-connection-multi',\n        title: translate('Connect using ' +\n                  (businessObject.isForCompensation ? '' : 'Sequence/MessageFlow or ') +\n                  'Association'),\n        action: {\n          click: startConnect,\n          dragstart: startConnect\n        }\n      }\n    });\n  }\n\n  if (isAny(businessObject, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {\n    assign(actions, {\n      'connect': {\n        group: 'connect',\n        className: 'bpmn-icon-connection-multi',\n        title: translate('Connect using DataInputAssociation'),\n        action: {\n          click: startConnect,\n          dragstart: startConnect\n        }\n      }\n    });\n  }\n\n  // delete element entry, only show if allowed by rules\n  var deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });\n\n  if (isArray(deleteAllowed)) {\n    // was the element returned as a deletion candidate?\n    deleteAllowed = deleteAllowed[0] === element;\n  }\n\n  if (deleteAllowed) {\n    assign(actions, {\n      'delete': {\n        group: 'edit',\n        className: 'bpmn-icon-trash',\n        title: translate('Remove'),\n        action: {\n          click: removeElement,\n          dragstart: removeElement\n        }\n      }\n    });\n  }\n\n  return actions;\n};\n\nfunction isEventType(eventBo, type, definition) {\n\n  var isType = eventBo.$instanceOf(type);\n  var isDefinition = false;\n\n  var definitions = eventBo.eventDefinitions || [];\n  forEach(definitions, function(def) {\n    if (def.$type === definition) {\n      isDefinition = true;\n    }\n  });\n\n  return isType && isDefinition;\n}\n","module.exports = {\n  __depends__: [\n    require(191),\n    require(230),\n    require(310),\n    require(228),\n    require(234),\n    require(146)\n  ],\n  __init__: [ 'contextPadProvider' ],\n  contextPadProvider: [ 'type', require(83) ]\n};","'use strict';\n\nvar ModelUtil = require(167),\n    getBusinessObject = ModelUtil.getBusinessObject,\n    is = ModelUtil.is;\n\nvar ModelCloneHelper = require(169);\n\nvar ModelCloneUtils = require(170),\n    getProperties = ModelCloneUtils.getProperties;\n\nvar IGNORED_PROPERTIES = ModelCloneUtils.IGNORED_PROPERTIES;\n\nvar filter = require(384),\n    forEach = require(386);\n\nfunction setProperties(descriptor, data, properties) {\n  forEach(properties, function(property) {\n    if (data[property] !== undefined) {\n      descriptor[property] = data[property];\n    }\n  });\n}\n\nfunction removeProperties(element, properties) {\n  forEach(properties, function(prop) {\n    if (element[prop]) {\n      delete element[prop];\n    }\n  });\n}\n\nfunction BpmnCopyPaste(\n    bpmnFactory, eventBus, copyPaste,\n    clipboard, canvas, bpmnRules) {\n\n  var helper = new ModelCloneHelper(eventBus);\n\n  copyPaste.registerDescriptor(function(element, descriptor) {\n    var businessObject = descriptor.oldBusinessObject = getBusinessObject(element);\n\n    var colors = {};\n\n    descriptor.type = element.type;\n\n    setProperties(descriptor, businessObject.di, [ 'isExpanded' ]);\n\n    setProperties(colors, businessObject.di, [ 'fill', 'stroke' ]);\n\n    descriptor.colors = colors;\n\n    if (element.type === 'label') {\n      return descriptor;\n    }\n\n    setProperties(descriptor, businessObject, [\n      'type',\n      'processRef',\n      'triggeredByEvent'\n    ]);\n\n    if (businessObject.default) {\n      descriptor.default = businessObject.default.id;\n    }\n\n    return descriptor;\n  });\n\n  eventBus.on('element.paste', function(context) {\n    var descriptor = context.descriptor,\n        createdElements = context.createdElements,\n        parent = descriptor.parent,\n        rootElement = canvas.getRootElement(),\n        oldBusinessObject = descriptor.oldBusinessObject,\n        newBusinessObject,\n        source,\n        target,\n        canConnect;\n\n    newBusinessObject = bpmnFactory.create(oldBusinessObject.$type);\n\n    var properties = getProperties(oldBusinessObject.$descriptor);\n\n    properties = filter(properties, function(property) {\n      return IGNORED_PROPERTIES.indexOf(property.replace(/bpmn:/, '')) === -1;\n    });\n\n    descriptor.businessObject = helper.clone(oldBusinessObject, newBusinessObject, properties);\n\n    if (descriptor.type === 'label') {\n      return;\n    }\n\n    if (is(parent, 'bpmn:Process')) {\n      descriptor.parent = is(rootElement, 'bpmn:Collaboration') ? rootElement : parent;\n    }\n\n    if (descriptor.type === 'bpmn:DataOutputAssociation' ||\n        descriptor.type === 'bpmn:DataInputAssociation' ||\n        descriptor.type === 'bpmn:MessageFlow') {\n      descriptor.parent = rootElement;\n    }\n\n    if (is(parent, 'bpmn:Lane')) {\n      descriptor.parent = parent.parent;\n    }\n\n    // make sure that the correct type of connection is created\n    if (descriptor.waypoints) {\n      source = createdElements[descriptor.source];\n      target = createdElements[descriptor.target];\n\n      if (source && target) {\n        source = source.element;\n        target = target.element;\n      }\n\n      canConnect = bpmnRules.canConnect(source, target);\n\n      if (canConnect) {\n        descriptor.type = canConnect.type;\n      }\n    }\n\n    // remove the id or else we cannot paste multiple times\n    delete newBusinessObject.id;\n\n    // assign an ID\n    bpmnFactory._ensureId(newBusinessObject);\n\n    if (descriptor.type === 'bpmn:Participant' && descriptor.processRef) {\n      descriptor.processRef = newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n    }\n\n    setProperties(newBusinessObject, descriptor, [\n      'isExpanded',\n      'triggeredByEvent'\n    ]);\n\n    removeProperties(descriptor, [\n      'triggeredByEvent'\n    ]);\n  });\n\n}\n\n\nBpmnCopyPaste.$inject = [\n  'bpmnFactory',\n  'eventBus',\n  'copyPaste',\n  'clipboard',\n  'canvas',\n  'bpmnRules'\n];\n\nmodule.exports = BpmnCopyPaste;\n","module.exports = {\n  __depends__: [\n    require(232)\n  ],\n  __init__: [ 'bpmnCopyPaste' ],\n  bpmnCopyPaste: [ 'type', require(85) ]\n};\n","'use strict';\n\nvar filter = require(384);\n\nvar isAny = require(140).isAny;\n\n/**\n * Registers element exclude filters for elements that currently do \n * not support distribution.\n */\nfunction BpmnDistributeElements(distributeElements) {\n\n  distributeElements.registerFilter(function(elements) {\n    return filter(elements, function(element) {\n      var cannotDistribute = isAny(element, [\n        'bpmn:Association',\n        'bpmn:BoundaryEvent',\n        'bpmn:DataInputAssociation',\n        'bpmn:DataOutputAssociation',\n        'bpmn:Lane',\n        'bpmn:MessageFlow',\n        'bpmn:Participant',\n        'bpmn:SequenceFlow',\n        'bpmn:TextAnnotation'\n      ]);\n\n      return !(element.labelTarget || cannotDistribute);\n    });\n  });\n}\n\nBpmnDistributeElements.$inject = [ 'distributeElements' ];\n\nmodule.exports = BpmnDistributeElements;\n","module.exports = {\n  __depends__: [\n    require(236)\n  ],\n  __init__: [ 'bpmnDistributeElements' ],\n  bpmnDistributeElements: [ 'type', require(87) ]\n};\n","'use strict';\n\nvar inherits = require(368);\n\nvar EditorActions = require(240);\n\nvar filter = require(384);\n\nvar is = require(167).is;\n\nvar getBBox = require(343).getBBox;\n\nfunction BpmnEditorActions(\n    injector,\n    canvas, elementRegistry, selection,\n    spaceTool,\n    lassoTool,\n    handTool,\n    globalConnect,\n    distributeElements,\n    alignElements,\n    directEditing,\n    searchPad,\n    modeling) {\n\n  injector.invoke(EditorActions, this);\n\n  this.register({\n    selectElements: function() {\n      // select all elements except for the invisible\n      // root element\n      var rootElement = canvas.getRootElement();\n\n      var elements = elementRegistry.filter(function(element) {\n        return element !== rootElement;\n      });\n\n      selection.select(elements);\n\n      return elements;\n    },\n    spaceTool: function() {\n      spaceTool.toggle();\n    },\n    lassoTool: function() {\n      lassoTool.toggle();\n    },\n    handTool: function() {\n      handTool.toggle();\n    },\n    globalConnectTool: function() {\n      globalConnect.toggle();\n    },\n    distributeElements: function(opts) {\n      var currentSelection = selection.get(),\n          type = opts.type;\n\n      if (currentSelection.length) {\n        distributeElements.trigger(currentSelection, type);\n      }\n    },\n    alignElements: function(opts) {\n      var currentSelection = selection.get(),\n          aligneableElements = [],\n          type = opts.type;\n\n      if (currentSelection.length) {\n        aligneableElements = filter(currentSelection, function(element) {\n          return !is(element, 'bpmn:Lane');\n        });\n\n        alignElements.trigger(aligneableElements, type);\n      }\n    },\n    setColor: function(opts) {\n      var currentSelection = selection.get();\n\n      if (currentSelection.length) {\n        modeling.setColor(currentSelection, opts);\n      }\n    },\n    directEditing: function() {\n      var currentSelection = selection.get();\n\n      if (currentSelection.length) {\n        directEditing.activate(currentSelection[0]);\n      }\n    },\n    find: function() {\n      searchPad.toggle();\n    },\n    moveToOrigin: function() {\n      var rootElement = canvas.getRootElement(),\n          boundingBox,\n          elements;\n\n      if (is(rootElement, 'bpmn:Collaboration')) {\n        elements = elementRegistry.filter(function(element) {\n          return is(element.parent, 'bpmn:Collaboration');\n        });\n      } else {\n        elements = elementRegistry.filter(function(element) {\n          return element !== rootElement && !is(element.parent, 'bpmn:SubProcess');\n        });\n      }\n\n      boundingBox = getBBox(elements);\n\n      modeling.moveElements(elements, { x: -boundingBox.x, y: -boundingBox.y }, rootElement);\n    }\n  });\n}\n\ninherits(BpmnEditorActions, EditorActions);\n\nBpmnEditorActions.$inject = [\n  'injector',\n  'canvas', 'elementRegistry', 'selection',\n  'spaceTool',\n  'lassoTool',\n  'handTool',\n  'globalConnect',\n  'distributeElements',\n  'alignElements',\n  'directEditing',\n  'searchPad',\n  'modeling'\n];\n\nmodule.exports = BpmnEditorActions;\n","module.exports = {\n  __depends__: [\n    require(210),\n    require(241),\n    require(245),\n    require(253),\n    require(317),\n    require(92),\n    require(86),\n    require(88),\n    require(156),\n    require(138)\n  ],\n  editorActions: [ 'type', require(89) ]\n};\n","'use strict';\n\nvar isAny = require(140).isAny;\n\n/**\n * Extention of GlobalConnect tool that implements BPMN specific rules about\n * connection start elements.\n */\nfunction BpmnGlobalConnect(globalConnect) {\n  globalConnect.registerProvider(this);\n}\n\nBpmnGlobalConnect.$inject = [ 'globalConnect' ];\n\nmodule.exports = BpmnGlobalConnect;\n\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {Boolean}\n */\nBpmnGlobalConnect.prototype.canStartConnect = function(source) {\n\n  if (nonExistantOrLabel(source)) {\n    return null;\n  }\n\n  var businessObject = source.businessObject;\n\n  return isAny(businessObject, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]);\n};\n\n\nfunction nonExistantOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isLabel(element) {\n  return element.labelTarget;\n}\n\n\n","module.exports = {\n  __depends__: [\n    require(243)\n  ],\n  __init__: [ 'bpmnGlobalConnect' ],\n  bpmnGlobalConnect: [ 'type', require(91) ]\n};\n","'use strict';\n\n/**\n * BPMN 2.0 specific key bindings.\n *\n * @param {Keyboard} keyboard\n * @param {EditorActions} editorActions\n */\nfunction BpmnKeyBindings(keyboard, editorActions) {\n\n  keyboard.addListener(function(key, modifiers) {\n\n    // ctrl + a -> select all elements\n    if (key === 65 && keyboard.isCmd(modifiers)) {\n      editorActions.trigger('selectElements');\n\n      return true;\n    }\n\n    // ctrl + f -> search labels\n    if (key === 70 && keyboard.isCmd(modifiers)) {\n      editorActions.trigger('find');\n\n      return true;\n    }\n\n    if (keyboard.hasModifier(modifiers)) {\n      return;\n    }\n\n    // s -> activate space tool\n    if (key === 83) {\n      editorActions.trigger('spaceTool');\n\n      return true;\n    }\n\n    // l -> activate lasso tool\n    if (key === 76) {\n      editorActions.trigger('lassoTool');\n\n      return true;\n    }\n\n    // h -> activate hand tool\n    if (key === 72) {\n      editorActions.trigger('handTool');\n\n      return true;\n    }\n\n    // c -> activate global connect tool\n    if (key === 67) {\n      editorActions.trigger('globalConnectTool');\n\n      return true;\n    }\n\n    // e -> activate direct editing\n    if (key === 69) {\n      editorActions.trigger('directEditing');\n\n      return true;\n    }\n  });\n}\n\nBpmnKeyBindings.$inject = [\n  'keyboard',\n  'editorActions'\n];\n\nmodule.exports = BpmnKeyBindings;","module.exports = {\n  __depends__: [\n    require(249)\n  ],\n  __init__: [ 'bpmnKeyBindings' ],\n  bpmnKeyBindings: [ 'type', require(93) ]\n};\n","var svgAppend = require(577),\n    svgAttr = require(579),\n    svgCreate = require(583),\n    svgRemove = require(586);\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is;\n\nvar translate = require(356).translate;\n\nvar MARKER_HIDDEN = 'djs-element-hidden',\n    MARKER_LABEL_HIDDEN = 'djs-label-hidden';\n\nfunction getStrokeColor(element, defaultColor) {\n  var bo = getBusinessObject(element);\n\n  return bo.di.get('stroke') || defaultColor || 'black';\n}\n\nfunction LabelEditingPreview(eventBus, canvas, elementRegistry, pathMap) {\n  var self = this;\n\n  var defaultLayer = canvas.getDefaultLayer();\n\n  var element, absoluteElementBBox, gfx;\n\n  eventBus.on('directEditing.activate', function(context) {\n    var activeProvider = context.active;\n\n    element = activeProvider.element.label || activeProvider.element;\n\n    // text annotation\n    if (is(element, 'bpmn:TextAnnotation')) {\n      absoluteElementBBox = canvas.getAbsoluteBBox(element);\n\n      gfx = svgCreate('g');\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n\n      var path = self.path = svgCreate('path');\n\n      svgAttr(path, {\n        d: textPathData,\n        strokeWidth: 2,\n        stroke: getStrokeColor(element)\n      });\n\n      svgAppend(gfx, path);\n\n      svgAppend(defaultLayer, gfx);\n\n      translate(gfx, element.x, element.y);\n    }\n\n    if (is(element, 'bpmn:TextAnnotation') ||\n        element.labelTarget) {\n      canvas.addMarker(element, MARKER_HIDDEN);\n    } else if (is(element, 'bpmn:Task') ||\n               is(element, 'bpmn:CallActivity') ||\n               is(element, 'bpmn:SubProcess') ||\n               is(element, 'bpmn:Participant')) {\n      canvas.addMarker(element, MARKER_LABEL_HIDDEN);\n    }\n  });\n\n  eventBus.on('directEditing.resize', function(context) {\n\n    // text annotation\n    if (is(element, 'bpmn:TextAnnotation')) {\n      var height = context.height,\n          dy = context.dy;\n\n      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: newElementHeight,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n\n      svgAttr(self.path, {\n        d: textPathData\n      });\n    }\n  });\n\n  eventBus.on([ 'directEditing.complete', 'directEditing.cancel' ], function(context) {\n    var activeProvider = context.active;\n\n    if (activeProvider) {\n      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);\n      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);\n    }\n\n    element = undefined;\n    absoluteElementBBox = undefined;\n\n    if (gfx) {\n      svgRemove(gfx);\n\n      gfx = undefined;\n    }\n  });\n}\n\nLabelEditingPreview.$inject = [ 'eventBus', 'canvas', 'elementRegistry', 'pathMap' ];\n\nmodule.exports = LabelEditingPreview;\n","'use strict';\n\nvar assign = require(516);\n\nvar UpdateLabelHandler = require(98);\n\nvar LabelUtil = require(97);\n\nvar is = require(167).is,\n    isExpanded = require(165).isExpanded;\n\nvar SMALL_FONT_SIZE = 11,\n    SMALL_LINE_HEIGHT = 13,\n    MEDIUM_FONT_SIZE = 12,\n    MEDIUM_LINE_HEIGHT = 14;\n\nfunction LabelEditingProvider(eventBus, canvas, directEditing, commandStack, resizeHandles) {\n\n  this._canvas = canvas;\n  this._commandStack = commandStack;\n\n  directEditing.registerProvider(this);\n\n  commandStack.registerHandler('element.updateLabel', UpdateLabelHandler);\n\n  // listen to dblclick on non-root elements\n  eventBus.on('element.dblclick', function(event) {\n    directEditing.activate(event.element);\n\n    resizeHandles.removeResizers();\n  });\n\n  // complete on followup canvas operation\n  eventBus.on([ 'element.mousedown', 'drag.init', 'canvas.viewbox.changing' ], function(event) {\n    directEditing.complete();\n  });\n\n  // cancel on command stack changes\n  eventBus.on([ 'commandStack.changed' ], function(e) {\n    directEditing.cancel();\n  });\n\n  if ('ontouchstart' in document.documentElement) {\n    // we deactivate automatic label editing on mobile devices\n    // as it breaks the user interaction workflow\n\n    // TODO(nre): we should temporarily focus the edited element here\n    // and release the focused viewport after the direct edit operation is finished\n  } else {\n    eventBus.on('create.end', 500, function(event) {\n      var element = event.shape,\n          canExecute = event.context.canExecute;\n\n      if (!canExecute) {\n        return;\n      }\n\n      if (is(element, 'bpmn:Task') || is(element, 'bpmn:TextAnnotation') ||\n          (is(element, 'bpmn:SubProcess') && !isExpanded(element))) {\n        directEditing.activate(element);\n\n        resizeHandles.removeResizers();\n      }\n    });\n  }\n}\n\nLabelEditingProvider.$inject = [ 'eventBus', 'canvas', 'directEditing', 'commandStack', 'resizeHandles' ];\n\nmodule.exports = LabelEditingProvider;\n\n\n/**\n * Activate direct editing for activities and text annotations.\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} an object with properties bounds (position and size), text and options\n */\nLabelEditingProvider.prototype.activate = function(element) {\n\n  // text\n  var text = LabelUtil.getLabel(element);\n\n  if (text === undefined) {\n    return;\n  }\n\n  var context = {\n    text: text\n  };\n\n  // bounds\n  var bounds = this.getEditingBBox(element);\n\n  assign(context, bounds);\n\n  // options\n  var target = element.label || element;\n\n  var options = {};\n\n  // tasks\n  if (is(element, 'bpmn:Task') ||\n      is(element, 'bpmn:Participant') ||\n      is(element, 'bpmn:Lane') ||\n      (is(element, 'bpmn:CallActivity') && !isExpanded(element)) ||\n      (is(element, 'bpmn:SubProcess') && !isExpanded(element))) {\n    assign(options, {\n      centerVertically: true\n    });\n  }\n\n  // external labels\n  if (target.labelTarget) {\n    assign(options, {\n      autoResize: true\n    });\n  }\n\n  // text annotations\n  if (is(element, 'bpmn:TextAnnotation')) {\n    assign(options, {\n      resizable: true,\n      autoResize: true\n    });\n  }\n\n  assign(context, {\n    options: options\n  });\n\n  return context;\n};\n\n\n/**\n * Get the editing bounding box based on the element's size and position\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} an object containing information about position and size (fixed or minimum and/or maximum)\n */\nLabelEditingProvider.prototype.getEditingBBox = function(element) {\n  var canvas = this._canvas;\n\n  var target = element.label || element;\n\n  var bbox = canvas.getAbsoluteBBox(target);\n\n  var mid = {\n    x: bbox.x + bbox.width / 2,\n    y: bbox.y + bbox.height / 2\n  };\n\n  // default position\n  var bounds = { x: bbox.x, y: bbox.y };\n\n  var zoom = canvas.zoom();\n\n  // take zoom into account\n  var smallFontSize = SMALL_FONT_SIZE * zoom,\n      smallLineHeight = SMALL_LINE_HEIGHT * zoom,\n      mediumFontSize = MEDIUM_FONT_SIZE * zoom,\n      mediumLineHeight = MEDIUM_LINE_HEIGHT * zoom;\n\n  var style = {};\n\n  // adjust for expanded pools AND lanes\n  if ((is(element, 'bpmn:Participant') && isExpanded(element))\n       || is(element, 'bpmn:Lane')) {\n\n    assign(bounds, {\n      width: bbox.height,\n      height: 30 * zoom,\n      x: bbox.x - bbox.height / 2 + (15 * zoom),\n      y: mid.y - (30 * zoom) / 2\n    });\n\n    assign(style, {\n      fontSize: mediumFontSize + 'px',\n      lineHeight: mediumLineHeight + 'px',\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px',\n      transform: 'rotate(-90deg)'\n    });\n  }\n\n\n  // internal labels for tasks and collapsed call activities, sub processes and participants\n  if (\n    is(element, 'bpmn:Task') ||\n    (is(element, 'bpmn:CallActivity') && !isExpanded(element)) ||\n    (is(element, 'bpmn:SubProcess') && !isExpanded(element)) ||\n    (is(element, 'bpmn:Participant') && !isExpanded(element))\n  ) {\n    assign(bounds, {\n      width: bbox.width,\n      height: bbox.height\n    });\n\n    assign(style, {\n      fontSize: mediumFontSize + 'px',\n      lineHeight: mediumLineHeight + 'px',\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px'\n    });\n  }\n\n\n  // internal labels for expanded sub processes\n  if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {\n    assign(bounds, {\n      width: bbox.width,\n      x: bbox.x\n    });\n\n    assign(style, {\n      fontSize: mediumFontSize + 'px',\n      lineHeight: mediumLineHeight + 'px',\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px'\n    });\n  }\n\n\n  // external labels for events, data elements, gateways and connections\n  if (target.labelTarget) {\n    var width = 90 * zoom,\n        paddingTop = 7 * zoom,\n        paddingBottom = 4 * zoom;\n\n    assign(bounds, {\n      width: width,\n      height: bbox.height + paddingTop + paddingBottom,\n      x: mid.x - width / 2,\n      y: bbox.y - paddingTop\n    });\n\n    assign(style, {\n      fontSize: smallFontSize + 'px',\n      lineHeight: smallLineHeight + 'px',\n      paddingTop: paddingTop + 'px',\n      paddingBottom: paddingBottom + 'px'\n    });\n  }\n\n\n  // text annotations\n  if (is(element, 'bpmn:TextAnnotation')) {\n    assign(bounds, {\n      width: bbox.width,\n      height: bbox.height,\n      minWidth: 30 * zoom,\n      minHeight: 10 * zoom\n    });\n\n    assign(style, {\n      textAlign: 'left',\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px',\n      fontSize: mediumFontSize + 'px',\n      lineHeight: mediumLineHeight + 'px'\n    });\n  }\n\n  return { bounds: bounds, style: style };\n};\n\n\nLabelEditingProvider.prototype.update = function(element, newLabel, activeContextText, bounds) {\n  var absoluteElementBBox = this._canvas.getAbsoluteBBox(element);\n\n  this._commandStack.execute('element.updateLabel', {\n    element: element,\n    newLabel: newLabel,\n    bounds: {\n      x: element.x,\n      y: element.y,\n      width: element.width / absoluteElementBBox.width * bounds.width,\n      height: element.height / absoluteElementBBox.height * bounds.height\n    }\n  });\n};\n","'use strict';\n\nvar is = require(167).is;\n\nfunction getLabelAttr(semantic) {\n  if (is(semantic, 'bpmn:FlowElement') ||\n      is(semantic, 'bpmn:Participant') ||\n      is(semantic, 'bpmn:Lane') ||\n      is(semantic, 'bpmn:SequenceFlow') ||\n      is(semantic, 'bpmn:MessageFlow')) {\n\n    return 'name';\n  }\n\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return 'text';\n  }\n}\n\nmodule.exports.getLabel = function(element) {\n  var semantic = element.businessObject,\n      attr = getLabelAttr(semantic);\n\n  if (attr) {\n    return semantic[attr] || '';\n  }\n};\n\n\nmodule.exports.setLabel = function(element, text, isExternal) {\n  var semantic = element.businessObject,\n      attr = getLabelAttr(semantic);\n\n  if (attr) {\n    semantic[attr] = text;\n  }\n\n  // show external label if not empty\n  if (isExternal) {\n    element.hidden = !text;\n  }\n\n  return element;\n};","'use strict';\n\nvar LabelUtil = require(97);\n\nvar TextUtil = require(357);\n\nvar hasExternalLabel = require(166).hasExternalLabel;\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is;\n\nvar NULL_DIMENSIONS = {\n  width: 0,\n  height: 0\n};\n\n\n/**\n * A handler that updates the text of a BPMN element.\n */\nfunction UpdateLabelHandler(modeling) {\n\n  var textUtil = new TextUtil();\n\n  /**\n   * Set the label and return the changed elements.\n   *\n   * Element parameter can be label itself or connection (i.e. sequence flow).\n   *\n   * @param {djs.model.Base} element\n   * @param {String} text\n   */\n  function setText(element, text) {\n\n    // external label if present\n    var label = element.label || element;\n\n    var labelTarget = element.labelTarget || element;\n\n    LabelUtil.setLabel(label, text, labelTarget !== label);\n\n    return [ label, labelTarget ];\n  }\n\n  function execute(ctx) {\n    ctx.oldLabel = LabelUtil.getLabel(ctx.element);\n    return setText(ctx.element, ctx.newLabel);\n  }\n\n  function revert(ctx) {\n    return setText(ctx.element, ctx.oldLabel);\n  }\n\n  function postExecute(ctx) {\n    var element = ctx.element,\n        label = element.label || element,\n        bounds = ctx.bounds;\n\n    // ignore internal labels for elements except text annotations\n    if (!hasExternalLabel(element) && !is(element, 'bpmn:TextAnnotation')) {\n      return;\n    }\n\n    var bo = getBusinessObject(label);\n\n    var text = bo.name || bo.text;\n\n    if (!text) {\n      return;\n    }\n\n    // get layouted text bounds and resize external\n    // external label accordingly\n    var newBounds = is(element, 'bpmn:TextAnnotation') ? bounds : getLayoutedBounds(label, text, textUtil);\n\n    modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);\n  }\n\n  // API\n\n  this.execute = execute;\n  this.revert = revert;\n  this.postExecute = postExecute;\n}\n\nUpdateLabelHandler.$inject = [ 'modeling' ];\n\nmodule.exports = UpdateLabelHandler;\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}","module.exports = {\n  __depends__: [\n    require(198),\n    require(224),\n    require(301),\n    require(191)\n  ],\n  __init__: [\n    'labelEditingProvider',\n    'labelEditingPreview'\n  ],\n  labelEditingProvider: [ 'type', require(96) ],\n  labelEditingPreview: [ 'type', require(95) ]\n};\n","'use strict';\n\nvar map = require(389),\n    assign = require(516),\n    pick = require(524);\n\n\nfunction BpmnFactory(moddle) {\n  this._model = moddle;\n}\n\nBpmnFactory.$inject = [ 'moddle' ];\n\n\nBpmnFactory.prototype._needsId = function(element) {\n  return element.$instanceOf('bpmn:RootElement') ||\n         element.$instanceOf('bpmn:FlowElement') ||\n         element.$instanceOf('bpmn:MessageFlow') ||\n         element.$instanceOf('bpmn:DataAssociation') ||\n         element.$instanceOf('bpmn:Artifact') ||\n         element.$instanceOf('bpmn:Participant') ||\n         element.$instanceOf('bpmn:Lane') ||\n         element.$instanceOf('bpmn:Process') ||\n         element.$instanceOf('bpmn:Collaboration') ||\n         element.$instanceOf('bpmndi:BPMNShape') ||\n         element.$instanceOf('bpmndi:BPMNEdge') ||\n         element.$instanceOf('bpmndi:BPMNDiagram') ||\n         element.$instanceOf('bpmndi:BPMNPlane') ||\n         element.$instanceOf('bpmn:Property');\n};\n\nBpmnFactory.prototype._ensureId = function(element) {\n\n  // generate semantic ids for elements\n  // bpmn:SequenceFlow -> SequenceFlow_ID\n  var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';\n\n  if (!element.id && this._needsId(element)) {\n    element.id = this._model.ids.nextPrefixed(prefix, element);\n  }\n};\n\n\nBpmnFactory.prototype.create = function(type, attrs) {\n  var element = this._model.create(type, attrs || {});\n\n  this._ensureId(element);\n\n  return element;\n};\n\n\nBpmnFactory.prototype.createDiLabel = function() {\n  return this.create('bpmndi:BPMNLabel', {\n    bounds: this.createDiBounds()\n  });\n};\n\n\nBpmnFactory.prototype.createDiShape = function(semantic, bounds, attrs) {\n\n  return this.create('bpmndi:BPMNShape', assign({\n    bpmnElement: semantic,\n    bounds: this.createDiBounds(bounds)\n  }, attrs));\n};\n\n\nBpmnFactory.prototype.createDiBounds = function(bounds) {\n  return this.create('dc:Bounds', bounds);\n};\n\n\nBpmnFactory.prototype.createDiWaypoints = function(waypoints) {\n  return map(waypoints, function(pos) {\n    return this.createDiWaypoint(pos);\n  }, this);\n};\n\nBpmnFactory.prototype.createDiWaypoint = function(point) {\n  return this.create('dc:Point', pick(point, [ 'x', 'y' ]));\n};\n\n\nBpmnFactory.prototype.createDiEdge = function(semantic, waypoints, attrs) {\n  return this.create('bpmndi:BPMNEdge', assign({\n    bpmnElement: semantic\n  }, attrs));\n};\n\nBpmnFactory.prototype.createDiPlane = function(semantic) {\n  return this.create('bpmndi:BPMNPlane', {\n    bpmnElement: semantic\n  });\n};\n\nmodule.exports = BpmnFactory;\n","'use strict';\n\nvar inherits = require(368);\n\nvar assign = require(516);\n\nvar BaseLayouter = require(327),\n    ManhattanLayout = require(330);\n\nvar LayoutUtil = require(329);\n\nvar isExpanded = require(165).isExpanded;\n\nvar getMid = LayoutUtil.getMid,\n    getOrientation = LayoutUtil.getOrientation;\n\nvar is = require(167).is;\n\n\nfunction BpmnLayouter() {}\n\ninherits(BpmnLayouter, BaseLayouter);\n\nmodule.exports = BpmnLayouter;\n\n\nBpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n\n  hints = hints || {};\n\n  var source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      start = hints.connectionStart,\n      end = hints.connectionEnd;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!start) {\n    start = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!end) {\n    end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(connection)) {\n      return [].concat([ start ], waypoints.slice(1, -1), [ end ]);\n    }\n  }\n\n  // manhattan layout sequence / message flows\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = {\n      preferredLayouts: [ 'v:v' ]\n    };\n\n    if (is(target, 'bpmn:Participant')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ]\n      };\n    }\n\n    if (isExpandedSubProcess(target)) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ]\n      };\n    }\n\n    if (isExpandedSubProcess(source) && is(target, 'bpmn:FlowNode')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ],\n        preserveDocking: isExpandedSubProcess(target) ? 'source' : 'target'\n      };\n    }\n\n    if (is(source, 'bpmn:Participant') && is(target, 'bpmn:FlowNode')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'straight', 'v:v' ],\n        preserveDocking: 'target'\n      };\n    }\n\n    if (is(target, 'bpmn:Event')) {\n      manhattanOptions = {\n        preferredLayouts: [ 'v:v' ]\n      };\n    }\n  } else\n\n\n  // layout all connection between flow elements h:h,\n  //\n  // except for\n  //\n  // (1) outgoing of BoundaryEvents -> layout h:v or v:h based on attach orientation\n  // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)\n  //\n  if (is(connection, 'bpmn:SequenceFlow') ||\n      isCompensationAssociation(connection)) {\n\n    // make sure boundary event connections do\n    // not look ugly =:>\n    if (is(source, 'bpmn:BoundaryEvent')) {\n\n      var orientation = getAttachOrientation(source);\n\n      if (/left|right/.test(orientation)) {\n        manhattanOptions = {\n          preferredLayouts: [ 'h:v' ]\n        };\n      } else\n\n      if (/top|bottom/.test(orientation)) {\n        manhattanOptions = {\n          preferredLayouts: [ 'v:h' ]\n        };\n      }\n    } else\n\n    if (is(source, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'v:h' ]\n      };\n    } else\n\n    if (is(target, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'h:v' ]\n      };\n    }\n\n    // apply horizontal love <3\n    else {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:h' ]\n      };\n    }\n  }\n\n  if (manhattanOptions) {\n\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints =\n      ManhattanLayout.repairConnection(\n        source, target,\n        start, end,\n        waypoints,\n        manhattanOptions);\n  }\n\n  return updatedWaypoints || [ start, end ];\n};\n\n\nfunction getAttachOrientation(attachedElement) {\n\n  var hostElement = attachedElement.host,\n      padding = -10;\n\n  return getOrientation(getMid(attachedElement), hostElement, padding);\n}\n\n\nfunction getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}\n\nfunction isCompensationAssociation(connection) {\n\n  var source = connection.source,\n      target = connection.target;\n\n  return is(target, 'bpmn:Activity') &&\n         is(source, 'bpmn:BoundaryEvent') &&\n         target.businessObject.isForCompensation;\n}\n\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}","'use strict';\n\nvar assign = require(516),\n    forEach = require(386),\n    inherits = require(368);\n\nvar Collections = require(340),\n    Model = require(331);\n\nvar getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is;\n\nvar CommandInterceptor = require(196);\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\nfunction BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n\n  var self = this;\n\n\n\n  ////// connection cropping /////////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        connection;\n\n    if (!context.cropped) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  ////// BPMN + DI update /////////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(updateParent));\n\n  this.reverted([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnectionWaypoints));\n\n\n  // update Default & Conditional flows\n  this.executed([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        oldSource = getBusinessObject(context.oldSource),\n        oldTarget = getBusinessObject(context.oldTarget),\n        newSource = getBusinessObject(connection.source),\n        newTarget = getBusinessObject(connection.target);\n\n    if (oldSource === newSource || oldTarget === newTarget) {\n      return;\n    }\n\n    // on reconnectStart -> default flow\n    if (oldSource && oldSource.default === businessObject) {\n      context.default = oldSource.default;\n      oldSource.default = undefined;\n    }\n\n    // on reconnectEnd -> default flow\n    if ((businessObject.sourceRef && businessObject.sourceRef.default) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent')) ) {\n      context.default = businessObject.sourceRef.default;\n      businessObject.sourceRef.default = undefined;\n    }\n\n    // on reconnectStart -> conditional flow\n    if (oldSource && (businessObject.conditionExpression) &&\n      !(is(newSource, 'bpmn:Activity') ||\n        is(newSource, 'bpmn:Gateway')) ) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n\n    // on reconnectEnd -> conditional flow\n    if (oldTarget && (businessObject.conditionExpression) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent')) ) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n  }));\n\n  this.reverted([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        newSource = getBusinessObject(connection.source);\n\n    // default flow\n    if (context.default) {\n      if (is(newSource, 'bpmn:ExclusiveGateway') || is(newSource, 'bpmn:InclusiveGateway') ||\n          is(newSource, 'bpmn:Activity')) {\n        newSource.default = context.default;\n      }\n    }\n\n    // conditional flow\n    if (context.conditionExpression && is(newSource, 'bpmn:Activity')) {\n      businessObject.conditionExpression = context.conditionExpression;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n}\n\ninherits(BpmnUpdater, CommandInterceptor);\n\nmodule.exports = BpmnUpdater;\n\nBpmnUpdater.$inject = [ 'eventBus', 'bpmnFactory', 'connectionDocking', 'translate' ];\n\n\n/////// implementation //////////////////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function(element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Model.Label) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};\n\n\nBpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = shape.businessObject.di;\n\n  var bounds = (shape instanceof Model.Label) ? this._getLabel(di).bounds : di.bounds;\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    Collections.remove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    Collections.add(newRefs, businessObject);\n  }\n};\n\n\n// update existing sourceElement and targetElement di information\nBpmnUpdater.prototype.updateDiConnection = function(di, newSource, newTarget) {\n\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n\n};\n\n\nBpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    Collections.remove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else\n\n  if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else\n\n      if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else\n\n  if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        Collections.remove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        Collections.add(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate(\n      'no parent for {element} in {parent}',\n      {\n        element: businessObject.id,\n        parent: newParent.id\n      }\n    ));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    Collections.remove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    Collections.remove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n\nBpmnUpdater.prototype.updateConnection = function(context) {\n\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        Collections.remove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        Collections.remove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMany sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n\n    visualParent = context.parent || context.newParent || newTarget;\n\n    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n\n    this.updateSemanticParent(businessObject, newSource, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n};\n\n\n/////// helpers /////////////////////////////////////////\n\nBpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n\n\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\nfunction ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n","'use strict';\n\nvar assign = require(516),\n    forEach = require(386),\n    inherits = require(368);\n\nvar is = require(167).is;\n\nvar isExpanded = require(165).isExpanded;\n\nvar BaseElementFactory = require(200),\n    LabelUtil = require(166);\n\n/**\n * A bpmn-aware factory for diagram-js shapes\n */\nfunction ElementFactory(bpmnFactory, moddle, translate) {\n  BaseElementFactory.call(this);\n\n  this._bpmnFactory = bpmnFactory;\n  this._moddle = moddle;\n  this._translate = translate;\n}\n\ninherits(ElementFactory, BaseElementFactory);\n\n\nElementFactory.$inject = [ 'bpmnFactory', 'moddle', 'translate' ];\n\nmodule.exports = ElementFactory;\n\nElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;\n\nElementFactory.prototype.create = function(elementType, attrs) {\n  // no special magic for labels,\n  // we assume their businessObjects have already been created\n  // and wired via attrs\n  if (elementType === 'label') {\n    return this.baseCreate(elementType, assign({ type: 'label' }, LabelUtil.DEFAULT_LABEL_SIZE, attrs));\n  }\n\n  return this.createBpmnElement(elementType, attrs);\n};\n\nElementFactory.prototype.createBpmnElement = function(elementType, attrs) {\n  var size,\n      translate = this._translate;\n\n  attrs = attrs || {};\n\n  var businessObject = attrs.businessObject;\n\n  if (!businessObject) {\n    if (!attrs.type) {\n      throw new Error(translate('no shape type specified'));\n    }\n\n    businessObject = this._bpmnFactory.create(attrs.type);\n  }\n\n  if (!businessObject.di) {\n    if (elementType === 'root') {\n      businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else\n    if (elementType === 'connection') {\n      businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else {\n      businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {\n        id: businessObject.id + '_di'\n      });\n    }\n  }\n\n  if (attrs.colors) {\n    assign(businessObject.di, attrs.colors);\n\n    delete attrs.colors;\n  }\n\n  applyAttributes(businessObject, attrs, [\n    'processRef',\n    'isInterrupting',\n    'associationDirection',\n    'isForCompensation'\n  ]);\n\n  if (attrs.isExpanded) {\n    applyAttribute(businessObject.di, attrs, 'isExpanded');\n  }\n\n  if (is(businessObject, 'bpmn:ExclusiveGateway')) {\n    businessObject.di.isMarkerVisible = true;\n  }\n\n  var eventDefinitions,\n      newEventDefinition;\n\n  if (attrs.eventDefinitionType) {\n    eventDefinitions = businessObject.get('eventDefinitions') || [];\n    newEventDefinition = this._moddle.create(attrs.eventDefinitionType);\n\n    eventDefinitions.push(newEventDefinition);\n\n    newEventDefinition.$parent = businessObject;\n    businessObject.eventDefinitions = eventDefinitions;\n\n    delete attrs.eventDefinitionType;\n  }\n\n  size = this._getDefaultSize(businessObject);\n\n  attrs = assign({\n    businessObject: businessObject,\n    id: businessObject.id\n  }, size, attrs);\n\n  return this.baseCreate(elementType, attrs);\n};\n\n\nElementFactory.prototype._getDefaultSize = function(semantic) {\n\n  if (is(semantic, 'bpmn:SubProcess')) {\n\n    if (isExpanded(semantic)) {\n      return { width: 350, height: 200 };\n    } else {\n      return { width: 100, height: 80 };\n    }\n  }\n\n  if (is(semantic, 'bpmn:Task')) {\n    return { width: 100, height: 80 };\n  }\n\n  if (is(semantic, 'bpmn:Gateway')) {\n    return { width: 50, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:Event')) {\n    return { width: 36, height: 36 };\n  }\n\n  if (is(semantic, 'bpmn:Participant')) {\n    if (!isExpanded(semantic)) {\n      return { width: 400, height: 100 };\n    } else {\n      return { width: 600, height: 250 };\n    }\n  }\n\n  if (is(semantic, 'bpmn:Lane')) {\n    return { width: 400, height: 100 };\n  }\n\n  if (is(semantic, 'bpmn:DataObjectReference')) {\n    return { width: 36, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:DataStoreReference')) {\n    return { width: 50, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return { width: 100, height: 30 };\n  }\n\n  return { width: 100, height: 80 };\n};\n\n\nElementFactory.prototype.createParticipantShape = function(collapsed) {\n\n  var attrs = { type: 'bpmn:Participant' };\n\n  if (!collapsed) {\n    attrs.processRef = this._bpmnFactory.create('bpmn:Process');\n  }\n\n  return this.createShape(attrs);\n};\n\n\n//////////// helpers ////////////////////////////////////\n\n/**\n * Apply attributes from a map to the given element,\n * remove attribute from the map on application.\n *\n * @param {Base} element\n * @param {Object} attrs (in/out map of attributes)\n * @param {Array<String>} attributeNames name of attributes to apply\n */\nfunction applyAttributes(element, attrs, attributeNames) {\n\n  forEach(attributeNames, function(property) {\n    if (attrs[property] !== undefined) {\n      applyAttribute(element, attrs, property);\n    }\n  });\n}\n\n/**\n * Apply named property to element and drain it from the attrs\n * collection.\n *\n * @param {Base} element\n * @param {Object} attrs (in/out map of attributes)\n * @param {String} attributeName to apply\n */\nfunction applyAttribute(element, attrs, attributeName) {\n  element[attributeName] = attrs[attributeName];\n\n  delete attrs[attributeName];\n}","'use strict';\n\nvar inherits = require(368);\n\nvar BaseModeling = require(254);\n\nvar UpdatePropertiesHandler = require(137),\n    UpdateCanvasRootHandler = require(135),\n    AddLaneHandler = require(130),\n    SplitLaneHandler = require(134),\n    ResizeLaneHandler = require(132),\n    UpdateFlowNodeRefsHandler = require(136),\n    IdClaimHandler = require(131),\n    SetColorHandler = require(133);\n\n\n/**\n * BPMN 2.0 modeling features activator\n *\n * @param {EventBus} eventBus\n * @param {ElementFactory} elementFactory\n * @param {CommandStack} commandStack\n * @param {BpmnRules} bpmnRules\n */\nfunction Modeling(eventBus, elementFactory, commandStack, bpmnRules) {\n  BaseModeling.call(this, eventBus, elementFactory, commandStack);\n\n  this._bpmnRules = bpmnRules;\n}\n\ninherits(Modeling, BaseModeling);\n\nModeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack', 'bpmnRules' ];\n\nmodule.exports = Modeling;\n\n\nModeling.prototype.getHandlers = function() {\n  var handlers = BaseModeling.prototype.getHandlers.call(this);\n\n  handlers['element.updateProperties'] = UpdatePropertiesHandler;\n  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;\n  handlers['lane.add'] = AddLaneHandler;\n  handlers['lane.resize'] = ResizeLaneHandler;\n  handlers['lane.split'] = SplitLaneHandler;\n  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;\n  handlers['id.updateClaim'] = IdClaimHandler;\n  handlers['element.setColor'] = SetColorHandler;\n\n  return handlers;\n};\n\n\nModeling.prototype.updateLabel = function(element, newLabel) {\n  this._commandStack.execute('element.updateLabel', {\n    element: element,\n    newLabel: newLabel\n  });\n};\n\n\nModeling.prototype.connect = function(source, target, attrs, hints) {\n\n  var bpmnRules = this._bpmnRules;\n\n  if (!attrs) {\n    attrs = bpmnRules.canConnect(source, target);\n  }\n\n  if (!attrs) {\n    return;\n  }\n\n  return this.createConnection(source, target, attrs, source.parent, hints);\n};\n\n\nModeling.prototype.updateProperties = function(element, properties) {\n  this._commandStack.execute('element.updateProperties', {\n    element: element,\n    properties: properties\n  });\n};\n\nModeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {\n  this._commandStack.execute('lane.resize', {\n    shape: laneShape,\n    newBounds: newBounds,\n    balanced: balanced\n  });\n};\n\nModeling.prototype.addLane = function(targetLaneShape, location) {\n  var context = {\n    shape: targetLaneShape,\n    location: location\n  };\n\n  this._commandStack.execute('lane.add', context);\n\n  return context.newLane;\n};\n\nModeling.prototype.splitLane = function(targetLane, count) {\n  this._commandStack.execute('lane.split', {\n    shape: targetLane,\n    count: count\n  });\n};\n\n/**\n * Transform the current diagram into a collaboration.\n *\n * @return {djs.model.Root} the new root element\n */\nModeling.prototype.makeCollaboration = function() {\n\n  var collaborationElement = this._create('root', {\n    type: 'bpmn:Collaboration'\n  });\n\n  var context = {\n    newRoot: collaborationElement\n  };\n\n  this._commandStack.execute('canvas.updateRoot', context);\n\n  return collaborationElement;\n};\n\nModeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {\n\n  this._commandStack.execute('lane.updateRefs', {\n    flowNodeShapes: flowNodeShapes,\n    laneShapes: laneShapes\n  });\n};\n\n/**\n * Transform the current diagram into a process.\n *\n * @return {djs.model.Root} the new root element\n */\nModeling.prototype.makeProcess = function() {\n\n  var processElement = this._create('root', {\n    type: 'bpmn:Process'\n  });\n\n  var context = {\n    newRoot: processElement\n  };\n\n  this._commandStack.execute('canvas.updateRoot', context);\n};\n\n\nModeling.prototype.claimId = function(id, moddleElement) {\n  this._commandStack.execute('id.updateClaim', {\n    id: id,\n    element: moddleElement,\n    claiming: true\n  });\n};\n\n\nModeling.prototype.unclaimId = function(id, moddleElement) {\n  this._commandStack.execute('id.updateClaim', {\n    id: id,\n    element: moddleElement\n  });\n};\n\nModeling.prototype.setColor = function(elements, colors) {\n  if (!elements.length) {\n    elements = [ elements ];\n  }\n\n  this._commandStack.execute('element.setColor', {\n    elements: elements,\n    colors: colors\n  });\n};\n","'use strict';\n\nvar inherits = require(368);\n\nvar is = require(167).is;\n\nvar CommandInterceptor = require(196);\n\n\nfunction AppendBehavior(eventBus, elementFactory, bpmnRules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // assign correct shape position unless already set\n\n  this.preExecute('shape.append', function(context) {\n\n    var source = context.source,\n        shape = context.shape;\n\n    if (!context.position) {\n\n      if (is(shape, 'bpmn:TextAnnotation')) {\n        context.position = {\n          x: source.x + source.width / 2 + 75,\n          y: source.y - (50) - shape.height / 2\n        };\n      } else {\n        context.position = {\n          x: source.x + source.width + 80 + shape.width / 2,\n          y: source.y + source.height / 2\n        };\n      }\n    }\n  }, true);\n}\n\n\nAppendBehavior.$inject = [ 'eventBus', 'elementFactory', 'bpmnRules' ];\n\ninherits(AppendBehavior, CommandInterceptor);\n\nmodule.exports = AppendBehavior;","'use strict';\n\nvar inherits = require(368);\n\nvar forEach = require(386);\n\nvar is = require(167).is;\n\nvar CommandInterceptor = require(196);\n\n\nfunction CopyPasteBehavior(eventBus, modeling, canvas) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('elements.paste', 1500, function(context) {\n    var topParent = context.topParent;\n\n    // always grab the latest root\n    if (!topParent.parent) {\n      context.topParent = canvas.getRootElement();\n    }\n\n    if (is(topParent, 'bpmn:Lane')) {\n      do {\n        // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n        topParent = context.topParent = topParent.parent;\n\n      } while (is(topParent, 'bpmn:Lane') || !is(topParent, 'bpmn:Participant'));\n    }\n  }, true);\n\n  this.postExecute('elements.paste', function(context) {\n\n    var tree = context.tree,\n        createdElements = tree.createdElements;\n\n    forEach(createdElements, function(data) {\n      var element = data.element,\n          businessObject = element.businessObject,\n          descriptor = data.descriptor,\n          defaultFlow;\n\n      if ((is(businessObject, 'bpmn:ExclusiveGateway') || is(businessObject, 'bpmn:InclusiveGateway') ||\n           is(businessObject, 'bpmn:Activity')) && descriptor.default) {\n\n        defaultFlow = createdElements[descriptor.default];\n\n        // if the default flow wasn't created, means that it wasn't copied\n        if (defaultFlow) {\n          defaultFlow = defaultFlow.element;\n        } else {\n          defaultFlow = undefined;\n        }\n\n        delete element.default;\n\n        modeling.updateProperties(element, { default: defaultFlow });\n      }\n    });\n  }, true);\n}\n\n\nCopyPasteBehavior.$inject = [ 'eventBus', 'modeling', 'canvas' ];\n\ninherits(CopyPasteBehavior, CommandInterceptor);\n\nmodule.exports = CopyPasteBehavior;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\n\n/**\n * BPMN specific create boundary event behavior\n */\nfunction CreateBoundaryEventBehavior(eventBus, modeling, elementFactory, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * replace intermediate event with boundary event when\n   * attaching it to a shape\n   */\n\n  this.preExecute('shape.create', function(context) {\n    var shape = context.shape,\n        host = context.host,\n        businessObject,\n        boundaryEvent;\n\n    var attrs = {\n      cancelActivity: true\n    };\n\n    if (host && is(shape, 'bpmn:IntermediateThrowEvent')) {\n      attrs.attachedToRef = host.businessObject;\n\n      businessObject = bpmnFactory.create('bpmn:BoundaryEvent', attrs);\n\n      boundaryEvent = {\n        type: 'bpmn:BoundaryEvent',\n        businessObject: businessObject\n      };\n\n      context.shape = elementFactory.createShape(boundaryEvent);\n    }\n  }, true);\n}\n\nCreateBoundaryEventBehavior.$inject = [ 'eventBus', 'modeling', 'elementFactory', 'bpmnFactory' ];\n\ninherits(CreateBoundaryEventBehavior, CommandInterceptor);\n\nmodule.exports = CreateBoundaryEventBehavior;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\n/**\n * BPMN specific create data object behavior\n */\nfunction CreateDataObjectBehavior(eventBus, bpmnFactory, moddle) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('shape.create', function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:DataObjectReference') && shape.type !== 'label') {\n\n      // create a DataObject every time a DataObjectReference is created\n      var dataObject = bpmnFactory.create('bpmn:DataObject');\n\n      // set the reference to the DataObject\n      shape.businessObject.dataObjectRef = dataObject;\n    }\n  });\n\n}\n\nCreateDataObjectBehavior.$inject = [ 'eventBus', 'bpmnFactory', 'moddle' ];\n\ninherits(CreateDataObjectBehavior, CommandInterceptor);\n\nmodule.exports = CreateDataObjectBehavior;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\n/**\n * BPMN specific create participant behavior\n */\nfunction CreateParticipantBehavior(eventBus, modeling, elementFactory, bpmnFactory, canvas) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * morph process into collaboration before adding\n   * participant onto collaboration\n   */\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape,\n        position = context.position;\n\n    var rootElement = canvas.getRootElement();\n\n    if (is(parent, 'bpmn:Process') && is(shape, 'bpmn:Participant') && !is(rootElement, 'bpmn:Collaboration')) {\n\n      // this is going to detach the process root\n      // and set the returned collaboration element\n      // as the new root element\n      var collaborationElement = modeling.makeCollaboration();\n\n      // monkey patch the create context\n      // so that the participant is being dropped\n      // onto the new collaboration root instead\n      context.position = position;\n      context.parent = collaborationElement;\n\n      context.processRoot = parent;\n    }\n  }, true);\n\n\n  this.execute('shape.create', function(context) {\n\n    var processRoot = context.processRoot,\n        shape = context.shape;\n\n    if (processRoot) {\n      context.oldProcessRef = shape.businessObject.processRef;\n\n      // assign the participant processRef\n      shape.businessObject.processRef = processRoot.businessObject;\n    }\n  }, true);\n\n\n  this.revert('shape.create', function(context) {\n    var processRoot = context.processRoot,\n        shape = context.shape;\n\n    if (processRoot) {\n      // assign the participant processRef\n      shape.businessObject.processRef = context.oldProcessRef;\n    }\n  }, true);\n\n\n  this.postExecute('shape.create', function(context) {\n\n    var processRoot = context.processRoot,\n        shape = context.shape;\n\n    if (processRoot) {\n      // process root is already detached at this point\n      var processChildren = processRoot.children.slice();\n      modeling.moveElements(processChildren, { x: 0, y: 0 }, shape);\n    }\n\n  }, true);\n\n}\n\nCreateParticipantBehavior.$inject = [ 'eventBus', 'modeling', 'elementFactory', 'bpmnFactory', 'canvas' ];\n\ninherits(CreateParticipantBehavior, CommandInterceptor);\n\nmodule.exports = CreateParticipantBehavior;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar Collections = require(340);\n\nvar find = require(385);\n\nvar is = require(167).is;\n\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n\n\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\nfunction DataInputAssociationBehavior(eventBus, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.executed([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnectEnd'\n  ], ifDataInputAssociation(fixTargetRef));\n\n  this.reverted([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnectEnd'\n  ], ifDataInputAssociation(fixTargetRef));\n\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n\n    var inputAssociations = element.get('dataInputAssociations');\n\n    return find(inputAssociations, function(association) {\n      return association !== removedConnection &&\n             association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n\n    var properties = element.get('properties');\n\n    var targetRefProp = find(properties, function(p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n\n      Collections.add(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      Collections.remove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\n\nDataInputAssociationBehavior.$inject = [ 'eventBus', 'bpmnFactory' ];\n\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n\nmodule.exports = DataInputAssociationBehavior;\n\n\n/**\n * Only call the given function when the event\n * touches a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\nfunction ifDataInputAssociation(fn) {\n\n  return function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\nvar getChildLanes = require(139).getChildLanes;\n\nvar eachElement = require(343).eachElement;\n\n\nvar LOW_PRIORITY = 500;\n\n\n/**\n * BPMN specific delete lane behavior\n */\nfunction DeleteLaneBehavior(eventBus, modeling, spaceTool) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  function compensateLaneDelete(shape, oldParent) {\n\n    var siblings = getChildLanes(oldParent);\n\n    var topAffected = [];\n    var bottomAffected = [];\n\n    eachElement(siblings, function(element) {\n\n      if (element.y > shape.y) {\n        bottomAffected.push(element);\n      } else {\n        topAffected.push(element);\n      }\n\n      return element.children;\n    });\n\n    if (!siblings.length) {\n      return;\n    }\n\n    var offset;\n\n    if (bottomAffected.length && topAffected.length) {\n      offset = shape.height / 2;\n    } else {\n      offset = shape.height;\n    }\n\n    var topAdjustments,\n        bottomAdjustments;\n\n    if (topAffected.length) {\n      topAdjustments = spaceTool.calculateAdjustments(\n        topAffected, 'y', offset, shape.y - 10);\n\n      spaceTool.makeSpace(\n        topAdjustments.movingShapes,\n        topAdjustments.resizingShapes,\n        { x: 0, y: offset }, 's');\n    }\n\n    if (bottomAffected.length) {\n      bottomAdjustments = spaceTool.calculateAdjustments(\n        bottomAffected, 'y', -offset, shape.y + shape.height + 10);\n\n      spaceTool.makeSpace(\n        bottomAdjustments.movingShapes,\n        bottomAdjustments.resizingShapes,\n        { x: 0, y: -offset }, 'n');\n    }\n  }\n\n\n  /**\n   * Adjust sizes of other lanes after lane deletion\n   */\n  this.postExecuted('shape.delete', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        oldParent = context.oldParent;\n\n    // only compensate lane deletes\n    if (!is(shape, 'bpmn:Lane')) {\n      return;\n    }\n\n    // compensate root deletes only\n    if (hints && hints.nested) {\n      return;\n    }\n\n    compensateLaneDelete(shape, oldParent);\n  });\n}\n\nDeleteLaneBehavior.$inject = [ 'eventBus', 'modeling', 'spaceTool' ];\n\ninherits(DeleteLaneBehavior, CommandInterceptor);\n\nmodule.exports = DeleteLaneBehavior;","'use strict';\n\nvar inherits = require(368);\n\nvar assign = require(516),\n    find = require(385);\n\nvar CommandInterceptor = require(196);\n\nvar getApproxIntersection = require(349).getApproxIntersection;\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}\n\nfunction getMid(bounds) {\n\n  return {\n    x: Math.round(bounds.x + bounds.width / 2),\n    y: Math.round(bounds.y + bounds.height / 2)\n  };\n}\n\nfunction DropOnFlow(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, position) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore, waypointsAfter, dockingPoint, source, target, reconnected;\n\n    var intersection = getApproxIntersection(waypoints, position);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : position;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length-1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || position);\n\n      reconnected = true;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n\n      if (!reconnected) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || position);\n      } else {\n        modeling.connect(shape, target, { type: targetFlow.type, waypoints: waypointsAfter });\n      }\n    }\n  }\n\n  this.preExecute('elements.move', function(context) {\n\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function(element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n\n  }, true);\n\n  this.postExecuted('elements.move', function(context) {\n\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n\n  }, true);\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n\n\n  this.postExecute('shape.create', function(context) {\n\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, position);\n    }\n  }, true);\n}\n\ninherits(DropOnFlow, CommandInterceptor);\n\nDropOnFlow.$inject = [ 'eventBus', 'bpmnRules', 'modeling' ];\n\nmodule.exports = DropOnFlow;\n","'use strict';\n\nvar getMid = require(329).getMid;\n\nvar lineIntersect = require(129);\n\n\n/**\n * Fix broken dockings after DI imports.\n *\n * @param {EventBus} eventBus\n */\nfunction ImportDockingFix(eventBus) {\n\n  function adjustDocking(startPoint, nextPoint, elementMid) {\n\n    var elementTop = {\n      x: elementMid.x,\n      y: elementMid.y - 50\n    };\n\n    var elementLeft = {\n      x: elementMid.x - 50,\n      y: elementMid.y\n    };\n\n    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop),\n        horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);\n\n    // original is horizontal or vertical center cross intersection\n    var centerIntersect;\n\n    if (verticalIntersect && horizontalIntersect) {\n      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {\n        centerIntersect = horizontalIntersect;\n      } else {\n        centerIntersect = verticalIntersect;\n      }\n    } else {\n      centerIntersect = verticalIntersect || horizontalIntersect;\n    }\n\n    startPoint.original = centerIntersect;\n  }\n\n  function fixDockings(connection) {\n    var waypoints = connection.waypoints;\n\n    adjustDocking(\n      waypoints[0],\n      waypoints[1],\n      getMid(connection.source)\n    );\n\n    adjustDocking(\n      waypoints[waypoints.length - 1],\n      waypoints[waypoints.length - 2],\n      getMid(connection.target)\n    );\n  }\n\n  eventBus.on('bpmnElement.added', function(e) {\n\n    var element = e.element;\n\n    if (element.waypoints) {\n      fixDockings(element);\n    }\n  });\n}\n\nImportDockingFix.$inject = [ 'eventBus' ];\n\nmodule.exports = ImportDockingFix;\n\n\n/////// helpers //////////////////////////////////\n\nfunction getDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}","'use strict';\n\nvar assign = require(516),\n    inherits = require(368);\n\nvar LabelUtil = require(166),\n    LabelLayoutUtil = require(127),\n    ModelUtil = require(167),\n    is = ModelUtil.is,\n    getBusinessObject = ModelUtil.getBusinessObject;\n\nvar hasExternalLabel = LabelUtil.hasExternalLabel,\n    getExternalLabelMid = LabelUtil.getExternalLabelMid,\n    getLabelAdjustment = LabelLayoutUtil.getLabelAdjustment;\n\nvar CommandInterceptor = require(196);\n\nvar TextUtil = require(357);\n\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\n\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n */\nfunction LabelSupport(eventBus, modeling, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  var textUtil = new TextUtil();\n\n\n  ///// create external labels on shape creation\n\n  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (!hasExternalLabel(businessObject)) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element);\n\n    // we don't care about x and y\n    var labelDimensions = getLayoutedBounds(\n      DEFAULT_LABEL_DIMENSIONS,\n      businessObject.name || '',\n      textUtil\n    );\n\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      hidden: !businessObject.name,\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  });\n\n\n  ///// update di information on label creation\n\n  this.executed([ 'label.create' ], function(event) {\n\n    var element = event.context.shape,\n        businessObject,\n        di;\n\n    // we want to trigger on real labels only\n    if (!element.labelTarget) {\n      return;\n    }\n\n    // we want to trigger on BPMN elements only\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    businessObject = element.businessObject,\n    di = businessObject.di;\n\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n\n  ///// update label position on connection change\n\n  function getHiddenLabelAdjustment(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label;\n\n    var labelPosition = getExternalLabelMid(connection);\n\n    return {\n      x: labelPosition.x - label.x - label.width / 2,\n      y: labelPosition.y - label.y - label.height / 2\n    };\n  }\n\n  function getVisibleLabelAdjustment(event) {\n\n    var command = event.command,\n        context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = (command === 'connection.reconnectStart');\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = (command === 'connection.reconnectEnd');\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute([\n    'connection.layout',\n    'connection.reconnectEnd',\n    'connection.reconnectStart',\n    'connection.updateWaypoints'\n  ], function(event) {\n\n    var label = event.context.connection.label,\n        labelAdjustment;\n\n    if (!label) {\n      return;\n    }\n\n    if (label.hidden) {\n      labelAdjustment = getHiddenLabelAdjustment(event);\n    } else {\n      labelAdjustment = getVisibleLabelAdjustment(event);\n    }\n\n    modeling.moveShape(label, labelAdjustment);\n  });\n\n\n  ////// keep label position on shape replace\n\n  this.postExecute([ 'shape.replace' ], function(event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject && hasExternalLabel(businessObject)) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n\n}\n\ninherits(LabelSupport, CommandInterceptor);\n\nLabelSupport.$inject = [ 'eventBus', 'modeling', 'bpmnFactory' ];\n\nmodule.exports = LabelSupport;\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}\n","'use strict';\n\nvar is = require(167).is;\n\nvar COLLAB_ERR_MSG = 'flow elements must be children of pools/participants',\n    PROCESS_ERR_MSG = 'participants cannot be pasted onto a non-empty process diagram';\n\nfunction ModelingFeedback(eventBus, tooltips, translate) {\n\n  function showError(position, message, timeout) {\n    tooltips.add({\n      position: {\n        x: position.x + 5,\n        y: position.y + 5\n      },\n      type: 'error',\n      timeout: timeout || 2000,\n      html: '<div>' + message + '</div>'\n    });\n  }\n\n  eventBus.on([ 'shape.move.rejected', 'create.rejected' ], function(event) {\n    var context = event.context,\n        shape = context.shape,\n        target = context.target;\n\n    if (is(target, 'bpmn:Collaboration') && is(shape, 'bpmn:FlowNode')) {\n      showError(event, translate(COLLAB_ERR_MSG));\n    }\n  });\n\n  eventBus.on([ 'elements.paste.rejected' ], function(event) {\n    var context = event.context,\n        position = context.position,\n        target = context.target;\n\n    if (is(target, 'bpmn:Collaboration')) {\n      showError(position, translate(COLLAB_ERR_MSG));\n    }\n\n    if (is(target, 'bpmn:Process')) {\n      showError(position, translate(PROCESS_ERR_MSG), 3000);\n    }\n  });\n}\n\n\nModelingFeedback.$inject = [ 'eventBus', 'tooltips', 'translate' ];\n\nmodule.exports = ModelingFeedback;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar lineIntersect = require(129);\n\n\nfunction RemoveElementBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Combine sequence flows when deleting an element\n   * if there is one incoming and one outgoing\n   * sequence flow\n   */\n  this.preExecute('shape.delete', function(e) {\n\n    var shape = e.context.shape;\n\n    if (shape.incoming.length == 1 && shape.outgoing.length == 1) {\n\n      var inConnection = shape.incoming[0],\n          outConnection = shape.outgoing[0];\n\n\n      if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {\n\n        // compute new, combined waypoints\n        var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);\n\n        modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);\n      }\n    }\n  });\n\n}\n\ninherits(RemoveElementBehavior, CommandInterceptor);\n\nRemoveElementBehavior.$inject = [ 'eventBus', 'bpmnRules', 'modeling' ];\n\nmodule.exports = RemoveElementBehavior;\n\n\n///////// helpers //////////////////////////////\n\nfunction getDocking(point) {\n  return point.original || point;\n}\n\n\nfunction getNewWaypoints(inWaypoints, outWaypoints) {\n\n  var intersection = lineIntersect(\n    getDocking(inWaypoints[inWaypoints.length - 2]),\n    getDocking(inWaypoints[inWaypoints.length - 1]),\n    getDocking(outWaypoints[1]),\n    getDocking(outWaypoints[0]));\n\n  if (intersection) {\n    return [].concat(\n      inWaypoints.slice(0, inWaypoints.length - 1),\n      [ intersection ],\n      outWaypoints.slice(1));\n  } else {\n    return [\n      getDocking(inWaypoints[0]),\n      getDocking(outWaypoints[outWaypoints.length - 1])\n    ];\n  }\n}","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\n\n/**\n * BPMN specific remove behavior\n */\nfunction RemoveParticipantBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  /**\n   * morph collaboration diagram into process diagram\n   * after the last participant has been removed\n   */\n\n  this.preExecute('shape.delete', function(context) {\n\n    var shape = context.shape,\n        parent = shape.parent;\n\n    // activate the behavior if the shape to be removed\n    // is a participant\n    if (is(shape, 'bpmn:Participant')) {\n      context.collaborationRoot = parent;\n    }\n  }, true);\n\n  this.postExecute('shape.delete', function(context) {\n\n    var collaborationRoot = context.collaborationRoot;\n\n    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {\n      // replace empty collaboration with process diagram\n      modeling.makeProcess();\n    }\n  }, true);\n\n}\n\nRemoveParticipantBehavior.$inject = [ 'eventBus', 'modeling' ];\n\ninherits(RemoveParticipantBehavior, CommandInterceptor);\n\nmodule.exports = RemoveParticipantBehavior;","'use strict';\n\nvar forEach = require(386),\n    find = require(385),\n    inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\nfunction ReplaceConnectionBehavior(eventBus, modeling, bpmnRules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  function fixConnection(connection) {\n\n    var source = connection.source,\n        target = connection.target,\n        parent = connection.parent;\n\n    // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n    if (!parent) {\n      return;\n    }\n\n    var replacementType,\n        remove;\n\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    }\n\n    // transform message flows into sequence flows, if possible\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n\n    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {\n      remove = true;\n    }\n\n\n    // remove invalid connection,\n    // unless it has been removed already\n    if (remove) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace SequenceFlow <> MessageFlow\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n\n  this.postExecuted('elements.move', function(context) {\n\n    var closure = context.closure,\n        allConnections = closure.allConnections;\n\n    forEach(allConnections, fixConnection);\n  }, true);\n\n  this.postExecuted([\n    'connection.reconnectStart',\n    'connection.reconnectEnd'\n  ], function(event) {\n\n    var connection = event.context.connection;\n\n    fixConnection(connection);\n  });\n\n  this.postExecuted('element.updateProperties', function(event) {\n    var context = event.context,\n        properties = context.properties,\n        element = context.element,\n        businessObject = element.businessObject,\n        connection;\n\n    // remove condition expression when morphing to default flow\n    if (properties.default) {\n      connection = find(element.outgoing, { id: element.businessObject.default.id });\n\n      if (connection) {\n        modeling.updateProperties(connection, { conditionExpression: undefined });\n      }\n    }\n\n    // remove default property from source when morphing to conditional flow\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\n      modeling.updateProperties(element.source, { default: undefined });\n    }\n  });\n}\n\ninherits(ReplaceConnectionBehavior, CommandInterceptor);\n\nReplaceConnectionBehavior.$inject = [ 'eventBus', 'modeling', 'bpmnRules' ];\n\nmodule.exports = ReplaceConnectionBehavior;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar forEach = require(386);\n\nvar isEventSubProcess = require(165).isEventSubProcess;\nvar is = require(167).is;\n\n/**\n * Defines the behaviour of what happens to the elements inside a container\n * that morphs into another BPMN element\n */\nfunction ReplaceElementBehaviour(eventBus, bpmnReplace, bpmnRules, elementRegistry, selection, modeling) {\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnReplace = bpmnReplace;\n  this._elementRegistry = elementRegistry;\n  this._selection = selection;\n  this._modeling = modeling;\n\n  this.postExecuted([ 'elements.move' ], 500, function(event) {\n\n    var context = event.context,\n        target = context.newParent,\n        newHost = context.newHost,\n        elements = [];\n\n    forEach(context.closure.topLevel, function(topLevelElements) {\n      if (isEventSubProcess(topLevelElements)) {\n        elements = elements.concat(topLevelElements.children);\n      } else {\n        elements = elements.concat(topLevelElements);\n      }\n    });\n\n    // Change target to host when the moving element is a `bpmn:BoundaryEvent`\n    if (elements.length === 1 && newHost) {\n      target = newHost;\n    }\n\n    var canReplace = bpmnRules.canReplace(elements, target);\n\n    if (canReplace) {\n      this.replaceElements(elements, canReplace.replacements, newHost);\n    }\n  }, this);\n\n  // update attachments if the host is replaced\n  this.postExecute([ 'shape.replace' ], 1500, function(e) {\n\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape,\n        attachers = oldShape.attachers,\n        canReplace;\n\n    if (attachers && attachers.length) {\n      canReplace = bpmnRules.canReplace(attachers, newShape);\n\n      this.replaceElements(attachers, canReplace.replacements);\n    }\n\n  }, this);\n\n  this.postExecuted( [ 'shape.replace' ], 1500, function(e) {\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape;\n\n    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);\n    modeling.updateProperties(newShape, { id: oldShape.id });\n  });\n}\n\ninherits(ReplaceElementBehaviour, CommandInterceptor);\n\n\nReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements, newHost) {\n  var elementRegistry = this._elementRegistry,\n      bpmnReplace = this._bpmnReplace,\n      selection = this._selection,\n      modeling = this._modeling;\n\n  forEach(newElements, function(replacement) {\n\n    var newElement = {\n      type: replacement.newElementType\n    };\n\n    var oldElement = elementRegistry.get(replacement.oldElementId);\n\n    if (newHost && is(oldElement, 'bpmn:BoundaryEvent')) {\n      modeling.updateAttachment(oldElement, null);\n    }\n\n    var idx = elements.indexOf(oldElement);\n\n    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });\n\n    if (newHost && is(elements[idx], 'bpmn:BoundaryEvent')) {\n      modeling.updateAttachment(elements[idx], newHost);\n    }\n  });\n\n  if (newElements) {\n    selection.select(elements);\n  }\n};\n\nReplaceElementBehaviour.$inject = [\n  'eventBus', 'bpmnReplace', 'bpmnRules',\n  'elementRegistry', 'selection', 'modeling'\n];\n\nmodule.exports = ReplaceElementBehaviour;\n","'use strict';\n\nvar is = require(167).is;\n\nvar roundBounds = require(329).roundBounds;\n\nvar hasPrimaryModifier = require(351).hasPrimaryModifier;\n\nvar SLIGHTLY_HIGHER_PRIORITY = 1001;\n\n\n/**\n * Invoke {@link Modeling#resizeLane} instead of\n * {@link Modeling#resizeShape} when resizing a Lane\n * or Participant shape.\n */\nfunction ResizeLaneBehavior(eventBus, modeling) {\n\n  eventBus.on('resize.start', SLIGHTLY_HIGHER_PRIORITY + 500, function(event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n\n      // should we resize the opposite lane(s) in\n      // order to compensate for the resize operation?\n      context.balanced = !hasPrimaryModifier(event);\n    }\n  });\n\n  /**\n   * Intercept resize end and call resize lane function instead.\n   */\n  eventBus.on('resize.end', SLIGHTLY_HIGHER_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n\n      if (canExecute) {\n        // ensure we have actual pixel values for new bounds\n        // (important when zoom level was > 1 during move)\n        newBounds = roundBounds(newBounds);\n\n        // perform the actual resize\n        modeling.resizeLane(shape, newBounds, context.balanced);\n      }\n\n      // stop propagation\n      return false;\n    }\n  });\n}\n\nResizeLaneBehavior.$inject = [ 'eventBus', 'modeling' ];\n\nmodule.exports = ResizeLaneBehavior;\n","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196),\n    getBusinessObject = require(167).getBusinessObject,\n    is = require(167).is,\n    computeChildrenBBox = require(300).computeChildrenBBox;\n\n\nvar LOW_PRIORITY = 500;\n\n\nfunction ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling, resize) {\n  CommandInterceptor.call(this, eventBus);\n\n\n  function hideEmptyLables(children) {\n    if (children.length) {\n      children.forEach(function(child) {\n        if (child.type === 'label' && !child.businessObject.name) {\n          child.hidden = true;\n        }\n      });\n    }\n  }\n\n  function expandedBounds(shape, defaultSize) {\n    var children = shape.children,\n        newBounds = defaultSize,\n        visibleElements,\n        visibleBBox;\n\n    visibleElements = filterVisible(children).concat([ shape ]);\n\n    visibleBBox = computeChildrenBBox(visibleElements);\n\n    if (visibleBBox) {\n      // center to visibleBBox with max(defaultSize, childrenBounds)\n      newBounds.width = Math.max(visibleBBox.width, newBounds.width);\n      newBounds.height = Math.max(visibleBBox.height, newBounds.height);\n\n      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;\n      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;\n    } else {\n      // center to collapsed shape with defaultSize\n      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;\n      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;\n    }\n\n    return newBounds;\n  }\n\n  function collapsedBounds(shape, defaultSize) {\n\n    return {\n      x: shape.x + (shape.width - defaultSize.width) / 2,\n      y: shape.y + (shape.height - defaultSize.height) / 2,\n      width: defaultSize.width,\n      height: defaultSize.height\n    };\n  }\n\n  this.executed([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\n\n    var context = e.context,\n        shape = context.shape;\n\n    if (!is(shape, 'bpmn:SubProcess')) {\n      return;\n    }\n\n    if (!shape.collapsed) {\n      // all children got made visible through djs, hide empty labels\n      hideEmptyLables(shape.children);\n\n      // remove collapsed marker\n      getBusinessObject(shape).di.isExpanded = true;\n    } else {\n      // place collapsed marker\n      getBusinessObject(shape).di.isExpanded = false;\n    }\n  });\n\n  this.reverted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\n\n    var context = e.context;\n    var shape = context.shape;\n\n\n    // revert removing/placing collapsed marker\n    if (!shape.collapsed) {\n      getBusinessObject(shape).di.isExpanded = true;\n\n    } else {\n      getBusinessObject(shape).di.isExpanded = false;\n    }\n  });\n\n  this.postExecuted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\n    var shape = e.context.shape,\n        defaultSize = elementFactory._getDefaultSize(shape),\n        newBounds;\n\n    if (shape.collapsed) {\n\n      // resize to default size of collapsed shapes\n      newBounds = collapsedBounds(shape, defaultSize);\n    } else {\n\n      // resize to bounds of max(visible children, defaultSize)\n      newBounds = expandedBounds(shape, defaultSize);\n    }\n\n    modeling.resizeShape(shape, newBounds);\n  });\n\n}\n\n\ninherits(ToggleElementCollapseBehaviour, CommandInterceptor);\n\nToggleElementCollapseBehaviour.$inject = [\n  'eventBus',\n  'elementFactory',\n  'modeling'\n];\n\nmodule.exports = ToggleElementCollapseBehaviour;\n\n\n\n/////// helpers ///////////////////////////\n\nfunction filterVisible(elements) {\n  return elements.filter(function(e) {\n    return !e.hidden;\n  });\n}","'use strict';\n\nvar forEach = require(386);\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nfunction UnclaimIdBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('elements.delete', function(event) {\n    var context = event.context,\n        elements = context.elements;\n\n    forEach(elements, function(element) {\n      modeling.unclaimId(element.businessObject.id, element.businessObject);\n    });\n\n  });\n}\n\ninherits(UnclaimIdBehavior, CommandInterceptor);\n\nUnclaimIdBehavior.$inject = [ 'eventBus', 'modeling' ];\n\nmodule.exports = UnclaimIdBehavior;","'use strict';\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is,\n    getBusinessObject = require(167).getBusinessObject;\n\n/**\n * A behavior that unsets the Default property of\n * sequence flow source on element delete, if the\n * removed element is the Gateway or Task's default flow.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nfunction DeleteSequenceFlowBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.preExecute('connection.delete', function(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source;\n\n    if (isDefaultFlow(connection, source)) {\n      modeling.updateProperties(source, {\n        'default': null\n      });\n    }\n  });\n}\n\ninherits(DeleteSequenceFlowBehavior, CommandInterceptor);\n\nDeleteSequenceFlowBehavior.$inject = [ 'eventBus', 'modeling' ];\n\nmodule.exports = DeleteSequenceFlowBehavior;\n\n\n/////// helpers ///////////////////////////\n\nfunction isDefaultFlow(connection, source) {\n\n  if (!is(connection, 'bpmn:SequenceFlow')) {\n    return false;\n  }\n\n  var sourceBo = getBusinessObject(source),\n      sequenceFlow = getBusinessObject(connection);\n\n  return sourceBo.get('default') === sequenceFlow;\n}","'use strict';\n\n\nvar inherits = require(368);\n\nvar CommandInterceptor = require(196);\n\nvar is = require(167).is;\n\nvar LOW_PRIORITY = 500,\n    HIGH_PRIORITY = 5000;\n\n\n/**\n * BPMN specific delete lane behavior\n */\nfunction UpdateFlowNodeRefsBehavior(eventBus, modeling, translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Ok, this is it:\n   *\n   * We have to update the Lane#flowNodeRefs _and_\n   * FlowNode#lanes with every FlowNode move/resize and\n   * Lane move/resize.\n   *\n   * We want to group that stuff to recompute containments\n   * as efficient as possible.\n   *\n   * Yea!\n   */\n\n  // the update context\n  var context;\n\n\n  function initContext() {\n    context = context || new UpdateContext();\n    context.enter();\n\n    return context;\n  }\n\n  function getContext() {\n    if (!context) {\n      throw new Error(translate('out of bounds release'));\n    }\n\n    return context;\n  }\n\n  function releaseContext() {\n\n    if (!context) {\n      throw new Error(translate('out of bounds release'));\n    }\n\n    var triggerUpdate = context.leave();\n\n    if (triggerUpdate) {\n      modeling.updateLaneRefs(context.flowNodes, context.lanes);\n\n      context = null;\n    }\n\n    return triggerUpdate;\n  }\n\n\n  var laneRefUpdateEvents = [\n    'spaceTool',\n    'lane.add',\n    'lane.resize',\n    'lane.split',\n    'elements.move',\n    'elements.delete',\n    'shape.create',\n    'shape.delete',\n    'shape.move',\n    'shape.resize'\n  ];\n\n\n  // listen to a lot of stuff to group lane updates\n\n  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY, function(event) {\n    initContext();\n  });\n\n  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY, function(event) {\n    releaseContext();\n  });\n\n\n  // Mark flow nodes + lanes that need an update\n\n  this.preExecute([\n    'shape.create',\n    'shape.move',\n    'shape.delete',\n    'shape.resize'\n  ], function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    var updateContext = getContext();\n\n    // no need to update labels\n    if (shape.labelTarget) {\n      return;\n    }\n\n    if (is(shape, 'bpmn:Lane')) {\n      updateContext.addLane(shape);\n    }\n\n    if (is(shape, 'bpmn:FlowNode')) {\n      updateContext.addFlowNode(shape);\n    }\n  });\n}\n\nUpdateFlowNodeRefsBehavior.$inject = [ 'eventBus', 'modeling' , 'translate'];\n\ninherits(UpdateFlowNodeRefsBehavior, CommandInterceptor);\n\nmodule.exports = UpdateFlowNodeRefsBehavior;\n\n\n\nfunction UpdateContext() {\n\n  this.flowNodes = [];\n  this.lanes = [];\n\n  this.counter = 0;\n\n  this.addLane = function(lane) {\n    this.lanes.push(lane);\n  };\n\n  this.addFlowNode = function(flowNode) {\n    this.flowNodes.push(flowNode);\n  };\n\n  this.enter = function() {\n    this.counter++;\n  };\n\n  this.leave = function() {\n    this.counter--;\n\n    return !this.counter;\n  };\n}","module.exports = {\n  __init__: [\n    'appendBehavior',\n    'copyPasteBehavior',\n    'createBoundaryEventBehavior',\n    'createDataObjectBehavior',\n    'dropOnFlowBehavior',\n    'createParticipantBehavior',\n    'dataInputAssociationBehavior',\n    'deleteLaneBehavior',\n    'importDockingFix',\n    'labelBehavior',\n    'modelingFeedback',\n    'removeParticipantBehavior',\n    'replaceConnectionBehavior',\n    'replaceElementBehaviour',\n    'resizeLaneBehavior',\n    'unsetDefaultFlowBehavior',\n    'updateFlowNodeRefsBehavior',\n    'removeElementBehavior',\n    'unclaimIdBehavior',\n    'toggleElementCollapseBehaviour'\n  ],\n  appendBehavior: [ 'type', require(105) ],\n  copyPasteBehavior: [ 'type', require(106) ],\n  createBoundaryEventBehavior: [ 'type', require(107) ],\n  createDataObjectBehavior: [ 'type', require(108) ],\n  dropOnFlowBehavior: [ 'type', require(112) ],\n  createParticipantBehavior: [ 'type', require(109) ],\n  dataInputAssociationBehavior: [ 'type', require(110) ],\n  deleteLaneBehavior: [ 'type', require(111) ],\n  importDockingFix: [ 'type', require(113) ],\n  labelBehavior: [ 'type', require(114) ],\n  modelingFeedback: [ 'type', require(115) ],\n  removeParticipantBehavior: [ 'type', require(117) ],\n  replaceConnectionBehavior: [ 'type', require(118) ],\n  replaceElementBehaviour: [ 'type', require(119) ],\n  resizeLaneBehavior: [ 'type', require(120) ],\n  unsetDefaultFlowBehavior: [ 'type', require(123) ],\n  updateFlowNodeRefsBehavior: [ 'type', require(124) ],\n  removeElementBehavior: [ 'type', require(116) ],\n  unclaimIdBehavior: [ 'type', require(122) ],\n  toggleElementCollapseBehaviour : [ 'type', require(121) ]\n};\n","'use strict';\n\n/**\n * Returns the length of a vector\n *\n * @param {Vector}\n * @return {Float}\n */\nfunction vectorLength(v) {\n  return Math.sqrt( Math.pow(v.x, 2) + Math.pow(v.y, 2) );\n}\n\nmodule.exports.vectorLength = vectorLength;\n\n/**\n * Calculates the angle between a line a the yAxis\n *\n * @param {Array}\n * @return {Float}\n */\nfunction getAngle(line) {\n  // return value is between 0, 180 and -180, -0\n  // @janstuemmel: maybe replace return a/b with b/a\n  return Math.atan( (line[1].y - line[0].y) / (line[1].x - line[0].x) );\n}\n\nmodule.exports.getAngle = getAngle;\n\n/**\n * Rotates a vector by a given angle\n *\n * @param {Vector}\n * @param {Float} Angle in radians\n * @return {Vector}\n */\nfunction rotateVector(vector, angle) {\n  return (!angle) ? vector : {\n    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,\n    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y\n  };\n}\n\nmodule.exports.rotateVector = rotateVector;\n\n/**\n * Solves a 2D equation system\n * a + r*b = c, where a,b,c are 2D vectors\n *\n * @param {Vector}\n * @param {Vector}\n * @param {Vector}\n * @return {Float}\n */\nfunction solveLambaSystem(a, b, c) {\n\n  // the 2d system\n  var system = [\n    { n: a[0] - c[0], lambda: b[0] },\n    { n: a[1] - c[1], lambda: b[1] }\n  ];\n\n  // solve\n  var n = system[0].n * b[0] + system[1].n * b[1],\n      l = system[0].lambda * b[0] + system[1].lambda * b[1];\n\n  return -n/l;\n}\n\n/**\n * Position of perpendicular foot\n *\n * @param {Point}\n * @param [ {Point}, {Point} ] line defined throug two points\n * @return {Point} the perpendicular foot position\n */\nfunction perpendicularFoot(point, line) {\n\n  var a = line[0], b = line[1];\n\n  // relative position of b from a\n  var bd = { x: b.x - a.x, y: b.y - a.y };\n\n  // solve equation system to the parametrized vectors param real value\n  var r = solveLambaSystem( [ a.x, a.y ], [ bd.x, bd.y ], [ point.x, point.y ] );\n\n  return { x: a.x + r*bd.x, y: a.y + r*bd.y };\n\n}\n\nmodule.exports.perpendicularFoot = perpendicularFoot;\n\n/**\n * Calculates the distance between a point and a line\n *\n * @param {Point}\n * @param [ {Point}, {Point} ] line defined throug two points\n * @return {Float} distance\n */\nfunction getDistancePointLine(point, line) {\n\n  var pfPoint = perpendicularFoot(point, line);\n\n  // distance vector\n  var connectionVector = {\n    x: pfPoint.x - point.x,\n    y: pfPoint.y - point.y\n  };\n\n  return vectorLength(connectionVector);\n}\n\nmodule.exports.getDistancePointLine = getDistancePointLine;\n\n/**\n * Calculates the distance between two points\n *\n * @param {Point}\n * @param {Point}\n * @return {Float} distance\n */\nfunction getDistancePointPoint(point1, point2) {\n\n  return vectorLength({\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  });\n}\n\nmodule.exports.getDistancePointPoint = getDistancePointPoint;\n","'use strict';\n\nvar GeometricUtil = require(126);\n\nvar getDistancePointPoint = require(126).getDistancePointPoint;\n\nvar getAttachment = require(128).getAttachment;\n\n\nfunction findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n\n  var index = attachment.segmentIndex;\n\n  var offset = newWaypoints.length - oldWaypoints.length;\n\n  // segmentMove happend\n  if (hints.segmentMove) {\n\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\n\n    // if label was on moved segment return new segment index\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    }\n\n    // label is after new segment index\n    if (index >= newSegmentStartIndex) {\n      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;\n    }\n\n    // if label is before new segment index\n    return index;\n  }\n\n  // bendpointMove happend\n  if (hints.bendpointMove) {\n\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex;\n\n    // waypoints length didnt change\n    if (offset === 0) {\n      return index;\n    }\n\n    // label behind new/removed bendpoint\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    }\n\n    // label before new/removed bendpoint\n    if (index < bendpointIndex) {\n\n      newIndex = index;\n\n      // decide label should take right or left segment\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {\n\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  }\n\n  // start/end changed\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart) {\n    return (index === 0) ? 0 : null;\n  }\n\n  if (hints.connectionEnd) {\n    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;\n  }\n\n  // if nothing fits, return null\n  return null;\n}\n\nmodule.exports.findNewLabelLineStartIndex = findNewLabelLineStartIndex;\n\n\n/**\n * Calculate the required adjustment (move delta) for the given label\n * after the connection waypoints got updated.\n *\n * @param {djs.model.Label} label\n * @param {Array<Point>} newWaypoints\n * @param {Array<Point>} oldWaypoints\n * @param {Object} hints\n *\n * @return {Point} delta\n */\nfunction getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {\n\n  var x = 0,\n      y = 0;\n\n  var labelPosition = getLabelMid(label);\n\n  // get closest attachment\n  var attachment = getAttachment(labelPosition, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n  if (newLabelLineIndex === null) {\n    return { x: x, y: y };\n  }\n\n  // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n  if (newLabelLineIndex < 0 ||\n      newLabelLineIndex > newWaypoints.length - 2) {\n    return { x: x, y: y };\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\n\n  // special rule if label on bendpoint\n  if (attachment.type === 'bendpoint') {\n\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex];\n\n    // bendpoint position hasnt changed, return same position\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return { x: x, y: y };\n    }\n\n    // new bendpoint and old bendpoint have same index, then just return the offset\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n\n      return {\n        x: newBendpoint.x - attachment.position.x,\n        y: newBendpoint.y - attachment.position.y\n      };\n    }\n\n    // if bendpoints get removed\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  };\n\n  // the rotated vector to label\n  var newLabelVector = GeometricUtil.rotateVector({\n    x: labelPosition.x - oldFoot.x,\n    y: labelPosition.y - oldFoot.y\n  }, angleDelta);\n\n  // the new relative position\n  x = newFoot.x + newLabelVector.x - labelPosition.x;\n  y = newFoot.y + newLabelVector.y - labelPosition.y;\n\n  return { x: x, y: y };\n}\n\nmodule.exports.getLabelAdjustment = getLabelAdjustment;\n\n\n//// HELPERS ///////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);\n\n  var relativePosition = distanceSegment1 / ( distanceSegment1 + distanceSegment2 );\n\n  return relativePosition;\n\n}\n\nfunction getLabelMid(label) {\n  return {\n    x: label.x + label.width / 2,\n    y: label.y + label.height / 2\n  };\n}\n\nfunction getAngleDelta(l1, l2) {\n  var a1 = GeometricUtil.getAngle(l1),\n      a2 = GeometricUtil.getAngle(l2);\n  return a2 - a1;\n}\n\nfunction getLine(waypoints, idx) {\n  return [ waypoints[idx], waypoints[idx+1] ];\n}\n\nfunction getRelativeFootPosition(line, foot) {\n\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n\n  return length === 0 ? 0 : lengthToFoot / length;\n}\n","'use strict';\n\nvar sqrt = Math.sqrt,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\n\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {Number} n\n *\n * @return {Number}\n */\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Number}\n */\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Array<Point>} line\n *\n * @return {Object} attachment\n */\nfunction getAttachment(point, line) {\n\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [ segmentStart ];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    }\n\n    // one intersection -> bendpoint attachment\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    }\n\n    // two intersections -> segment attachment\n    if (intersections.length === 2) {\n\n      attachmentPosition = mid(intersections[0], intersections[1]);\n\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}\n\nmodule.exports.getAttachment = getAttachment;\n\n/**\n * Gets the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {Number} cr circle radius\n *\n * @return {Array<Point>} intersections\n */\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n\n  var disc = pBy2 * pBy2 - q;\n\n  // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  }\n\n  // if disc == 0 ... dealt with later\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) { // abScalingFactor1 == abScalingFactor2\n    return [ i1 ];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  };\n\n  // return only points on line segment\n  return [ i1, i2 ].filter(function(p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\n\n\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return (\n    fenced(p.x, segmentStart.x, segmentEnd.x) &&\n    fenced(p.y, segmentStart.y, segmentEnd.y)\n  );\n}\n\nfunction fenced(n, rangeStart, rangeEnd) {\n\n  // use matching threshold to work around\n  // precisison errors in intersection computation\n\n  return (\n    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&\n    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD\n  );\n}\n\n/**\n * Calculate mid of two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\nfunction mid(p1, p2) {\n\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\n\nvar EQUAL_THRESHOLD = 0.1;\n\nfunction pointsEqual(p1, p2) {\n\n  return (\n    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&\n    abs(p1.y - p2.y) <= EQUAL_THRESHOLD\n  );\n}\n","'use strict';\n\n/**\n * Returns the intersection between two line segments a and b.\n *\n * @param {Point} l1s\n * @param {Point} l1e\n * @param {Point} l2s\n * @param {Point} l2e\n *\n * @return {Point}\n */\nmodule.exports = function lineIntersect(l1s, l1e, l2s, l2e) {\n  // if the lines intersect, the result contains the x and y of the\n  // intersection (treating the lines as infinite) and booleans for\n  // whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, c, numerator;\n\n  denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));\n\n  if (denominator == 0) {\n    return null;\n  }\n\n  a = l1s.y - l2s.y;\n  b = l1s.x - l2s.x;\n  numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);\n\n  c = numerator / denominator;\n\n  // if we cast these lines infinitely in\n  // both directions, they intersect here\n  return {\n    x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),\n    y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))\n  };\n};","'use strict';\n\nvar filter = require(384);\n\nvar Elements = require(343);\n\nvar getLanesRoot = require(139).getLanesRoot,\n    getChildLanes = require(139).getChildLanes,\n    LANE_INDENTATION = require(139).LANE_INDENTATION;\n\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @param {Modeling} modeling\n */\nfunction AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\n\nAddLaneHandler.$inject = [ 'modeling', 'spaceTool' ];\n\nmodule.exports = AddLaneHandler;\n\n\nAddLaneHandler.prototype.preExecute = function(context) {\n\n  var spaceTool = this._spaceTool,\n      modeling = this._modeling;\n\n  var shape = context.shape,\n      location = context.location;\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var isRoot = lanesRoot === shape,\n      laneParent = isRoot ? shape : shape.parent;\n\n  var existingChildLanes = getChildLanes(laneParent);\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    modeling.createShape({ type: 'bpmn:Lane' }, {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    }, laneParent);\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n\n  Elements.eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (element === shape) {\n      return [];\n    }\n\n    return filter(element.children, function(c) {\n      return c !== shape;\n    });\n  });\n\n  var offset = location === 'top' ? -120 : 120,\n      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\n      spacePos = lanePosition + (location === 'top' ? 10 : -10),\n      direction = location === 'top' ? 'n' : 's';\n\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction);\n\n  // (2) create new lane at open space\n  context.newLane = modeling.createShape({ type: 'bpmn:Lane' }, {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  }, laneParent);\n};\n","'use strict';\n\n\nfunction IdClaimHandler(moddle) {\n  this._moddle = moddle;\n}\n\nIdClaimHandler.$inject = [ 'moddle' ];\n\nmodule.exports = IdClaimHandler;\n\n\nIdClaimHandler.prototype.execute = function(context) {\n  var ids = this._moddle.ids,\n      id = context.id,\n      element = context.element,\n      claiming = context.claiming;\n\n  if (claiming) {\n    ids.claim(id, element);\n  } else {\n    ids.unclaim(id);\n  }\n};\n\n/**\n * Command revert implementation.\n */\nIdClaimHandler.prototype.revert = function(context) {\n  var ids = this._moddle.ids,\n      id = context.id,\n      element = context.element,\n      claiming = context.claiming;\n\n  if (claiming) {\n    ids.unclaim(id);\n  } else {\n    ids.claim(id, element);\n  }\n};\n\n","'use strict';\n\nvar is = require(167).is;\n\nvar getLanesRoot = require(139).getLanesRoot,\n    computeLanesResize = require(139).computeLanesResize;\n\nvar eachElement = require(343).eachElement;\n\nvar asTRBL = require(329).asTRBL,\n    substractTRBL = require(300).substractTRBL;\n\n\n/**\n * A handler that resizes a lane.\n *\n * @param {Modeling} modeling\n */\nfunction ResizeLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\n\nResizeLaneHandler.$inject = [ 'modeling', 'spaceTool' ];\n\nmodule.exports = ResizeLaneHandler;\n\n\nResizeLaneHandler.prototype.preExecute = function(context) {\n\n  var shape = context.shape,\n      newBounds = context.newBounds,\n      balanced = context.balanced;\n\n  if (balanced !== false) {\n    this.resizeBalanced(shape, newBounds);\n  } else {\n    this.resizeSpace(shape, newBounds);\n  }\n};\n\n\n/**\n * Resize balanced, adjusting next / previous lane sizes.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n */\nResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {\n\n  var modeling = this._modeling;\n\n  var resizeNeeded = computeLanesResize(shape, newBounds);\n\n  // resize the lane\n  modeling.resizeShape(shape, newBounds);\n\n  // resize other lanes as needed\n  resizeNeeded.forEach(function(r) {\n    modeling.resizeShape(r.shape, r.newBounds);\n  });\n};\n\n\n/**\n * Resize, making actual space and moving below / above elements.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n */\nResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {\n  var spaceTool = this._spaceTool;\n\n  var shapeTrbl = asTRBL(shape),\n      newTrbl = asTRBL(newBounds);\n\n  var trblDiff = substractTRBL(newTrbl, shapeTrbl);\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var allAffected = [],\n      allLanes = [];\n\n  eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (is(element, 'bpmn:Lane') || is(element, 'bpmn:Participant')) {\n      allLanes.push(element);\n    }\n\n    return element.children;\n  });\n\n  var change,\n      spacePos,\n      direction,\n      offset,\n      adjustments;\n\n  if (trblDiff.bottom || trblDiff.top) {\n\n    change = trblDiff.bottom || trblDiff.top;\n    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);\n    direction = trblDiff.bottom ? 's' : 'n';\n\n    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;\n\n    adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);\n  }\n\n\n  if (trblDiff.left || trblDiff.right) {\n\n    change = trblDiff.right || trblDiff.left;\n    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);\n    direction = trblDiff.right ? 'e' : 'w';\n\n    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;\n\n    adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);\n\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);\n  }\n};","'use strict';\r\n\r\nvar assign = require(516),\r\n    forEach = require(386);\r\n\r\nfunction SetColorHandler(commandStack) {\r\n  this._commandStack = commandStack;\r\n}\r\n\r\nSetColorHandler.$inject = [ 'commandStack' ];\r\n\r\nmodule.exports = SetColorHandler;\r\n\r\nSetColorHandler.prototype.postExecute = function(context) {\r\n  var elements = context.elements,\r\n      colors = context.colors || { fill: undefined, stroke: undefined };\r\n\r\n  var that = this;\r\n\r\n  var di = {};\r\n\r\n  if ('fill' in colors) {\r\n    assign(di, { fill: colors.fill });\r\n  }\r\n\r\n  if ('stroke' in colors) {\r\n    assign(di, { stroke: colors.stroke });\r\n  }\r\n\r\n  forEach(elements, function(element) {\r\n    that._commandStack.execute('element.updateProperties', {\r\n      element: element,\r\n      properties: {\r\n        di: di\r\n      }\r\n    });\r\n  });\r\n\r\n};\r\n\r\nSetColorHandler.prototype.execute = function(context) {};\r\n\r\nSetColorHandler.prototype.revert = function(context) {};\r\n","'use strict';\n\nvar getChildLanes = require(139).getChildLanes;\n\nvar LANE_INDENTATION = require(139).LANE_INDENTATION;\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if neccessary.\n *\n * @param {Modeling} modeling\n */\nfunction SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\n\nSplitLaneHandler.$inject = [ 'modeling', 'translate'];\n\nmodule.exports = SplitLaneHandler;\n\n\nSplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling,\n      translate = this._translate;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\n\n  // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n  var laneY,\n      laneHeight,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    laneY = shape.y + idx * newLanesHeight;\n\n    // if bottom lane\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - (newLanesHeight * idx);\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};\n","'use strict';\n\nvar Collections = require(340);\n\n\nfunction UpdateCanvasRootHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\n\nUpdateCanvasRootHandler.$inject = [ 'canvas', 'modeling' ];\n\nmodule.exports = UpdateCanvasRootHandler;\n\n\nUpdateCanvasRootHandler.prototype.execute = function(context) {\n\n  var canvas = this._canvas;\n\n  var newRoot = context.newRoot,\n      newRootBusinessObject = newRoot.businessObject,\n      oldRoot = canvas.getRootElement(),\n      oldRootBusinessObject = oldRoot.businessObject,\n      bpmnDefinitions = oldRootBusinessObject.$parent,\n      diPlane = oldRootBusinessObject.di;\n\n  // (1) replace process old <> new root\n  canvas.setRootElement(newRoot, true);\n\n  // (2) update root elements\n  Collections.add(bpmnDefinitions.rootElements, newRootBusinessObject);\n  newRootBusinessObject.$parent = bpmnDefinitions;\n\n  Collections.remove(bpmnDefinitions.rootElements, oldRootBusinessObject);\n  oldRootBusinessObject.$parent = null;\n\n  // (3) wire di\n  oldRootBusinessObject.di = null;\n\n  diPlane.bpmnElement = newRootBusinessObject;\n  newRootBusinessObject.di = diPlane;\n\n  context.oldRoot = oldRoot;\n\n  // TODO(nikku): return changed elements?\n  // return [ newRoot, oldRoot ];\n};\n\n\nUpdateCanvasRootHandler.prototype.revert = function(context) {\n\n  var canvas = this._canvas;\n\n  var newRoot = context.newRoot,\n      newRootBusinessObject = newRoot.businessObject,\n      oldRoot = context.oldRoot,\n      oldRootBusinessObject = oldRoot.businessObject,\n      bpmnDefinitions = newRootBusinessObject.$parent,\n      diPlane = newRootBusinessObject.di;\n\n  // (1) replace process old <> new root\n  canvas.setRootElement(oldRoot, true);\n\n  // (2) update root elements\n  Collections.remove(bpmnDefinitions.rootElements, newRootBusinessObject);\n  newRootBusinessObject.$parent = null;\n\n  Collections.add(bpmnDefinitions.rootElements, oldRootBusinessObject);\n  oldRootBusinessObject.$parent = bpmnDefinitions;\n\n  // (3) wire di\n  newRootBusinessObject.di = null;\n\n  diPlane.bpmnElement = oldRootBusinessObject;\n  oldRootBusinessObject.di = diPlane;\n\n  // TODO(nikku): return changed elements?\n  // return [ newRoot, oldRoot ];\n};","'use strict';\n\nvar collectLanes = require(139).collectLanes;\n\nvar getLanesRoot = require(139).getLanesRoot;\n\nvar is = require(167).is;\n\nvar Collections = require(340);\n\nvar asTRBL = require(329).asTRBL;\n\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n    LANES_ATTR = 'lanes';\n\n/**\n * A handler that updates lane refs on changed elements\n */\nfunction UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\n\nUpdateFlowNodeRefsHandler.$inject = [ 'elementRegistry' ];\n\nmodule.exports = UpdateFlowNodeRefsHandler;\n\n\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {\n\n  var handledNodes = {};\n\n  var updates = [];\n\n  var participantCache = {};\n\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n\n    var laneTrbl = asTRBL(laneShape);\n\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n\n    return elementMid.x > laneTrbl.left &&\n           elementMid.x < laneTrbl.right &&\n           elementMid.y > laneTrbl.top &&\n           elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (!handledNodes[flowNodeShape.id]) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes[flowNodeShape.id] = flowNodeShape;\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n\n    return allLaneShapes.filter(function(l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function(shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function(laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes[root.id]) {\n      return;\n    }\n\n    var children = root.children.filter(function(c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n\n    children.forEach(addFlowNodeShape);\n\n    handledNodes[root.id] = root;\n  });\n\n  flowNodeShapes.forEach(addFlowNodeShape);\n\n\n  allFlowNodeShapes.forEach(function(flowNodeShape) {\n\n    var flowNode = flowNodeShape.businessObject;\n\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n\n    updates.push({ flowNode: flowNode, remove: remove, add: add });\n  });\n\n  laneShapes.forEach(function(laneShape) {\n\n    var lane = laneShape.businessObject;\n\n    // lane got removed XX-)\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {\n        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });\n      });\n    }\n  });\n\n  return updates;\n};\n\nUpdateFlowNodeRefsHandler.prototype.execute = function(context) {\n\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire old\n    update.remove.forEach(function(oldLane) {\n      Collections.remove(lanes, oldLane);\n      Collections.remove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire new\n    update.add.forEach(function(newLane) {\n      Collections.add(lanes, newLane);\n      Collections.add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\n\nUpdateFlowNodeRefsHandler.prototype.revert = function(context) {\n\n  var updates = context.updates;\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire new\n    update.add.forEach(function(newLane) {\n      Collections.remove(lanes, newLane);\n      Collections.remove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire old\n    update.remove.forEach(function(oldLane) {\n      Collections.add(lanes, oldLane);\n      Collections.add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};","'use strict';\n\nvar reduce = require(525),\n    keys = require(519),\n    forEach = require(386),\n    assign = require(516);\n\nvar getBusinessObject = require(167).getBusinessObject;\n\nvar TextUtil = require(357);\n\nvar DEFAULT_FLOW = 'default',\n    NAME = 'name',\n    ID = 'id',\n    DI = 'di';\n\nvar NULL_DIMENSIONS = {\n  width: 0,\n  height: 0\n};\n\n/**\n * A handler that implements a BPMN 2.0 property update.\n *\n * This should be used to set simple properties on elements with\n * an underlying BPMN business object.\n *\n * Use respective diagram-js provided handlers if you would\n * like to perform automated modeling.\n */\nfunction UpdatePropertiesHandler(elementRegistry, moddle, translate, modeling) {\n  this._elementRegistry = elementRegistry;\n  this._moddle = moddle;\n  this._translate = translate;\n  this._modeling = modeling;\n\n  this._textUtil = new TextUtil();\n}\n\nUpdatePropertiesHandler.$inject = [ 'elementRegistry', 'moddle', 'translate', 'modeling' ];\n\nmodule.exports = UpdatePropertiesHandler;\n\n\n////// api /////////////////////////////////////////////\n\n/**\n * Updates a BPMN element with a list of new properties\n *\n * @param {Object} context\n * @param {djs.model.Base} context.element the element to update\n * @param {Object} context.properties a list of properties to set on the element's\n *                                    businessObject (the BPMN model element)\n *\n * @return {Array<djs.model.Base>} the updated element\n */\nUpdatePropertiesHandler.prototype.execute = function(context) {\n\n  var element = context.element,\n      changed = [ element ],\n      translate = this._translate;\n\n  if (!element) {\n    throw new Error(translate('element required'));\n  }\n\n  var elementRegistry = this._elementRegistry,\n      ids = this._moddle.ids;\n\n  var businessObject = element.businessObject,\n      properties = unwrapBusinessObjects(context.properties),\n      oldProperties = context.oldProperties || getProperties(businessObject, properties);\n\n  if (isIdChange(properties, businessObject)) {\n    ids.unclaim(businessObject[ID]);\n\n    elementRegistry.updateId(element, properties[ID]);\n\n    ids.claim(properties[ID], businessObject);\n  }\n\n  // correctly indicate visual changes on default flow updates\n  if (DEFAULT_FLOW in properties) {\n\n    if (properties[DEFAULT_FLOW]) {\n      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));\n    }\n\n    if (businessObject[DEFAULT_FLOW]) {\n      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));\n    }\n  }\n\n  if (NAME in properties && element.label) {\n    changed.push(element.label);\n\n    // show the label\n    element.label.hidden = !properties[NAME];\n  }\n\n  if (DI in properties && businessObject.di) {\n    setDiProperties(businessObject.di, properties.di);\n  }\n\n  // update properties\n  setProperties(businessObject, properties);\n\n  // store old values\n  context.oldProperties = oldProperties;\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};\n\n\nUpdatePropertiesHandler.prototype.postExecute = function(context) {\n  var element = context.element,\n      label = element.label;\n\n  var text = label && getBusinessObject(label).name;\n\n  if (!text) {\n    return;\n  }\n\n  // get layouted text bounds and resize external\n  // external label accordingly\n  var newLabelBounds = getLayoutedBounds(label, text, this._textUtil);\n\n  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);\n};\n\n/**\n * Reverts the update on a BPMN elements properties.\n *\n * @param  {Object} context\n *\n * @return {djs.model.Base} the updated element\n */\nUpdatePropertiesHandler.prototype.revert = function(context) {\n\n  var element = context.element,\n      properties = context.properties,\n      oldProperties = context.oldProperties,\n      businessObject = element.businessObject,\n      elementRegistry = this._elementRegistry,\n      ids = this._moddle.ids;\n\n  if (DI in oldProperties && businessObject.di) {\n    setDiProperties(businessObject.di, oldProperties.di);\n  }\n\n  // update properties\n  setProperties(businessObject, oldProperties);\n\n  if (isIdChange(properties, businessObject)) {\n    ids.unclaim(properties[ID]);\n\n    elementRegistry.updateId(element, oldProperties[ID]);\n\n    ids.claim(oldProperties[ID], businessObject);\n  }\n\n  return context.changed;\n};\n\n\nfunction isIdChange(properties, businessObject) {\n  return ID in properties && properties[ID] !== businessObject[ID];\n}\n\n\nfunction getProperties(businessObject, properties) {\n  var propertyNames = keys(properties);\n\n  return reduce(propertyNames, function(result, key) {\n\n    // handle DI seperately\n    if (key !== DI) {\n      result[key] = businessObject.get(key);\n    } else {\n      result[key] = getDiProperties(businessObject.di, keys(properties.di));\n    }\n\n    return result;\n  }, {});\n}\n\n\nfunction getDiProperties(di, propertyNames) {\n  return reduce(propertyNames, function(result, key) {\n    result[key] = di.get(key);\n\n    return result;\n  }, {});\n}\n\n\nfunction setProperties(businessObject, properties) {\n  forEach(properties, function(value, key) {\n    businessObject.set(key, value);\n  });\n}\n\n\nfunction setDiProperties(di, properties) {\n  forEach(properties, function(value, key) {\n    di.set(key, value);\n  });\n}\n\n\nvar referencePropertyNames = [ 'default' ];\n\n/**\n * Make sure we unwrap the actual business object\n * behind diagram element that may have been\n * passed as arguments.\n *\n * @param  {Object} properties\n *\n * @return {Object} unwrappedProps\n */\nfunction unwrapBusinessObjects(properties) {\n\n  var unwrappedProps = assign({}, properties);\n\n  referencePropertyNames.forEach(function(name) {\n    if (name in properties) {\n      unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);\n    }\n  });\n\n  return unwrappedProps;\n}\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}","module.exports = {\n  __init__: [ 'modeling', 'bpmnUpdater' ],\n  __depends__: [\n    require(125),\n    require(99),\n    require(154),\n    require(142),\n    require(152),\n    require(198),\n    require(321),\n    require(251),\n    require(212),\n    require(310),\n    require(224),\n    require(317)\n  ],\n  bpmnFactory: [ 'type', require(100) ],\n  bpmnUpdater: [ 'type', require(102) ],\n  elementFactory: [ 'type', require(103) ],\n  modeling: [ 'type', require(104) ],\n  layouter: [ 'type', require(101) ],\n  connectionDocking: [ 'type', require(328) ]\n};\n","'use strict';\n\nvar is = require(167).is;\n\nvar getParent = require(140).getParent;\n\nvar asTRBL = require(329).asTRBL,\n    substractTRBL = require(300).substractTRBL,\n    resizeTRBL = require(300).resizeTRBL;\n\nvar abs = Math.abs;\n\n\nfunction getTRBLResize(oldBounds, newBounds) {\n  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));\n}\n\n\nvar LANE_PARENTS = [\n  'bpmn:Participant',\n  'bpmn:Process',\n  'bpmn:SubProcess'\n];\n\nvar LANE_INDENTATION = 30;\n\nmodule.exports.LANE_INDENTATION = LANE_INDENTATION;\n\n\n/**\n * Collect all lane shapes in the given paren\n *\n * @param  {djs.model.Shape} shape\n * @param  {Array<djs.model.Base>} [collectedShapes]\n *\n * @return {Array<djs.model.Base>}\n */\nfunction collectLanes(shape, collectedShapes) {\n\n  collectedShapes = collectedShapes || [];\n\n  shape.children.filter(function(s) {\n    if (is(s, 'bpmn:Lane')) {\n      collectLanes(s, collectedShapes);\n\n      collectedShapes.push(s);\n    }\n  });\n\n  return collectedShapes;\n}\n\nmodule.exports.collectLanes = collectLanes;\n\n/**\n * Return the lane children of the given element.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Array<djs.model.Shape>}\n */\nfunction getChildLanes(shape) {\n  return shape.children.filter(function(c) {\n    return is(c, 'bpmn:Lane');\n  });\n}\n\nmodule.exports.getChildLanes = getChildLanes;\n\n/**\n * Return the root element containing the given lane shape\n *\n * @param {djs.model.Shape} shape\n *\n * @return {djs.model.Shape}\n */\nfunction getLanesRoot(shape) {\n  return getParent(shape, LANE_PARENTS) || shape;\n}\n\nmodule.exports.getLanesRoot = getLanesRoot;\n\n\n/**\n * Compute the required resize operations for lanes\n * adjacent to the given shape, assuming it will be\n * resized to the given new bounds.\n *\n * @param {djs.model.Shape} shape\n * @param {Bounds} newBounds\n *\n * @return {Array<Object>}\n */\nfunction computeLanesResize(shape, newBounds) {\n\n  var rootElement = getLanesRoot(shape);\n\n  var initialShapes = is(rootElement, 'bpmn:Process') ? [] : [ rootElement ];\n\n  var allLanes = collectLanes(rootElement, initialShapes),\n      shapeTrbl = asTRBL(shape),\n      shapeNewTrbl = asTRBL(newBounds),\n      trblResize = getTRBLResize(shape, newBounds),\n      resizeNeeded = [];\n\n  allLanes.forEach(function(other) {\n\n    if (other === shape) {\n      return;\n    }\n\n    var topResize = 0,\n        rightResize = trblResize.right,\n        bottomResize = 0,\n        leftResize = trblResize.left;\n\n    var otherTrbl = asTRBL(other);\n\n    if (trblResize.top) {\n      if (abs(otherTrbl.bottom - shapeTrbl.top) < 10) {\n        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;\n      }\n\n      if (abs(otherTrbl.top - shapeTrbl.top) < 5) {\n        topResize = shapeNewTrbl.top - otherTrbl.top;\n      }\n    }\n\n    if (trblResize.bottom) {\n      if (abs(otherTrbl.top - shapeTrbl.bottom) < 10) {\n        topResize = shapeNewTrbl.bottom - otherTrbl.top;\n      }\n\n      if (abs(otherTrbl.bottom - shapeTrbl.bottom) < 5) {\n        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;\n      }\n    }\n\n    if (topResize || rightResize || bottomResize || leftResize) {\n\n      resizeNeeded.push({\n        shape: other,\n        newBounds: resizeTRBL(other, {\n          top: topResize,\n          right: rightResize,\n          bottom: bottomResize,\n          left: leftResize\n        })\n      });\n    }\n\n  });\n\n  return resizeNeeded;\n}\n\nmodule.exports.computeLanesResize = computeLanesResize;\n","'use strict';\n\nvar any = require(382);\n\nvar is = require(167).is;\n\n\n/**\n * Return true if element has any of the given types.\n *\n * @param {djs.model.Base} element\n * @param {Array<String>} types\n *\n * @return {Boolean}\n */\nfunction isAny(element, types) {\n  return any(types, function(t) {\n    return is(element, t);\n  });\n}\n\nmodule.exports.isAny = isAny;\n\n\n/**\n * Return the parent of the element with any of the given types.\n *\n * @param {djs.model.Base} element\n * @param {String|Array<String>} anyType\n *\n * @return {djs.model.Base}\n */\nfunction getParent(element, anyType) {\n\n  if (typeof anyType === 'string') {\n    anyType = [ anyType ];\n  }\n\n  while ((element = element.parent)) {\n    if (isAny(element, anyType)) {\n      return element;\n    }\n  }\n\n  return null;\n}\n\nmodule.exports.getParent = getParent;\n","'use strict';\n\nvar inherits = require(368);\n\nvar OrderingProvider = require(284);\n\nvar isAny = require(140).isAny;\n\nvar findIndex = require(371);\n\nvar find = require(385);\n\n\n/**\n * a simple ordering provider that makes sure:\n *\n * (1) elements are ordered by a {level} property\n * (2) elements with {alwaysOnTop} are always added to the root\n */\nfunction BpmnOrderingProvider(eventBus, translate) {\n\n  OrderingProvider.call(this, eventBus);\n\n  var orders = [\n    { type: 'bpmn:SubProcess', order: { level: 6 } },\n    {\n      type: 'bpmn:SequenceFlow',\n      order: {\n        level: 5,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer'\n        ]\n      }\n    },\n    // handle DataAssociation(s) like message flows and render them always on top\n    { type: 'bpmn:DataAssociation', order: { level: 9, containers: [ 'bpmn:Collaboration', 'bpmn:Process' ] } },\n    { type: 'bpmn:MessageFlow', order: { level: 9, containers: [ 'bpmn:Collaboration' ] } },\n    {\n      type: 'bpmn:Association',\n      order: {\n        level: 6,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer',\n          'bpmn:Collaboration'\n        ]\n      }\n    },\n    { type: 'bpmn:BoundaryEvent', order: { level: 8 } },\n    { type: 'bpmn:Participant', order: { level: -2 } },\n    { type: 'bpmn:Lane', order: { level: -1 } }\n  ];\n\n  function computeOrder(element) {\n    if (element.labelTarget) {\n      return { level: 10 };\n    }\n\n    var entry = find(orders, function(o) {\n      return isAny(element, [ o.type ]);\n    });\n\n    return entry && entry.order || { level: 1 };\n  }\n\n  function getOrder(element) {\n\n    var order = element.order;\n\n    if (!order) {\n      element.order = order = computeOrder(element);\n    }\n\n    return order;\n  }\n\n  function findActualParent(element, newParent, containers) {\n\n    var actualParent = newParent;\n\n    while (actualParent) {\n\n      if (isAny(actualParent, containers)) {\n        break;\n      }\n\n      actualParent = actualParent.parent;\n    }\n\n    if (!actualParent) {\n      throw new Error(translate('no parent for {element} in {parent}', {\n        element: element.id,\n        parent: newParent.id\n      }));\n    }\n\n    return actualParent;\n  }\n\n  this.getOrdering = function(element, newParent) {\n\n    var elementOrder = getOrder(element);\n\n\n    if (elementOrder.containers) {\n      newParent = findActualParent(element, newParent, elementOrder.containers);\n    }\n\n\n    var currentIndex = newParent.children.indexOf(element);\n\n    var insertIndex = findIndex(newParent.children, function(child) {\n\n      // do not compare with labels, they are created\n      // in the wrong order (right after elements) during import and\n      // mess up the positioning.\n      if (!element.labelTarget && child.labelTarget) {\n        return false;\n      }\n\n      return elementOrder.level < getOrder(child).level;\n    });\n\n\n    // if the element is already in the child list at\n    // a smaller index, we need to adjust the inser index.\n    // this takes into account that the element is being removed\n    // before being re-inserted\n    if (insertIndex !== -1) {\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\n        insertIndex -= 1;\n      }\n    }\n\n    return {\n      index: insertIndex,\n      parent: newParent\n    };\n  };\n}\n\nBpmnOrderingProvider.$inject = [ 'eventBus', 'translate' ];\n\ninherits(BpmnOrderingProvider, OrderingProvider);\n\nmodule.exports = BpmnOrderingProvider;\n","module.exports = {\n  __init__: [ 'bpmnOrderingProvider' ],\n  __depends__: [\n    require(325)\n  ],\n  bpmnOrderingProvider: [ 'type', require(141) ]\n};","'use strict';\n\nvar assign = require(516);\n\n/**\n * A palette provider for BPMN 2.0 elements.\n */\nfunction PaletteProvider(palette, create, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate) {\n\n  this._palette = palette;\n  this._create = create;\n  this._elementFactory = elementFactory;\n  this._spaceTool = spaceTool;\n  this._lassoTool = lassoTool;\n  this._handTool = handTool;\n  this._globalConnect = globalConnect;\n  this._translate = translate;\n\n  palette.registerProvider(this);\n}\n\nmodule.exports = PaletteProvider;\n\nPaletteProvider.$inject = [\n  'palette',\n  'create',\n  'elementFactory',\n  'spaceTool',\n  'lassoTool',\n  'handTool',\n  'globalConnect',\n  'translate'\n];\n\n\nPaletteProvider.prototype.getPaletteEntries = function(element) {\n\n  var actions  = {},\n      create = this._create,\n      elementFactory = this._elementFactory,\n      spaceTool = this._spaceTool,\n      lassoTool = this._lassoTool,\n      handTool = this._handTool,\n      globalConnect = this._globalConnect,\n      translate = this._translate;\n\n  function createAction(type, group, className, title, options) {\n\n    function createListener(event) {\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n\n      if (options) {\n        shape.businessObject.di.isExpanded = options.isExpanded;\n      }\n\n      create.start(event, shape);\n    }\n\n    var shortType = type.replace(/^bpmn/:/, '');\n\n    return {\n      group: group,\n      className: className,\n      title: title || translate('Create {type}', { type: translate(shortType) }),\n      action: {\n        dragstart: createListener,\n        click: createListener\n      }\n    };\n  }\n\n  function createParticipant(event, collapsed) {\n    create.start(event, elementFactory.createParticipantShape(collapsed));\n  }\n\n  assign(actions, {\n    'hand-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-hand-tool',\n      title: translate('Activate the hand tool'),\n      action: {\n        click: function(event) {\n          handTool.activateHand(event);\n        }\n      }\n    },\n    'lasso-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-lasso-tool',\n      title: translate('Activate the lasso tool'),\n      action: {\n        click: function(event) {\n          lassoTool.activateSelection(event);\n        }\n      }\n    },\n    'space-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-space-tool',\n      title: translate('Activate the create/remove space tool'),\n      action: {\n        click: function(event) {\n          spaceTool.activateSelection(event);\n        }\n      }\n    },\n    'global-connect-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-connection-multi',\n      title: translate('Activate the global connect tool'),\n      action: {\n        click: function(event) {\n          globalConnect.toggle(event);\n        }\n      }\n    },\n    'tool-separator': {\n      group: 'tools',\n      separator: true\n    },\n    'create.start-event': createAction(\n      'bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none'\n    ),\n    'create.intermediate-event': createAction('bpmn:IntermediateThrowEvent', 'event',\n      'bpmn-icon-intermediate-event-none', translate('Create IntermediateThrowEvent/BoundaryEvent')\n    ),\n    'create.end-event': createAction(\n      'bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none'\n    ),\n    'create.exclusive-gateway': createAction(\n      'bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-xor'\n    ),\n    'create.task': createAction(\n      'bpmn:Task', 'activity', 'bpmn-icon-task'\n    ),\n    'create.data-object': createAction(\n      'bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object'\n    ),\n    'create.data-store': createAction(\n      'bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store'\n    ),\n    'create.subprocess-expanded': createAction(\n      'bpmn:SubProcess', 'activity', 'bpmn-icon-subprocess-expanded', translate('Create expanded SubProcess'),\n      { isExpanded: true }\n    ),\n    'create.participant-expanded': {\n      group: 'collaboration',\n      className: 'bpmn-icon-participant',\n      title: translate('Create Pool/Participant'),\n      action: {\n        dragstart: createParticipant,\n        click: createParticipant\n      }\n    }\n  });\n\n  return actions;\n};\n","module.exports = {\n  __depends__: [\n    require(290),\n    require(234),\n    require(317),\n    require(253),\n    require(245),\n    require(325),\n    require(92)\n  ],\n  __init__: [ 'paletteProvider' ],\n  paletteProvider: [ 'type', require(143) ]\n};\n","'use strict';\n\nvar is = require(167).is,\n    isEventSubProcess = require(165).isEventSubProcess,\n    getBusinessObject = require(167).getBusinessObject,\n    isExpanded = require(165).isExpanded,\n    isDifferentType = require(147).isDifferentType;\n\nvar forEach = require(386),\n    filter = require(384),\n    reject = require(391);\n\nvar replaceOptions = require(151);\n\n\n/**\n * This module is an element agnostic replace menu provider for the popup menu.\n */\nfunction ReplaceMenuProvider(popupMenu, modeling, moddle, bpmnReplace, rules, translate) {\n\n  this._popupMenu = popupMenu;\n  this._modeling = modeling;\n  this._moddle = moddle;\n  this._bpmnReplace = bpmnReplace;\n  this._rules = rules;\n  this._translate = translate;\n\n  this.register();\n}\n\nReplaceMenuProvider.$inject = [ 'popupMenu', 'modeling', 'moddle', 'bpmnReplace', 'rules', 'translate' ];\n\n\n/**\n * Register replace menu provider in the popup menu\n */\nReplaceMenuProvider.prototype.register = function() {\n  this._popupMenu.registerProvider('bpmn-replace', this);\n};\n\n\n/**\n * Get all entries from replaceOptions for the given element and apply filters\n * on them. Get for example only elements, which are different from the current one.\n *\n * @param {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu entry items\n */\nReplaceMenuProvider.prototype.getEntries = function(element) {\n\n  var businessObject = element.businessObject;\n\n  var rules = this._rules;\n\n  var entries;\n\n  if (!rules.allowed('shape.replace', { element: element })) {\n    return [];\n  }\n\n  var differentType = isDifferentType(element);\n\n  // start events outside event sub processes\n  if (is(businessObject, 'bpmn:StartEvent') && !isEventSubProcess(businessObject.$parent)) {\n\n    entries = filter(replaceOptions.START_EVENT, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded/collapsed pools\n  if (is(businessObject, 'bpmn:Participant')) {\n\n    entries = filter(replaceOptions.PARTICIPANT, function(entry) {\n      return isExpanded(businessObject) !== entry.target.isExpanded;\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // start events inside event sub processes\n  if (is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent)) {\n\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS_START_EVENT, function(entry) {\n\n      var target = entry.target;\n\n      var isInterrupting = target.isInterrupting !== false;\n\n      var isInterruptingEqual = getBusinessObject(element).isInterrupting === isInterrupting;\n\n      // filters elements which types and event definition are equal but have have different interrupting types\n      return differentType(entry) || !differentType(entry) && !isInterruptingEqual;\n\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // end events\n  if (is(businessObject, 'bpmn:EndEvent')) {\n\n    entries = filter(replaceOptions.END_EVENT, function(entry) {\n      var target = entry.target;\n\n      // hide cancel end events outside transactions\n      if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.$parent, 'bpmn:Transaction')) {\n        return false;\n      }\n\n      return differentType(entry);\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // boundary events\n  if (is(businessObject, 'bpmn:BoundaryEvent')) {\n\n    entries = filter(replaceOptions.BOUNDARY_EVENT, function(entry) {\n\n      var target = entry.target;\n\n      if (target.eventDefinition == 'bpmn:CancelEventDefinition' &&\n         !is(businessObject.attachedToRef, 'bpmn:Transaction')) {\n        return false;\n      }\n      var cancelActivity = target.cancelActivity !== false;\n\n      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;\n\n      return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // intermediate events\n  if (is(businessObject, 'bpmn:IntermediateCatchEvent') ||\n      is(businessObject, 'bpmn:IntermediateThrowEvent')) {\n\n    entries = filter(replaceOptions.INTERMEDIATE_EVENT, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // gateways\n  if (is(businessObject, 'bpmn:Gateway')) {\n\n    entries = filter(replaceOptions.GATEWAY, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // transactions\n  if (is(businessObject, 'bpmn:Transaction')) {\n\n    entries = filter(replaceOptions.TRANSACTION, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded event sub processes\n  if (isEventSubProcess(businessObject) && isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded sub processes\n  if (is(businessObject, 'bpmn:SubProcess') && isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.SUBPROCESS_EXPANDED, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // collapsed ad hoc sub processes\n  if (is(businessObject, 'bpmn:AdHocSubProcess') && !isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.TASK, function(entry) {\n\n      var target = entry.target;\n\n      var isTargetSubProcess = target.type === 'bpmn:SubProcess';\n\n      var isTargetExpanded = target.isExpanded === true;\n\n      return isDifferentType(element, target) && ( !isTargetSubProcess || isTargetExpanded );\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // sequence flows\n  if (is(businessObject, 'bpmn:SequenceFlow')) {\n    return this._createSequenceFlowEntries(element, replaceOptions.SEQUENCE_FLOW);\n  }\n\n  // flow nodes\n  if (is(businessObject, 'bpmn:FlowNode')) {\n    entries = filter(replaceOptions.TASK, differentType);\n\n    // collapsed SubProcess can not be replaced with itself\n    if (is(businessObject, 'bpmn:SubProcess') && !isExpanded(businessObject)) {\n      entries = reject(entries, function(entry) {\n        return entry.label === 'Sub Process (collapsed)';\n      });\n    }\n\n    return this._createEntries(element, entries);\n  }\n\n  return [];\n};\n\n\n/**\n * Get a list of header items for the given element. This includes buttons\n * for multi instance markers and for the ad hoc marker.\n *\n * @param {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu entry items\n */\nReplaceMenuProvider.prototype.getHeaderEntries = function(element) {\n\n  var headerEntries = [];\n\n  if (is(element, 'bpmn:Activity') && !isEventSubProcess(element)) {\n    headerEntries = headerEntries.concat(this._getLoopEntries(element));\n  }\n\n  if (is(element, 'bpmn:SubProcess') &&\n      !is(element, 'bpmn:Transaction') &&\n      !isEventSubProcess(element)) {\n    headerEntries.push(this._getAdHocEntry(element));\n  }\n\n  return headerEntries;\n};\n\n\n/**\n * Creates an array of menu entry objects for a given element and filters the replaceOptions\n * according to a filter function.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} replaceOptions\n *\n * @return {Array<Object>} a list of menu items\n */\nReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {\n  var menuEntries = [];\n\n  var self = this;\n\n  forEach(replaceOptions, function(definition) {\n    var entry = self._createMenuEntry(definition, element);\n\n    menuEntries.push(entry);\n  });\n\n  return menuEntries;\n};\n\n/**\n * Creates an array of menu entry objects for a given sequence flow.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} replaceOptions\n\n * @return {Array<Object>} a list of menu items\n */\nReplaceMenuProvider.prototype._createSequenceFlowEntries = function(element, replaceOptions) {\n\n  var businessObject = getBusinessObject(element);\n\n  var menuEntries = [];\n\n  var modeling = this._modeling,\n      moddle = this._moddle;\n\n  var self = this;\n\n  forEach(replaceOptions, function(entry) {\n\n    switch (entry.actionName) {\n    case 'replace-with-default-flow':\n      if (businessObject.sourceRef.default !== businessObject &&\n            (is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||\n             is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||\n             is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||\n             is(businessObject.sourceRef, 'bpmn:Activity'))) {\n\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element.source, { default: businessObject });\n        }));\n      }\n      break;\n    case 'replace-with-conditional-flow':\n      if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'bpmn:Activity')) {\n\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\n          var conditionExpression = moddle.create('bpmn:FormalExpression', { body: '' });\n\n          modeling.updateProperties(element, { conditionExpression: conditionExpression });\n        }));\n      }\n      break;\n    default:\n        // default flows\n      if (is(businessObject.sourceRef, 'bpmn:Activity') && businessObject.conditionExpression) {\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element, { conditionExpression: undefined });\n        }));\n      }\n        // conditional flows\n      if ((is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||\n           is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||\n           is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||\n           is(businessObject.sourceRef, 'bpmn:Activity')) &&\n           businessObject.sourceRef.default === businessObject) {\n\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element.source, { default: undefined });\n        }));\n      }\n    }\n  });\n\n  return menuEntries;\n};\n\n\n/**\n * Creates and returns a single menu entry item.\n *\n * @param  {Object} definition a single replace options definition object\n * @param  {djs.model.Base} element\n * @param  {Function} [action] an action callback function which gets called when\n *                             the menu entry is being triggered.\n *\n * @return {Object} menu entry item\n */\nReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {\n  var translate = this._translate;\n  var replaceElement = this._bpmnReplace.replaceElement;\n\n  var replaceAction = function() {\n    return replaceElement(element, definition.target);\n  };\n\n  action = action || replaceAction;\n\n  var menuEntry = {\n    label: translate(definition.label),\n    className: definition.className,\n    id: definition.actionName,\n    action: action\n  };\n\n  return menuEntry;\n};\n\n/**\n * Get a list of menu items containing buttons for multi instance markers\n *\n * @param  {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu items\n */\nReplaceMenuProvider.prototype._getLoopEntries = function(element) {\n\n  var self = this;\n  var translate = this._translate;\n\n  function toggleLoopEntry(event, entry) {\n    var loopCharacteristics;\n\n    if (entry.active) {\n      loopCharacteristics = undefined;\n    } else {\n      loopCharacteristics = self._moddle.create(entry.options.loopCharacteristics);\n\n      if (entry.options.isSequential) {\n        loopCharacteristics.isSequential = entry.options.isSequential;\n      }\n    }\n    self._modeling.updateProperties(element, { loopCharacteristics: loopCharacteristics });\n  }\n\n  var businessObject = getBusinessObject(element),\n      loopCharacteristics = businessObject.loopCharacteristics;\n\n  var isSequential,\n      isLoop,\n      isParallel;\n\n  if (loopCharacteristics) {\n    isSequential = loopCharacteristics.isSequential;\n    isLoop = loopCharacteristics.isSequential === undefined;\n    isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;\n  }\n\n\n  var loopEntries = [\n    {\n      id: 'toggle-parallel-mi',\n      className: 'bpmn-icon-parallel-mi-marker',\n      title: translate('Parallel Multi Instance'),\n      active: isParallel,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',\n        isSequential: false\n      }\n    },\n    {\n      id: 'toggle-sequential-mi',\n      className: 'bpmn-icon-sequential-mi-marker',\n      title: translate('Sequential Multi Instance'),\n      active: isSequential,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',\n        isSequential: true\n      }\n    },\n    {\n      id: 'toggle-loop',\n      className: 'bpmn-icon-loop-marker',\n      title: translate('Loop'),\n      active: isLoop,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:StandardLoopCharacteristics'\n      }\n    }\n  ];\n  return loopEntries;\n};\n\n\n/**\n * Get the menu items containing a button for the ad hoc marker\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} a menu item\n */\nReplaceMenuProvider.prototype._getAdHocEntry = function(element) {\n  var translate = this._translate;\n  var businessObject = getBusinessObject(element);\n\n  var isAdHoc = is(businessObject, 'bpmn:AdHocSubProcess');\n\n  var replaceElement = this._bpmnReplace.replaceElement;\n\n  var adHocEntry = {\n    id: 'toggle-adhoc',\n    className: 'bpmn-icon-ad-hoc-marker',\n    title: translate('Ad-hoc'),\n    active: isAdHoc,\n    action: function(event, entry) {\n      if (isAdHoc) {\n        return replaceElement(element, { type: 'bpmn:SubProcess' });\n      } else {\n        return replaceElement(element, { type: 'bpmn:AdHocSubProcess' });\n      }\n    }\n  };\n\n  return adHocEntry;\n};\n\nmodule.exports = ReplaceMenuProvider;\n","module.exports = {\n  __depends__: [\n    require(292),\n    require(152)\n  ],\n  __init__: [ 'replaceMenuProvider' ],\n  replaceMenuProvider: [ 'type', require(145) ]\n};","'use strict';\n\nvar getBusinessObject = require(167).getBusinessObject;\nvar isExpanded = require(165).isExpanded;\n\n/**\n * Returns true, if an element is from a different type\n * than a target definition. Takes into account the type,\n * event definition type and triggeredByEvent property.\n *\n * @param {djs.model.Base} element\n *\n * @return {Boolean}\n */\nfunction isDifferentType(element) {\n\n  return function(entry) {\n    var target = entry.target;\n\n    var businessObject = getBusinessObject(element),\n        eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];\n\n    var isTypeEqual = businessObject.$type === target.type;\n\n    var isEventDefinitionEqual = (\n      (eventDefinition && eventDefinition.$type) === target.eventDefinitionType\n    );\n\n    var isTriggeredByEventEqual = (\n      businessObject.triggeredByEvent === target.triggeredByEvent\n    );\n\n    var isExpandedEqual = (\n        target.isExpanded === undefined ||\n        target.isExpanded === isExpanded(businessObject)\n    );\n\n    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;\n  };\n}\n\nmodule.exports.isDifferentType = isDifferentType;","'use strict';\n\nvar CommandInterceptor = require(196);\n\nvar inherits = require(368);\n\nvar assign = require(516),\n    forEach = require(386);\n\nvar domQuery = require(538);\n\nvar svgAttr = require(579);\n\nvar LOW_PRIORITY = 250;\n\nfunction BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Replace the visuals of all elements in the context which can be replaced\n   *\n   * @param  {Object} context\n   */\n  function replaceVisual(context) {\n\n    var replacements = context.canExecute.replacements;\n\n    forEach(replacements, function(replacement) {\n\n      var id = replacement.oldElementId;\n\n      var newElement = {\n        type: replacement.newElementType\n      };\n\n      // if the visual of the element is already replaced\n      if (context.visualReplacements[id]) {\n        return;\n      }\n\n      var element = elementRegistry.get(id);\n\n      assign(newElement, { x: element.x, y: element.y });\n\n      // create a temporary shape\n      var tempShape = elementFactory.createShape(newElement);\n\n      canvas.addShape(tempShape, element.parent);\n\n      // select the original SVG element related to the element and hide it\n      var gfx = domQuery('[data-element-id=' + element.id + ']', context.dragGroup);\n\n      if (gfx) {\n        svgAttr(gfx, { display: 'none' });\n      }\n\n      // clone the gfx of the temporary shape and add it to the drag group\n      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);\n\n      context.visualReplacements[id] = dragger;\n\n      canvas.removeShape(tempShape);\n    });\n  }\n\n  /**\n   * Restore the original visuals of the previously replaced elements\n   *\n   * @param  {Object} context\n   */\n  function restoreVisual(context) {\n\n    var visualReplacements = context.visualReplacements;\n\n    forEach(visualReplacements, function(dragger, id) {\n\n      var originalGfx = domQuery('[data-element-id=' + id + ']', context.dragGroup);\n\n      if (originalGfx) {\n        svgAttr(originalGfx, { display: 'inline' });\n      }\n\n      dragger.remove();\n\n      if (visualReplacements[id]) {\n        delete visualReplacements[id];\n      }\n    });\n  }\n\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        canExecute = context.canExecute;\n\n    if (!context.visualReplacements) {\n      context.visualReplacements = {};\n    }\n\n    if (canExecute.replacements) {\n      replaceVisual(context);\n    } else {\n      restoreVisual(context);\n    }\n  });\n}\n\nBpmnReplacePreview.$inject = [ 'eventBus', 'elementRegistry', 'elementFactory', 'canvas', 'previewSupport' ];\n\ninherits(BpmnReplacePreview, CommandInterceptor);\n\nmodule.exports = BpmnReplacePreview;\n","module.exports = {\n  __depends__: [ require(294) ],\n  __init__: [ 'bpmnReplacePreview' ],\n  bpmnReplacePreview: [ 'type', require(148) ]\n};\n","'use strict';\n\nvar pick = require(524),\n    assign = require(516),\n    intersection = require(374),\n    filter = require(384),\n    has = require(518);\n\nvar is = require(167).is,\n    isExpanded = require(165).isExpanded,\n    isEventSubProcess = require(165).isEventSubProcess,\n    ModelCloneUtils = require(170),\n    getProperties = ModelCloneUtils.getProperties;\n\nvar IGNORED_PROPERTIES = ModelCloneUtils.IGNORED_PROPERTIES;\n\nvar ModelCloneHelper = require(169);\n\nvar CUSTOM_PROPERTIES = [\n  'cancelActivity',\n  'instantiate',\n  'eventGatewayType',\n  'triggeredByEvent',\n  'isInterrupting'\n];\n\n\nfunction toggeling(element, target) {\n\n  var oldCollapsed = has(element, 'collapsed') ?\n                     element.collapsed : !isExpanded(element);\n\n  var targetCollapsed;\n\n  if (has(target, 'collapsed') || has(target, 'isExpanded')) {\n    // property is explicitly set so use it\n    targetCollapsed = has(target, 'collapsed') ?\n                      target.collapsed : !target.isExpanded;\n  } else {\n    // keep old state\n    targetCollapsed = oldCollapsed;\n  }\n\n  if (oldCollapsed !== targetCollapsed) {\n    element.collapsed = oldCollapsed;\n    return true;\n  }\n\n  return false;\n}\n\n\n\n/**\n * This module takes care of replacing BPMN elements\n */\nfunction BpmnReplace(bpmnFactory, replace, selection, modeling, eventBus) {\n\n  var helper = new ModelCloneHelper(eventBus);\n\n  /**\n   * Prepares a new business object for the replacement element\n   * and triggers the replace operation.\n   *\n   * @param  {djs.model.Base} element\n   * @param  {Object} target\n   * @param  {Object} [hints]\n   *\n   * @return {djs.model.Base} the newly created element\n   */\n  function replaceElement(element, target, hints) {\n\n    hints = hints || {};\n\n    var type = target.type,\n        oldBusinessObject = element.businessObject;\n\n    if (is(oldBusinessObject, 'bpmn:SubProcess')) {\n      if (type === 'bpmn:SubProcess') {\n        if (toggeling(element, target)) {\n          // expanding or collapsing process\n          modeling.toggleCollapse(element);\n\n          return element;\n        }\n      }\n    }\n\n    var newBusinessObject = bpmnFactory.create(type);\n\n    var newElement = {\n      type: type,\n      businessObject: newBusinessObject\n    };\n\n    var elementProps = getProperties(oldBusinessObject.$descriptor),\n        newElementProps = getProperties(newBusinessObject.$descriptor, true),\n        properties = intersection(elementProps, newElementProps);\n\n    // initialize special properties defined in target definition\n    assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));\n\n    properties = filter(properties, function(property) {\n      var propName = property.replace(/bpmn:/, '');\n\n      // so the applied properties from 'target' don't get lost\n      if (newBusinessObject[property] !== undefined) {\n        return false;\n      }\n\n      // retain loop characteristics if the target element is not an event sub process\n      if (propName === 'loopCharacteristics') {\n        return !isEventSubProcess(newBusinessObject);\n      }\n\n      if ((propName === 'processRef' && target.isExpanded === false) ||\n           propName === 'triggeredByEvent' ||\n           propName === 'eventDefinitions') {\n        return false;\n      }\n\n      return IGNORED_PROPERTIES.indexOf(propName) === -1;\n    });\n\n    newBusinessObject = helper.clone(oldBusinessObject, newBusinessObject, properties);\n\n    // initialize custom BPMN extensions\n    if (target.eventDefinitionType) {\n      newElement.eventDefinitionType = target.eventDefinitionType;\n    }\n\n    if (is(oldBusinessObject, 'bpmn:Activity')) {\n\n      if (is(oldBusinessObject, 'bpmn:SubProcess')) {\n        // no toggeling, so keep old state\n        newElement.isExpanded = isExpanded(oldBusinessObject);\n      }\n      // else if property is explicitly set, use it\n      else if (has(target, 'isExpanded')) {\n        newElement.isExpanded = target.isExpanded;\n      }\n\n      // TODO: need also to respect min/max Size\n      // copy size, from an expanded subprocess to an expanded alternative subprocess\n      // except bpmn:Task, because Task is always expanded\n      if ((isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'bpmn:Task')) && newElement.isExpanded) {\n        newElement.width = element.width;\n        newElement.height = element.height;\n      }\n    }\n\n    // transform collapsed/expanded pools\n    if (is(oldBusinessObject, 'bpmn:Participant')) {\n\n      // create expanded pool\n      if (target.isExpanded === true) {\n        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n      } else {\n        // remove children when transforming to collapsed pool\n        hints.moveChildren = false;\n      }\n\n        // apply same size\n      newElement.width = element.width;\n      newElement.height = element.height;\n    }\n\n    newBusinessObject.name = oldBusinessObject.name;\n\n    // retain default flow's reference between inclusive <-> exclusive gateways and activities\n    if ((is(oldBusinessObject, 'bpmn:ExclusiveGateway') || is(oldBusinessObject, 'bpmn:InclusiveGateway') ||\n         is(oldBusinessObject, 'bpmn:Activity')) &&\n        (is(newBusinessObject, 'bpmn:ExclusiveGateway') || is(newBusinessObject, 'bpmn:InclusiveGateway') ||\n         is(newBusinessObject, 'bpmn:Activity')))\n    {\n      newBusinessObject.default = oldBusinessObject.default;\n    }\n\n    if ('fill' in oldBusinessObject.di || 'stroke' in oldBusinessObject.di) {\n      assign(newElement, { colors: pick(oldBusinessObject.di, [ 'fill', 'stroke' ]) });\n    }\n\n    newElement = replace.replaceElement(element, newElement, hints);\n\n    if (hints.select !== false) {\n      selection.select(newElement);\n    }\n\n    return newElement;\n  }\n\n  this.replaceElement = replaceElement;\n}\n\nBpmnReplace.$inject = [ 'bpmnFactory', 'replace', 'selection', 'modeling', 'eventBus' ];\n\nmodule.exports = BpmnReplace;\n","'use strict';\n\nmodule.exports.START_EVENT = [\n  {\n    label: 'Start Event',\n    actionName: 'replace-with-none-start',\n    className: 'bpmn-icon-start-event-none',\n    target: {\n      type: 'bpmn:StartEvent'\n    }\n  },\n  {\n    label: 'Intermediate Throw Event',\n    actionName: 'replace-with-none-intermediate-throwing',\n    className: 'bpmn-icon-intermediate-event-none',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent'\n    }\n  },\n  {\n    label: 'End Event',\n    actionName: 'replace-with-none-end',\n    className: 'bpmn-icon-end-event-none',\n    target: {\n      type: 'bpmn:EndEvent'\n    }\n  },\n  {\n    label: 'Message Start Event',\n    actionName: 'replace-with-message-start',\n    className: 'bpmn-icon-start-event-message',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Start Event',\n    actionName: 'replace-with-timer-start',\n    className: 'bpmn-icon-start-event-timer',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Start Event',\n    actionName: 'replace-with-conditional-start',\n    className: 'bpmn-icon-start-event-condition',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Start Event',\n    actionName: 'replace-with-signal-start',\n    className: 'bpmn-icon-start-event-signal',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  }\n];\n\nmodule.exports.INTERMEDIATE_EVENT = [\n  {\n    label: 'Start Event',\n    actionName: 'replace-with-none-start',\n    className: 'bpmn-icon-start-event-none',\n    target: {\n      type: 'bpmn:StartEvent'\n    }\n  },\n  {\n    label: 'Intermediate Throw Event',\n    actionName: 'replace-with-none-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-none',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent'\n    }\n  },\n  {\n    label: 'End Event',\n    actionName: 'replace-with-none-end',\n    className: 'bpmn-icon-end-event-none',\n    target: {\n      type: 'bpmn:EndEvent'\n    }\n  },\n  {\n    label: 'Message Intermediate Catch Event',\n    actionName: 'replace-with-message-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-message',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Message Intermediate Throw Event',\n    actionName: 'replace-with-message-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-message',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Intermediate Catch Event',\n    actionName: 'replace-with-timer-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-timer',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation Intermediate Throw Event',\n    actionName: 'replace-with-escalation-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-escalation',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Intermediate Catch Event',\n    actionName: 'replace-with-conditional-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-condition',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Link Intermediate Catch Event',\n    actionName: 'replace-with-link-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-link',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:LinkEventDefinition'\n    }\n  },\n  {\n    label: 'Link Intermediate Throw Event',\n    actionName: 'replace-with-link-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-link',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:LinkEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation Intermediate Throw Event',\n    actionName: 'replace-with-compensation-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-compensation',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Intermediate Catch Event',\n    actionName: 'replace-with-signal-intermediate-catch',\n    className: 'bpmn-icon-intermediate-event-catch-signal',\n    target: {\n      type: 'bpmn:IntermediateCatchEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Intermediate Throw Event',\n    actionName: 'replace-with-signal-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-throw-signal',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  }\n];\n\nmodule.exports.END_EVENT = [\n  {\n    label: 'Start Event',\n    actionName: 'replace-with-none-start',\n    className: 'bpmn-icon-start-event-none',\n    target: {\n      type: 'bpmn:StartEvent'\n    }\n  },\n  {\n    label: 'Intermediate Throw Event',\n    actionName: 'replace-with-none-intermediate-throw',\n    className: 'bpmn-icon-intermediate-event-none',\n    target: {\n      type: 'bpmn:IntermediateThrowEvent'\n    }\n  },\n  {\n    label: 'End Event',\n    actionName: 'replace-with-none-end',\n    className: 'bpmn-icon-end-event-none',\n    target: {\n      type: 'bpmn:EndEvent'\n    }\n  },\n  {\n    label: 'Message End Event',\n    actionName: 'replace-with-message-end',\n    className: 'bpmn-icon-end-event-message',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation End Event',\n    actionName: 'replace-with-escalation-end',\n    className: 'bpmn-icon-end-event-escalation',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Error End Event',\n    actionName: 'replace-with-error-end',\n    className: 'bpmn-icon-end-event-error',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:ErrorEventDefinition'\n    }\n  },\n  {\n    label: 'Cancel End Event',\n    actionName: 'replace-with-cancel-end',\n    className: 'bpmn-icon-end-event-cancel',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:CancelEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation End Event',\n    actionName: 'replace-with-compensation-end',\n    className: 'bpmn-icon-end-event-compensation',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Signal End Event',\n    actionName: 'replace-with-signal-end',\n    className: 'bpmn-icon-end-event-signal',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Terminate End Event',\n    actionName: 'replace-with-terminate-end',\n    className: 'bpmn-icon-end-event-terminate',\n    target: {\n      type: 'bpmn:EndEvent',\n      eventDefinitionType: 'bpmn:TerminateEventDefinition'\n    }\n  }\n];\n\nmodule.exports.GATEWAY = [\n  {\n    label: 'Exclusive Gateway',\n    actionName: 'replace-with-exclusive-gateway',\n    className: 'bpmn-icon-gateway-xor',\n    target: {\n      type: 'bpmn:ExclusiveGateway'\n    }\n  },\n  {\n    label: 'Parallel Gateway',\n    actionName: 'replace-with-parallel-gateway',\n    className: 'bpmn-icon-gateway-parallel',\n    target: {\n      type: 'bpmn:ParallelGateway'\n    }\n  },\n  {\n    label: 'Inclusive Gateway',\n    actionName: 'replace-with-inclusive-gateway',\n    className: 'bpmn-icon-gateway-or',\n    target: {\n      type: 'bpmn:InclusiveGateway'\n    }\n  },\n  {\n    label: 'Complex Gateway',\n    actionName: 'replace-with-complex-gateway',\n    className: 'bpmn-icon-gateway-complex',\n    target: {\n      type: 'bpmn:ComplexGateway'\n    }\n  },\n  {\n    label: 'Event based Gateway',\n    actionName: 'replace-with-event-based-gateway',\n    className: 'bpmn-icon-gateway-eventbased',\n    target: {\n      type: 'bpmn:EventBasedGateway',\n      instantiate: false,\n      eventGatewayType: 'Exclusive'\n    }\n  }\n  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194\n  // {\n  //   label: 'Event based instantiating Gateway',\n  //   actionName: 'replace-with-exclusive-event-based-gateway',\n  //   className: 'bpmn-icon-exclusive-event-based',\n  //   target: {\n  //     type: 'bpmn:EventBasedGateway'\n  //   },\n  //   options: {\n  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }\n  //   }\n  // },\n  // {\n  //   label: 'Parallel Event based instantiating Gateway',\n  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',\n  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',\n  //   target: {\n  //     type: 'bpmn:EventBasedGateway'\n  //   },\n  //   options: {\n  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }\n  //   }\n  // }\n];\n\nmodule.exports.SUBPROCESS_EXPANDED = [\n  {\n    label: 'Transaction',\n    actionName: 'replace-with-transaction',\n    className: 'bpmn-icon-transaction',\n    target: {\n      type: 'bpmn:Transaction',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Event Sub Process',\n    actionName: 'replace-with-event-subprocess',\n    className: 'bpmn-icon-event-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      triggeredByEvent: true,\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Sub Process (collapsed)',\n    actionName: 'replace-with-collapsed-subprocess',\n    className: 'bpmn-icon-subprocess-collapsed',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: false\n    }\n  }\n];\n\nmodule.exports.TRANSACTION = [\n  {\n    label: 'Sub Process',\n    actionName: 'replace-with-subprocess',\n    className: 'bpmn-icon-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Event Sub Process',\n    actionName: 'replace-with-event-subprocess',\n    className: 'bpmn-icon-event-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      triggeredByEvent: true,\n      isExpanded: true\n    }\n  }\n];\n\nmodule.exports.EVENT_SUB_PROCESS = [\n  {\n    label: 'Sub Process',\n    actionName: 'replace-with-subprocess',\n    className: 'bpmn-icon-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Transaction',\n    actionName: 'replace-with-transaction',\n    className: 'bpmn-icon-transaction',\n    target: {\n      type: 'bpmn:Transaction',\n      isExpanded: true\n    }\n  }\n];\n\nmodule.exports.TASK = [\n  {\n    label: 'Task',\n    actionName: 'replace-with-task',\n    className: 'bpmn-icon-task',\n    target: {\n      type: 'bpmn:Task'\n    }\n  },\n  {\n    label: 'Send Task',\n    actionName: 'replace-with-send-task',\n    className: 'bpmn-icon-send',\n    target: {\n      type: 'bpmn:SendTask'\n    }\n  },\n  {\n    label: 'Receive Task',\n    actionName: 'replace-with-receive-task',\n    className: 'bpmn-icon-receive',\n    target: {\n      type: 'bpmn:ReceiveTask'\n    }\n  },\n  {\n    label: 'User Task',\n    actionName: 'replace-with-user-task',\n    className: 'bpmn-icon-user',\n    target: {\n      type: 'bpmn:UserTask'\n    }\n  },\n  {\n    label: 'Manual Task',\n    actionName: 'replace-with-manual-task',\n    className: 'bpmn-icon-manual',\n    target: {\n      type: 'bpmn:ManualTask'\n    }\n  },\n  {\n    label: 'Business Rule Task',\n    actionName: 'replace-with-rule-task',\n    className: 'bpmn-icon-business-rule',\n    target: {\n      type: 'bpmn:BusinessRuleTask'\n    }\n  },\n  {\n    label: 'Service Task',\n    actionName: 'replace-with-service-task',\n    className: 'bpmn-icon-service',\n    target: {\n      type: 'bpmn:ServiceTask'\n    }\n  },\n  {\n    label: 'Script Task',\n    actionName: 'replace-with-script-task',\n    className: 'bpmn-icon-script',\n    target: {\n      type: 'bpmn:ScriptTask'\n    }\n  },\n  {\n    label: 'Call Activity',\n    actionName: 'replace-with-call-activity',\n    className: 'bpmn-icon-call-activity',\n    target: {\n      type: 'bpmn:CallActivity'\n    }\n  },\n  {\n    label: 'Sub Process (collapsed)',\n    actionName: 'replace-with-collapsed-subprocess',\n    className: 'bpmn-icon-subprocess-collapsed',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: false\n    }\n  },\n  {\n    label: 'Sub Process (expanded)',\n    actionName: 'replace-with-expanded-subprocess',\n    className: 'bpmn-icon-subprocess-expanded',\n    target: {\n      type: 'bpmn:SubProcess',\n      isExpanded: true\n    }\n  }\n];\n\nmodule.exports.BOUNDARY_EVENT = [\n  {\n    label: 'Message Boundary Event',\n    actionName: 'replace-with-message-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-message',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Boundary Event',\n    actionName: 'replace-with-timer-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-timer',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation Boundary Event',\n    actionName: 'replace-with-escalation-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-escalation',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Boundary Event',\n    actionName: 'replace-with-conditional-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-condition',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Error Boundary Event',\n    actionName: 'replace-with-error-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-error',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:ErrorEventDefinition'\n    }\n  },\n  {\n    label: 'Cancel Boundary Event',\n    actionName: 'replace-with-cancel-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-cancel',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:CancelEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Boundary Event',\n    actionName: 'replace-with-signal-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-signal',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation Boundary Event',\n    actionName: 'replace-with-compensation-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-compensation',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Message Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-message-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Timer Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-timer-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Escalation Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-escalation-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Conditional Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-conditional-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition',\n      cancelActivity: false\n    }\n  },\n  {\n    label: 'Signal Boundary Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-signal-boundary',\n    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',\n    target: {\n      type: 'bpmn:BoundaryEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition',\n      cancelActivity: false\n    }\n  }\n];\n\nmodule.exports.EVENT_SUB_PROCESS_START_EVENT = [\n  {\n    label: 'Message Start Event',\n    actionName: 'replace-with-message-start',\n    className: 'bpmn-icon-start-event-message',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition'\n    }\n  },\n  {\n    label: 'Timer Start Event',\n    actionName: 'replace-with-timer-start',\n    className: 'bpmn-icon-start-event-timer',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition'\n    }\n  },\n  {\n    label: 'Conditional Start Event',\n    actionName: 'replace-with-conditional-start',\n    className: 'bpmn-icon-start-event-condition',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition'\n    }\n  },\n  {\n    label: 'Signal Start Event',\n    actionName: 'replace-with-signal-start',\n    className: 'bpmn-icon-start-event-signal',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition'\n    }\n  },\n  {\n    label: 'Error Start Event',\n    actionName: 'replace-with-error-start',\n    className: 'bpmn-icon-start-event-error',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ErrorEventDefinition'\n    }\n  },\n  {\n    label: 'Escalation Start Event',\n    actionName: 'replace-with-escalation-start',\n    className: 'bpmn-icon-start-event-escalation',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition'\n    }\n  },\n  {\n    label: 'Compensation Start Event',\n    actionName: 'replace-with-compensation-start',\n    className: 'bpmn-icon-start-event-compensation',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:CompensateEventDefinition'\n    }\n  },\n  {\n    label: 'Message Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-message-start',\n    className: 'bpmn-icon-start-event-non-interrupting-message',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:MessageEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Timer Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-timer-start',\n    className: 'bpmn-icon-start-event-non-interrupting-timer',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:TimerEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Conditional Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-conditional-start',\n    className: 'bpmn-icon-start-event-non-interrupting-condition',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:ConditionalEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Signal Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-signal-start',\n    className: 'bpmn-icon-start-event-non-interrupting-signal',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:SignalEventDefinition',\n      isInterrupting: false\n    }\n  },\n  {\n    label: 'Escalation Start Event (non-interrupting)',\n    actionName: 'replace-with-non-interrupting-escalation-start',\n    className: 'bpmn-icon-start-event-non-interrupting-escalation',\n    target: {\n      type: 'bpmn:StartEvent',\n      eventDefinitionType: 'bpmn:EscalationEventDefinition',\n      isInterrupting: false\n    }\n  }\n];\n\nmodule.exports.SEQUENCE_FLOW = [\n  {\n    label: 'Sequence Flow',\n    actionName: 'replace-with-sequence-flow',\n    className: 'bpmn-icon-connection'\n  },\n  {\n    label: 'Default Flow',\n    actionName: 'replace-with-default-flow',\n    className: 'bpmn-icon-default-flow'\n  },\n  {\n    label: 'Conditional Flow',\n    actionName: 'replace-with-conditional-flow',\n    className: 'bpmn-icon-conditional-flow'\n  }\n];\n\nmodule.exports.PARTICIPANT = [\n  {\n    label: 'Expanded Pool',\n    actionName: 'replace-with-expanded-pool',\n    className: 'bpmn-icon-participant',\n    target: {\n      type: 'bpmn:Participant',\n      isExpanded: true\n    }\n  },\n  {\n    label: 'Collapsed Pool',\n    actionName: 'replace-with-collapsed-pool',\n    // TODO(@janstuemmel): maybe design new icon\n    className: 'bpmn-icon-lane',\n    target: {\n      type: 'bpmn:Participant',\n      isExpanded: false\n    }\n  }\n];\n","module.exports = {\n  __depends__: [\n    require(296),\n    require(310)\n  ],\n  bpmnReplace: [ 'type', require(150) ]\n};\n","'use strict';\n\nvar find = require(385),\n    any = require(382),\n    every = require(383),\n    filter = require(384),\n    forEach = require(386),\n    inherits = require(368);\n\nvar is = require(167).is,\n    isAny = require(140).isAny,\n    getBusinessObject = require(167).getBusinessObject,\n    isExpanded = require(165).isExpanded,\n    isEventSubProcess = require(165).isEventSubProcess,\n    isInterrupting = require(165).isInterrupting,\n    hasErrorEventDefinition = require(165).hasErrorEventDefinition,\n    hasEscalationEventDefinition = require(165).hasEscalationEventDefinition,\n    hasCompensateEventDefinition = require(165).hasCompensateEventDefinition;\n\n\nvar RuleProvider = require(302);\n\nvar isBoundaryAttachment = require(158).getBoundaryAttachment;\n\n/**\n * BPMN specific modeling rule\n */\nfunction BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\n\ninherits(BpmnRules, RuleProvider);\n\nBpmnRules.$inject = [ 'eventBus' ];\n\nmodule.exports = BpmnRules;\n\nBpmnRules.prototype.init = function() {\n\n  this.addRule('connection.create', function(context) {\n    var source = context.source,\n        target = context.target;\n\n    return canConnect(source, target);\n  });\n\n  this.addRule('connection.reconnectStart', function(context) {\n\n    var connection = context.connection,\n        source = context.hover || context.source,\n        target = connection.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.reconnectEnd', function(context) {\n\n    var connection = context.connection,\n        source = connection.source,\n        target = context.hover || context.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.updateWaypoints', function(context) {\n    // OK! but visually ignore\n    return null;\n  });\n\n  this.addRule('shape.resize', function(context) {\n\n    var shape = context.shape,\n        newBounds = context.newBounds;\n\n    return canResize(shape, newBounds);\n  });\n\n  this.addRule('elements.move', function(context) {\n\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n\n    return canAttach(shapes, target, null, position) ||\n           canReplace(shapes, target, position) ||\n           canMove(shapes, target, position) ||\n           canInsert(shapes, target, position);\n  });\n\n  this.addRule([ 'shape.create', 'shape.append' ], function(context) {\n    var target = context.target,\n        shape = context.shape,\n        source = context.source,\n        position = context.position;\n\n    return canAttach([ shape ], target, source, position) || canCreate(shape, target, source, position);\n  });\n\n  this.addRule('element.copy', function(context) {\n    var collection = context.collection,\n        element = context.element;\n\n    return canCopy(collection, element);\n  });\n\n  this.addRule('element.paste', function(context) {\n    var parent = context.parent,\n        element = context.element,\n        position = context.position,\n        source = context.source,\n        target = context.target;\n\n    if (source || target) {\n      return canConnect(source, target);\n    }\n\n    return canAttach([ element ], parent, null, position) || canCreate(element, parent, null, position);\n  });\n\n  this.addRule('elements.paste', function(context) {\n    var tree = context.tree,\n        target = context.target;\n\n    return canPaste(tree, target);\n  });\n\n  this.addRule([ 'elements.delete' ], function(context) {\n\n    // do not allow deletion of labels\n    return filter(context.elements, function(e) {\n      return !isLabel(e);\n    });\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\n\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\n\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\n\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\n\nBpmnRules.prototype.canMove = canMove;\n\nBpmnRules.prototype.canAttach = canAttach;\n\nBpmnRules.prototype.canReplace = canReplace;\n\nBpmnRules.prototype.canDrop = canDrop;\n\nBpmnRules.prototype.canInsert = canInsert;\n\nBpmnRules.prototype.canCreate = canCreate;\n\nBpmnRules.prototype.canConnect = canConnect;\n\nBpmnRules.prototype.canResize = canResize;\n\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\nfunction nonExistantOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction getOrganizationalParent(element) {\n\n  var bo = getBusinessObject(element);\n\n  while (bo && !is(bo, 'bpmn:Process')) {\n    if (is(bo, 'bpmn:Participant')) {\n      return bo.processRef || bo;\n    }\n\n    bo = bo.$parent;\n  }\n\n  return bo;\n}\n\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') &&\n         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\n\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n\n  return parentA === parentB;\n}\n\nfunction isMessageFlowSource(element) {\n  return is(element, 'bpmn:InteractionNode') &&\n        !isForCompensation(element) && (\n            !is(element, 'bpmn:Event') || (\n              is(element, 'bpmn:ThrowEvent') &&\n              hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n            )\n  );\n}\n\nfunction isMessageFlowTarget(element) {\n  return is(element, 'bpmn:InteractionNode') &&\n        !isForCompensation(element) && (\n            !is(element, 'bpmn:Event') || (\n              is(element, 'bpmn:CatchEvent') &&\n              hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n            )\n  );\n}\n\nfunction getScopeParent(element) {\n\n  var bo = getBusinessObject(element);\n\n  if (is(bo, 'bpmn:Participant')) {\n    return null;\n  }\n\n  while (bo) {\n    bo = bo.$parent;\n\n    if (is(bo, 'bpmn:FlowElementsContainer')) {\n      return bo;\n    }\n  }\n\n  return bo;\n}\n\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n\n  return scopeParentA && (scopeParentA === scopeParentB);\n}\n\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return !!find(bo.eventDefinitions || [], function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return (bo.eventDefinitions || []).every(function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction isSequenceFlowSource(element) {\n  return is(element, 'bpmn:FlowNode') &&\n        !is(element, 'bpmn:EndEvent') &&\n        !isEventSubProcess(element) &&\n        !(is(element, 'bpmn:IntermediateThrowEvent') &&\n          hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n        ) &&\n        !isCompensationBoundary(element) &&\n        !isForCompensation(element);\n}\n\nfunction isSequenceFlowTarget(element) {\n  return is(element, 'bpmn:FlowNode') &&\n        !is(element, 'bpmn:StartEvent') &&\n        !is(element, 'bpmn:BoundaryEvent') &&\n        !isEventSubProcess(element) &&\n        !(is(element, 'bpmn:IntermediateCatchEvent') &&\n          hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n        ) &&\n        !isForCompensation(element);\n\n}\n\nfunction isEventBasedTarget(element) {\n  return is(element, 'bpmn:ReceiveTask') || (\n         is(element, 'bpmn:IntermediateCatchEvent') && (\n           hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||\n           hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||\n           hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||\n           hasEventDefinition(element, 'bpmn:SignalEventDefinition')\n         )\n  );\n}\n\nfunction isLabel(element) {\n  return element.labelTarget;\n}\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n\nfunction getParents(element) {\n\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\nfunction canConnect(source, target, connection) {\n\n  if (nonExistantOrLabel(source) || nonExistantOrLabel(target)) {\n    return null;\n  }\n\n  // See https://github.com/bpmn-io/bpmn-js/issues/178\n  // as a workround we disallow connections with same\n  // target and source element.\n  // This rule must be removed if a auto layout for this\n  // connections is implemented.\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n\n    if (canConnectMessageFlow(source, target)) {\n      return { type: 'bpmn:MessageFlow' };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return { type: 'bpmn:SequenceFlow' };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element\n *\n * @return {Boolean}\n */\nfunction canDrop(element, target, position) {\n\n  // can move labels everywhere\n  if (isLabel(element) && !isConnection(target)) {\n    return true;\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // on existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent')) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation' ])) {\n    return isAny(target, [\n      'bpmn:Collaboration',\n      'bpmn:Lane',\n      'bpmn:Participant',\n      'bpmn:Process',\n      'bpmn:SubProcess' ]);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration')\n      || element.source.parent == target\n      || element.target.parent == target;\n  }\n\n  return false;\n}\n\nfunction canPaste(tree, target) {\n  var topLevel = tree[0],\n      participants;\n\n  if (is(target, 'bpmn:Collaboration')) {\n    return every(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n  }\n\n  if (is(target, 'bpmn:Process')) {\n    participants = any(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n\n    return !(participants && target.children.length > 0);\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  if (is(target, 'bpmn:FlowElementsContainer')) {\n    return isExpanded(target);\n  }\n\n  return isAny(target, [\n    'bpmn:Collaboration',\n    'bpmn:Lane',\n    'bpmn:Participant',\n    'bpmn:Process',\n    'bpmn:SubProcess' ]);\n}\n\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\nfunction isBoundaryCandidate(element) {\n  return isBoundaryEvent(element) ||\n        (is(element, 'bpmn:IntermediateThrowEvent') && !element.parent);\n}\n\n\nfunction canAttach(elements, target, source, position) {\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  // disallow appending as boundary event\n  if (source) {\n    return false;\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // allow default move operation\n  if (!target) {\n    return true;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n\n\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\nfunction canReplace(elements, target, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n\n  forEach(elements, function(element) {\n\n    if (!isEventSubProcess(target)) {\n\n      if (is(element, 'bpmn:StartEvent') &&\n          element.type !== 'label' &&\n          canDrop(element, target)) {\n\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compansate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) ||\n            hasEscalationEventDefinition(element) ||\n            hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&\n          element.type !== 'label') {\n\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n\n  return canExecute.replacements.length ? canExecute : false;\n}\n\nfunction canMove(elements, target) {\n\n  // do not move selection containing boundary events\n  if (any(elements, isBoundaryEvent)) {\n    return false;\n  }\n\n  // do not move selection containing lanes\n  if (any(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function(element) {\n    return canDrop(element, target);\n  });\n}\n\nfunction canCreate(shape, target, source, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(target)) {\n    return null;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return (!!isExpanded(shape)) && (\n          !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\n    );\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check, whether one side of the relationship\n * is a text annotation.\n */\nfunction isOneTextAnnotation(source, target) {\n\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n\n  return (\n    (sourceTextAnnotation || targetTextAnnotation) &&\n    (sourceTextAnnotation !== targetTextAnnotation)\n  );\n}\n\n\nfunction canConnectAssociation(source, target) {\n\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  }\n\n  // compensation boundary events are exception\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  }\n\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  return isOneTextAnnotation(source, target);\n}\n\nfunction canConnectMessageFlow(source, target) {\n\n  return isMessageFlowSource(source) &&\n         isMessageFlowTarget(target) &&\n        !isSameOrganization(source, target);\n}\n\nfunction canConnectSequenceFlow(source, target) {\n\n  return isSequenceFlowSource(source) &&\n         isSequenceFlowTarget(target) &&\n         isSameScope(source, target) &&\n         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\n\nfunction canConnectDataAssociation(source, target) {\n\n  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {\n    return { type: 'bpmn:DataInputAssociation' };\n  }\n\n  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {\n    return { type: 'bpmn:DataOutputAssociation' };\n  }\n\n  return false;\n}\n\nfunction canInsert(shape, flow, position) {\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n  return (\n    isAny(flow, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&\n    !isLabel(flow) &&\n    is(shape, 'bpmn:FlowNode') &&\n    !is(shape, 'bpmn:BoundaryEvent') &&\n    canDrop(shape, flow.parent, position));\n}\n\nfunction contains(collection, element) {\n  return (collection && element) && collection.indexOf(element) !== -1;\n}\n\nfunction canCopy(collection, element) {\n  if (is(element, 'bpmn:Lane') && !contains(collection, element.parent)) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent') && !contains(collection, element.host)) {\n    return false;\n  }\n\n  return true;\n}\n","module.exports = {\n  __depends__: [\n    require(304)\n  ],\n  __init__: [ 'bpmnRules' ],\n  bpmnRules: [ 'type', require(153) ]\n};\n","'use strict';\n\nvar map = require(389),\n    filter = require(384),\n    sortBy = require(394);\n\nvar labelUtil = require(97);\n\n\n/**\n * Provides ability to search through BPMN elements\n */\nfunction BpmnSearchProvider(elementRegistry, searchPad, canvas) {\n\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n\n  searchPad.registerProvider(this);\n}\n\nmodule.exports = BpmnSearchProvider;\n\nBpmnSearchProvider.$inject = [\n  'elementRegistry',\n  'searchPad',\n  'canvas'\n];\n\n\n/**\n * Finds all elements that match given pattern\n *\n * <Result> :\n *  {\n *    primaryTokens: <Array<Token>>,\n *    secondaryTokens: <Array<Token>>,\n *    element: <Element>\n *  }\n *\n * <Token> :\n *  {\n *    normal|matched: <String>\n *  }\n *\n * @param  {String} pattern\n * @return {Array<Result>}\n */\nBpmnSearchProvider.prototype.find = function(pattern) {\n  var rootElement = this._canvas.getRootElement();\n\n  var elements = this._elementRegistry.filter(function(element) {\n    if (element.labelTarget) {\n      return false;\n    }\n    return true;\n  });\n\n  // do not include root element\n  elements = filter(elements, function(element) {\n    return element !== rootElement;\n  });\n\n  elements = map(elements, function(element) {\n    return {\n      primaryTokens: matchAndSplit(labelUtil.getLabel(element), pattern),\n      secondaryTokens: matchAndSplit(element.id, pattern),\n      element: element\n    };\n  });\n\n  // exclude non-matched elements\n  elements = filter(elements, function(element) {\n    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);\n  });\n\n  elements = sortBy(elements, function(element) {\n    return labelUtil.getLabel(element.element) + element.element.id;\n  });\n\n  return elements;\n};\n\n\nfunction hasMatched(tokens) {\n  var matched = filter(tokens, function(t) {\n    return !!t.matched;\n  });\n\n  return matched.length > 0;\n}\n\n\nfunction matchAndSplit(text, pattern) {\n  var tokens = [],\n      originalText = text;\n\n  if (!text) {\n    return tokens;\n  }\n\n  text = text.toLowerCase();\n  pattern = pattern.toLowerCase();\n\n  var i = text.indexOf(pattern);\n\n  if (i > -1) {\n    if (i !== 0) {\n      tokens.push({\n        normal: originalText.substr(0, i)\n      });\n    }\n\n    tokens.push({\n      matched: originalText.substr(i, pattern.length)\n    });\n\n    if (pattern.length + i < text.length) {\n      tokens.push({\n        normal: originalText.substr(pattern.length + i, text.length)\n      });\n    }\n  } else {\n    tokens.push({\n      normal: originalText\n    });\n  }\n\n  return tokens;\n}","module.exports = {\n  __depends__: [\n    require(306)\n  ],\n  __init__: [ 'bpmnSearch'],\n  bpmnSearch: [ 'type', require(155) ]\n};\n","'use strict';\n\nvar inherits = require(368);\n\nvar abs = Math.abs;\n\nvar forEach = require(386),\n    filter = require(384),\n    assign = require(516);\n\nvar getBoundingBox = require(343).getBBox;\n\nvar is = require(167).is,\n    isAny = require(140).isAny,\n    isExpanded = require(165).isExpanded;\n\nvar Snapping = require(313),\n    SnapUtil = require(312);\n\nvar asTRBL = require(329).asTRBL;\n\nvar round = Math.round;\n\nvar mid = SnapUtil.mid,\n    topLeft = SnapUtil.topLeft,\n    bottomRight = SnapUtil.bottomRight,\n    isSnapped = SnapUtil.isSnapped,\n    setSnapped = SnapUtil.setSnapped;\n\nvar getBoundaryAttachment = require(158).getBoundaryAttachment,\n    getParticipantSizeConstraints = require(158).getParticipantSizeConstraints,\n    getLanesRoot = require(139).getLanesRoot;\n\nvar HIGH_PRIORITY = 1500;\n\n\n/**\n * BPMN specific snapping functionality\n *\n *  * snap on process elements if a pool is created inside a\n *    process diagram\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nfunction BpmnSnapping(eventBus, canvas, bpmnRules, elementRegistry) {\n\n  // instantiate super\n  Snapping.call(this, eventBus, canvas);\n\n\n  /**\n   * Drop participant on process <> process elements snapping\n   */\n  eventBus.on('create.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        participantSnapBox = context.participantSnapBox;\n\n    if (!isSnapped(event) && participantSnapBox) {\n      snapParticipant(participantSnapBox, shape, event);\n    }\n  });\n\n  eventBus.on('shape.move.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n\n  function canAttach(shape, target, position) {\n    return bpmnRules.canAttach([ shape ], target, null, position) === 'attach';\n  }\n\n  function canConnect(source, target) {\n    return bpmnRules.canConnect(source, target);\n  }\n\n  /**\n   * Snap boundary events to elements border\n   */\n  eventBus.on([\n    'create.move',\n    'create.end',\n    'shape.move.move',\n    'shape.move.end'\n  ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        target = context.target,\n        shape = context.shape;\n\n    if (target && !isSnapped(event) && canAttach(shape, target, event)) {\n      snapBoundaryEvent(event, shape, target);\n    }\n  });\n\n  /**\n   * Adjust parent for flowElements to the target participant\n   * when droping onto lanes.\n   */\n  eventBus.on([\n    'shape.move.hover',\n    'shape.move.move',\n    'shape.move.end',\n    'create.hover',\n    'create.move',\n    'create.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hover = event.hover;\n\n    if (is(hover, 'bpmn:Lane') && !isAny(shape, [ 'bpmn:Lane', 'bpmn:Participant' ])) {\n      event.hover = getLanesRoot(hover);\n      event.hoverGfx = elementRegistry.getGraphics(event.hover);\n    }\n  });\n\n  /**\n   * Snap sequence flows.\n   */\n  eventBus.on([\n    'connect.move',\n    'connect.hover',\n    'connect.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        source = context.source,\n        target = context.target;\n\n    var connection = canConnect(source, target) || {};\n\n    if (!context.initialSourcePosition) {\n      context.initialSourcePosition = context.sourcePosition;\n    }\n\n    if (target && connection.type === 'bpmn:SequenceFlow') {\n\n      // snap source\n      context.sourcePosition = mid(source);\n\n      // snap target\n      assign(event, mid(target));\n    } else {\n\n      // otherwise reset source snap\n      context.sourcePosition = context.initialSourcePosition;\n    }\n\n  });\n\n\n  eventBus.on([\n    'create.move',\n    'shape.move.move'\n  ], function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        target = context.target;\n\n    var threshold = 30;\n\n    if (is(shape, 'bpmn:Lane')) {\n      if (isAny(target, [ 'bpmn:Lane', 'bpmn:Participant' ])) {\n\n        var childLanes = filter(target.children, function(c) {\n          return is(c, 'bpmn:Lane');\n        });\n\n        var y = event.y,\n            targetTrbl;\n\n        var insert = childLanes.reduce(function(insert, l) {\n\n          var laneTrbl = asTRBL(l);\n\n          if (abs(laneTrbl.top - y) < threshold) {\n            insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });\n          } else\n          if (abs(laneTrbl.bottom - y) < threshold) {\n            insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });\n          } else\n          if (laneTrbl.top < y && laneTrbl.bottom > y) {\n            if (abs(laneTrbl.top - y) > abs(laneTrbl.bottom - y)) {\n              insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });\n            } else {\n              insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });\n            }\n\n          }\n\n          return insert;\n        }, false);\n\n\n        if (!insert) {\n          targetTrbl = asTRBL(target);\n\n          if (abs(targetTrbl.top - y) < threshold) {\n            insert = { before: { element: target, y: targetTrbl.top } };\n          } else\n          if (abs(targetTrbl.bottom - y) < threshold) {\n            insert = { after: { element: target, y: targetTrbl.bottom } };\n          } else {\n            insert = { into: { element: target, y: (targetTrbl.top + targetTrbl.bottom) / 2 } };\n          }\n\n        }\n\n        if (insert.before && insert.after) {\n          console.log('insert between', insert.before.element.id, 'and', insert.after.element.id);\n          setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);\n          setSnapped(event, 'y', insert.before.y);\n        } else\n        if (insert.after) {\n          console.log('insert after', insert.after.element.id);\n          setSnapped(event, 'x', insert.after.element.x + insert.after.element.width / 2);\n          setSnapped(event, 'y', insert.after.y);\n        } else\n        if (insert.before) {\n          console.log('insert before', insert.before.element.id);\n          setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);\n          setSnapped(event, 'y', insert.before.y);\n        } else\n        if (insert.into) {\n          console.log('insert into', insert.into.element.id);\n          setSnapped(event, 'x', insert.into.element.x + insert.into.element.width / 2);\n          setSnapped(event, 'y', insert.into.y);\n        }\n      }\n    }\n\n  });\n\n  eventBus.on('resize.start', HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n      context.minDimensions = { width: 140, height: 120 };\n    }\n\n    if (is(shape, 'bpmn:Participant')) {\n      context.minDimensions = { width: 300, height: 150 };\n    }\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n      context.resizeConstraints = getParticipantSizeConstraints(shape, context.direction, context.balanced);\n    }\n\n    if (is(shape, 'bpmn:TextAnnotation')) {\n      context.minDimensions = { width: 50, height: 30 };\n    }\n  });\n\n}\n\ninherits(BpmnSnapping, Snapping);\n\nBpmnSnapping.$inject = [ 'eventBus', 'canvas', 'bpmnRules', 'elementRegistry' ];\n\nmodule.exports = BpmnSnapping;\n\n\nBpmnSnapping.prototype.initSnap = function(event) {\n\n  var context = event.context,\n      shape = event.shape,\n      shapeMid,\n      shapeBounds,\n      shapeTopLeft,\n      shapeBottomRight,\n      snapContext;\n\n\n  snapContext = Snapping.prototype.initSnap.call(this, event);\n\n  if (is(shape, 'bpmn:Participant')) {\n    // assign higher priority for outer snaps on participants\n    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);\n  }\n\n\n  if (shape) {\n\n    shapeMid = mid(shape, event);\n\n    shapeBounds = {\n      width: shape.width,\n      height: shape.height,\n      x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,\n      y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y\n    };\n\n    shapeTopLeft = topLeft(shapeBounds);\n    shapeBottomRight = bottomRight(shapeBounds);\n\n    snapContext.setSnapOrigin('top-left', {\n      x: shapeTopLeft.x - event.x,\n      y: shapeTopLeft.y - event.y\n    });\n\n    snapContext.setSnapOrigin('bottom-right', {\n      x: shapeBottomRight.x - event.x,\n      y: shapeBottomRight.y - event.y\n    });\n\n    forEach(shape.outgoing, function(c) {\n      var docking = c.waypoints[0];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n    forEach(shape.incoming, function(c) {\n      var docking = c.waypoints[c.waypoints.length - 1];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n  }\n\n  var source = context.source;\n\n  if (source) {\n    snapContext.addDefaultSnap('mid', mid(source));\n  }\n};\n\n\nBpmnSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\n\n  // use target parent as snap target\n  if (is(shape, 'bpmn:BoundaryEvent') && shape.type !== 'label') {\n    target = target.parent;\n  }\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    this.addTargetSnaps(snapPoints, shape, target.parent);\n  }\n\n  var siblings = this.getSiblings(shape, target) || [];\n\n  forEach(siblings, function(sibling) {\n\n    // do not snap to lanes\n    if (is(sibling, 'bpmn:Lane')) {\n      return;\n    }\n\n    if (sibling.waypoints) {\n      forEach(sibling.waypoints, function(waypoint, i) {\n        var nextWaypoint = sibling.waypoints[i+1];\n\n        if (!nextWaypoint) {\n          return;\n        }\n\n        if (nextWaypoint.x === waypoint.x || nextWaypoint.y === waypoint.y) {\n          snapPoints.add('mid', waypoint);\n        }\n      });\n\n      return;\n    }\n\n    snapPoints.add('mid', mid(sibling));\n\n    if (is(sibling, 'bpmn:Participant')) {\n      snapPoints.add('top-left', topLeft(sibling));\n      snapPoints.add('bottom-right', bottomRight(sibling));\n    }\n  });\n\n\n  forEach(shape.incoming, function(c) {\n\n    if (siblings.indexOf(c.source) === -1) {\n      snapPoints.add('mid', mid(c.source));\n    }\n\n    var docking = c.waypoints[0];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n\n\n  forEach(shape.outgoing, function(c) {\n\n    if (siblings.indexOf(c.target) === -1) {\n      snapPoints.add('mid', mid(c.target));\n    }\n\n    var docking = c.waypoints[c.waypoints.length - 1];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n};\n\n\n/////// participant snapping //////////////////\n\nfunction initParticipantSnapping(context, shape, elements) {\n\n  if (!elements.length) {\n    return;\n  }\n\n  var snapBox = getBoundingBox(elements.filter(function(e) {\n    return !e.labelTarget && !e.waypoints;\n  }));\n\n  snapBox.x -= 50;\n  snapBox.y -= 20;\n  snapBox.width += 70;\n  snapBox.height += 40;\n\n  // adjust shape height to include bounding box\n  shape.width = Math.max(shape.width, snapBox.width);\n  shape.height = Math.max(shape.height, snapBox.height);\n\n  context.participantSnapBox = snapBox;\n}\n\nfunction snapParticipant(snapBox, shape, event, offset) {\n  offset = offset || 0;\n\n  var shapeHalfWidth = shape.width / 2 - offset,\n      shapeHalfHeight = shape.height / 2;\n\n  var currentTopLeft = {\n    x: event.x - shapeHalfWidth - offset,\n    y: event.y - shapeHalfHeight\n  };\n\n  var currentBottomRight = {\n    x: event.x + shapeHalfWidth + offset,\n    y: event.y + shapeHalfHeight\n  };\n\n  var snapTopLeft = snapBox,\n      snapBottomRight = bottomRight(snapBox);\n\n  if (currentTopLeft.x >= snapTopLeft.x) {\n    setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);\n  } else\n  if (currentBottomRight.x <= snapBottomRight.x) {\n    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);\n  }\n\n  if (currentTopLeft.y >= snapTopLeft.y) {\n    setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);\n  } else\n  if (currentBottomRight.y <= snapBottomRight.y) {\n    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);\n  }\n}\n\n\n/////// boundary event snapping /////////////////////////\n\n\nfunction snapBoundaryEvent(event, shape, target) {\n  var targetTRBL = asTRBL(target);\n\n  var direction = getBoundaryAttachment(event, target);\n\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top);\n  } else\n  if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom);\n  }\n\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left);\n  } else\n  if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right);\n  }\n}\n","'use strict';\n\nvar getOrientation = require(329).getOrientation;\n\n\nfunction getBoundaryAttachment(position, targetBounds) {\n\n  var orientation = getOrientation(position, targetBounds, -15);\n\n  if (orientation !== 'intersect') {\n    return orientation;\n  } else {\n    return null;\n  }\n}\n\nmodule.exports.getBoundaryAttachment = getBoundaryAttachment;\n\n\n\n// participant snapping box implementation /////////////////\n\nvar is = require(167).is;\n\nvar asTRBL = require(329).asTRBL;\n\nvar collectLanes = require(139).collectLanes,\n    getLanesRoot = require(139).getLanesRoot;\n\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max;\n\n\nfunction addToTrbl(trbl, attr, value, choice) {\n\n  var current = trbl[attr];\n\n  // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}\n\nfunction addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}\n\nfunction addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}\n\n\nvar LANE_MIN_HEIGHT = 60,\n    LANE_MIN_WIDTH = 300,\n    LANE_RIGHT_PADDING = 20,\n    LANE_LEFT_PADDING = 50,\n    LANE_TOP_PADDING = 20,\n    LANE_BOTTOM_PADDING = 20;\n\n\nfunction getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {\n\n  var lanesRoot = getLanesRoot(laneShape);\n\n  var isFirst = true,\n      isLast = true;\n\n  ///// max top/bottom size for lanes\n\n  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);\n\n  var laneTrbl = asTRBL(laneShape);\n\n  var maxTrbl = {},\n      minTrbl = {};\n\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\n  } else\n  if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\n  }\n\n  allLanes.forEach(function(other) {\n\n    var otherTrbl = asTRBL(other);\n\n    if (/n/.test(resizeDirection)) {\n\n      if (otherTrbl.top < (laneTrbl.top - 10)) {\n        isFirst = false;\n      }\n\n      // max top size (based on next element)\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n\n      // min top size (based on self or nested element)\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n    }\n\n    if (/s/.test(resizeDirection)) {\n\n      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {\n        isLast = false;\n      }\n\n      // max bottom size (based on previous element)\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n\n      // min bottom size (based on self or nested element)\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n    }\n  });\n\n\n  ///// max top/bottom/left/right size based on flow nodes\n\n  var flowElements = lanesRoot.children.filter(function(s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n\n  flowElements.forEach(function(flowElement) {\n\n    var flowElementTrbl = asTRBL(flowElement);\n\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n\n\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}\n\n\nmodule.exports.getParticipantSizeConstraints = getParticipantSizeConstraints;","module.exports = {\n  __init__: [ 'snapping' ],\n  snapping: [ 'type', require(157) ]\n};","'use strict';\n\nvar assign = require(516),\n    map = require(389);\n\nvar LabelUtil = require(166);\n\nvar TextUtil = require(357);\n\nvar is = require(167).is;\n\nvar hasExternalLabel = LabelUtil.hasExternalLabel,\n    getExternalLabelBounds = LabelUtil.getExternalLabelBounds,\n    isExpanded = require(165).isExpanded,\n    elementToString = require(163).elementToString;\n\n\nfunction elementData(semantic, attrs) {\n  return assign({\n    id: semantic.id,\n    type: semantic.$type,\n    businessObject: semantic\n  }, attrs);\n}\n\nfunction collectWaypoints(waypoints) {\n  return map(waypoints, function(p) {\n    return { x: p.x, y: p.y };\n  });\n}\n\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\n    element: elementToString(refSemantic),\n    referenced: elementToString(semantic),\n    property: property\n  }));\n}\n\n\n/**\n * An importer that adds bpmn elements to the canvas\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n * @param {ElementFactory} elementFactory\n * @param {ElementRegistry} elementRegistry\n */\nfunction BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n\n  this._elementFactory = elementFactory;\n  this._elementRegistry = elementRegistry;\n  this._translate = translate;\n\n  this._textUtil = new TextUtil();\n}\n\nBpmnImporter.$inject = [ 'eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate' ];\n\nmodule.exports = BpmnImporter;\n\n\n/**\n * Add bpmn element (semantic) to the canvas onto the\n * specified parent shape.\n */\nBpmnImporter.prototype.add = function(semantic, parentElement) {\n\n  var di = semantic.di,\n      element,\n      translate = this._translate,\n      hidden;\n\n  // ROOT ELEMENT\n  // handle the special case that we deal with a\n  // invisible root element (process or collaboration)\n  if (is(di, 'bpmndi:BPMNPlane')) {\n\n    // add a virtual element (not being drawn)\n    element = this._elementFactory.createRoot(elementData(semantic));\n\n    this._canvas.setRootElement(element);\n  }\n\n  // SHAPE\n  else if (is(di, 'bpmndi:BPMNShape')) {\n\n    var collapsed = !isExpanded(semantic);\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    var bounds = semantic.di.bounds;\n\n    element = this._elementFactory.createShape(elementData(semantic, {\n      collapsed: collapsed,\n      hidden: hidden,\n      x: Math.round(bounds.x),\n      y: Math.round(bounds.y),\n      width: Math.round(bounds.width),\n      height: Math.round(bounds.height)\n    }));\n\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\n      this._attachBoundary(semantic, element);\n    }\n\n    this._canvas.addShape(element, parentElement);\n  }\n\n  // CONNECTION\n  else if (is(di, 'bpmndi:BPMNEdge')) {\n\n    var source = this._getSource(semantic),\n        target = this._getTarget(semantic);\n\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    element = this._elementFactory.createConnection(elementData(semantic, {\n      hidden: hidden,\n      source: source,\n      target: target,\n      waypoints: collectWaypoints(semantic.di.waypoint)\n    }));\n\n    if (is(semantic, 'bpmn:DataAssociation')) {\n\n      // render always on top; this ensures DataAssociations\n      // are rendered correctly across different \"hacks\" people\n      // love to model such as cross participant / sub process\n      // associations\n      parentElement = null;\n    }\n\n    this._canvas.addConnection(element, parentElement);\n  } else {\n    throw new Error(translate('unknown di {di} for element {semantic}', {\n      di: elementToString(di),\n      semantic: elementToString(semantic)\n    }));\n  }\n  // (optional) LABEL\n  if (hasExternalLabel(semantic)) {\n    this.addLabel(semantic, element);\n  }\n\n\n  this._eventBus.fire('bpmnElement.added', { element: element });\n\n  return element;\n};\n\n\n/**\n * Attach the boundary element to the given host\n *\n * @param {ModdleElement} boundarySemantic\n * @param {djs.model.Base} boundaryElement\n */\nBpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\n  var translate = this._translate;\n  var hostSemantic = boundarySemantic.attachedToRef;\n\n  if (!hostSemantic) {\n    throw new Error(translate('missing {semantic}#attachedToRef', {\n      semantic: elementToString(boundarySemantic)\n    }));\n  }\n\n  var host = this._elementRegistry.get(hostSemantic.id),\n      attachers = host && host.attachers;\n\n  if (!host) {\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\n  }\n\n  // wire element.host <> host.attachers\n  boundaryElement.host = host;\n\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n\n  if (attachers.indexOf(boundaryElement) === -1) {\n    attachers.push(boundaryElement);\n  }\n};\n\n\n/**\n * add label for an element\n */\nBpmnImporter.prototype.addLabel = function(semantic, element) {\n  var bounds,\n      text,\n      label;\n\n  bounds = getExternalLabelBounds(semantic, element);\n\n  text = semantic.name;\n\n  if (text) {\n    // get corrected bounds from actual layouted text\n    bounds = getLayoutedBounds(bounds, text, this._textUtil);\n  }\n\n  label = this._elementFactory.createLabel(elementData(semantic, {\n    id: semantic.id + '_label',\n    labelTarget: element,\n    type: 'label',\n    hidden: element.hidden || !semantic.name,\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  }));\n\n  return this._canvas.addShape(label, element.parent);\n};\n\n/**\n * Return the drawn connection end based on the given side.\n *\n * @throws {Error} if the end is not yet drawn\n */\nBpmnImporter.prototype._getEnd = function(semantic, side) {\n\n  var element,\n      refSemantic,\n      type = semantic.$type,\n      translate = this._translate;\n\n  refSemantic = semantic[side + 'Ref'];\n\n  // handle mysterious isMany DataAssociation#sourceRef\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = refSemantic && refSemantic[0];\n  }\n\n  // fix source / target for DataInputAssociation / DataOutputAssociation\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||\n      side === 'target' && type === 'bpmn:DataInputAssociation') {\n\n    refSemantic = semantic.$parent;\n  }\n\n  element = refSemantic && this._getElement(refSemantic);\n\n  if (element) {\n    return element;\n  }\n\n  if (refSemantic) {\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\n  } else {\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\n      semantic: elementToString(semantic),\n      side: side\n    }));\n  }\n};\n\nBpmnImporter.prototype._getSource = function(semantic) {\n  return this._getEnd(semantic, 'source');\n};\n\nBpmnImporter.prototype._getTarget = function(semantic) {\n  return this._getEnd(semantic, 'target');\n};\n\n\nBpmnImporter.prototype._getElement = function(semantic) {\n  return this._elementRegistry.get(semantic.id);\n};\n\n\n// TODO(nikku): repeating code (search for <getLayoutedBounds>)\n\nvar EXTERNAL_LABEL_STYLE = {\n  fontFamily: 'Arial, sans-serif',\n  fontSize: '11px'\n};\n\nfunction getLayoutedBounds(bounds, text, textUtil) {\n\n  var layoutedLabelDimensions = textUtil.getDimensions(text, {\n    box: {\n      width: 90,\n      height: 30,\n      x: bounds.width / 2 + bounds.x,\n      y: bounds.height / 2 + bounds.y\n    },\n    style: EXTERNAL_LABEL_STYLE\n  });\n\n  // resize label shape to fit label text\n  return {\n    x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),\n    y: Math.round(bounds.y),\n    width: Math.ceil(layoutedLabelDimensions.width),\n    height: Math.ceil(layoutedLabelDimensions.height)\n  };\n}","'use strict';\n\nvar filter = require(384),\n    find = require(385),\n    forEach = require(386);\n\nvar Refs = require(552);\n\nvar elementToString = require(163).elementToString;\n\nvar diRefs = new Refs({ name: 'bpmnElement', enumerable: true }, { name: 'di' });\n\n/**\n * Returns true if an element has the given meta-model type\n *\n * @param  {ModdleElement}  element\n * @param  {String}         type\n *\n * @return {Boolean}\n */\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n\n\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n */\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function(e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\n\n\nfunction BpmnTreeWalker(handler, translate) {\n\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n\n  ///// Helpers /////////////////////////////////\n\n  function contextual(fn, ctx) {\n    return function(e) {\n      fn(e, ctx);\n    };\n  }\n\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n\n  function visit(element, ctx) {\n\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(\n        translate('already rendered {element}', { element: elementToString(element) })\n      );\n    }\n\n    // call handler\n    return handler.element(element, ctx);\n  }\n\n  function visitRoot(element, diagram) {\n    return handler.root(element, diagram);\n  }\n\n  function visitIfDi(element, ctx) {\n\n    try {\n      var gfx = element.di && visit(element, ctx);\n\n      handled(element);\n\n      return gfx;\n    } catch (e) {\n      logError(e.message, { element: element, error: e });\n\n      console.error(translate('failed to import {element}', { element: elementToString(element) }));\n      console.error(e);\n    }\n  }\n\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  ////// DI handling ////////////////////////////\n\n  function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n\n    if (bpmnElement) {\n      if (bpmnElement.di) {\n        logError(\n          translate('multiple DI elements defined for {element}', {\n            element: elementToString(bpmnElement)\n          }),\n          { element: bpmnElement  }\n        );\n      } else {\n        diRefs.bind(bpmnElement, 'di');\n        bpmnElement.di = di;\n      }\n    } else {\n      logError(\n        translate('no bpmnElement referenced in {element}', {\n          element: elementToString(di)\n        }),\n        { element: di }\n      );\n    }\n  }\n\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n\n  function handlePlane(plane) {\n    registerDi(plane);\n\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n\n  ////// Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any)\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error(translate('diagram not part of bpmn:Definitions'));\n    }\n\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error(translate('no diagram to display'));\n    }\n\n    // load DI from selected diagram only\n    handleDiagram(diagram);\n\n\n    var plane = diagram.plane;\n\n    if (!plane) {\n      throw new Error(translate(\n        'no plane for {element}',\n        { element: elementToString(diagram) }\n      ));\n    }\n\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n\n      if (!rootElement) {\n        throw new Error(translate('no process or collaboration to display'));\n      } else {\n\n        logError(\n          translate('correcting missing bpmnElement on {plane} to {rootElement}', {\n            plane: elementToString(plane),\n            rootElement: elementToString(rootElement)\n          })\n        );\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n\n\n    var ctx = visitRoot(rootElement, plane);\n\n    if (is(rootElement, 'bpmn:Process')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(\n        translate('unsupported bpmnElement for {plane}: {rootElement}', {\n          plane: elementToString(plane),\n          rootElement: elementToString(rootElement)\n        })\n      );\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  }\n\n  function handleDeferred(deferred) {\n    forEach(deferred, function(d) { d(); });\n  }\n\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n\n  function handleUnhandledProcesses(rootElements) {\n\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function(e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n\n    processes.forEach(contextual(handleProcess));\n  }\n\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n\n  function handleArtifact(artifact, context) {\n\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n\n  function handleArtifacts(artifacts, context) {\n\n    forEach(artifacts, function(e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function() {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n\n  function handleIoSpecification(ioSpecification, context) {\n\n    if (!ioSpecification) {\n      return;\n    }\n\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n\n  function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  }\n\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function() {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleBoundaryEvent(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleLane(lane, context) {\n    var newContext = visitIfDi(lane, context);\n\n    if (lane.childLaneSet) {\n      handleLaneSet(lane.childLaneSet, newContext || context);\n    }\n\n    wireFlowNodeRefs(lane);\n  }\n\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n\n  function handleFlowElementsContainer(container, context) {\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n\n    handleFlowElements(container.flowElements, context);\n  }\n\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function(e) {\n      if (is(e, 'bpmn:SequenceFlow')) {\n        deferred.push(function() {\n          handleSequenceFlow(e, context);\n        });\n      } else if (is(e, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function() {\n          handleBoundaryEvent(e, context);\n        });\n      } else if (is(e, 'bpmn:FlowNode')) {\n        handleFlowNode(e, context);\n      } else if (is(e, 'bpmn:DataObject')) {\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(e, 'bpmn:DataStoreReference')) {\n        handleDataElement(e, context);\n      } else if (is(e, 'bpmn:DataObjectReference')) {\n        handleDataElement(e, context);\n      } else {\n        logError(\n          translate('unrecognized flowElement {element} in context {context}', {\n            element: elementToString(e),\n            context: (context ? elementToString(context.businessObject) : 'null')\n          }),\n          { element: e, context: context }\n        );\n      }\n    });\n  }\n\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n\n  function handleCollaboration(collaboration) {\n\n    forEach(collaboration.participants, contextual(handleParticipant));\n\n    handleArtifacts(collaboration.artifacts);\n\n    // handle message flows latest in the process\n    deferred.push(function() {\n      handleMessageFlows(collaboration.messageFlows);\n    });\n  }\n\n\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function(flowNode) {\n      var lanes = flowNode.get('lanes');\n\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n\n  ///// API ////////////////////////////////\n\n  return {\n    handleDefinitions: handleDefinitions\n  };\n}\n\nmodule.exports = BpmnTreeWalker;","'use strict';\n\nvar BpmnTreeWalker = require(161);\n\n\n/**\n * Import the definitions into a diagram.\n *\n * Errors and warnings are reported through the specified callback.\n *\n * @param  {Diagram} diagram\n * @param  {ModdleElement} definitions\n * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done\n */\nfunction importBpmnDiagram(diagram, definitions, done) {\n\n  var importer = diagram.get('bpmnImporter'),\n      eventBus = diagram.get('eventBus'),\n      translate = diagram.get('translate');\n\n  var error,\n      warnings = [];\n\n  /**\n   * Walk the diagram semantically, importing (=drawing)\n   * all elements you encounter.\n   *\n   * @param {ModdleElement} definitions\n   */\n  function render(definitions) {\n\n    var visitor = {\n\n      root: function(element) {\n        return importer.add(element);\n      },\n\n      element: function(element, parentShape) {\n        return importer.add(element, parentShape);\n      },\n\n      error: function(message, context) {\n        warnings.push({ message: message, context: context });\n      }\n    };\n\n    var walker = new BpmnTreeWalker(visitor, translate);\n\n    // traverse BPMN 2.0 document model,\n    // starting at definitions\n    walker.handleDefinitions(definitions);\n  }\n\n  eventBus.fire('import.render.start', { definitions: definitions });\n\n  try {\n    render(definitions);\n  } catch (e) {\n    error = e;\n  }\n\n  eventBus.fire('import.render.complete', {\n    error: error,\n    warnings: warnings\n  });\n\n  done(error, warnings);\n}\n\nmodule.exports.importBpmnDiagram = importBpmnDiagram;","'use strict';\n\nmodule.exports.elementToString = function(e) {\n  if (!e) {\n    return '<null>';\n  }\n\n  return '<' + e.$type + (e.id ? ' id=\"' + e.id : '') + '\" />';\n};","module.exports = {\n  __depends__: [\n    require(325)\n  ],\n  bpmnImporter: [ 'type', require(160) ]\n};","'use strict';\n\nvar is = require(167).is,\n    getBusinessObject = require(167).getBusinessObject;\n\nvar forEach = require(386);\n\nmodule.exports.isExpanded = function(element) {\n\n  if (is(element, 'bpmn:CallActivity')) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:SubProcess')) {\n    return !!getBusinessObject(element).di.isExpanded;\n  }\n\n  if (is(element, 'bpmn:Participant')) {\n    return !!getBusinessObject(element).processRef;\n  }\n\n  return true;\n};\n\nmodule.exports.isInterrupting = function(element) {\n  return element && getBusinessObject(element).isInterrupting !== false;\n};\n\nmodule.exports.isEventSubProcess = function(element) {\n  return element && !!getBusinessObject(element).triggeredByEvent;\n};\n\nfunction hasEventDefinition(element, eventType) {\n  var bo = getBusinessObject(element),\n      hasEventDefinition = false;\n\n  if (bo.eventDefinitions) {\n    forEach(bo.eventDefinitions, function(event) {\n      if (is(event, eventType)) {\n        hasEventDefinition = true;\n      }\n    });\n  }\n\n  return hasEventDefinition;\n}\n\nmodule.exports.hasEventDefinition = hasEventDefinition;\n\nmodule.exports.hasErrorEventDefinition = function(element) {\n  return hasEventDefinition(element, 'bpmn:ErrorEventDefinition');\n};\n\nmodule.exports.hasEscalationEventDefinition = function(element) {\n  return hasEventDefinition(element, 'bpmn:EscalationEventDefinition');\n};\n\nmodule.exports.hasCompensateEventDefinition = function(element) {\n  return hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n};\n","'use strict';\n\nvar assign = require(516);\n\nvar is = require(167).is;\n\nvar DEFAULT_LABEL_SIZE = module.exports.DEFAULT_LABEL_SIZE = {\n  width: 90,\n  height: 20\n};\n\nvar FLOW_LABEL_INDENT = module.exports.FLOW_LABEL_INDENT = 15;\n\n\n/**\n * Returns true if the given semantic has an external label\n *\n * @param {BpmnElement} semantic\n * @return {Boolean} true if has label\n */\nmodule.exports.hasExternalLabel = function(semantic) {\n  return is(semantic, 'bpmn:Event') ||\n         is(semantic, 'bpmn:Gateway') ||\n         is(semantic, 'bpmn:DataStoreReference') ||\n         is(semantic, 'bpmn:DataObjectReference') ||\n         is(semantic, 'bpmn:SequenceFlow') ||\n         is(semantic, 'bpmn:MessageFlow');\n};\n\n/**\n * Get the position for sequence flow labels\n *\n * @param  {Array<Point>} waypoints\n * @return {Point} the label position\n */\nfunction getFlowLabelPosition(waypoints) {\n\n  // get the waypoints mid\n  var mid = waypoints.length / 2 - 1;\n\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  // get position\n  var position = getWaypointsMid(waypoints);\n\n  // calculate angle\n  var angle = Math.atan( (second.y - first.y) / (second.x - first.x) );\n\n  var x = position.x,\n      y = position.y;\n\n  if ( Math.abs(angle) < Math.PI / 2 ) {\n    y -= FLOW_LABEL_INDENT;\n  } else {\n    x += FLOW_LABEL_INDENT;\n  }\n\n  return { x: x, y: y };\n}\n\nmodule.exports.getFlowLabelPosition = getFlowLabelPosition;\n\n/**\n * Get the middle of a number of waypoints\n *\n * @param  {Array<Point>} waypoints\n * @return {Point} the mid point\n */\nfunction getWaypointsMid(waypoints) {\n\n  var mid = waypoints.length / 2 - 1;\n\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  return {\n    x: first.x + (second.x - first.x) / 2,\n    y: first.y + (second.y - first.y) / 2\n  };\n}\n\nmodule.exports.getWaypointsMid = getWaypointsMid;\n\n\nfunction getExternalLabelMid(element) {\n\n  if (element.waypoints) {\n    return getFlowLabelPosition(element.waypoints);\n  } else {\n    return {\n      x: element.x + element.width / 2,\n      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2\n    };\n  }\n}\n\nmodule.exports.getExternalLabelMid = getExternalLabelMid;\n\n\n/**\n * Returns the bounds of an elements label, parsed from the elements DI or\n * generated from its bounds.\n *\n * @param {BpmnElement} semantic\n * @param {djs.model.Base} element\n */\nmodule.exports.getExternalLabelBounds = function(semantic, element) {\n\n  var mid,\n      size,\n      bounds,\n      di = semantic.di,\n      label = di.label;\n\n  if (label && label.bounds) {\n    bounds = label.bounds;\n\n    size = {\n      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),\n      height: bounds.height\n    };\n\n    mid = {\n      x: bounds.x + bounds.width / 2,\n      y: bounds.y + bounds.height / 2\n    };\n  } else {\n\n    mid = getExternalLabelMid(element);\n\n    size = DEFAULT_LABEL_SIZE;\n  }\n\n  return assign({\n    x: mid.x - size.width / 2,\n    y: mid.y - size.height / 2\n  }, size);\n};\n","'use strict';\n\n/**\n * Is an element of the given BPMN type?\n *\n * @param  {djs.model.Base|ModdleElement} element\n * @param  {String} type\n *\n * @return {Boolean}\n */\nfunction is(element, type) {\n  var bo = getBusinessObject(element);\n\n  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);\n}\n\nmodule.exports.is = is;\n\n\n/**\n * Return the business object for a given element.\n *\n * @param  {djs.model.Base|ModdleElement} element\n *\n * @return {ModdleElement}\n */\nfunction getBusinessObject(element) {\n  return (element && element.businessObject) || element;\n}\n\nmodule.exports.getBusinessObject = getBusinessObject;\n","/**\n * This file must not be changed or exchanged.\n *\n * @see http://bpmn.io/license for more information.\n */\n\n'use strict';\n\nvar domify = require(535);\n\nvar domDelegate = require(534);\n\n/* jshint -W101 */\n\n// inlined ../resources/bpmnjs.png\nvar logoData = module.exports.BPMNIO_LOGO = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';\n\n/* jshint +W101 */\n\n\nfunction css(attrs) {\n  return attrs.join(';');\n}\n\nvar LIGHTBOX_STYLES = css([\n  'z-index: 1001',\n  'position: fixed',\n  'top: 0',\n  'left: 0',\n  'right: 0',\n  'bottom: 0'\n]);\n\nvar BACKDROP_STYLES = css([\n  'width: 100%',\n  'height: 100%',\n  'background: rgba(0,0,0,0.2)'\n]);\n\nvar NOTICE_STYLES = css([\n  'position: absolute',\n  'left: 50%',\n  'top: 40%',\n  'margin: 0 -130px',\n  'width: 260px',\n  'padding: 10px',\n  'background: white',\n  'border: solid 1px #AAA',\n  'border-radius: 3px',\n  'font-family: Helvetica, Arial, sans-serif',\n  'font-size: 14px',\n  'line-height: 1.2em'\n]);\n\nvar LIGHTBOX_MARKUP =\n  '<div class=\"bjs-powered-by-lightbox\" style=\"' + LIGHTBOX_STYLES + '\">' +\n    '<div class=\"backdrop\" style=\"' + BACKDROP_STYLES + '\"></div>' +\n    '<div class=\"notice\" style=\"' + NOTICE_STYLES + '\">' +\n      '<a href=\"http://bpmn.io\" target=\"_blank\" style=\"float: left; margin-right: 10px\">' +\n        '<img src=\"data:image/png;base64,'+ logoData +'\">' +\n      '</a>' +\n      'Web-based tooling for BPMN, DMN and CMMN diagrams ' +\n      'powered by <a href=\"http://bpmn.io\" target=\"_blank\">bpmn.io</a>.' +\n    '</div>' +\n  '</div>';\n\n\nvar lightbox;\n\nfunction open() {\n\n  if (!lightbox) {\n    lightbox = domify(LIGHTBOX_MARKUP);\n\n    domDelegate.bind(lightbox, '.backdrop', 'click', function(event) {\n      document.body.removeChild(lightbox);\n    });\n  }\n\n  document.body.appendChild(lightbox);\n}\n\nmodule.exports.open = open;","'use strict';\n\nvar forEach = require(386),\n    filter = require(384),\n    any = require(382),\n    sort = require(394),\n    isArray = require(506);\n\nvar IGNORED_PROPERTIES = require(170).IGNORED_PROPERTIES;\n\nfunction isAllowedIn(extProp, type) {\n  var allowedIn = extProp.meta.allowedIn;\n\n  // '*' is a wildcard, which means any element is allowed to use this property\n  if (allowedIn.length === 1 && allowedIn[0] === '*') {\n    return true;\n  }\n\n  return allowedIn.indexOf(type) !== -1;\n}\n\nfunction isType(element, types) {\n  return any(types, function(type) {\n    return typeof element === type;\n  });\n}\n\n/**\n * A bpmn properties cloning interface\n *\n */\nfunction ModelCloneHelper(eventBus) {\n  this._eventBus = eventBus;\n}\n\nmodule.exports = ModelCloneHelper;\n\n\nModelCloneHelper.prototype.clone = function(refElement, newElement, properties) {\n  // hasNestedProperty: property allows us to avoid ending up with empty (xml) tags\n  // f.ex: if extensionElements.values is empty, don't set it\n  var context = {\n    newElement: newElement,\n    hasNestedProperty: false\n  };\n\n  // we want the extensionElements to be cloned last\n  // so that they can check certain properties\n  properties = sort(properties, function(prop) {\n    return prop === 'bpmn:extensionElements';\n  });\n\n  forEach(properties, function(propName) {\n    var refElementProp = refElement.get(propName),\n        newElementProp = newElement.get(propName),\n        propDescriptor = newElement.$model.getPropertyDescriptor(newElement, propName),\n        newProperty, name;\n\n    // we're not interested in cloning:\n    // - same values from simple types\n    // - cloning id's\n    // - cloning reference elements\n    if (newElementProp === refElementProp ||\n       (propDescriptor && (propDescriptor.isId || propDescriptor.isReference))) {\n      return;\n    }\n\n    // if the property is of type 'boolean', 'string', 'number' or 'null', just set it\n    if (isType(refElementProp, [ 'boolean', 'string', 'number' ]) || refElementProp === null) {\n      newElement.set(propName, refElementProp);\n\n      return;\n    }\n\n    if (isArray(refElementProp)) {\n\n      forEach(refElementProp, function(extElement) {\n        var newProp;\n\n        context.refTopLevelProperty = extElement;\n\n        newProp = this._deepClone(extElement, context);\n\n        if (context.hasNestedProperty) {\n          newProp.$parent = newElement;\n\n          newElementProp.push(newProp);\n        }\n\n        context.hasNestedProperty = false;\n      }, this);\n\n    } else {\n      name = propName.replace(/bpmn:/, '');\n\n      context.refTopLevelProperty = refElementProp;\n\n      newProperty = this._deepClone(refElementProp, context);\n\n      if (context.hasNestedProperty) {\n        newElement[name] = newProperty;\n      }\n\n      context.hasNestedProperty = false;\n    }\n  }, this);\n\n  return newElement;\n};\n\nModelCloneHelper.prototype._deepClone = function _deepClone(propertyElement, context) {\n  var eventBus = this._eventBus;\n\n  var newProp = propertyElement.$model.create(propertyElement.$type);\n\n  var properties = filter(Object.keys(propertyElement), function(prop) {\n    var descriptor = newProp.$model.getPropertyDescriptor(newProp, prop);\n\n    if (descriptor && (descriptor.isId || descriptor.isReference)) {\n      return false;\n    }\n\n    // we need to make sure we don't clone certain properties\n    // which we cannot easily know if they hold references or not\n    if (IGNORED_PROPERTIES.indexOf(prop) !== -1) {\n      return false;\n    }\n\n    // make sure we don't copy the type\n    return prop !== '$type';\n  });\n\n  if (!properties.length) {\n    context.hasNestedProperty = true;\n  }\n\n  forEach(properties, function(propName) {\n    // check if the propertyElement has this property defined\n    if (propertyElement[propName] !== undefined &&\n       (propertyElement[propName].$type || isArray(propertyElement[propName]))) {\n\n      if (isArray(propertyElement[propName])) {\n        newProp[propName] = [];\n\n        forEach(propertyElement[propName], function(property) {\n          var extProp = propertyElement.$model.getTypeDescriptor(property.$type),\n              newDeepProp;\n\n          // we're not going to copy undefined types\n          if (!extProp) {\n            return;\n          }\n\n          var canClone = eventBus.fire('property.clone', {\n            newElement: context.newElement,\n            refTopLevelProperty: context.refTopLevelProperty,\n            propertyDescriptor: extProp\n          });\n\n          if (!canClone) {\n            // if can clone is 'undefined' or 'false'\n            // check for the meta information if it is allowed\n            if (propertyElement.$type === 'bpmn:ExtensionElements' &&\n                extProp.meta && extProp.meta.allowedIn &&\n                !isAllowedIn(extProp, context.newElement.$type)) {\n              return false;\n            }\n          }\n\n          newDeepProp = this._deepClone(property, context);\n\n          newDeepProp.$parent = newProp;\n\n          if (!newProp[propName]) {\n            newProp[propName] = [];\n          }\n\n          context.hasNestedProperty = true;\n\n          newProp[propName].push(newDeepProp);\n        }, this);\n\n      } else if (propertyElement[propName].$type) {\n        newProp[propName] = this._deepClone(propertyElement[propName], context);\n\n        if (newProp[propName]) {\n          context.hasNestedProperty = true;\n\n          newProp[propName].$parent = newProp;\n        }\n      }\n    } else {\n      context.hasNestedProperty = true;\n\n      // just assign directly if it's a value\n      newProp[propName] = propertyElement[propName];\n    }\n  }, this);\n\n  return newProp;\n};\n","'use strict';\n\nvar forEach = require(386);\n\n/**\n * These are the properties that should be ignored when cloning elements.\n *\n * @type {Array}\n */\nmodule.exports.IGNORED_PROPERTIES = [\n  'lanes',\n  'incoming',\n  'outgoing',\n  'artifacts',\n  'default',\n  'flowElements'\n];\n\n\nfunction getProperties(descriptor, keepDefault) {\n  var properties = [];\n\n  forEach(descriptor.properties, function(property) {\n\n    if (keepDefault && property.default) {\n      return;\n    }\n\n    properties.push(property.ns.name);\n  });\n\n  return properties;\n}\n\nmodule.exports.getProperties = getProperties;\n","module.exports = require(173);","'use strict';\n\nvar isString = require(513),\n    isFunction = require(508),\n    assign = require(516);\n\nvar Moddle = require(543),\n    XmlReader = require(541),\n    XmlWriter = require(542);\n\n/**\n * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.\n *\n * @class BpmnModdle\n * @extends Moddle\n *\n * @param {Object|Array} packages to use for instantiating the model\n * @param {Object} [options] additional options to pass over\n */\nfunction BpmnModdle(packages, options) {\n  Moddle.call(this, packages, options);\n}\n\nBpmnModdle.prototype = Object.create(Moddle.prototype);\n\nmodule.exports = BpmnModdle;\n\n\n/**\n * Instantiates a BPMN model tree from a given xml string.\n *\n * @param {String}   xmlStr\n * @param {String}   [typeName='bpmn:Definitions'] name of the root element\n * @param {Object}   [options]  options to pass to the underlying reader\n * @param {Function} done       callback that is invoked with (err, result, parseContext)\n *                              once the import completes\n */\nBpmnModdle.prototype.fromXML = function(xmlStr, typeName, options, done) {\n\n  if (!isString(typeName)) {\n    done = options;\n    options = typeName;\n    typeName = 'bpmn:Definitions';\n  }\n\n  if (isFunction(options)) {\n    done = options;\n    options = {};\n  }\n\n  var reader = new XmlReader(assign({ model: this, lax: true }, options));\n  var rootHandler = reader.handler(typeName);\n\n  reader.fromXML(xmlStr, rootHandler, done);\n};\n\n\n/**\n * Serializes a BPMN 2.0 object tree to XML.\n *\n * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`\n * @param {Object}   [options]  to pass to the underlying writer\n * @param {Function} done       callback invoked with (err, xmlStr) once the import completes\n */\nBpmnModdle.prototype.toXML = function(element, options, done) {\n\n  if (isFunction(options)) {\n    done = options;\n    options = {};\n  }\n\n  var writer = new XmlWriter(options);\n  try {\n    var result = writer.toXML(element);\n    done(null, result);\n  } catch (e) {\n    done(e);\n  }\n};\n","'use strict';\n\nvar assign = require(516);\n\nvar BpmnModdle = require(172);\n\nvar packages = {\n  bpmn: require(175),\n  bpmndi: require(176),\n  dc: require(177),\n  di: require(178),\n  bioc: require(174)\n};\n\nmodule.exports = function(additionalPackages, options) {\n  return new BpmnModdle(assign({}, packages, additionalPackages), options);\n};\n","module.exports={\r\n  \"name\": \"bpmn.io colors for BPMN\",\r\n  \"uri\": \"http://bpmn.io/schema/bpmn/biocolor/1.0\",\r\n  \"prefix\": \"bioc\",\r\n  \"types\": [\r\n    {\r\n      \"name\": \"ColoredShape\",\r\n      \"extends\": [ \"bpmndi:BPMNShape\" ],\r\n      \"properties\": [\r\n        {\r\n          \"name\": \"stroke\",\r\n          \"isAttr\": true,\r\n          \"type\": \"String\"\r\n        },\r\n        {\r\n          \"name\": \"fill\",\r\n          \"isAttr\": true,\r\n          \"type\": \"String\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"name\": \"ColoredEdge\",\r\n      \"extends\": [ \"bpmndi:BPMNEdge\" ],\r\n      \"properties\": [\r\n        {\r\n          \"name\": \"stroke\",\r\n          \"isAttr\": true,\r\n          \"type\": \"String\"\r\n        },\r\n        {\r\n          \"name\": \"fill\",\r\n          \"isAttr\": true,\r\n          \"type\": \"String\"\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"emumerations\": [],\r\n  \"associations\": []\r\n}\r\n","module.exports={\n  \"name\": \"BPMN20\",\n  \"uri\": \"http://www.omg.org/spec/BPMN/20100524/MODEL\",\n  \"associations\": [],\n  \"types\": [\n    {\n      \"name\": \"Interface\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"operations\",\n          \"type\": \"Operation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"implementationRef\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Operation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"inMessageRef\",\n          \"type\": \"Message\",\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outMessageRef\",\n          \"type\": \"Message\",\n          \"isReference\": true\n        },\n        {\n          \"name\": \"errorRef\",\n          \"type\": \"Error\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"implementationRef\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"EndPoint\",\n      \"superClass\": [\n        \"RootElement\"\n      ]\n    },\n    {\n      \"name\": \"Auditing\",\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"GlobalTask\",\n      \"superClass\": [\n        \"CallableElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"resources\",\n          \"type\": \"ResourceRole\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Monitoring\",\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"Performer\",\n      \"superClass\": [\n        \"ResourceRole\"\n      ]\n    },\n    {\n      \"name\": \"Process\",\n      \"superClass\": [\n        \"FlowElementsContainer\",\n        \"CallableElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"processType\",\n          \"type\": \"ProcessType\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isClosed\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"auditing\",\n          \"type\": \"Auditing\"\n        },\n        {\n          \"name\": \"monitoring\",\n          \"type\": \"Monitoring\"\n        },\n        {\n          \"name\": \"properties\",\n          \"type\": \"Property\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"laneSets\",\n          \"type\": \"LaneSet\",\n          \"isMany\": true,\n          \"replaces\": \"FlowElementsContainer#laneSets\"\n        },\n        {\n          \"name\": \"flowElements\",\n          \"type\": \"FlowElement\",\n          \"isMany\": true,\n          \"replaces\": \"FlowElementsContainer#flowElements\"\n        },\n        {\n          \"name\": \"artifacts\",\n          \"type\": \"Artifact\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"resources\",\n          \"type\": \"ResourceRole\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"correlationSubscriptions\",\n          \"type\": \"CorrelationSubscription\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"supports\",\n          \"type\": \"Process\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"definitionalCollaborationRef\",\n          \"type\": \"Collaboration\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"isExecutable\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LaneSet\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"lanes\",\n          \"type\": \"Lane\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Lane\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"partitionElementRef\",\n          \"type\": \"BaseElement\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"partitionElement\",\n          \"type\": \"BaseElement\"\n        },\n        {\n          \"name\": \"flowNodeRef\",\n          \"type\": \"FlowNode\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"childLaneSet\",\n          \"type\": \"LaneSet\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"GlobalManualTask\",\n      \"superClass\": [\n        \"GlobalTask\"\n      ]\n    },\n    {\n      \"name\": \"ManualTask\",\n      \"superClass\": [\n        \"Task\"\n      ]\n    },\n    {\n      \"name\": \"UserTask\",\n      \"superClass\": [\n        \"Task\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"renderings\",\n          \"type\": \"Rendering\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Rendering\",\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"HumanPerformer\",\n      \"superClass\": [\n        \"Performer\"\n      ]\n    },\n    {\n      \"name\": \"PotentialOwner\",\n      \"superClass\": [\n        \"HumanPerformer\"\n      ]\n    },\n    {\n      \"name\": \"GlobalUserTask\",\n      \"superClass\": [\n        \"GlobalTask\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"renderings\",\n          \"type\": \"Rendering\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Gateway\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"gatewayDirection\",\n          \"type\": \"GatewayDirection\",\n          \"default\": \"Unspecified\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"EventBasedGateway\",\n      \"superClass\": [\n        \"Gateway\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"instantiate\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"eventGatewayType\",\n          \"type\": \"EventBasedGatewayType\",\n          \"isAttr\": true,\n          \"default\": \"Exclusive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ComplexGateway\",\n      \"superClass\": [\n        \"Gateway\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"activationCondition\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"default\",\n          \"type\": \"SequenceFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ExclusiveGateway\",\n      \"superClass\": [\n        \"Gateway\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"default\",\n          \"type\": \"SequenceFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"InclusiveGateway\",\n      \"superClass\": [\n        \"Gateway\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"default\",\n          \"type\": \"SequenceFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ParallelGateway\",\n      \"superClass\": [\n        \"Gateway\"\n      ]\n    },\n    {\n      \"name\": \"RootElement\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"Relationship\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"type\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"direction\",\n          \"type\": \"RelationshipDirection\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"source\",\n          \"isMany\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        },\n        {\n          \"name\": \"target\",\n          \"isMany\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BaseElement\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"isAttr\": true,\n          \"type\": \"String\",\n          \"isId\": true\n        },\n        {\n          \"name\": \"documentation\",\n          \"type\": \"Documentation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"extensionDefinitions\",\n          \"type\": \"ExtensionDefinition\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"extensionElements\",\n          \"type\": \"ExtensionElements\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Extension\",\n      \"properties\": [\n        {\n          \"name\": \"mustUnderstand\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"definition\",\n          \"type\": \"ExtensionDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ExtensionDefinition\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"extensionAttributeDefinitions\",\n          \"type\": \"ExtensionAttributeDefinition\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ExtensionAttributeDefinition\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"type\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isReference\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"extensionDefinition\",\n          \"type\": \"ExtensionDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ExtensionElements\",\n      \"properties\": [\n        {\n          \"name\": \"valueRef\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        },\n        {\n          \"name\": \"values\",\n          \"type\": \"Element\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"extensionAttributeDefinition\",\n          \"type\": \"ExtensionAttributeDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Documentation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"text\",\n          \"type\": \"String\",\n          \"isBody\": true\n        },\n        {\n          \"name\": \"textFormat\",\n          \"default\": \"text/plain\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Event\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowNode\",\n        \"InteractionNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"properties\",\n          \"type\": \"Property\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"IntermediateCatchEvent\",\n      \"superClass\": [\n        \"CatchEvent\"\n      ]\n    },\n    {\n      \"name\": \"IntermediateThrowEvent\",\n      \"superClass\": [\n        \"ThrowEvent\"\n      ]\n    },\n    {\n      \"name\": \"EndEvent\",\n      \"superClass\": [\n        \"ThrowEvent\"\n      ]\n    },\n    {\n      \"name\": \"StartEvent\",\n      \"superClass\": [\n        \"CatchEvent\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isInterrupting\",\n          \"default\": true,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ThrowEvent\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Event\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataInputs\",\n          \"type\": \"DataInput\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"dataInputAssociations\",\n          \"type\": \"DataInputAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"inputSet\",\n          \"type\": \"InputSet\"\n        },\n        {\n          \"name\": \"eventDefinitions\",\n          \"type\": \"EventDefinition\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"eventDefinitionRef\",\n          \"type\": \"EventDefinition\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CatchEvent\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Event\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"parallelMultiple\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\",\n          \"default\": false\n        },\n        {\n          \"name\": \"dataOutputs\",\n          \"type\": \"DataOutput\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"dataOutputAssociations\",\n          \"type\": \"DataOutputAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"outputSet\",\n          \"type\": \"OutputSet\"\n        },\n        {\n          \"name\": \"eventDefinitions\",\n          \"type\": \"EventDefinition\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"eventDefinitionRef\",\n          \"type\": \"EventDefinition\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"BoundaryEvent\",\n      \"superClass\": [\n        \"CatchEvent\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"cancelActivity\",\n          \"default\": true,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"attachedToRef\",\n          \"type\": \"Activity\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"EventDefinition\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"RootElement\"\n      ]\n    },\n    {\n      \"name\": \"CancelEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ]\n    },\n    {\n      \"name\": \"ErrorEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"errorRef\",\n          \"type\": \"Error\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"TerminateEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ]\n    },\n    {\n      \"name\": \"EscalationEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"escalationRef\",\n          \"type\": \"Escalation\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Escalation\",\n      \"properties\": [\n        {\n          \"name\": \"structureRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"escalationCode\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ],\n      \"superClass\": [\n        \"RootElement\"\n      ]\n    },\n    {\n      \"name\": \"CompensateEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"waitForCompletion\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"activityRef\",\n          \"type\": \"Activity\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"TimerEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"timeDate\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"timeCycle\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"timeDuration\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"LinkEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"target\",\n          \"type\": \"LinkEventDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"source\",\n          \"type\": \"LinkEventDefinition\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"messageRef\",\n          \"type\": \"Message\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"operationRef\",\n          \"type\": \"Operation\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ConditionalEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"condition\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"SignalEventDefinition\",\n      \"superClass\": [\n        \"EventDefinition\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"signalRef\",\n          \"type\": \"Signal\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Signal\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"structureRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ImplicitThrowEvent\",\n      \"superClass\": [\n        \"ThrowEvent\"\n      ]\n    },\n    {\n      \"name\": \"DataState\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ItemAwareElement\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"itemSubjectRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"dataState\",\n          \"type\": \"DataState\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DataAssociation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"assignment\",\n          \"type\": \"Assignment\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"ItemAwareElement\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"ItemAwareElement\",\n          \"isReference\": true\n        },\n        {\n          \"name\": \"transformation\",\n          \"type\": \"FormalExpression\",\n          \"xml\": {\n            \"serialize\": \"property\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"DataInput\",\n      \"superClass\": [\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isCollection\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"inputSetRef\",\n          \"type\": \"InputSet\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"inputSetWithOptional\",\n          \"type\": \"InputSet\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"inputSetWithWhileExecuting\",\n          \"type\": \"InputSet\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"DataOutput\",\n      \"superClass\": [\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isCollection\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"outputSetRef\",\n          \"type\": \"OutputSet\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outputSetWithOptional\",\n          \"type\": \"OutputSet\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outputSetWithWhileExecuting\",\n          \"type\": \"OutputSet\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"InputSet\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"dataInputRefs\",\n          \"type\": \"DataInput\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"optionalInputRefs\",\n          \"type\": \"DataInput\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"whileExecutingInputRefs\",\n          \"type\": \"DataInput\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outputSetRefs\",\n          \"type\": \"OutputSet\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"OutputSet\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataOutputRefs\",\n          \"type\": \"DataOutput\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"inputSetRefs\",\n          \"type\": \"InputSet\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"optionalOutputRefs\",\n          \"type\": \"DataOutput\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"whileExecutingOutputRefs\",\n          \"type\": \"DataOutput\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Property\",\n      \"superClass\": [\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DataInputAssociation\",\n      \"superClass\": [\n        \"DataAssociation\"\n      ]\n    },\n    {\n      \"name\": \"DataOutputAssociation\",\n      \"superClass\": [\n        \"DataAssociation\"\n      ]\n    },\n    {\n      \"name\": \"InputOutputSpecification\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataInputs\",\n          \"type\": \"DataInput\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"dataOutputs\",\n          \"type\": \"DataOutput\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"inputSets\",\n          \"type\": \"InputSet\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"outputSets\",\n          \"type\": \"OutputSet\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"DataObject\",\n      \"superClass\": [\n        \"FlowElement\",\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isCollection\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InputOutputBinding\",\n      \"properties\": [\n        {\n          \"name\": \"inputDataRef\",\n          \"type\": \"InputSet\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outputDataRef\",\n          \"type\": \"OutputSet\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"operationRef\",\n          \"type\": \"Operation\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Assignment\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"from\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"to\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"DataStore\",\n      \"superClass\": [\n        \"RootElement\",\n        \"ItemAwareElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"capacity\",\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        },\n        {\n          \"name\": \"isUnlimited\",\n          \"default\": true,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DataStoreReference\",\n      \"superClass\": [\n        \"ItemAwareElement\",\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataStoreRef\",\n          \"type\": \"DataStore\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"DataObjectReference\",\n      \"superClass\": [\n        \"ItemAwareElement\",\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataObjectRef\",\n          \"type\": \"DataObject\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ConversationLink\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"InteractionNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"InteractionNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ConversationAssociation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"innerConversationNodeRef\",\n          \"type\": \"ConversationNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outerConversationNodeRef\",\n          \"type\": \"ConversationNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CallConversation\",\n      \"superClass\": [\n        \"ConversationNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"calledCollaborationRef\",\n          \"type\": \"Collaboration\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"participantAssociations\",\n          \"type\": \"ParticipantAssociation\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Conversation\",\n      \"superClass\": [\n        \"ConversationNode\"\n      ]\n    },\n    {\n      \"name\": \"SubConversation\",\n      \"superClass\": [\n        \"ConversationNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"conversationNodes\",\n          \"type\": \"ConversationNode\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ConversationNode\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"InteractionNode\",\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"participantRefs\",\n          \"type\": \"Participant\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"messageFlowRefs\",\n          \"type\": \"MessageFlow\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"correlationKeys\",\n          \"type\": \"CorrelationKey\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"GlobalConversation\",\n      \"superClass\": [\n        \"Collaboration\"\n      ]\n    },\n    {\n      \"name\": \"PartnerEntity\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"participantRef\",\n          \"type\": \"Participant\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"PartnerRole\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"participantRef\",\n          \"type\": \"Participant\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CorrelationProperty\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"correlationPropertyRetrievalExpression\",\n          \"type\": \"CorrelationPropertyRetrievalExpression\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"type\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Error\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"structureRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"errorCode\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CorrelationKey\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"correlationPropertyRef\",\n          \"type\": \"CorrelationProperty\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Expression\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"isAbstract\": false,\n      \"properties\": [\n        {\n          \"name\": \"body\",\n          \"type\": \"String\",\n          \"isBody\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"FormalExpression\",\n      \"superClass\": [\n        \"Expression\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"language\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"evaluatesToTypeRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Message\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"itemRef\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ItemDefinition\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"itemKind\",\n          \"type\": \"ItemKind\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"structureRef\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isCollection\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"import\",\n          \"type\": \"Import\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"FlowElement\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"auditing\",\n          \"type\": \"Auditing\"\n        },\n        {\n          \"name\": \"monitoring\",\n          \"type\": \"Monitoring\"\n        },\n        {\n          \"name\": \"categoryValueRef\",\n          \"type\": \"CategoryValue\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"SequenceFlow\",\n      \"superClass\": [\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isImmediate\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"conditionExpression\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"FlowNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"FlowNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"FlowElementsContainer\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"laneSets\",\n          \"type\": \"LaneSet\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"flowElements\",\n          \"type\": \"FlowElement\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CallableElement\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"ioSpecification\",\n          \"type\": \"InputOutputSpecification\",\n          \"xml\": {\n            \"serialize\": \"property\"\n          }\n        },\n        {\n          \"name\": \"supportedInterfaceRef\",\n          \"type\": \"Interface\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"ioBinding\",\n          \"type\": \"InputOutputBinding\",\n          \"isMany\": true,\n          \"xml\": {\n            \"serialize\": \"property\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"FlowNode\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"incoming\",\n          \"type\": \"SequenceFlow\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outgoing\",\n          \"type\": \"SequenceFlow\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"lanes\",\n          \"type\": \"Lane\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CorrelationPropertyRetrievalExpression\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"messagePath\",\n          \"type\": \"FormalExpression\"\n        },\n        {\n          \"name\": \"messageRef\",\n          \"type\": \"Message\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CorrelationPropertyBinding\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"dataPath\",\n          \"type\": \"FormalExpression\"\n        },\n        {\n          \"name\": \"correlationPropertyRef\",\n          \"type\": \"CorrelationProperty\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Resource\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"resourceParameters\",\n          \"type\": \"ResourceParameter\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ResourceParameter\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isRequired\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"type\",\n          \"type\": \"ItemDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CorrelationSubscription\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"correlationKeyRef\",\n          \"type\": \"CorrelationKey\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"correlationPropertyBinding\",\n          \"type\": \"CorrelationPropertyBinding\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageFlow\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"InteractionNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"InteractionNode\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"messageRef\",\n          \"type\": \"Message\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageFlowAssociation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"innerMessageFlowRef\",\n          \"type\": \"MessageFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outerMessageFlowRef\",\n          \"type\": \"MessageFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"InteractionNode\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"incomingConversationLinks\",\n          \"type\": \"ConversationLink\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outgoingConversationLinks\",\n          \"type\": \"ConversationLink\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Participant\",\n      \"superClass\": [\n        \"InteractionNode\",\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"interfaceRef\",\n          \"type\": \"Interface\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"participantMultiplicity\",\n          \"type\": \"ParticipantMultiplicity\"\n        },\n        {\n          \"name\": \"endPointRefs\",\n          \"type\": \"EndPoint\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"processRef\",\n          \"type\": \"Process\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ParticipantAssociation\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"innerParticipantRef\",\n          \"type\": \"Participant\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"outerParticipantRef\",\n          \"type\": \"Participant\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ParticipantMultiplicity\",\n      \"properties\": [\n        {\n          \"name\": \"minimum\",\n          \"default\": 0,\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        },\n        {\n          \"name\": \"maximum\",\n          \"default\": 1,\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Collaboration\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"isClosed\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"participants\",\n          \"type\": \"Participant\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"messageFlows\",\n          \"type\": \"MessageFlow\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"artifacts\",\n          \"type\": \"Artifact\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"conversations\",\n          \"type\": \"ConversationNode\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"conversationAssociations\",\n          \"type\": \"ConversationAssociation\"\n        },\n        {\n          \"name\": \"participantAssociations\",\n          \"type\": \"ParticipantAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"messageFlowAssociations\",\n          \"type\": \"MessageFlowAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"correlationKeys\",\n          \"type\": \"CorrelationKey\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"choreographyRef\",\n          \"type\": \"Choreography\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"conversationLinks\",\n          \"type\": \"ConversationLink\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ChoreographyActivity\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"participantRefs\",\n          \"type\": \"Participant\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"initiatingParticipantRef\",\n          \"type\": \"Participant\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"correlationKeys\",\n          \"type\": \"CorrelationKey\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"loopType\",\n          \"type\": \"ChoreographyLoopType\",\n          \"default\": \"None\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"CallChoreography\",\n      \"superClass\": [\n        \"ChoreographyActivity\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"calledChoreographyRef\",\n          \"type\": \"Choreography\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"participantAssociations\",\n          \"type\": \"ParticipantAssociation\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"SubChoreography\",\n      \"superClass\": [\n        \"ChoreographyActivity\",\n        \"FlowElementsContainer\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"artifacts\",\n          \"type\": \"Artifact\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ChoreographyTask\",\n      \"superClass\": [\n        \"ChoreographyActivity\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"messageFlowRef\",\n          \"type\": \"MessageFlow\",\n          \"isMany\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Choreography\",\n      \"superClass\": [\n        \"FlowElementsContainer\",\n        \"Collaboration\"\n      ]\n    },\n    {\n      \"name\": \"GlobalChoreographyTask\",\n      \"superClass\": [\n        \"Choreography\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"initiatingParticipantRef\",\n          \"type\": \"Participant\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"TextAnnotation\",\n      \"superClass\": [\n        \"Artifact\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"text\",\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"textFormat\",\n          \"default\": \"text/plain\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Group\",\n      \"superClass\": [\n        \"Artifact\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"categoryValueRef\",\n          \"type\": \"CategoryValue\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Association\",\n      \"superClass\": [\n        \"Artifact\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"associationDirection\",\n          \"type\": \"AssociationDirection\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"sourceRef\",\n          \"type\": \"BaseElement\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"targetRef\",\n          \"type\": \"BaseElement\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Category\",\n      \"superClass\": [\n        \"RootElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"categoryValue\",\n          \"type\": \"CategoryValue\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Artifact\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"CategoryValue\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"categorizedFlowElements\",\n          \"type\": \"FlowElement\",\n          \"isVirtual\": true,\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"value\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Activity\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"FlowNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isForCompensation\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"default\",\n          \"type\": \"SequenceFlow\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"ioSpecification\",\n          \"type\": \"InputOutputSpecification\",\n          \"xml\": {\n            \"serialize\": \"property\"\n          }\n        },\n        {\n          \"name\": \"boundaryEventRefs\",\n          \"type\": \"BoundaryEvent\",\n          \"isMany\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"properties\",\n          \"type\": \"Property\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"dataInputAssociations\",\n          \"type\": \"DataInputAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"dataOutputAssociations\",\n          \"type\": \"DataOutputAssociation\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"startQuantity\",\n          \"default\": 1,\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        },\n        {\n          \"name\": \"resources\",\n          \"type\": \"ResourceRole\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"completionQuantity\",\n          \"default\": 1,\n          \"isAttr\": true,\n          \"type\": \"Integer\"\n        },\n        {\n          \"name\": \"loopCharacteristics\",\n          \"type\": \"LoopCharacteristics\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ServiceTask\",\n      \"superClass\": [\n        \"Task\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"operationRef\",\n          \"type\": \"Operation\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"SubProcess\",\n      \"superClass\": [\n        \"Activity\",\n        \"FlowElementsContainer\",\n        \"InteractionNode\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"triggeredByEvent\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"artifacts\",\n          \"type\": \"Artifact\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"LoopCharacteristics\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"MultiInstanceLoopCharacteristics\",\n      \"superClass\": [\n        \"LoopCharacteristics\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"isSequential\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"behavior\",\n          \"type\": \"MultiInstanceBehavior\",\n          \"default\": \"All\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"loopCardinality\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"loopDataInputRef\",\n          \"type\": \"ItemAwareElement\",\n          \"isReference\": true\n        },\n        {\n          \"name\": \"loopDataOutputRef\",\n          \"type\": \"ItemAwareElement\",\n          \"isReference\": true\n        },\n        {\n          \"name\": \"inputDataItem\",\n          \"type\": \"DataInput\",\n          \"xml\": {\n            \"serialize\": \"property\"\n          }\n        },\n        {\n          \"name\": \"outputDataItem\",\n          \"type\": \"DataOutput\",\n          \"xml\": {\n            \"serialize\": \"property\"\n          }\n        },\n        {\n          \"name\": \"complexBehaviorDefinition\",\n          \"type\": \"ComplexBehaviorDefinition\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"completionCondition\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"oneBehaviorEventRef\",\n          \"type\": \"EventDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"noneBehaviorEventRef\",\n          \"type\": \"EventDefinition\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"StandardLoopCharacteristics\",\n      \"superClass\": [\n        \"LoopCharacteristics\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"testBefore\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"loopCondition\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"loopMaximum\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"CallActivity\",\n      \"superClass\": [\n        \"Activity\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"calledElement\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Task\",\n      \"superClass\": [\n        \"Activity\",\n        \"InteractionNode\"\n      ]\n    },\n    {\n      \"name\": \"SendTask\",\n      \"superClass\": [\n        \"Task\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"operationRef\",\n          \"type\": \"Operation\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"messageRef\",\n          \"type\": \"Message\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ReceiveTask\",\n      \"superClass\": [\n        \"Task\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"instantiate\",\n          \"default\": false,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"operationRef\",\n          \"type\": \"Operation\",\n          \"isAttr\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"messageRef\",\n          \"type\": \"Message\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ScriptTask\",\n      \"superClass\": [\n        \"Task\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"scriptFormat\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"script\",\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BusinessRuleTask\",\n      \"superClass\": [\n        \"Task\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AdHocSubProcess\",\n      \"superClass\": [\n        \"SubProcess\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"completionCondition\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"ordering\",\n          \"type\": \"AdHocOrdering\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"cancelRemainingInstances\",\n          \"default\": true,\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Transaction\",\n      \"superClass\": [\n        \"SubProcess\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"protocol\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"method\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GlobalScriptTask\",\n      \"superClass\": [\n        \"GlobalTask\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"scriptLanguage\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"script\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GlobalBusinessRuleTask\",\n      \"superClass\": [\n        \"GlobalTask\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"implementation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ComplexBehaviorDefinition\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"condition\",\n          \"type\": \"FormalExpression\"\n        },\n        {\n          \"name\": \"event\",\n          \"type\": \"ImplicitThrowEvent\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ResourceRole\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"resourceRef\",\n          \"type\": \"Resource\",\n          \"isReference\": true\n        },\n        {\n          \"name\": \"resourceParameterBindings\",\n          \"type\": \"ResourceParameterBinding\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"resourceAssignmentExpression\",\n          \"type\": \"ResourceAssignmentExpression\"\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ResourceParameterBinding\",\n      \"properties\": [\n        {\n          \"name\": \"expression\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        },\n        {\n          \"name\": \"parameterRef\",\n          \"type\": \"ResourceParameter\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"ResourceAssignmentExpression\",\n      \"properties\": [\n        {\n          \"name\": \"expression\",\n          \"type\": \"Expression\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ],\n      \"superClass\": [\n        \"BaseElement\"\n      ]\n    },\n    {\n      \"name\": \"Import\",\n      \"properties\": [\n        {\n          \"name\": \"importType\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"location\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"namespace\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Definitions\",\n      \"superClass\": [\n        \"BaseElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"targetNamespace\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"expressionLanguage\",\n          \"default\": \"http://www.w3.org/1999/XPath\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"typeLanguage\",\n          \"default\": \"http://www.w3.org/2001/XMLSchema\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"imports\",\n          \"type\": \"Import\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"extensions\",\n          \"type\": \"Extension\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"rootElements\",\n          \"type\": \"RootElement\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"diagrams\",\n          \"isMany\": true,\n          \"type\": \"bpmndi:BPMNDiagram\"\n        },\n        {\n          \"name\": \"exporter\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"relationships\",\n          \"type\": \"Relationship\",\n          \"isMany\": true\n        },\n        {\n          \"name\": \"exporterVersion\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        }\n      ]\n    }\n  ],\n  \"emumerations\": [\n    {\n      \"name\": \"ProcessType\",\n      \"literalValues\": [\n        {\n          \"name\": \"None\"\n        },\n        {\n          \"name\": \"Public\"\n        },\n        {\n          \"name\": \"Private\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GatewayDirection\",\n      \"literalValues\": [\n        {\n          \"name\": \"Unspecified\"\n        },\n        {\n          \"name\": \"Converging\"\n        },\n        {\n          \"name\": \"Diverging\"\n        },\n        {\n          \"name\": \"Mixed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"EventBasedGatewayType\",\n      \"literalValues\": [\n        {\n          \"name\": \"Parallel\"\n        },\n        {\n          \"name\": \"Exclusive\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RelationshipDirection\",\n      \"literalValues\": [\n        {\n          \"name\": \"None\"\n        },\n        {\n          \"name\": \"Forward\"\n        },\n        {\n          \"name\": \"Backward\"\n        },\n        {\n          \"name\": \"Both\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ItemKind\",\n      \"literalValues\": [\n        {\n          \"name\": \"Physical\"\n        },\n        {\n          \"name\": \"Information\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ChoreographyLoopType\",\n      \"literalValues\": [\n        {\n          \"name\": \"None\"\n        },\n        {\n          \"name\": \"Standard\"\n        },\n        {\n          \"name\": \"MultiInstanceSequential\"\n        },\n        {\n          \"name\": \"MultiInstanceParallel\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AssociationDirection\",\n      \"literalValues\": [\n        {\n          \"name\": \"None\"\n        },\n        {\n          \"name\": \"One\"\n        },\n        {\n          \"name\": \"Both\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MultiInstanceBehavior\",\n      \"literalValues\": [\n        {\n          \"name\": \"None\"\n        },\n        {\n          \"name\": \"One\"\n        },\n        {\n          \"name\": \"All\"\n        },\n        {\n          \"name\": \"Complex\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AdHocOrdering\",\n      \"literalValues\": [\n        {\n          \"name\": \"Parallel\"\n        },\n        {\n          \"name\": \"Sequential\"\n        }\n      ]\n    }\n  ],\n  \"prefix\": \"bpmn\",\n  \"xml\": {\n    \"tagAlias\": \"lowerCase\",\n    \"typePrefix\": \"t\"\n  }\n}","module.exports={\n  \"name\": \"BPMNDI\",\n  \"uri\": \"http://www.omg.org/spec/BPMN/20100524/DI\",\n  \"types\": [\n    {\n      \"name\": \"BPMNDiagram\",\n      \"properties\": [\n        {\n          \"name\": \"plane\",\n          \"type\": \"BPMNPlane\",\n          \"redefines\": \"di:Diagram#rootElement\"\n        },\n        {\n          \"name\": \"labelStyle\",\n          \"type\": \"BPMNLabelStyle\",\n          \"isMany\": true\n        }\n      ],\n      \"superClass\": [\n        \"di:Diagram\"\n      ]\n    },\n    {\n      \"name\": \"BPMNPlane\",\n      \"properties\": [\n        {\n          \"name\": \"bpmnElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"bpmn:BaseElement\",\n          \"redefines\": \"di:DiagramElement#modelElement\"\n        }\n      ],\n      \"superClass\": [\n        \"di:Plane\"\n      ]\n    },\n    {\n      \"name\": \"BPMNShape\",\n      \"properties\": [\n        {\n          \"name\": \"bpmnElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"bpmn:BaseElement\",\n          \"redefines\": \"di:DiagramElement#modelElement\"\n        },\n        {\n          \"name\": \"isHorizontal\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"isExpanded\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"isMarkerVisible\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"label\",\n          \"type\": \"BPMNLabel\"\n        },\n        {\n          \"name\": \"isMessageVisible\",\n          \"isAttr\": true,\n          \"type\": \"Boolean\"\n        },\n        {\n          \"name\": \"participantBandKind\",\n          \"type\": \"ParticipantBandKind\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"choreographyActivityShape\",\n          \"type\": \"BPMNShape\",\n          \"isAttr\": true,\n          \"isReference\": true\n        }\n      ],\n      \"superClass\": [\n        \"di:LabeledShape\"\n      ]\n    },\n    {\n      \"name\": \"BPMNEdge\",\n      \"properties\": [\n        {\n          \"name\": \"label\",\n          \"type\": \"BPMNLabel\"\n        },\n        {\n          \"name\": \"bpmnElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"bpmn:BaseElement\",\n          \"redefines\": \"di:DiagramElement#modelElement\"\n        },\n        {\n          \"name\": \"sourceElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"di:DiagramElement\",\n          \"redefines\": \"di:Edge#source\"\n        },\n        {\n          \"name\": \"targetElement\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"type\": \"di:DiagramElement\",\n          \"redefines\": \"di:Edge#target\"\n        },\n        {\n          \"name\": \"messageVisibleKind\",\n          \"type\": \"MessageVisibleKind\",\n          \"isAttr\": true,\n          \"default\": \"initiating\"\n        }\n      ],\n      \"superClass\": [\n        \"di:LabeledEdge\"\n      ]\n    },\n    {\n      \"name\": \"BPMNLabel\",\n      \"properties\": [\n        {\n          \"name\": \"labelStyle\",\n          \"type\": \"BPMNLabelStyle\",\n          \"isAttr\": true,\n          \"isReference\": true,\n          \"redefines\": \"di:DiagramElement#style\"\n        }\n      ],\n      \"superClass\": [\n        \"di:Label\"\n      ]\n    },\n    {\n      \"name\": \"BPMNLabelStyle\",\n      \"properties\": [\n        {\n          \"name\": \"font\",\n          \"type\": \"dc:Font\"\n        }\n      ],\n      \"superClass\": [\n        \"di:Style\"\n      ]\n    }\n  ],\n  \"emumerations\": [\n    {\n      \"name\": \"ParticipantBandKind\",\n      \"literalValues\": [\n        {\n          \"name\": \"top_initiating\"\n        },\n        {\n          \"name\": \"middle_initiating\"\n        },\n        {\n          \"name\": \"bottom_initiating\"\n        },\n        {\n          \"name\": \"top_non_initiating\"\n        },\n        {\n          \"name\": \"middle_non_initiating\"\n        },\n        {\n          \"name\": \"bottom_non_initiating\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MessageVisibleKind\",\n      \"literalValues\": [\n        {\n          \"name\": \"initiating\"\n        },\n        {\n          \"name\": \"non_initiating\"\n        }\n      ]\n    }\n  ],\n  \"associations\": [],\n  \"prefix\": \"bpmndi\"\n}","module.exports={\n  \"name\": \"DC\",\n  \"uri\": \"http://www.omg.org/spec/DD/20100524/DC\",\n  \"types\": [\n    {\n      \"name\": \"Boolean\"\n    },\n    {\n      \"name\": \"Integer\"\n    },\n    {\n      \"name\": \"Real\"\n    },\n    {\n      \"name\": \"String\"\n    },\n    {\n      \"name\": \"Font\",\n      \"properties\": [\n        {\n          \"name\": \"name\",\n          \"type\": \"String\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"size\",\n          \"type\": \"Real\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isBold\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isItalic\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isUnderline\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"isStrikeThrough\",\n          \"type\": \"Boolean\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Point\",\n      \"properties\": [\n        {\n          \"name\": \"x\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"y\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Bounds\",\n      \"properties\": [\n        {\n          \"name\": \"x\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"y\",\n          \"type\": \"Real\",\n          \"default\": \"0\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"width\",\n          \"type\": \"Real\",\n          \"isAttr\": true\n        },\n        {\n          \"name\": \"height\",\n          \"type\": \"Real\",\n          \"isAttr\": true\n        }\n      ]\n    }\n  ],\n  \"prefix\": \"dc\",\n  \"associations\": []\n}","module.exports={\n  \"name\": \"DI\",\n  \"uri\": \"http://www.omg.org/spec/DD/20100524/DI\",\n  \"types\": [\n    {\n      \"name\": \"DiagramElement\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true,\n          \"isId\": true\n        },\n        {\n          \"name\": \"extension\",\n          \"type\": \"Extension\"\n        },\n        {\n          \"name\": \"owningDiagram\",\n          \"type\": \"Diagram\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"owningElement\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"modelElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true,\n          \"type\": \"Element\"\n        },\n        {\n          \"name\": \"style\",\n          \"type\": \"Style\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"ownedElement\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Node\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"DiagramElement\"\n      ]\n    },\n    {\n      \"name\": \"Edge\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"DiagramElement\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"source\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"target\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isReference\": true\n        },\n        {\n          \"name\": \"waypoint\",\n          \"isUnique\": false,\n          \"isMany\": true,\n          \"type\": \"dc:Point\",\n          \"xml\": {\n            \"serialize\": \"xsi:type\"\n          }\n        }\n      ]\n    },\n    {\n      \"name\": \"Diagram\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true,\n          \"isId\": true\n        },\n        {\n          \"name\": \"rootElement\",\n          \"type\": \"DiagramElement\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true\n        },\n        {\n          \"name\": \"name\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"documentation\",\n          \"isAttr\": true,\n          \"type\": \"String\"\n        },\n        {\n          \"name\": \"resolution\",\n          \"isAttr\": true,\n          \"type\": \"Real\"\n        },\n        {\n          \"name\": \"ownedStyle\",\n          \"type\": \"Style\",\n          \"isReadOnly\": true,\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Shape\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Node\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"bounds\",\n          \"type\": \"dc:Bounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Plane\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Node\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"planeElement\",\n          \"type\": \"DiagramElement\",\n          \"subsettedProperty\": \"DiagramElement-ownedElement\",\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"LabeledEdge\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Edge\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"ownedLabel\",\n          \"type\": \"Label\",\n          \"isReadOnly\": true,\n          \"subsettedProperty\": \"DiagramElement-ownedElement\",\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"LabeledShape\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Shape\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"ownedLabel\",\n          \"type\": \"Label\",\n          \"isReadOnly\": true,\n          \"subsettedProperty\": \"DiagramElement-ownedElement\",\n          \"isVirtual\": true,\n          \"isMany\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Label\",\n      \"isAbstract\": true,\n      \"superClass\": [\n        \"Node\"\n      ],\n      \"properties\": [\n        {\n          \"name\": \"bounds\",\n          \"type\": \"dc:Bounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Style\",\n      \"isAbstract\": true,\n      \"properties\": [\n        {\n          \"name\": \"id\",\n          \"type\": \"String\",\n          \"isAttr\": true,\n          \"isId\": true\n        }\n      ]\n    },\n    {\n      \"name\": \"Extension\",\n      \"properties\": [\n        {\n          \"name\": \"values\",\n          \"type\": \"Element\",\n          \"isMany\": true\n        }\n      ]\n    }\n  ],\n  \"associations\": [],\n  \"prefix\": \"di\",\n  \"xml\": {\n    \"tagAlias\": \"lowerCase\"\n  }\n}","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('/'offset/' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('/'length/' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+//0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like /n and /t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^/s+|/s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","/**\n * Module dependencies.\n */\n\ntry {\n  var index = require(187);\n} catch (err) {\n  var index = require(187);\n}\n\n/**\n * Whitespace regexp.\n */\n\nvar re = //s+/;\n\n/**\n * toString reference.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nmodule.exports = function(el){\n  return new ClassList(el);\n};\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  if (!el || !el.nodeType) {\n    throw new Error('A DOM element reference is required');\n  }\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function(name){\n  // classList\n  if (this.list) {\n    this.list.add(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (!~i) arr.push(name);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function(name){\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  // classList\n  if (this.list) {\n    this.list.remove(name);\n    return this;\n  }\n\n  // fallback\n  var arr = this.array();\n  var i = index(arr, name);\n  if (~i) arr.splice(i, 1);\n  this.el.className = arr.join(' ');\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function(re){\n  var arr = this.array();\n  for (var i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`, can force state via `force`.\n *\n * For browsers that support classList, but do not support `force` yet,\n * the mistake will be detected and corrected.\n *\n * @param {String} name\n * @param {Boolean} force\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function(name, force){\n  // classList\n  if (this.list) {\n    if (\"undefined\" !== typeof force) {\n      if (force !== this.list.toggle(name, force)) {\n        this.list.toggle(name); // toggle again to correct\n      }\n    } else {\n      this.list.toggle(name);\n    }\n    return this;\n  }\n\n  // fallback\n  if (\"undefined\" !== typeof force) {\n    if (!force) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  } else {\n    if (this.has(name)) {\n      this.remove(name);\n    } else {\n      this.add(name);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function(){\n  var className = this.el.getAttribute('class') || '';\n  var str = className.replace(/^/s+|/s+$/g, '');\n  var arr = str.split(re);\n  if ('' === arr[0]) arr.shift();\n  return arr;\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has =\nClassList.prototype.contains = function(name){\n  return this.list\n    ? this.list.contains(name)\n    : !! ~index(this.array(), name);\n};\n","var matches = require(188)\n\nmodule.exports = function (element, selector, checkYoSelf, root) {\n  element = checkYoSelf ? {parentNode: element} : element\n\n  root = root || document\n\n  // Make sure `element !== document` and `element != null`\n  // otherwise we get an illegal invocation\n  while ((element = element.parentNode) && element !== document) {\n    if (matches(element, selector))\n      return element\n    // After `matches` on the edge case that\n    // the selector matches the root\n    // (when the root is not the document)\n    if (element === root)\n      return\n  }\n}\n","/**\n * Module dependencies.\n */\n\ntry {\n  var closest = require(184);\n} catch(err) {\n  var closest = require(184);\n}\n\ntry {\n  var event = require(185);\n} catch(err) {\n  var event = require(185);\n}\n\n/**\n * Delegate event `type` to `selector`\n * and invoke `fn(e)`. A callback function\n * is returned which may be passed to `.unbind()`.\n *\n * @param {Element} el\n * @param {String} selector\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, selector, type, fn, capture){\n  return event.bind(el, type, function(e){\n    var target = e.target || e.srcElement;\n    e.delegateTarget = closest(target, selector, true, el);\n    if (e.delegateTarget) fn.call(el, e);\n  }, capture);\n};\n\n/**\n * Unbind event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  event.unbind(el, type, fn, capture);\n};\n","/**\n * Module Dependencies\n */\n\ntry {\n  var matches = require(188)\n} catch (err) {\n  var matches = require(188)\n}\n\n/**\n * Export `closest`\n */\n\nmodule.exports = closest\n\n/**\n * Closest\n *\n * @param {Element} el\n * @param {String} selector\n * @param {Element} scope (optional)\n */\n\nfunction closest (el, selector, scope) {\n  scope = scope || document.documentElement;\n\n  // walk up the dom\n  while (el && el !== scope) {\n    if (matches(el, selector)) return el;\n    el = el.parentNode;\n  }\n\n  // check scope for match\n  return matches(el, selector) ? el : null;\n}\n","var bind, unbind, prefix;\n\nfunction detect () {\n  bind = window.addEventListener ? 'addEventListener' : 'attachEvent';\n  unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent';\n  prefix = bind !== 'addEventListener' ? 'on' : '';\n}\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  if (!bind) detect();\n  el[bind](prefix + type, fn, capture || false);\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  if (!unbind) detect();\n  el[unbind](prefix + type, fn, capture || false);\n  return fn;\n};\n","var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',\n    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',\n    prefix = bind !== 'addEventListener' ? 'on' : '';\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  el[bind](prefix + type, fn, capture || false);\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  el[unbind](prefix + type, fn, capture || false);\n  return fn;\n};","module.exports = function(arr, obj){\n  if (arr.indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};","/**\n * Module dependencies.\n */\n\ntry {\n  var query = require(189);\n} catch (err) {\n  var query = require(189);\n}\n\n/**\n * Element prototype.\n */\n\nvar proto = Element.prototype;\n\n/**\n * Vendor function.\n */\n\nvar vendor = proto.matches\n  || proto.webkitMatchesSelector\n  || proto.mozMatchesSelector\n  || proto.msMatchesSelector\n  || proto.oMatchesSelector;\n\n/**\n * Expose `match()`.\n */\n\nmodule.exports = match;\n\n/**\n * Match `el` to `selector`.\n *\n * @param {Element} el\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction match(el, selector) {\n  if (!el || el.nodeType !== 1) return false;\n  if (vendor) return vendor.call(el, selector);\n  var nodes = query.all(selector, el.parentNode);\n  for (var i = 0; i < nodes.length; ++i) {\n    if (nodes[i] == el) return true;\n  }\n  return false;\n}\n","function one(selector, el) {\n  return el.querySelector(selector);\n}\n\nexports = module.exports = function(selector, el){\n  el = el || document;\n  return one(selector, el);\n};\n\nexports.all = function(selector, el){\n  el = el || document;\n  return el.querySelectorAll(selector);\n};\n\nexports.engine = function(obj){\n  if (!obj.one) throw new Error('.one callback required');\n  if (!obj.all) throw new Error('.all callback required');\n  one = obj.one;\n  exports.all = obj.all;\n  return exports;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","module.exports = {\r\n  __depends__: [ require(247) ],\r\n  __init__: [ 'directEditing' ],\r\n  directEditing: [ 'type', require(192) ]\r\n};","'use strict';\r\n\r\nvar bind = require(396),\r\n    find = require(385);\r\n\r\nvar TextBox = require(193);\r\n\r\n\r\n/**\r\n * A direct editing component that allows users\r\n * to edit an elements text directly in the diagram\r\n *\r\n * @param {EventBus} eventBus the event bus\r\n */\r\nfunction DirectEditing(eventBus, canvas) {\r\n\r\n  this._eventBus = eventBus;\r\n\r\n  this._providers = [];\r\n  this._textbox = new TextBox({\r\n    container: canvas.getContainer(),\r\n    keyHandler: bind(this._handleKey, this),\r\n    resizeHandler: bind(this._handleResize, this)\r\n  });\r\n}\r\n\r\nDirectEditing.$inject = [ 'eventBus', 'canvas' ];\r\n\r\n\r\n/**\r\n * Register a direct editing provider\r\n\r\n * @param {Object} provider the provider, must expose an #activate(element) method that returns\r\n *                          an activation context ({ bounds: {x, y, width, height }, text }) if\r\n *                          direct editing is available for the given element.\r\n *                          Additionally the provider must expose a #update(element, value) method\r\n *                          to receive direct editing updates.\r\n */\r\nDirectEditing.prototype.registerProvider = function(provider) {\r\n  this._providers.push(provider);\r\n};\r\n\r\n\r\n/**\r\n * Returns true if direct editing is currently active\r\n *\r\n * @return {Boolean}\r\n */\r\nDirectEditing.prototype.isActive = function() {\r\n  return !!this._active;\r\n};\r\n\r\n\r\n/**\r\n * Cancel direct editing, if it is currently active\r\n */\r\nDirectEditing.prototype.cancel = function() {\r\n  if (!this._active) {\r\n    return;\r\n  }\r\n\r\n  this._fire('cancel');\r\n  this.close();\r\n};\r\n\r\n\r\nDirectEditing.prototype._fire = function(event, context) {\r\n  this._eventBus.fire('directEditing.' + event, context || { active: this._active });\r\n};\r\n\r\nDirectEditing.prototype.close = function() {\r\n  this._textbox.destroy();\r\n\r\n  this._fire('deactivate');\r\n\r\n  this._active = null;\r\n\r\n  this.resizable = undefined;\r\n};\r\n\r\n\r\nDirectEditing.prototype.complete = function() {\r\n\r\n  var active = this._active;\r\n\r\n  if (!active) {\r\n    return;\r\n  }\r\n\r\n  var text = this.getValue();\r\n\r\n  var bounds = this.$textbox.getBoundingClientRect();\r\n\r\n  if (text !== active.context.text || this.resizable) {\r\n    active.provider.update(active.element, text, active.context.text, {\r\n      x: bounds.top,\r\n      y: bounds.left,\r\n      width: bounds.width,\r\n      height: bounds.height\r\n    });\r\n  }\r\n\r\n  this._fire('complete');\r\n\r\n  this.close();\r\n};\r\n\r\n\r\nDirectEditing.prototype.getValue = function() {\r\n  return this._textbox.getValue();\r\n};\r\n\r\n\r\nDirectEditing.prototype._handleKey = function(e) {\r\n\r\n  // stop bubble\r\n  e.stopPropagation();\r\n\r\n  var key = e.keyCode || e.charCode;\r\n\r\n  // ESC\r\n  if (key === 27) {\r\n    e.preventDefault();\r\n    return this.cancel();\r\n  }\r\n\r\n  // Enter\r\n  if (key === 13 && !e.shiftKey) {\r\n    e.preventDefault();\r\n    return this.complete();\r\n  }\r\n};\r\n\r\n\r\nDirectEditing.prototype._handleResize = function(event) {\r\n  this._fire('resize', event);\r\n};\r\n\r\n\r\n/**\r\n * Activate direct editing on the given element\r\n *\r\n * @param {Object} ElementDescriptor the descriptor for a shape or connection\r\n * @return {Boolean} true if the activation was possible\r\n */\r\nDirectEditing.prototype.activate = function(element) {\r\n  if (this.isActive()) {\r\n    this.cancel();\r\n  }\r\n\r\n  // the direct editing context\r\n  var context;\r\n\r\n  var provider = find(this._providers, function(p) {\r\n    return (context = p.activate(element)) ? p : null;\r\n  });\r\n\r\n  // check if activation took place\r\n  if (context) {\r\n    this.$textbox = this._textbox.create(\r\n      context.bounds,\r\n      context.style,\r\n      context.text,\r\n      context.options\r\n    );\r\n\r\n    this._active = {\r\n      element: element,\r\n      context: context,\r\n      provider: provider\r\n    };\r\n\r\n    if (context.options && context.options.resizable) {\r\n      this.resizable = true;\r\n    }\r\n\r\n    this._fire('activate');\r\n  }\r\n\r\n  return !!context;\r\n};\r\n\r\n\r\nmodule.exports = DirectEditing;","'use strict';\r\n\r\nvar assign = require(516),\r\n    bind = require(396),\r\n    pick = require(524);\r\n\r\nvar domAttr = require(530),\r\n    domClasses = require(531),\r\n    domEvent = require(536),\r\n    domRemove = require(539);\r\n\r\nvar min = Math.min,\r\n    max = Math.max;\r\n\r\nfunction preventDefault(e) {\r\n  e.preventDefault();\r\n}\r\n\r\nfunction stopPropagation(e) {\r\n  e.stopPropagation();\r\n}\r\n\r\nfunction isTextNode(node) {\r\n  return node.nodeType === Node.TEXT_NODE;\r\n}\r\n\r\nfunction toArray(nodeList) {\r\n  return [].slice.call(nodeList);\r\n}\r\n\r\n/**\r\n * Initializes a container for a content editable div.\r\n *\r\n * Structure:\r\n *\r\n * container\r\n *   parent\r\n *     content\r\n *     handle\r\n *\r\n * @param {object} options\r\n * @param {DOMElement} options.container The DOM element to append the contentContainer to\r\n * @param {Function} options.keyHandler Handler for key events\r\n * @param {Function} options.resizeHandler Handler for resize events\r\n */\r\nfunction TextBox(options) {\r\n  this.container = options.container;\r\n\r\n  this.parent = document.createElement('div');\r\n\r\n  this.content = document.createElement('div');\r\n\r\n  this.parent.appendChild(this.content);\r\n\r\n  domAttr(this.content, 'contentEditable', 'true');\r\n\r\n  this.keyHandler = options.keyHandler || function() {};\r\n  this.resizeHandler = options.resizeHandler || function() {};\r\n\r\n  this.autoResize = bind(this.autoResize, this);\r\n  this.handlePaste = bind(this.handlePaste, this);\r\n}\r\n\r\nmodule.exports = TextBox;\r\n\r\n\r\n/**\r\n * Create a text box with the given position, size, style and text content\r\n *\r\n * @param {Object} bounds\r\n * @param {Number} bounds.x absolute x position\r\n * @param {Number} bounds.y absolute y position\r\n * @param {Number} [bounds.width] fixed width value\r\n * @param {Number} [bounds.height] fixed height value\r\n * @param {Number} [bounds.maxWidth] maximum width value\r\n * @param {Number} [bounds.maxHeight] maximum height value\r\n * @param {Number} [bounds.minWidth] minimum width value\r\n * @param {Number} [bounds.minHeight] minimum height value\r\n * @param {Object} [style]\r\n * @param {String} value text content\r\n *\r\n * @return {DOMElement} The created content DOM element\r\n */\r\nTextBox.prototype.create = function(bounds, style, value, options) {\r\n  var self = this;\r\n\r\n  var parent = this.parent,\r\n      content = this.content,\r\n      container = this.container;\r\n\r\n  options = this.options = options || {};\r\n\r\n  style = this.style = style || {};\r\n\r\n  var parentStyle = pick(style, [\r\n    'width',\r\n    'height',\r\n    'maxWidth',\r\n    'maxHeight',\r\n    'minWidth',\r\n    'minHeight',\r\n    'left',\r\n    'top',\r\n    'backgroundColor',\r\n    'position',\r\n    'overflow',\r\n    'border',\r\n    'wordWrap',\r\n    'textAlign',\r\n    'outline',\r\n    'transform'\r\n  ]);\r\n\r\n  assign(parent.style, {\r\n    width: bounds.width + 'px',\r\n    height: bounds.height + 'px',\r\n    maxWidth: bounds.maxWidth + 'px',\r\n    maxHeight: bounds.maxHeight + 'px',\r\n    minWidth: bounds.minWidth + 'px',\r\n    minHeight: bounds.minHeight + 'px',\r\n    left: bounds.x + 'px',\r\n    top: bounds.y + 'px',\r\n    backgroundColor: '#ffffff',\r\n    position: 'absolute',\r\n    overflow: 'visible',\r\n    border: '1px solid #ccc',\r\n    wordWrap: 'normal',\r\n    textAlign: 'center',\r\n    outline: 'none'\r\n  }, parentStyle);\r\n\r\n  var contentStyle = pick(style, [\r\n    'fontSize',\r\n    'lineHeight',\r\n    'padding',\r\n    'paddingTop',\r\n    'paddingRight',\r\n    'paddingBottom',\r\n    'paddingLeft'\r\n  ]);\r\n\r\n  assign(content.style, {\r\n    boxSizing: 'border-box',\r\n    width: '100%',\r\n    outline: 'none'\r\n  }, contentStyle);\r\n\r\n  if (options.centerVertically) {\r\n    assign(content.style, {\r\n      position: 'absolute',\r\n      top: '50%',\r\n      transform: 'translate(0, -50%)'\r\n    }, contentStyle);\r\n  }\r\n\r\n  content.innerText = value;\r\n\r\n  domEvent.bind(content, 'keydown', this.keyHandler);\r\n  domEvent.bind(content, 'mousedown', stopPropagation);\r\n  domEvent.bind(content, 'paste', self.handlePaste);\r\n\r\n  if (options.autoResize) {\r\n    domEvent.bind(content, 'input', this.autoResize);\r\n  }\r\n\r\n  if (options.resizable) {\r\n    this.resizable(style);\r\n  }\r\n\r\n  container.appendChild(parent);\r\n\r\n  // set selection to end of text\r\n  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);\r\n\r\n  return parent;\r\n};\r\n\r\n/**\r\n * Intercept paste events to remove formatting from pasted text.\r\n */\r\nTextBox.prototype.handlePaste = function(e) {\r\n  var self = this;\r\n\r\n  var options = this.options,\r\n      style = this.style;\r\n\r\n  e.preventDefault();\r\n\r\n  var text;\r\n\r\n  if (e.clipboardData) {\r\n\r\n    // Chrome, Firefox, Safari\r\n    text = e.clipboardData.getData('text/plain');\r\n  } else {\r\n\r\n    // Internet Explorer\r\n    text = window.clipboardData.getData('Text');\r\n  }\r\n\r\n  // insertHTML command not supported by Internet Explorer\r\n  var success = document.execCommand('insertHTML', false, text);\r\n\r\n  if (!success) {\r\n\r\n    // Internet Explorer\r\n    var range = this.getSelection(),\r\n        startContainer = range.startContainer,\r\n        endContainer = range.endContainer,\r\n        startOffset = range.startOffset,\r\n        endOffset = range.endOffset,\r\n        commonAncestorContainer = range.commonAncestorContainer;\r\n\r\n    var childNodesArray = toArray(commonAncestorContainer.childNodes);\r\n\r\n    var container,\r\n        offset;\r\n\r\n    if (isTextNode(commonAncestorContainer)) {\r\n      var containerTextContent = startContainer.textContent;\r\n\r\n      startContainer.textContent =\r\n        containerTextContent.substring(0, startOffset)\r\n        + text\r\n        + containerTextContent.substring(endOffset);\r\n\r\n      container = startContainer;\r\n      offset = startOffset + text.length;\r\n\r\n    } else if (startContainer === this.content && endContainer === this.content) {\r\n      var textNode = document.createTextNode(text);\r\n\r\n      this.content.insertBefore(textNode, childNodesArray[startOffset]);\r\n\r\n      container = textNode;\r\n      offset = textNode.textContent.length;\r\n    } else {\r\n      var startContainerChildIndex = childNodesArray.indexOf(startContainer),\r\n          endContainerChildIndex = childNodesArray.indexOf(endContainer);\r\n\r\n      childNodesArray.forEach(function(childNode, index) {\r\n\r\n        if (index === startContainerChildIndex) {\r\n          childNode.textContent =\r\n            startContainer.textContent.substring(0, startOffset) +\r\n            text +\r\n            endContainer.textContent.substring(endOffset);\r\n        } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {\r\n          domRemove(childNode);\r\n        }\r\n      });\r\n\r\n      container = startContainer;\r\n      offset = startOffset + text.length;\r\n    }\r\n\r\n    if (container && offset !== undefined) {\r\n\r\n      // is necessary in Internet Explorer\r\n      setTimeout(function() {\r\n        self.setSelection(container, offset);\r\n      });\r\n    }\r\n  }\r\n\r\n  if (options.autoResize) {\r\n    var hasResized = this.autoResize(style);\r\n\r\n    if (hasResized) {\r\n      this.resizeHandler(hasResized);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Automatically resize element vertically to fit its content.\r\n */\r\nTextBox.prototype.autoResize = function() {\r\n  var parent = this.parent,\r\n      content = this.content;\r\n\r\n  var fontSize = parseInt(this.style.fontSize) || 12;\r\n\r\n  if (content.scrollHeight > parent.offsetHeight ||\r\n      content.scrollHeight < parent.offsetHeight - fontSize) {\r\n    var bounds = parent.getBoundingClientRect();\r\n\r\n    var height = content.scrollHeight;\r\n    parent.style.height = height + 'px';\r\n\r\n    this.resizeHandler({\r\n      width: bounds.width,\r\n      height: bounds.height,\r\n      dx: 0,\r\n      dy: height - bounds.height\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Make an element resizable by adding a resize handle.\r\n */\r\nTextBox.prototype.resizable = function() {\r\n  var self = this;\r\n\r\n  var parent = this.parent,\r\n      resizeHandle = this.resizeHandle;\r\n\r\n  var minWidth = parseInt(this.style.minWidth) || 0,\r\n      minHeight = parseInt(this.style.minHeight) || 0,\r\n      maxWidth = parseInt(this.style.maxWidth) || Infinity,\r\n      maxHeight = parseInt(this.style.maxHeight) || Infinity;\r\n\r\n  if (!resizeHandle) {\r\n    resizeHandle = this.resizeHandle = document.createElement('div');\r\n\r\n    domClasses(resizeHandle).add('djs-direct-editing-resize-handle');\r\n\r\n    var startX, startY, startWidth, startHeight;\r\n\r\n    var onMouseDown = function(e) {\r\n      preventDefault(e);\r\n      stopPropagation(e);\r\n\r\n      startX = e.clientX;\r\n      startY = e.clientY;\r\n\r\n      var bounds = parent.getBoundingClientRect();\r\n\r\n      startWidth = bounds.width;\r\n      startHeight = bounds.height;\r\n\r\n      domEvent.bind(document, 'mousemove', onMouseMove);\r\n      domEvent.bind(document, 'mouseup', onMouseUp);\r\n    };\r\n\r\n    var onMouseMove = function(e) {\r\n      preventDefault(e);\r\n      stopPropagation(e);\r\n\r\n      var newWidth = min(max(startWidth + e.clientX - startX, minWidth), maxWidth);\r\n      var newHeight = min(max(startHeight + e.clientY - startY, minHeight), maxHeight);\r\n\r\n      parent.style.width = newWidth + 'px';\r\n      parent.style.height = newHeight + 'px';\r\n\r\n      self.resizeHandler({\r\n        width: startWidth,\r\n        height: startHeight,\r\n        dx: e.clientX - startX,\r\n        dy: e.clientY - startY\r\n      });\r\n    };\r\n\r\n    var onMouseUp = function(e) {\r\n      preventDefault(e);\r\n      stopPropagation(e);\r\n\r\n      domEvent.unbind(document,'mousemove', onMouseMove, false);\r\n      domEvent.unbind(document, 'mouseup', onMouseUp, false);\r\n    };\r\n\r\n    domEvent.bind(resizeHandle, 'mousedown', onMouseDown);\r\n  }\r\n\r\n  assign(resizeHandle.style, {\r\n    position: 'absolute',\r\n    bottom: '0px',\r\n    right: '0px',\r\n    cursor: 'nwse-resize',\r\n    width: '0',\r\n    height: '0',\r\n    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',\r\n    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',\r\n    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',\r\n    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'\r\n  });\r\n\r\n  parent.appendChild(resizeHandle);\r\n};\r\n\r\n\r\n/**\r\n * Clear content and style of the textbox, unbind listeners and\r\n * reset CSS style.\r\n */\r\nTextBox.prototype.destroy = function() {\r\n  var parent = this.parent,\r\n      content = this.content,\r\n      resizeHandle = this.resizeHandle;\r\n\r\n  // clear content\r\n  content.innerText = '';\r\n\r\n  // clear styles\r\n  parent.removeAttribute('style');\r\n  content.removeAttribute('style');\r\n\r\n  domEvent.unbind(content, 'keydown', this.keyHandler);\r\n  domEvent.unbind(content, 'mousedown', stopPropagation);\r\n  domEvent.unbind(content, 'input', this.autoResize);\r\n  domEvent.unbind(content, 'paste', this.handlePaste);\r\n\r\n  if (resizeHandle) {\r\n    resizeHandle.removeAttribute('style');\r\n\r\n    domRemove(resizeHandle);\r\n  }\r\n\r\n  domRemove(parent);\r\n};\r\n\r\n\r\nTextBox.prototype.getValue = function() {\r\n  return this.content.innerText;\r\n};\r\n\r\n\r\nTextBox.prototype.getSelection = function() {\r\n  var selection = window.getSelection(),\r\n      range = selection.getRangeAt(0);\r\n\r\n  return range;\r\n};\r\n\r\n\r\nTextBox.prototype.setSelection = function(container, offset) {\r\n  var range = document.createRange();\r\n\r\n  if (container === null) {\r\n    range.selectNodeContents(this.content);\r\n  } else {\r\n    range.setStart(container, offset);\r\n    range.setEnd(container, offset);\r\n  }\r\n\r\n  var selection = window.getSelection();\r\n\r\n  selection.removeAllRanges();\r\n  selection.addRange(range);\r\n};\r\n","module.exports = require(195);","'use strict';\r\n\r\nvar di = require(359);\r\n\r\n\r\n/**\r\n * Bootstrap an injector from a list of modules, instantiating a number of default components\r\n *\r\n * @ignore\r\n * @param {Array<didi.Module>} bootstrapModules\r\n *\r\n * @return {didi.Injector} a injector to use to access the components\r\n */\r\nfunction bootstrap(bootstrapModules) {\r\n\r\n  var modules = [],\r\n      components = [];\r\n\r\n  function hasModule(m) {\r\n    return modules.indexOf(m) >= 0;\r\n  }\r\n\r\n  function addModule(m) {\r\n    modules.push(m);\r\n  }\r\n\r\n  function visit(m) {\r\n    if (hasModule(m)) {\r\n      return;\r\n    }\r\n\r\n    (m.__depends__ || []).forEach(visit);\r\n\r\n    if (hasModule(m)) {\r\n      return;\r\n    }\r\n\r\n    addModule(m);\r\n\r\n    (m.__init__ || []).forEach(function(c) {\r\n      components.push(c);\r\n    });\r\n  }\r\n\r\n  bootstrapModules.forEach(visit);\r\n\r\n  var injector = new di.Injector(modules);\r\n\r\n  components.forEach(function(c) {\r\n\r\n    try {\r\n      // eagerly resolve component (fn or string)\r\n      injector[typeof c === 'string' ? 'get' : 'invoke'](c);\r\n    } catch (e) {\r\n      console.error('Failed to instantiate component');\r\n      console.error(e.stack);\r\n\r\n      throw e;\r\n    }\r\n  });\r\n\r\n  return injector;\r\n}\r\n\r\n/**\r\n * Creates an injector from passed options.\r\n *\r\n * @ignore\r\n * @param  {Object} options\r\n * @return {didi.Injector}\r\n */\r\nfunction createInjector(options) {\r\n\r\n  options = options || {};\r\n\r\n  var configModule = {\r\n    'config': ['value', options]\r\n  };\r\n\r\n  var coreModule = require(204);\r\n\r\n  var modules = [ configModule, coreModule ].concat(options.modules || []);\r\n\r\n  return bootstrap(modules);\r\n}\r\n\r\n\r\n/**\r\n * The main diagram-js entry point that bootstraps the diagram with the given\r\n * configuration.\r\n *\r\n * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.\r\n *\r\n * @class djs.Diagram\r\n * @memberOf djs\r\n * @constructor\r\n *\r\n * @example\r\n *\r\n * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>\r\n *\r\n * // plug-in implemenentation\r\n * function MyLoggingPlugin(eventBus) {\r\n *   eventBus.on('shape.added', function(event) {\r\n *     console.log('shape ', event.shape, ' was added to the diagram');\r\n *   });\r\n * }\r\n *\r\n * // export as module\r\n * module.exports = {\r\n *   __init__: [ 'myLoggingPlugin' ],\r\n *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]\r\n * };\r\n *\r\n *\r\n * // instantiate the diagram with the new plug-in\r\n *\r\n * var diagram = new Diagram({ modules: [ require('path-to-my-logging-plugin') ] });\r\n *\r\n * diagram.invoke([ 'canvas', function(canvas) {\r\n *   // add shape to drawing canvas\r\n *   canvas.addShape({ x: 10, y: 10 });\r\n * });\r\n *\r\n * // 'shape ... was added to the diagram' logged to console\r\n *\r\n * @param {Object} options\r\n * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram\r\n * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with\r\n */\r\nfunction Diagram(options, injector) {\r\n\r\n  // create injector unless explicitly specified\r\n  this.injector = injector = injector || createInjector(options);\r\n\r\n  // API\r\n\r\n  /**\r\n   * Resolves a diagram service\r\n   *\r\n   * @method Diagram#get\r\n   *\r\n   * @param {String} name the name of the diagram service to be retrieved\r\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\r\n   */\r\n  this.get = injector.get;\r\n\r\n  /**\r\n   * Executes a function into which diagram services are injected\r\n   *\r\n   * @method Diagram#invoke\r\n   *\r\n   * @param {Function|Object[]} fn the function to resolve\r\n   * @param {Object} locals a number of locals to use to resolve certain dependencies\r\n   */\r\n  this.invoke = injector.invoke;\r\n\r\n  // init\r\n\r\n  // indicate via event\r\n\r\n\r\n  /**\r\n   * An event indicating that all plug-ins are loaded.\r\n   *\r\n   * Use this event to fire other events to interested plug-ins\r\n   *\r\n   * @memberOf Diagram\r\n   *\r\n   * @event diagram.init\r\n   *\r\n   * @example\r\n   *\r\n   * eventBus.on('diagram.init', function() {\r\n   *   eventBus.fire('my-custom-event', { foo: 'BAR' });\r\n   * });\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this.get('eventBus').fire('diagram.init');\r\n}\r\n\r\nmodule.exports = Diagram;\r\n\r\n\r\n/**\r\n * Destroys the diagram\r\n *\r\n * @method  Diagram#destroy\r\n */\r\nDiagram.prototype.destroy = function() {\r\n  this.get('eventBus').fire('diagram.destroy');\r\n};\r\n\r\n/**\r\n * Clear the diagram, removing all contents.\r\n */\r\nDiagram.prototype.clear = function() {\r\n  this.get('eventBus').fire('diagram.clear');\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    isFunction = require(508),\r\n    isArray = require(506),\r\n    isNumber = require(510);\r\n\r\n\r\nvar DEFAULT_PRIORITY = 1000;\r\n\r\n\r\nfunction isObject(element) {\r\n  return typeof element === 'object';\r\n}\r\n\r\n/**\r\n * A utility that can be used to plug-in into the command execution for\r\n * extension and/or validation.\r\n *\r\n * @param {EventBus} eventBus\r\n *\r\n * @example\r\n *\r\n * var inherits = require('inherits');\r\n *\r\n * var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');\r\n *\r\n * function CommandLogger(eventBus) {\r\n *   CommandInterceptor.call(this, eventBus);\r\n *\r\n *   this.preExecute(function(event) {\r\n *     console.log('command pre-execute', event);\r\n *   });\r\n * }\r\n *\r\n * inherits(CommandLogger, CommandInterceptor);\r\n *\r\n */\r\nfunction CommandInterceptor(eventBus) {\r\n  this._eventBus = eventBus;\r\n}\r\n\r\nCommandInterceptor.$inject = [ 'eventBus' ];\r\n\r\nmodule.exports = CommandInterceptor;\r\n\r\nfunction unwrapEvent(fn, that) {\r\n  return function(event) {\r\n    return fn.call(that || null, event.context, event.command, event);\r\n  };\r\n}\r\n\r\n/**\r\n * Register an interceptor for a command execution\r\n *\r\n * @param {String|Array<String>} [events] list of commands to register on\r\n * @param {String} [hook] command hook, i.e. preExecute, executed to listen on\r\n * @param {Number} [priority] the priority on which to hook into the execution\r\n * @param {Function} handlerFn interceptor to be invoked with (event)\r\n * @param {Boolean} unwrap if true, unwrap the event and pass (context, command, event) to the\r\n *                          listener instead\r\n * @param {Object} [that] Pass context (`this`) to the handler function\r\n */\r\nCommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {\r\n\r\n  if (isFunction(hook) || isNumber(hook)) {\r\n    that = unwrap;\r\n    unwrap = handlerFn;\r\n    handlerFn = priority;\r\n    priority = hook;\r\n    hook = null;\r\n  }\r\n\r\n  if (isFunction(priority)) {\r\n    that = unwrap;\r\n    unwrap = handlerFn;\r\n    handlerFn = priority;\r\n    priority = DEFAULT_PRIORITY;\r\n  }\r\n\r\n  if (isObject(unwrap)) {\r\n    that = unwrap;\r\n    unwrap = false;\r\n  }\r\n\r\n  if (!isFunction(handlerFn)) {\r\n    throw new Error('handlerFn must be a function');\r\n  }\r\n\r\n  if (!isArray(events)) {\r\n    events = [ events ];\r\n  }\r\n\r\n  var eventBus = this._eventBus;\r\n\r\n  forEach(events, function(event) {\r\n    // concat commandStack(.event)?(.hook)?\r\n    var fullEvent = [ 'commandStack', event, hook ].filter(function(e) { return e; }).join('.');\r\n\r\n    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);\r\n  });\r\n};\r\n\r\n\r\nvar hooks = [\r\n  'canExecute',\r\n  'preExecute',\r\n  'preExecuted',\r\n  'execute',\r\n  'executed',\r\n  'postExecute',\r\n  'postExecuted',\r\n  'revert',\r\n  'reverted'\r\n];\r\n\r\n/*\r\n * Install hook shortcuts\r\n *\r\n * This will generate the CommandInterceptor#(preExecute|...|reverted) methods\r\n * which will in term forward to CommandInterceptor#on.\r\n */\r\nforEach(hooks, function(hook) {\r\n\r\n  /**\r\n   * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}\r\n   *\r\n   * A named hook for plugging into the command execution\r\n   *\r\n   * @param {String|Array<String>} [events] list of commands to register on\r\n   * @param {Number} [priority] the priority on which to hook into the execution\r\n   * @param {Function} handlerFn interceptor to be invoked with (event)\r\n   * @param {Boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the\r\n   *                          listener instead\r\n   * @param {Object} [that] Pass context (`this`) to the handler function\r\n   */\r\n  CommandInterceptor.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {\r\n\r\n    if (isFunction(events) || isNumber(events)) {\r\n      that = unwrap;\r\n      unwrap = handlerFn;\r\n      handlerFn = priority;\r\n      priority = events;\r\n      events = null;\r\n    }\r\n\r\n    this.on(events, hook, priority, handlerFn, unwrap, that);\r\n  };\r\n});\r\n","'use strict';\r\n\r\nvar unique = require(378),\r\n    isArray = require(506),\r\n    assign = require(516);\r\n\r\nvar InternalEvent = require(202).Event;\r\n\r\n\r\n/**\r\n * A service that offers un- and redoable execution of commands.\r\n *\r\n * The command stack is responsible for executing modeling actions\r\n * in a un- and redoable manner. To do this it delegates the actual\r\n * command execution to {@link CommandHandler}s.\r\n *\r\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\r\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\r\n * identified by a command context.\r\n *\r\n *\r\n * ## Life-Cycle events\r\n *\r\n * In the process the command stack fires a number of life-cycle events\r\n * that other components to participate in the command execution.\r\n *\r\n *    * preExecute\r\n *    * preExecuted\r\n *    * execute\r\n *    * executed\r\n *    * postExecute\r\n *    * postExecuted\r\n *    * revert\r\n *    * reverted\r\n *\r\n * A special event is used for validating, whether a command can be\r\n * performed prior to its execution.\r\n *\r\n *    * canExecute\r\n *\r\n * Each of the events is fired as `commandStack.{eventName}` and\r\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\r\n * components fine grained control on where to hook into.\r\n *\r\n * The event object fired transports `command`, the name of the\r\n * command and `context`, the command context.\r\n *\r\n *\r\n * ## Creating Command Handlers\r\n *\r\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\r\n * and {@link CommandHandler#revert(ctx)} methods to implement\r\n * redoing and undoing of a command.\r\n *\r\n * A command handler _must_ ensure undo is performed properly in order\r\n * not to break the undo chain. It must also return the shapes that\r\n * got changed during the `execute` and `revert` operations.\r\n *\r\n * Command handlers may execute other modeling operations (and thus\r\n * commands) in their `preExecute` and `postExecute` phases. The command\r\n * stack will properly group all commands together into a logical unit\r\n * that may be re- and undone atomically.\r\n *\r\n * Command handlers must not execute other commands from within their\r\n * core implementation (`execute`, `revert`).\r\n *\r\n *\r\n * ## Change Tracking\r\n *\r\n * During the execution of the CommandStack it will keep track of all\r\n * elements that have been touched during the command's execution.\r\n *\r\n * At the end of the CommandStack execution it will notify interested\r\n * components via an 'elements.changed' event with all the dirty\r\n * elements.\r\n *\r\n * The event can be picked up by components that are interested in the fact\r\n * that elements have been changed. One use case for this is updating\r\n * their graphical representation after moving / resizing or deletion.\r\n *\r\n * @see CommandHandler\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Injector} injector\r\n */\r\nfunction CommandStack(eventBus, injector) {\r\n\r\n  /**\r\n   * A map of all registered command handlers.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this._handlerMap = {};\r\n\r\n  /**\r\n   * A stack containing all re/undoable actions on the diagram\r\n   *\r\n   * @type {Array<Object>}\r\n   */\r\n  this._stack = [];\r\n\r\n  /**\r\n   * The current index on the stack\r\n   *\r\n   * @type {Number}\r\n   */\r\n  this._stackIdx = -1;\r\n\r\n  /**\r\n   * Current active commandStack execution\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this._currentExecution = {\r\n    actions: [],\r\n    dirty: []\r\n  };\r\n\r\n\r\n  this._injector = injector;\r\n  this._eventBus = eventBus;\r\n\r\n  this._uid = 1;\r\n\r\n  eventBus.on([ 'diagram.destroy', 'diagram.clear' ], this.clear, this);\r\n}\r\n\r\nCommandStack.$inject = [ 'eventBus', 'injector' ];\r\n\r\nmodule.exports = CommandStack;\r\n\r\n\r\n/**\r\n * Execute a command\r\n *\r\n * @param {String} command the command to execute\r\n * @param {Object} context the environment to execute the command in\r\n */\r\nCommandStack.prototype.execute = function(command, context) {\r\n  if (!command) {\r\n    throw new Error('command required');\r\n  }\r\n\r\n  var action = { command: command, context: context };\r\n\r\n  this._pushAction(action);\r\n  this._internalExecute(action);\r\n  this._popAction(action);\r\n};\r\n\r\n\r\n/**\r\n * Ask whether a given command can be executed.\r\n *\r\n * Implementors may hook into the mechanism on two ways:\r\n *\r\n *   * in event listeners:\r\n *\r\n *     Users may prevent the execution via an event listener.\r\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\r\n *\r\n *   * in command handlers:\r\n *\r\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\r\n *     it will be called to figure out whether the execution is allowed.\r\n *\r\n * @param  {String} command the command to execute\r\n * @param  {Object} context the environment to execute the command in\r\n *\r\n * @return {Boolean} true if the command can be executed\r\n */\r\nCommandStack.prototype.canExecute = function(command, context) {\r\n\r\n  var action = { command: command, context: context };\r\n\r\n  var handler = this._getHandler(command);\r\n\r\n  var result = this._fire(command, 'canExecute', action);\r\n\r\n  // handler#canExecute will only be called if no listener\r\n  // decided on a result already\r\n  if (result === undefined) {\r\n    if (!handler) {\r\n      return false;\r\n    }\r\n\r\n    if (handler.canExecute) {\r\n      result = handler.canExecute(context);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Clear the command stack, erasing all undo / redo history\r\n */\r\nCommandStack.prototype.clear = function() {\r\n  this._stack.length = 0;\r\n  this._stackIdx = -1;\r\n\r\n  this._fire('changed');\r\n};\r\n\r\n\r\n/**\r\n * Undo last command(s)\r\n */\r\nCommandStack.prototype.undo = function() {\r\n  var action = this._getUndoAction(),\r\n      next;\r\n\r\n  if (action) {\r\n    this._pushAction(action);\r\n\r\n    while (action) {\r\n      this._internalUndo(action);\r\n      next = this._getUndoAction();\r\n\r\n      if (!next || next.id !== action.id) {\r\n        break;\r\n      }\r\n\r\n      action = next;\r\n    }\r\n\r\n    this._popAction();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Redo last command(s)\r\n */\r\nCommandStack.prototype.redo = function() {\r\n  var action = this._getRedoAction(),\r\n      next;\r\n\r\n  if (action) {\r\n    this._pushAction(action);\r\n\r\n    while (action) {\r\n      this._internalExecute(action, true);\r\n      next = this._getRedoAction();\r\n\r\n      if (!next || next.id !== action.id) {\r\n        break;\r\n      }\r\n\r\n      action = next;\r\n    }\r\n\r\n    this._popAction();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Register a handler instance with the command stack\r\n *\r\n * @param {String} command\r\n * @param {CommandHandler} handler\r\n */\r\nCommandStack.prototype.register = function(command, handler) {\r\n  this._setHandler(command, handler);\r\n};\r\n\r\n\r\n/**\r\n * Register a handler type with the command stack\r\n * by instantiating it and injecting its dependencies.\r\n *\r\n * @param {String} command\r\n * @param {Function} a constructor for a {@link CommandHandler}\r\n */\r\nCommandStack.prototype.registerHandler = function(command, handlerCls) {\r\n\r\n  if (!command || !handlerCls) {\r\n    throw new Error('command and handlerCls must be defined');\r\n  }\r\n\r\n  var handler = this._injector.instantiate(handlerCls);\r\n  this.register(command, handler);\r\n};\r\n\r\nCommandStack.prototype.canUndo = function() {\r\n  return !!this._getUndoAction();\r\n};\r\n\r\nCommandStack.prototype.canRedo = function() {\r\n  return !!this._getRedoAction();\r\n};\r\n\r\n////// stack access  //////////////////////////////////////\r\n\r\nCommandStack.prototype._getRedoAction = function() {\r\n  return this._stack[this._stackIdx + 1];\r\n};\r\n\r\n\r\nCommandStack.prototype._getUndoAction = function() {\r\n  return this._stack[this._stackIdx];\r\n};\r\n\r\n\r\n////// internal functionality /////////////////////////////\r\n\r\nCommandStack.prototype._internalUndo = function(action) {\r\n  var self = this;\r\n\r\n  var command = action.command,\r\n      context = action.context;\r\n\r\n  var handler = this._getHandler(command);\r\n\r\n  // guard against illegal nested command stack invocations\r\n  this._atomicDo(function() {\r\n    self._fire(command, 'revert', action);\r\n\r\n    if (handler.revert) {\r\n      self._markDirty(handler.revert(context));\r\n    }\r\n\r\n    self._revertedAction(action);\r\n\r\n    self._fire(command, 'reverted', action);\r\n  });\r\n};\r\n\r\n\r\nCommandStack.prototype._fire = function(command, qualifier, event) {\r\n  if (arguments.length < 3) {\r\n    event = qualifier;\r\n    qualifier = null;\r\n  }\r\n\r\n  var names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ],\r\n      i, name, result;\r\n\r\n  event = assign(new InternalEvent(), event);\r\n\r\n  for (i = 0; (name = names[i]); i++) {\r\n    result = this._eventBus.fire('commandStack.' + name, event);\r\n\r\n    if (event.cancelBubble) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nCommandStack.prototype._createId = function() {\r\n  return this._uid++;\r\n};\r\n\r\nCommandStack.prototype._atomicDo = function(fn) {\r\n\r\n  var execution = this._currentExecution;\r\n\r\n  execution.atomic = true;\r\n\r\n  try {\r\n    fn();\r\n  } finally {\r\n    execution.atomic = false;\r\n  }\r\n};\r\n\r\nCommandStack.prototype._internalExecute = function(action, redo) {\r\n  var self = this;\r\n\r\n  var command = action.command,\r\n      context = action.context;\r\n\r\n  var handler = this._getHandler(command);\r\n\r\n  if (!handler) {\r\n    throw new Error('no command handler registered for <' + command + '>');\r\n  }\r\n\r\n  this._pushAction(action);\r\n\r\n  if (!redo) {\r\n    this._fire(command, 'preExecute', action);\r\n\r\n    if (handler.preExecute) {\r\n      handler.preExecute(context);\r\n    }\r\n\r\n    this._fire(command, 'preExecuted', action);\r\n  }\r\n\r\n  // guard against illegal nested command stack invocations\r\n  this._atomicDo(function() {\r\n\r\n    self._fire(command, 'execute', action);\r\n\r\n    if (handler.execute) {\r\n      // actual execute + mark return results as dirty\r\n      self._markDirty(handler.execute(context));\r\n    }\r\n\r\n    // log to stack\r\n    self._executedAction(action, redo);\r\n\r\n    self._fire(command, 'executed', action);\r\n  });\r\n\r\n  if (!redo) {\r\n    this._fire(command, 'postExecute', action);\r\n\r\n    if (handler.postExecute) {\r\n      handler.postExecute(context);\r\n    }\r\n\r\n    this._fire(command, 'postExecuted', action);\r\n  }\r\n\r\n  this._popAction(action);\r\n};\r\n\r\n\r\nCommandStack.prototype._pushAction = function(action) {\r\n\r\n  var execution = this._currentExecution,\r\n      actions = execution.actions;\r\n\r\n  var baseAction = actions[0];\r\n\r\n  if (execution.atomic) {\r\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\r\n  }\r\n\r\n  if (!action.id) {\r\n    action.id = (baseAction && baseAction.id) || this._createId();\r\n  }\r\n\r\n  actions.push(action);\r\n};\r\n\r\n\r\nCommandStack.prototype._popAction = function() {\r\n  var execution = this._currentExecution,\r\n      actions = execution.actions,\r\n      dirty = execution.dirty;\r\n\r\n  actions.pop();\r\n\r\n  if (!actions.length) {\r\n    this._eventBus.fire('elements.changed', { elements: unique(dirty) });\r\n\r\n    dirty.length = 0;\r\n\r\n    this._fire('changed');\r\n  }\r\n};\r\n\r\n\r\nCommandStack.prototype._markDirty = function(elements) {\r\n  var execution = this._currentExecution;\r\n\r\n  if (!elements) {\r\n    return;\r\n  }\r\n\r\n  elements = isArray(elements) ? elements : [ elements ];\r\n\r\n  execution.dirty = execution.dirty.concat(elements);\r\n};\r\n\r\n\r\nCommandStack.prototype._executedAction = function(action, redo) {\r\n  var stackIdx = ++this._stackIdx;\r\n\r\n  if (!redo) {\r\n    this._stack.splice(stackIdx, this._stack.length, action);\r\n  }\r\n};\r\n\r\n\r\nCommandStack.prototype._revertedAction = function(action) {\r\n  this._stackIdx--;\r\n};\r\n\r\n\r\nCommandStack.prototype._getHandler = function(command) {\r\n  return this._handlerMap[command];\r\n};\r\n\r\nCommandStack.prototype._setHandler = function(command, handler) {\r\n  if (!command || !handler) {\r\n    throw new Error('command and handler required');\r\n  }\r\n\r\n  if (this._handlerMap[command]) {\r\n    throw new Error('overriding handler for command <' + command + '>');\r\n  }\r\n\r\n  this._handlerMap[command] = handler;\r\n};\r\n","module.exports = {\r\n  commandStack: [ 'type', require(197) ]\r\n};\r\n","'use strict';\r\n\r\nvar isNumber = require(510),\r\n    assign = require(516),\r\n    forEach = require(386),\r\n    every = require(383),\r\n    debounce = require(397);\r\n\r\nvar Collections = require(340),\r\n    Elements = require(343);\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583),\r\n    svgTransform = require(587);\r\n\r\nvar createMatrix = require(584).createMatrix;\r\n\r\n\r\nfunction round(number, resolution) {\r\n  return Math.round(number * resolution) / resolution;\r\n}\r\n\r\nfunction ensurePx(number) {\r\n  return isNumber(number) ? number + 'px' : number;\r\n}\r\n\r\n/**\r\n * Creates a HTML container element for a SVG element with\r\n * the given configuration\r\n *\r\n * @param  {Object} options\r\n * @return {HTMLElement} the container element\r\n */\r\nfunction createContainer(options) {\r\n\r\n  options = assign({}, { width: '100%', height: '100%' }, options);\r\n\r\n  var container = options.container || document.body;\r\n\r\n  // create a <div> around the svg element with the respective size\r\n  // this way we can always get the correct container size\r\n  // (this is impossible for <svg> elements at the moment)\r\n  var parent = document.createElement('div');\r\n  parent.setAttribute('class', 'djs-container');\r\n\r\n  assign(parent.style, {\r\n    position: 'relative',\r\n    overflow: 'hidden',\r\n    width: ensurePx(options.width),\r\n    height: ensurePx(options.height)\r\n  });\r\n\r\n  container.appendChild(parent);\r\n\r\n  return parent;\r\n}\r\n\r\nfunction createGroup(parent, cls) {\r\n  var group = svgCreate('g');\r\n  svgClasses(group).add(cls);\r\n\r\n  svgAppend(parent, group);\r\n\r\n  return group;\r\n}\r\n\r\nvar BASE_LAYER = 'base';\r\n\r\n\r\nvar REQUIRED_MODEL_ATTRS = {\r\n  shape: [ 'x', 'y', 'width', 'height' ],\r\n  connection: [ 'waypoints' ]\r\n};\r\n\r\n/**\r\n * The main drawing canvas.\r\n *\r\n * @class\r\n * @constructor\r\n *\r\n * @emits Canvas#canvas.init\r\n *\r\n * @param {Object} config\r\n * @param {EventBus} eventBus\r\n * @param {GraphicsFactory} graphicsFactory\r\n * @param {ElementRegistry} elementRegistry\r\n */\r\nfunction Canvas(config, eventBus, graphicsFactory, elementRegistry) {\r\n\r\n  this._eventBus = eventBus;\r\n  this._elementRegistry = elementRegistry;\r\n  this._graphicsFactory = graphicsFactory;\r\n\r\n  this._init(config || {});\r\n}\r\n\r\nCanvas.$inject = [ 'config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry' ];\r\n\r\nmodule.exports = Canvas;\r\n\r\n\r\nCanvas.prototype._init = function(config) {\r\n\r\n  var eventBus = this._eventBus;\r\n\r\n  // Creates a <svg> element that is wrapped into a <div>.\r\n  // This way we are always able to correctly figure out the size of the svg element\r\n  // by querying the parent node.\r\n  //\r\n  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)\r\n  //\r\n  // <div class=\"djs-container\" style=\"width: {desired-width}, height: {desired-height}\">\r\n  //   <svg width=\"100%\" height=\"100%\">\r\n  //    ...\r\n  //   </svg>\r\n  // </div>\r\n\r\n  // html container\r\n  var container = this._container = createContainer(config);\r\n\r\n  var svg = this._svg = svgCreate('svg');\r\n  svgAttr(svg, { width: '100%', height: '100%' });\r\n\r\n  svgAppend(container, svg);\r\n\r\n  var viewport = this._viewport = createGroup(svg, 'viewport');\r\n\r\n  this._layers = {};\r\n\r\n  // debounce canvas.viewbox.changed events\r\n  // for smoother diagram interaction\r\n  if (config.deferUpdate !== false) {\r\n    this._viewboxChanged = debounce(this._viewboxChanged, 300);\r\n  }\r\n\r\n  eventBus.on('diagram.init', function() {\r\n\r\n    /**\r\n     * An event indicating that the canvas is ready to be drawn on.\r\n     *\r\n     * @memberOf Canvas\r\n     *\r\n     * @event canvas.init\r\n     *\r\n     * @type {Object}\r\n     * @property {Snap<SVGSVGElement>} svg the created svg element\r\n     * @property {Snap<SVGGroup>} viewport the direct parent of diagram elements and shapes\r\n     */\r\n    eventBus.fire('canvas.init', {\r\n      svg: svg,\r\n      viewport: viewport\r\n    });\r\n\r\n    // fire this in order for certain components to check\r\n    // if they need to be adjusted due the canvas size\r\n    this.resized();\r\n\r\n  }, this);\r\n\r\n  eventBus.on('diagram.destroy', 500, this._destroy, this);\r\n  eventBus.on('diagram.clear', 500, this._clear, this);\r\n};\r\n\r\nCanvas.prototype._destroy = function(emit) {\r\n  this._eventBus.fire('canvas.destroy', {\r\n    svg: this._svg,\r\n    viewport: this._viewport\r\n  });\r\n\r\n  var parent = this._container.parentNode;\r\n\r\n  if (parent) {\r\n    parent.removeChild(this._container);\r\n  }\r\n\r\n  delete this._svg;\r\n  delete this._container;\r\n  delete this._layers;\r\n  delete this._rootElement;\r\n  delete this._viewport;\r\n};\r\n\r\nCanvas.prototype._clear = function() {\r\n\r\n  var self = this;\r\n\r\n  var allElements = this._elementRegistry.getAll();\r\n\r\n  // remove all elements\r\n  allElements.forEach(function(element) {\r\n    var type = Elements.getType(element);\r\n\r\n    if (type === 'root') {\r\n      self.setRootElement(null, true);\r\n    } else {\r\n      self._removeElement(element, type);\r\n    }\r\n  });\r\n\r\n  // force recomputation of view box\r\n  delete this._cachedViewbox;\r\n};\r\n\r\n/**\r\n * Returns the default layer on which\r\n * all elements are drawn.\r\n *\r\n * @returns {Snap<SVGGroup>}\r\n */\r\nCanvas.prototype.getDefaultLayer = function() {\r\n  return this.getLayer(BASE_LAYER);\r\n};\r\n\r\n/**\r\n * Returns a layer that is used to draw elements\r\n * or annotations on it.\r\n *\r\n * @param  {String} name\r\n *\r\n * @returns {Snap<SVGGroup>}\r\n */\r\nCanvas.prototype.getLayer = function(name) {\r\n\r\n  if (!name) {\r\n    throw new Error('must specify a name');\r\n  }\r\n\r\n  var layer = this._layers[name];\r\n  if (!layer) {\r\n    layer = this._layers[name] = createGroup(this._viewport, 'layer-' + name);\r\n  }\r\n\r\n  return layer;\r\n};\r\n\r\n\r\n/**\r\n * Returns the html element that encloses the\r\n * drawing canvas.\r\n *\r\n * @return {DOMNode}\r\n */\r\nCanvas.prototype.getContainer = function() {\r\n  return this._container;\r\n};\r\n\r\n\r\n/////////////// markers ///////////////////////////////////\r\n\r\nCanvas.prototype._updateMarker = function(element, marker, add) {\r\n  var container;\r\n\r\n  if (!element.id) {\r\n    element = this._elementRegistry.get(element);\r\n  }\r\n\r\n  // we need to access all\r\n  container = this._elementRegistry._elements[element.id];\r\n\r\n  if (!container) {\r\n    return;\r\n  }\r\n\r\n  forEach([ container.gfx, container.secondaryGfx ], function(gfx) {\r\n    if (gfx) {\r\n      // invoke either addClass or removeClass based on mode\r\n      if (add) {\r\n        svgClasses(gfx).add(marker);\r\n      } else {\r\n        svgClasses(gfx).remove(marker);\r\n      }\r\n    }\r\n  });\r\n\r\n  /**\r\n   * An event indicating that a marker has been updated for an element\r\n   *\r\n   * @event element.marker.update\r\n   * @type {Object}\r\n   * @property {djs.model.Element} element the shape\r\n   * @property {Object} gfx the graphical representation of the shape\r\n   * @property {String} marker\r\n   * @property {Boolean} add true if the marker was added, false if it got removed\r\n   */\r\n  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });\r\n};\r\n\r\n\r\n/**\r\n * Adds a marker to an element (basically a css class).\r\n *\r\n * Fires the element.marker.update event, making it possible to\r\n * integrate extension into the marker life-cycle, too.\r\n *\r\n * @example\r\n * canvas.addMarker('foo', 'some-marker');\r\n *\r\n * var fooGfx = canvas.getGraphics('foo');\r\n *\r\n * fooGfx; // <g class=\"... some-marker\"> ... </g>\r\n *\r\n * @param {String|djs.model.Base} element\r\n * @param {String} marker\r\n */\r\nCanvas.prototype.addMarker = function(element, marker) {\r\n  this._updateMarker(element, marker, true);\r\n};\r\n\r\n\r\n/**\r\n * Remove a marker from an element.\r\n *\r\n * Fires the element.marker.update event, making it possible to\r\n * integrate extension into the marker life-cycle, too.\r\n *\r\n * @param  {String|djs.model.Base} element\r\n * @param  {String} marker\r\n */\r\nCanvas.prototype.removeMarker = function(element, marker) {\r\n  this._updateMarker(element, marker, false);\r\n};\r\n\r\n/**\r\n * Check the existence of a marker on element.\r\n *\r\n * @param  {String|djs.model.Base} element\r\n * @param  {String} marker\r\n */\r\nCanvas.prototype.hasMarker = function(element, marker) {\r\n  if (!element.id) {\r\n    element = this._elementRegistry.get(element);\r\n  }\r\n\r\n  var gfx = this.getGraphics(element);\r\n\r\n  return svgClasses(gfx).has(marker);\r\n};\r\n\r\n/**\r\n * Toggles a marker on an element.\r\n *\r\n * Fires the element.marker.update event, making it possible to\r\n * integrate extension into the marker life-cycle, too.\r\n *\r\n * @param  {String|djs.model.Base} element\r\n * @param  {String} marker\r\n */\r\nCanvas.prototype.toggleMarker = function(element, marker) {\r\n  if (this.hasMarker(element, marker)) {\r\n    this.removeMarker(element, marker);\r\n  } else {\r\n    this.addMarker(element, marker);\r\n  }\r\n};\r\n\r\nCanvas.prototype.getRootElement = function() {\r\n  if (!this._rootElement) {\r\n    this.setRootElement({ id: '__implicitroot', children: [] });\r\n  }\r\n\r\n  return this._rootElement;\r\n};\r\n\r\n\r\n\r\n//////////////// root element handling ///////////////////////////\r\n\r\n/**\r\n * Sets a given element as the new root element for the canvas\r\n * and returns the new root element.\r\n *\r\n * @param {Object|djs.model.Root} element\r\n * @param {Boolean} [override] whether to override the current root element, if any\r\n *\r\n * @return {Object|djs.model.Root} new root element\r\n */\r\nCanvas.prototype.setRootElement = function(element, override) {\r\n\r\n  if (element) {\r\n    this._ensureValid('root', element);\r\n  }\r\n\r\n  var currentRoot = this._rootElement,\r\n      elementRegistry = this._elementRegistry,\r\n      eventBus = this._eventBus;\r\n\r\n  if (currentRoot) {\r\n    if (!override) {\r\n      throw new Error('rootElement already set, need to specify override');\r\n    }\r\n\r\n    // simulate element remove event sequence\r\n    eventBus.fire('root.remove', { element: currentRoot });\r\n    eventBus.fire('root.removed', { element: currentRoot });\r\n\r\n    elementRegistry.remove(currentRoot);\r\n  }\r\n\r\n  if (element) {\r\n    var gfx = this.getDefaultLayer();\r\n\r\n    // resemble element add event sequence\r\n    eventBus.fire('root.add', { element: element });\r\n\r\n    elementRegistry.add(element, gfx, this._svg);\r\n\r\n    eventBus.fire('root.added', { element: element, gfx: gfx });\r\n  }\r\n\r\n  this._rootElement = element;\r\n\r\n  return element;\r\n};\r\n\r\n\r\n\r\n///////////// add functionality ///////////////////////////////\r\n\r\nCanvas.prototype._ensureValid = function(type, element) {\r\n  if (!element.id) {\r\n    throw new Error('element must have an id');\r\n  }\r\n\r\n  if (this._elementRegistry.get(element.id)) {\r\n    throw new Error('element with id ' + element.id + ' already exists');\r\n  }\r\n\r\n  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];\r\n\r\n  var valid = every(requiredAttrs, function(attr) {\r\n    return typeof element[attr] !== 'undefined';\r\n  });\r\n\r\n  if (!valid) {\r\n    throw new Error(\r\n      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);\r\n  }\r\n};\r\n\r\nCanvas.prototype._setParent = function(element, parent, parentIndex) {\r\n  Collections.add(parent.children, element, parentIndex);\r\n  element.parent = parent;\r\n};\r\n\r\n/**\r\n * Adds an element to the canvas.\r\n *\r\n * This wires the parent <-> child relationship between the element and\r\n * a explicitly specified parent or an implicit root element.\r\n *\r\n * During add it emits the events\r\n *\r\n *  * <{type}.add> (element, parent)\r\n *  * <{type}.added> (element, gfx)\r\n *\r\n * Extensions may hook into these events to perform their magic.\r\n *\r\n * @param {String} type\r\n * @param {Object|djs.model.Base} element\r\n * @param {Object|djs.model.Base} [parent]\r\n * @param {Number} [parentIndex]\r\n *\r\n * @return {Object|djs.model.Base} the added element\r\n */\r\nCanvas.prototype._addElement = function(type, element, parent, parentIndex) {\r\n\r\n  parent = parent || this.getRootElement();\r\n\r\n  var eventBus = this._eventBus,\r\n      graphicsFactory = this._graphicsFactory;\r\n\r\n  this._ensureValid(type, element);\r\n\r\n  eventBus.fire(type + '.add', { element: element, parent: parent });\r\n\r\n  this._setParent(element, parent, parentIndex);\r\n\r\n  // create graphics\r\n  var gfx = graphicsFactory.create(type, element);\r\n\r\n  this._elementRegistry.add(element, gfx);\r\n\r\n  // update its visual\r\n  graphicsFactory.update(type, element, gfx);\r\n\r\n  eventBus.fire(type + '.added', { element: element, gfx: gfx });\r\n\r\n  return element;\r\n};\r\n\r\n/**\r\n * Adds a shape to the canvas\r\n *\r\n * @param {Object|djs.model.Shape} shape to add to the diagram\r\n * @param {djs.model.Base} [parent]\r\n * @param {Number} [parentIndex]\r\n *\r\n * @return {djs.model.Shape} the added shape\r\n */\r\nCanvas.prototype.addShape = function(shape, parent, parentIndex) {\r\n  return this._addElement('shape', shape, parent, parentIndex);\r\n};\r\n\r\n/**\r\n * Adds a connection to the canvas\r\n *\r\n * @param {Object|djs.model.Connection} connection to add to the diagram\r\n * @param {djs.model.Base} [parent]\r\n * @param {Number} [parentIndex]\r\n *\r\n * @return {djs.model.Connection} the added connection\r\n */\r\nCanvas.prototype.addConnection = function(connection, parent, parentIndex) {\r\n  return this._addElement('connection', connection, parent, parentIndex);\r\n};\r\n\r\n\r\n/**\r\n * Internal remove element\r\n */\r\nCanvas.prototype._removeElement = function(element, type) {\r\n\r\n  var elementRegistry = this._elementRegistry,\r\n      graphicsFactory = this._graphicsFactory,\r\n      eventBus = this._eventBus;\r\n\r\n  element = elementRegistry.get(element.id || element);\r\n\r\n  if (!element) {\r\n    // element was removed already\r\n    return;\r\n  }\r\n\r\n  eventBus.fire(type + '.remove', { element: element });\r\n\r\n  graphicsFactory.remove(element);\r\n\r\n  // unset parent <-> child relationship\r\n  Collections.remove(element.parent && element.parent.children, element);\r\n  element.parent = null;\r\n\r\n  eventBus.fire(type + '.removed', { element: element });\r\n\r\n  elementRegistry.remove(element);\r\n\r\n  return element;\r\n};\r\n\r\n\r\n/**\r\n * Removes a shape from the canvas\r\n *\r\n * @param {String|djs.model.Shape} shape or shape id to be removed\r\n *\r\n * @return {djs.model.Shape} the removed shape\r\n */\r\nCanvas.prototype.removeShape = function(shape) {\r\n\r\n  /**\r\n   * An event indicating that a shape is about to be removed from the canvas.\r\n   *\r\n   * @memberOf Canvas\r\n   *\r\n   * @event shape.remove\r\n   * @type {Object}\r\n   * @property {djs.model.Shape} element the shape descriptor\r\n   * @property {Object} gfx the graphical representation of the shape\r\n   */\r\n\r\n  /**\r\n   * An event indicating that a shape has been removed from the canvas.\r\n   *\r\n   * @memberOf Canvas\r\n   *\r\n   * @event shape.removed\r\n   * @type {Object}\r\n   * @property {djs.model.Shape} element the shape descriptor\r\n   * @property {Object} gfx the graphical representation of the shape\r\n   */\r\n  return this._removeElement(shape, 'shape');\r\n};\r\n\r\n\r\n/**\r\n * Removes a connection from the canvas\r\n *\r\n * @param {String|djs.model.Connection} connection or connection id to be removed\r\n *\r\n * @return {djs.model.Connection} the removed connection\r\n */\r\nCanvas.prototype.removeConnection = function(connection) {\r\n\r\n  /**\r\n   * An event indicating that a connection is about to be removed from the canvas.\r\n   *\r\n   * @memberOf Canvas\r\n   *\r\n   * @event connection.remove\r\n   * @type {Object}\r\n   * @property {djs.model.Connection} element the connection descriptor\r\n   * @property {Object} gfx the graphical representation of the connection\r\n   */\r\n\r\n  /**\r\n   * An event indicating that a connection has been removed from the canvas.\r\n   *\r\n   * @memberOf Canvas\r\n   *\r\n   * @event connection.removed\r\n   * @type {Object}\r\n   * @property {djs.model.Connection} element the connection descriptor\r\n   * @property {Object} gfx the graphical representation of the connection\r\n   */\r\n  return this._removeElement(connection, 'connection');\r\n};\r\n\r\n\r\n/**\r\n * Return the graphical object underlaying a certain diagram element\r\n *\r\n * @param {String|djs.model.Base} element descriptor of the element\r\n * @param {Boolean} [secondary=false] whether to return the secondary connected element\r\n *\r\n * @return {SVGElement}\r\n */\r\nCanvas.prototype.getGraphics = function(element, secondary) {\r\n  return this._elementRegistry.getGraphics(element, secondary);\r\n};\r\n\r\n\r\n/**\r\n * Perform a viewbox update via a given change function.\r\n *\r\n * @param {Function} changeFn\r\n */\r\nCanvas.prototype._changeViewbox = function(changeFn) {\r\n\r\n  // notify others of the upcoming viewbox change\r\n  this._eventBus.fire('canvas.viewbox.changing');\r\n\r\n  // perform actual change\r\n  changeFn.apply(this);\r\n\r\n  // reset the cached viewbox so that\r\n  // a new get operation on viewbox or zoom\r\n  // triggers a viewbox re-computation\r\n  this._cachedViewbox = null;\r\n\r\n  // notify others of the change; this step\r\n  // may or may not be debounced\r\n  this._viewboxChanged();\r\n};\r\n\r\nCanvas.prototype._viewboxChanged = function() {\r\n  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });\r\n};\r\n\r\n\r\n/**\r\n * Gets or sets the view box of the canvas, i.e. the\r\n * area that is currently displayed.\r\n *\r\n * The getter may return a cached viewbox (if it is currently\r\n * changing). To force a recomputation, pass `false` as the first argument.\r\n *\r\n * @example\r\n *\r\n * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })\r\n *\r\n * // sets the visible area of the diagram to (100|100) -> (600|100)\r\n * // and and scales it according to the diagram width\r\n *\r\n * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.\r\n *\r\n * console.log(viewbox);\r\n * // {\r\n * //   inner: Dimensions,\r\n * //   outer: Dimensions,\r\n * //   scale,\r\n * //   x, y,\r\n * //   width, height\r\n * // }\r\n *\r\n * // if the current diagram is zoomed and scrolled, you may reset it to the\r\n * // default zoom via this method, too:\r\n *\r\n * var zoomedAndScrolledViewbox = canvas.viewbox();\r\n *\r\n * canvas.viewbox({\r\n *   x: 0,\r\n *   y: 0,\r\n *   width: zoomedAndScrolledViewbox.outer.width,\r\n *   height: zoomedAndScrolledViewbox.outer.height\r\n * });\r\n *\r\n * @param  {Object} [box] the new view box to set\r\n * @param  {Number} box.x the top left X coordinate of the canvas visible in view box\r\n * @param  {Number} box.y the top left Y coordinate of the canvas visible in view box\r\n * @param  {Number} box.width the visible width\r\n * @param  {Number} box.height\r\n *\r\n * @return {Object} the current view box\r\n */\r\nCanvas.prototype.viewbox = function(box) {\r\n\r\n  if (box === undefined && this._cachedViewbox) {\r\n    return this._cachedViewbox;\r\n  }\r\n\r\n  var viewport = this._viewport,\r\n      innerBox,\r\n      outerBox = this.getSize(),\r\n      matrix,\r\n      scale,\r\n      x, y;\r\n\r\n  if (!box) {\r\n    // compute the inner box based on the\r\n    // diagrams default layer. This allows us to exclude\r\n    // external components, such as overlays\r\n    innerBox = this.getDefaultLayer().getBBox();\r\n\r\n    var transform = svgTransform(viewport);\r\n    matrix = transform ? transform.matrix : createMatrix();\r\n    scale = round(matrix.a, 1000);\r\n\r\n    x = round(-matrix.e || 0, 1000);\r\n    y = round(-matrix.f || 0, 1000);\r\n\r\n    box = this._cachedViewbox = {\r\n      x: x ? x / scale : 0,\r\n      y: y ? y / scale : 0,\r\n      width: outerBox.width / scale,\r\n      height: outerBox.height / scale,\r\n      scale: scale,\r\n      inner: {\r\n        width: innerBox.width,\r\n        height: innerBox.height,\r\n        x: innerBox.x,\r\n        y: innerBox.y\r\n      },\r\n      outer: outerBox\r\n    };\r\n\r\n    return box;\r\n  } else {\r\n\r\n    this._changeViewbox(function() {\r\n      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);\r\n\r\n      var matrix = this._svg.createSVGMatrix()\r\n        .scale(scale)\r\n        .translate(-box.x, -box.y);\r\n\r\n      svgTransform(viewport, matrix);\r\n    });\r\n  }\r\n\r\n  return box;\r\n};\r\n\r\n\r\n/**\r\n * Gets or sets the scroll of the canvas.\r\n *\r\n * @param {Object} [delta] the new scroll to apply.\r\n *\r\n * @param {Number} [delta.dx]\r\n * @param {Number} [delta.dy]\r\n */\r\nCanvas.prototype.scroll = function(delta) {\r\n\r\n  var node = this._viewport;\r\n  var matrix = node.getCTM();\r\n\r\n  if (delta) {\r\n    this._changeViewbox(function() {\r\n      delta = assign({ dx: 0, dy: 0 }, delta || {});\r\n\r\n      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);\r\n\r\n      setCTM(node, matrix);\r\n    });\r\n  }\r\n\r\n  return { x: matrix.e, y: matrix.f };\r\n};\r\n\r\n\r\n/**\r\n * Gets or sets the current zoom of the canvas, optionally zooming\r\n * to the specified position.\r\n *\r\n * The getter may return a cached zoom level. Call it with `false` as\r\n * the first argument to force recomputation of the current level.\r\n *\r\n * @param {String|Number} [newScale] the new zoom level, either a number, i.e. 0.9,\r\n *                                   or `fit-viewport` to adjust the size to fit the current viewport\r\n * @param {String|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null\r\n *\r\n * @return {Number} the current scale\r\n */\r\nCanvas.prototype.zoom = function(newScale, center) {\r\n\r\n  if (!newScale) {\r\n    return this.viewbox(newScale).scale;\r\n  }\r\n\r\n  if (newScale === 'fit-viewport') {\r\n    return this._fitViewport(center);\r\n  }\r\n\r\n  var outer,\r\n      matrix;\r\n\r\n  this._changeViewbox(function() {\r\n\r\n    if (typeof center !== 'object') {\r\n      outer = this.viewbox().outer;\r\n\r\n      center = {\r\n        x: outer.width / 2,\r\n        y: outer.height / 2\r\n      };\r\n    }\r\n\r\n    matrix = this._setZoom(newScale, center);\r\n  });\r\n\r\n  return round(matrix.a, 1000);\r\n};\r\n\r\nfunction setCTM(node, m) {\r\n  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';\r\n  node.setAttribute('transform', mstr);\r\n}\r\n\r\nCanvas.prototype._fitViewport = function(center) {\r\n\r\n  var vbox = this.viewbox(),\r\n      outer = vbox.outer,\r\n      inner = vbox.inner,\r\n      newScale,\r\n      newViewbox;\r\n\r\n  // display the complete diagram without zooming in.\r\n  // instead of relying on internal zoom, we perform a\r\n  // hard reset on the canvas viewbox to realize this\r\n  //\r\n  // if diagram does not need to be zoomed in, we focus it around\r\n  // the diagram origin instead\r\n\r\n  if (inner.x >= 0 &&\r\n      inner.y >= 0 &&\r\n      inner.x + inner.width <= outer.width &&\r\n      inner.y + inner.height <= outer.height &&\r\n      !center) {\r\n\r\n    newViewbox = {\r\n      x: 0,\r\n      y: 0,\r\n      width: Math.max(inner.width + inner.x, outer.width),\r\n      height: Math.max(inner.height + inner.y, outer.height)\r\n    };\r\n  } else {\r\n\r\n    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);\r\n    newViewbox = {\r\n      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),\r\n      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),\r\n      width: outer.width / newScale,\r\n      height: outer.height / newScale\r\n    };\r\n  }\r\n\r\n  this.viewbox(newViewbox);\r\n\r\n  return this.viewbox(false).scale;\r\n};\r\n\r\n\r\nCanvas.prototype._setZoom = function(scale, center) {\r\n\r\n  var svg = this._svg,\r\n      viewport = this._viewport;\r\n\r\n  var matrix = svg.createSVGMatrix();\r\n  var point = svg.createSVGPoint();\r\n\r\n  var centerPoint,\r\n      originalPoint,\r\n      currentMatrix,\r\n      scaleMatrix,\r\n      newMatrix;\r\n\r\n  currentMatrix = viewport.getCTM();\r\n\r\n  var currentScale = currentMatrix.a;\r\n\r\n  if (center) {\r\n    centerPoint = assign(point, center);\r\n\r\n    // revert applied viewport transformations\r\n    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());\r\n\r\n    // create scale matrix\r\n    scaleMatrix = matrix\r\n                    .translate(originalPoint.x, originalPoint.y)\r\n                    .scale(1 / currentScale * scale)\r\n                    .translate(-originalPoint.x, -originalPoint.y);\r\n\r\n    newMatrix = currentMatrix.multiply(scaleMatrix);\r\n  } else {\r\n    newMatrix = matrix.scale(scale);\r\n  }\r\n\r\n  setCTM(this._viewport, newMatrix);\r\n\r\n  return newMatrix;\r\n};\r\n\r\n\r\n/**\r\n * Returns the size of the canvas\r\n *\r\n * @return {Dimensions}\r\n */\r\nCanvas.prototype.getSize = function() {\r\n  return {\r\n    width: this._container.clientWidth,\r\n    height: this._container.clientHeight\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Return the absolute bounding box for the given element\r\n *\r\n * The absolute bounding box may be used to display overlays in the\r\n * callers (browser) coordinate system rather than the zoomed in/out\r\n * canvas coordinates.\r\n *\r\n * @param  {ElementDescriptor} element\r\n * @return {Bounds} the absolute bounding box\r\n */\r\nCanvas.prototype.getAbsoluteBBox = function(element) {\r\n  var vbox = this.viewbox();\r\n  var bbox;\r\n\r\n  // connection\r\n  // use svg bbox\r\n  if (element.waypoints) {\r\n    var gfx = this.getGraphics(element);\r\n\r\n    bbox = gfx.getBBox();\r\n  }\r\n  // shapes\r\n  // use data\r\n  else {\r\n    bbox = element;\r\n  }\r\n\r\n  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;\r\n  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;\r\n\r\n  var width = bbox.width * vbox.scale;\r\n  var height = bbox.height * vbox.scale;\r\n\r\n  return {\r\n    x: x,\r\n    y: y,\r\n    width: width,\r\n    height: height\r\n  };\r\n};\r\n\r\n/**\r\n * Fires an event in order other modules can react to the\r\n * canvas resizing\r\n */\r\nCanvas.prototype.resized = function() {\r\n\r\n  // force recomputation of view box\r\n  delete this._cachedViewbox;\r\n\r\n  this._eventBus.fire('canvas.resized');\r\n};\r\n","'use strict';\r\n\r\nvar Model = require(331);\r\n\r\nvar assign = require(516);\r\n\r\n/**\r\n * A factory for diagram-js shapes\r\n */\r\nfunction ElementFactory() {\r\n  this._uid = 12;\r\n}\r\n\r\nmodule.exports = ElementFactory;\r\n\r\n\r\nElementFactory.prototype.createRoot = function(attrs) {\r\n  return this.create('root', attrs);\r\n};\r\n\r\nElementFactory.prototype.createLabel = function(attrs) {\r\n  return this.create('label', attrs);\r\n};\r\n\r\nElementFactory.prototype.createShape = function(attrs) {\r\n  return this.create('shape', attrs);\r\n};\r\n\r\nElementFactory.prototype.createConnection = function(attrs) {\r\n  return this.create('connection', attrs);\r\n};\r\n\r\n/**\r\n * Create a model element with the given type and\r\n * a number of pre-set attributes.\r\n *\r\n * @param  {String} type\r\n * @param  {Object} attrs\r\n * @return {djs.model.Base} the newly created model instance\r\n */\r\nElementFactory.prototype.create = function(type, attrs) {\r\n\r\n  attrs = assign({}, attrs || {});\r\n\r\n  if (!attrs.id) {\r\n    attrs.id = type + '_' + (this._uid++);\r\n  }\r\n\r\n  return Model.create(type, attrs);\r\n};","'use strict';\r\n\r\nvar ELEMENT_ID = 'data-element-id';\r\n\r\nvar svgAttr = require(579);\r\n\r\n\r\n/**\r\n * @class\r\n *\r\n * A registry that keeps track of all shapes in the diagram.\r\n */\r\nfunction ElementRegistry(eventBus) {\r\n  this._elements = {};\r\n\r\n  this._eventBus = eventBus;\r\n}\r\n\r\nElementRegistry.$inject = [ 'eventBus' ];\r\n\r\nmodule.exports = ElementRegistry;\r\n\r\n/**\r\n * Register a pair of (element, gfx, (secondaryGfx)).\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {SVGElement} gfx\r\n * @param {SVGElement} [secondaryGfx] optional other element to register, too\r\n */\r\nElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {\r\n\r\n  var id = element.id;\r\n\r\n  this._validateId(id);\r\n\r\n  // associate dom node with element\r\n  svgAttr(gfx, ELEMENT_ID, id);\r\n\r\n  if (secondaryGfx) {\r\n    svgAttr(secondaryGfx, ELEMENT_ID, id);\r\n  }\r\n\r\n  this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };\r\n};\r\n\r\n/**\r\n * Removes an element from the registry.\r\n *\r\n * @param {djs.model.Base} element\r\n */\r\nElementRegistry.prototype.remove = function(element) {\r\n  var elements = this._elements,\r\n      id = element.id || element,\r\n      container = id && elements[id];\r\n\r\n  if (container) {\r\n\r\n    // unset element id on gfx\r\n    svgAttr(container.gfx, ELEMENT_ID, '');\r\n\r\n    if (container.secondaryGfx) {\r\n      svgAttr(container.secondaryGfx, ELEMENT_ID, '');\r\n    }\r\n\r\n    delete elements[id];\r\n  }\r\n};\r\n\r\n/**\r\n * Update the id of an element\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {String} newId\r\n */\r\nElementRegistry.prototype.updateId = function(element, newId) {\r\n\r\n  this._validateId(newId);\r\n\r\n  if (typeof element === 'string') {\r\n    element = this.get(element);\r\n  }\r\n\r\n  this._eventBus.fire('element.updateId', {\r\n    element: element,\r\n    newId: newId\r\n  });\r\n\r\n  var gfx = this.getGraphics(element),\r\n      secondaryGfx = this.getGraphics(element, true);\r\n\r\n  this.remove(element);\r\n\r\n  element.id = newId;\r\n\r\n  this.add(element, gfx, secondaryGfx);\r\n};\r\n\r\n/**\r\n * Return the model element for a given id or graphics.\r\n *\r\n * @example\r\n *\r\n * elementRegistry.get('SomeElementId_1');\r\n * elementRegistry.get(gfx);\r\n *\r\n *\r\n * @param {String|SVGElement} filter for selecting the element\r\n *\r\n * @return {djs.model.Base}\r\n */\r\nElementRegistry.prototype.get = function(filter) {\r\n  var id;\r\n\r\n  if (typeof filter === 'string') {\r\n    id = filter;\r\n  } else {\r\n    id = filter && svgAttr(filter, ELEMENT_ID);\r\n  }\r\n\r\n  var container = this._elements[id];\r\n  return container && container.element;\r\n};\r\n\r\n/**\r\n * Return all elements that match a given filter function.\r\n *\r\n * @param {Function} fn\r\n *\r\n * @return {Array<djs.model.Base>}\r\n */\r\nElementRegistry.prototype.filter = function(fn) {\r\n\r\n  var filtered = [];\r\n\r\n  this.forEach(function(element, gfx) {\r\n    if (fn(element, gfx)) {\r\n      filtered.push(element);\r\n    }\r\n  });\r\n\r\n  return filtered;\r\n};\r\n\r\n/**\r\n * Return all rendered model elements.\r\n *\r\n * @return {Array<djs.model.Base>}\r\n */\r\nElementRegistry.prototype.getAll = function() {\r\n  return this.filter(function(e) { return e; });\r\n};\r\n\r\n/**\r\n * Iterate over all diagram elements.\r\n *\r\n * @param {Function} fn\r\n */\r\nElementRegistry.prototype.forEach = function(fn) {\r\n\r\n  var map = this._elements;\r\n\r\n  Object.keys(map).forEach(function(id) {\r\n    var container = map[id],\r\n        element = container.element,\r\n        gfx = container.gfx;\r\n\r\n    return fn(element, gfx);\r\n  });\r\n};\r\n\r\n/**\r\n * Return the graphical representation of an element or its id.\r\n *\r\n * @example\r\n * elementRegistry.getGraphics('SomeElementId_1');\r\n * elementRegistry.getGraphics(rootElement); // <g ...>\r\n *\r\n * elementRegistry.getGraphics(rootElement, true); // <svg ...>\r\n *\r\n *\r\n * @param {String|djs.model.Base} filter\r\n * @param {Boolean} [secondary=false] whether to return the secondary connected element\r\n *\r\n * @return {SVGElement}\r\n */\r\nElementRegistry.prototype.getGraphics = function(filter, secondary) {\r\n  var id = filter.id || filter;\r\n\r\n  var container = this._elements[id];\r\n  return container && (secondary ? container.secondaryGfx : container.gfx);\r\n};\r\n\r\n/**\r\n * Validate the suitability of the given id and signals a problem\r\n * with an exception.\r\n *\r\n * @param {String} id\r\n *\r\n * @throws {Error} if id is empty or already assigned\r\n */\r\nElementRegistry.prototype._validateId = function(id) {\r\n  if (!id) {\r\n    throw new Error('element must have an id');\r\n  }\r\n\r\n  if (this._elements[id]) {\r\n    throw new Error('element with id ' + id + ' already added');\r\n  }\r\n};\r\n","'use strict';\r\n\r\nvar isFunction = require(508),\r\n    isArray = require(506),\r\n    isNumber = require(510),\r\n    bind = require(396),\r\n    assign = require(516);\r\n\r\nvar FN_REF = '__fn';\r\n\r\nvar DEFAULT_PRIORITY = 1000;\r\n\r\nvar slice = Array.prototype.slice;\r\n\r\n/**\r\n * A general purpose event bus.\r\n *\r\n * This component is used to communicate across a diagram instance.\r\n * Other parts of a diagram can use it to listen to and broadcast events.\r\n *\r\n *\r\n * ## Registering for Events\r\n *\r\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\r\n * methods to register for events. {@link EventBus#off} can be used to\r\n * remove event registrations. Listeners receive an instance of {@link Event}\r\n * as the first argument. It allows them to hook into the event execution.\r\n *\r\n * ```javascript\r\n *\r\n * // listen for event\r\n * eventBus.on('foo', function(event) {\r\n *\r\n *   // access event type\r\n *   event.type; // 'foo'\r\n *\r\n *   // stop propagation to other listeners\r\n *   event.stopPropagation();\r\n *\r\n *   // prevent event default\r\n *   event.preventDefault();\r\n * });\r\n *\r\n * // listen for event with custom payload\r\n * eventBus.on('bar', function(event, payload) {\r\n *   console.log(payload);\r\n * });\r\n *\r\n * // listen for event returning value\r\n * eventBus.on('foobar', function(event) {\r\n *\r\n *   // stop event propagation + prevent default\r\n *   return false;\r\n *\r\n *   // stop event propagation + return custom result\r\n *   return {\r\n *     complex: 'listening result'\r\n *   };\r\n * });\r\n *\r\n *\r\n * // listen with custom priority (default=1000, higher is better)\r\n * eventBus.on('priorityfoo', 1500, function(event) {\r\n *   console.log('invoked first!');\r\n * });\r\n *\r\n *\r\n * // listen for event and pass the context (`this`)\r\n * eventBus.on('foobar', function(event) {\r\n *   this.foo();\r\n * }, this);\r\n * ```\r\n *\r\n *\r\n * ## Emitting Events\r\n *\r\n * Events can be emitted via the event bus using {@link EventBus#fire}.\r\n *\r\n * ```javascript\r\n *\r\n * // false indicates that the default action\r\n * // was prevented by listeners\r\n * if (eventBus.fire('foo') === false) {\r\n *   console.log('default has been prevented!');\r\n * };\r\n *\r\n *\r\n * // custom args + return value listener\r\n * eventBus.on('sum', function(event, a, b) {\r\n *   return a + b;\r\n * });\r\n *\r\n * // you can pass custom arguments + retrieve result values.\r\n * var sum = eventBus.fire('sum', 1, 2);\r\n * console.log(sum); // 3\r\n * ```\r\n */\r\nfunction EventBus() {\r\n  this._listeners = {};\r\n\r\n  // cleanup on destroy on lowest priority to allow\r\n  // message passing until the bitter end\r\n  this.on('diagram.destroy', 1, this._destroy, this);\r\n}\r\n\r\nmodule.exports = EventBus;\r\n\r\n\r\n/**\r\n * Register an event listener for events with the given name.\r\n *\r\n * The callback will be invoked with `event, ...additionalArguments`\r\n * that have been passed to {@link EventBus#fire}.\r\n *\r\n * Returning false from a listener will prevent the events default action\r\n * (if any is specified). To stop an event from being processed further in\r\n * other listeners execute {@link Event#stopPropagation}.\r\n *\r\n * Returning anything but `undefined` from a listener will stop the listener propagation.\r\n *\r\n * @param {String|Array<String>} events\r\n * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher\r\n * @param {Function} callback\r\n * @param {Object} [that] Pass context (`this`) to the callback\r\n */\r\nEventBus.prototype.on = function(events, priority, callback, that) {\r\n\r\n  events = isArray(events) ? events : [ events ];\r\n\r\n  if (isFunction(priority)) {\r\n    that = callback;\r\n    callback = priority;\r\n    priority = DEFAULT_PRIORITY;\r\n  }\r\n\r\n  if (!isNumber(priority)) {\r\n    throw new Error('priority must be a number');\r\n  }\r\n\r\n  var actualCallback = callback;\r\n\r\n  if (that) {\r\n    actualCallback = bind(callback, that);\r\n\r\n    // make sure we remember and are able to remove\r\n    // bound callbacks via {@link #off} using the original\r\n    // callback\r\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\r\n  }\r\n\r\n  var self = this,\r\n      listener = { priority: priority, callback: actualCallback };\r\n\r\n  events.forEach(function(e) {\r\n    self._addListener(e, listener);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Register an event listener that is executed only once.\r\n *\r\n * @param {String} event the event name to register for\r\n * @param {Function} callback the callback to execute\r\n * @param {Object} [that] Pass context (`this`) to the callback\r\n */\r\nEventBus.prototype.once = function(event, priority, callback, that) {\r\n  var self = this;\r\n\r\n  if (isFunction(priority)) {\r\n    that = callback;\r\n    callback = priority;\r\n    priority = DEFAULT_PRIORITY;\r\n  }\r\n\r\n  if (!isNumber(priority)) {\r\n    throw new Error('priority must be a number');\r\n  }\r\n\r\n  function wrappedCallback() {\r\n    self.off(event, wrappedCallback);\r\n    return callback.apply(that, arguments);\r\n  }\r\n\r\n  // make sure we remember and are able to remove\r\n  // bound callbacks via {@link #off} using the original\r\n  // callback\r\n  wrappedCallback[FN_REF] = callback;\r\n\r\n  this.on(event, priority, wrappedCallback);\r\n};\r\n\r\n\r\n/**\r\n * Removes event listeners by event and callback.\r\n *\r\n * If no callback is given, all listeners for a given event name are being removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} [callback]\r\n */\r\nEventBus.prototype.off = function(event, callback) {\r\n  var listeners = this._getListeners(event),\r\n      listener,\r\n      listenerCallback,\r\n      idx;\r\n\r\n  if (callback) {\r\n\r\n    // move through listeners from back to front\r\n    // and remove matching listeners\r\n    for (idx = listeners.length - 1; (listener = listeners[idx]); idx--) {\r\n      listenerCallback = listener.callback;\r\n\r\n      if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\r\n        listeners.splice(idx, 1);\r\n      }\r\n    }\r\n  } else {\r\n    // clear listeners\r\n    listeners.length = 0;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Fires a named event.\r\n *\r\n * @example\r\n *\r\n * // fire event by name\r\n * events.fire('foo');\r\n *\r\n * // fire event object with nested type\r\n * var event = { type: 'foo' };\r\n * events.fire(event);\r\n *\r\n * // fire event with explicit type\r\n * var event = { x: 10, y: 20 };\r\n * events.fire('element.moved', event);\r\n *\r\n * // pass additional arguments to the event\r\n * events.on('foo', function(event, bar) {\r\n *   alert(bar);\r\n * });\r\n *\r\n * events.fire({ type: 'foo' }, 'I am bar!');\r\n *\r\n * @param {String} [name] the optional event name\r\n * @param {Object} [event] the event object\r\n * @param {...Object} additional arguments to be passed to the callback functions\r\n *\r\n * @return {Boolean} the events return value, if specified or false if the\r\n *                   default action was prevented by listeners\r\n */\r\nEventBus.prototype.fire = function(type, data) {\r\n\r\n  var event,\r\n      listeners,\r\n      returnValue,\r\n      args;\r\n\r\n  args = slice.call(arguments);\r\n\r\n  if (typeof type === 'object') {\r\n    event = type;\r\n    type = event.type;\r\n  }\r\n\r\n  if (!type) {\r\n    throw new Error('no event type specified');\r\n  }\r\n\r\n  listeners = this._listeners[type];\r\n\r\n  if (!listeners) {\r\n    return;\r\n  }\r\n\r\n  // we make sure we fire instances of our home made\r\n  // events here. We wrap them only once, though\r\n  if (data instanceof Event) {\r\n    // we are fine, we alread have an event\r\n    event = data;\r\n  } else {\r\n    event = new Event();\r\n    event.init(data);\r\n  }\r\n\r\n  // ensure we pass the event as the first parameter\r\n  args[0] = event;\r\n\r\n  // original event type (in case we delegate)\r\n  var originalType = event.type;\r\n\r\n  // update event type before delegation\r\n  if (type !== originalType) {\r\n    event.type = type;\r\n  }\r\n\r\n  try {\r\n    returnValue = this._invokeListeners(event, args, listeners);\r\n  } finally {\r\n    // reset event type after delegation\r\n    if (type !== originalType) {\r\n      event.type = originalType;\r\n    }\r\n  }\r\n\r\n  // set the return value to false if the event default\r\n  // got prevented and no other return value exists\r\n  if (returnValue === undefined && event.defaultPrevented) {\r\n    returnValue = false;\r\n  }\r\n\r\n  return returnValue;\r\n};\r\n\r\n\r\nEventBus.prototype.handleError = function(error) {\r\n  return this.fire('error', { error: error }) === false;\r\n};\r\n\r\n\r\nEventBus.prototype._destroy = function() {\r\n  this._listeners = {};\r\n};\r\n\r\nEventBus.prototype._invokeListeners = function(event, args, listeners) {\r\n\r\n  var idx,\r\n      listener,\r\n      returnValue;\r\n\r\n  for (idx = 0; (listener = listeners[idx]); idx++) {\r\n\r\n    // handle stopped propagation\r\n    if (event.cancelBubble) {\r\n      break;\r\n    }\r\n\r\n    returnValue = this._invokeListener(event, args, listener);\r\n  }\r\n\r\n  return returnValue;\r\n};\r\n\r\nEventBus.prototype._invokeListener = function(event, args, listener) {\r\n\r\n  var returnValue;\r\n\r\n  try {\r\n    // returning false prevents the default action\r\n    returnValue = invokeFunction(listener.callback, args);\r\n\r\n    // stop propagation on return value\r\n    if (returnValue !== undefined) {\r\n      event.returnValue = returnValue;\r\n      event.stopPropagation();\r\n    }\r\n\r\n    // prevent default on return false\r\n    if (returnValue === false) {\r\n      event.preventDefault();\r\n    }\r\n  } catch (e) {\r\n    if (!this.handleError(e)) {\r\n      console.error('unhandled error in event listener');\r\n      console.error(e.stack);\r\n\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  return returnValue;\r\n};\r\n\r\n/*\r\n * Add new listener with a certain priority to the list\r\n * of listeners (for the given event).\r\n *\r\n * The semantics of listener registration / listener execution are\r\n * first register, first serve: New listeners will always be inserted\r\n * after existing listeners with the same priority.\r\n *\r\n * Example: Inserting two listeners with priority 1000 and 1300\r\n *\r\n *    * before: [ 1500, 1500, 1000, 1000 ]\r\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\r\n *\r\n * @param {String} event\r\n * @param {Object} listener { priority, callback }\r\n */\r\nEventBus.prototype._addListener = function(event, newListener) {\r\n\r\n  var listeners = this._getListeners(event),\r\n      existingListener,\r\n      idx;\r\n\r\n  // ensure we order listeners by priority from\r\n  // 0 (high) to n > 0 (low)\r\n  for (idx = 0; (existingListener = listeners[idx]); idx++) {\r\n    if (existingListener.priority < newListener.priority) {\r\n\r\n      // prepend newListener at before existingListener\r\n      listeners.splice(idx, 0, newListener);\r\n      return;\r\n    }\r\n  }\r\n\r\n  listeners.push(newListener);\r\n};\r\n\r\n\r\nEventBus.prototype._getListeners = function(name) {\r\n  var listeners = this._listeners[name];\r\n\r\n  if (!listeners) {\r\n    this._listeners[name] = listeners = [];\r\n  }\r\n\r\n  return listeners;\r\n};\r\n\r\n\r\n/**\r\n * A event that is emitted via the event bus.\r\n */\r\nfunction Event() { }\r\n\r\nmodule.exports.Event = Event;\r\n\r\nEvent.prototype.stopPropagation = function() {\r\n  this.cancelBubble = true;\r\n};\r\n\r\nEvent.prototype.preventDefault = function() {\r\n  this.defaultPrevented = true;\r\n};\r\n\r\nEvent.prototype.init = function(data) {\r\n  assign(this, data || {});\r\n};\r\n\r\n\r\n/**\r\n * Invoke function. Be fast...\r\n *\r\n * @param {Function} fn\r\n * @param {Array<Object>} args\r\n *\r\n * @return {Any}\r\n */\r\nfunction invokeFunction(fn, args) {\r\n  return fn.apply(null, args);\r\n}\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    reduce = require(390);\r\n\r\nvar GraphicsUtil = require(346);\r\n\r\nvar translate = require(356).translate;\r\n\r\nvar domClear = require(532);\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\n\r\n/**\r\n * A factory that creates graphical elements\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementRegistry} elementRegistry\r\n */\r\nfunction GraphicsFactory(eventBus, elementRegistry) {\r\n  this._eventBus = eventBus;\r\n  this._elementRegistry = elementRegistry;\r\n}\r\n\r\nGraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];\r\n\r\nmodule.exports = GraphicsFactory;\r\n\r\n\r\nGraphicsFactory.prototype._getChildren = function(element) {\r\n\r\n  var gfx = this._elementRegistry.getGraphics(element);\r\n\r\n  var childrenGfx;\r\n\r\n  // root element\r\n  if (!element.parent) {\r\n    childrenGfx = gfx;\r\n  } else {\r\n    childrenGfx = GraphicsUtil.getChildren(gfx);\r\n    if (!childrenGfx) {\r\n      childrenGfx = svgCreate('g');\r\n      svgClasses(childrenGfx).add('djs-children');\r\n\r\n      svgAppend(gfx.parentNode, childrenGfx);\r\n    }\r\n  }\r\n\r\n  return childrenGfx;\r\n};\r\n\r\n/**\r\n * Clears the graphical representation of the element and returns the\r\n * cleared visual (the <g class=\"djs-visual\" /> element).\r\n */\r\nGraphicsFactory.prototype._clear = function(gfx) {\r\n  var visual = GraphicsUtil.getVisual(gfx);\r\n\r\n  domClear(visual);\r\n\r\n  return visual;\r\n};\r\n\r\n/**\r\n * Creates a gfx container for shapes and connections\r\n *\r\n * The layout is as follows:\r\n *\r\n * <g class=\"djs-group\">\r\n *\r\n *   <!-- the gfx -->\r\n *   <g class=\"djs-element djs-(shape|connection)\">\r\n *     <g class=\"djs-visual\">\r\n *       <!-- the renderer draws in here -->\r\n *     </g>\r\n *\r\n *     <!-- extensions (overlays, click box, ...) goes here\r\n *   </g>\r\n *\r\n *   <!-- the gfx child nodes -->\r\n *   <g class=\"djs-children\"></g>\r\n * </g>\r\n *\r\n * @param {Object} parent\r\n * @param {String} type the type of the element, i.e. shape | connection\r\n */\r\nGraphicsFactory.prototype._createContainer = function(type, parentGfx) {\r\n  var outerGfx = svgCreate('g');\r\n  svgClasses(outerGfx).add('djs-group');\r\n\r\n  svgAppend(parentGfx, outerGfx);\r\n\r\n  var gfx = svgCreate('g');\r\n  svgClasses(gfx).add('djs-element');\r\n  svgClasses(gfx).add('djs-' + type);\r\n\r\n  svgAppend(outerGfx, gfx);\r\n\r\n  // create visual\r\n  var visual = svgCreate('g');\r\n  svgClasses(visual).add('djs-visual');\r\n\r\n  svgAppend(gfx, visual);\r\n\r\n  return gfx;\r\n};\r\n\r\nGraphicsFactory.prototype.create = function(type, element) {\r\n  var childrenGfx = this._getChildren(element.parent);\r\n  return this._createContainer(type, childrenGfx);\r\n};\r\n\r\nGraphicsFactory.prototype.updateContainments = function(elements) {\r\n\r\n  var self = this,\r\n      elementRegistry = this._elementRegistry,\r\n      parents;\r\n\r\n  parents = reduce(elements, function(map, e) {\r\n\r\n    if (e.parent) {\r\n      map[e.parent.id] = e.parent;\r\n    }\r\n\r\n    return map;\r\n  }, {});\r\n\r\n  // update all parents of changed and reorganized their children\r\n  // in the correct order (as indicated in our model)\r\n  forEach(parents, function(parent) {\r\n\r\n    var childGfx = self._getChildren(parent),\r\n        children = parent.children;\r\n\r\n    if (!children) {\r\n      return;\r\n    }\r\n\r\n    forEach(children.slice().reverse(), function(c) {\r\n      var gfx = elementRegistry.getGraphics(c);\r\n\r\n      prependTo(gfx.parentNode, childGfx);\r\n    });\r\n  });\r\n};\r\n\r\nGraphicsFactory.prototype.drawShape = function(visual, element) {\r\n  var eventBus = this._eventBus;\r\n\r\n  return eventBus.fire('render.shape', { gfx: visual, element: element });\r\n};\r\n\r\nGraphicsFactory.prototype.getShapePath = function(element) {\r\n  var eventBus = this._eventBus;\r\n\r\n  return eventBus.fire('render.getShapePath', element);\r\n};\r\n\r\nGraphicsFactory.prototype.drawConnection = function(visual, element) {\r\n  var eventBus = this._eventBus;\r\n\r\n  return eventBus.fire('render.connection', { gfx: visual, element: element });\r\n};\r\n\r\nGraphicsFactory.prototype.getConnectionPath = function(waypoints) {\r\n  var eventBus = this._eventBus;\r\n\r\n  return eventBus.fire('render.getConnectionPath', waypoints);\r\n};\r\n\r\nGraphicsFactory.prototype.update = function(type, element, gfx) {\r\n  // Do not update root element\r\n  if (!element.parent) {\r\n    return;\r\n  }\r\n\r\n  var visual = this._clear(gfx);\r\n\r\n  // redraw\r\n  if (type === 'shape') {\r\n    this.drawShape(visual, element);\r\n\r\n    // update positioning\r\n    translate(gfx, element.x, element.y);\r\n  } else\r\n  if (type === 'connection') {\r\n    this.drawConnection(visual, element);\r\n  } else {\r\n    throw new Error('unknown type: ' + type);\r\n  }\r\n\r\n  if (element.hidden) {\r\n    svgAttr(gfx, 'display', 'none');\r\n  } else {\r\n    svgAttr(gfx, 'display', 'block');\r\n  }\r\n};\r\n\r\nGraphicsFactory.prototype.remove = function(element) {\r\n  var gfx = this._elementRegistry.getGraphics(element);\r\n\r\n  // remove\r\n  svgRemove(gfx.parentNode);\r\n};\r\n\r\n////////// helpers ///////////\r\n\r\nfunction prependTo(newNode, parentNode) {\r\n  parentNode.insertBefore(newNode, parentNode.firstChild);\r\n}\r\n","module.exports = {\r\n  __depends__: [ require(208) ],\r\n  __init__: [ 'canvas' ],\r\n  canvas: [ 'type', require(199) ],\r\n  elementRegistry: [ 'type', require(201) ],\r\n  elementFactory: [ 'type', require(200) ],\r\n  eventBus: [ 'type', require(202) ],\r\n  graphicsFactory: [ 'type', require(203) ]\r\n};","'use strict';\r\n\r\nvar DEFAULT_RENDER_PRIORITY = 1000;\r\n\r\n/**\r\n * The base implementation of shape and connection renderers.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Number} [renderPriority=1000]\r\n */\r\nfunction BaseRenderer(eventBus, renderPriority) {\r\n  var self = this;\r\n\r\n  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;\r\n\r\n  eventBus.on([ 'render.shape', 'render.connection' ], renderPriority, function(evt, context) {\r\n    var type = evt.type,\r\n        element = context.element,\r\n        visuals = context.gfx;\r\n\r\n    if (self.canRender(element)) {\r\n      if (type === 'render.shape') {\r\n        return self.drawShape(visuals, element);\r\n      } else {\r\n        return self.drawConnection(visuals, element);\r\n      }\r\n    }\r\n  });\r\n\r\n  eventBus.on([ 'render.getShapePath', 'render.getConnectionPath'], renderPriority, function(evt, element) {\r\n    if (self.canRender(element)) {\r\n      if (evt.type === 'render.getShapePath') {\r\n        return self.getShapePath(element);\r\n      } else {\r\n        return self.getConnectionPath(element);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Should check whether *this* renderer can render\r\n * the element/connection.\r\n *\r\n * @param {element} element\r\n *\r\n * @returns {Boolean}\r\n */\r\nBaseRenderer.prototype.canRender = function() {};\r\n\r\n/**\r\n * Provides the shape's snap svg element to be drawn on the `canvas`.\r\n *\r\n * @param {djs.Graphics} visuals\r\n * @param {Shape} shape\r\n *\r\n * @returns {Snap.svg} [returns a Snap.svg paper element ]\r\n */\r\nBaseRenderer.prototype.drawShape = function() {};\r\n\r\n/**\r\n * Provides the shape's snap svg element to be drawn on the `canvas`.\r\n *\r\n * @param {djs.Graphics} visuals\r\n * @param {Connection} connection\r\n *\r\n * @returns {Snap.svg} [returns a Snap.svg paper element ]\r\n */\r\nBaseRenderer.prototype.drawConnection = function() {};\r\n\r\n/**\r\n * Gets the SVG path of a shape that represents it's visual bounds.\r\n *\r\n * @param {Shape} shape\r\n *\r\n * @return {string} svg path\r\n */\r\nBaseRenderer.prototype.getShapePath = function() {};\r\n\r\n/**\r\n * Gets the SVG path of a connection that represents it's visual bounds.\r\n *\r\n * @param {Connection} connection\r\n *\r\n * @return {string} svg path\r\n */\r\nBaseRenderer.prototype.getConnectionPath = function() {};\r\n\r\nmodule.exports = BaseRenderer;\r\n","'use strict';\r\n\r\nvar inherits = require(368);\r\n\r\nvar BaseRenderer = require(205);\r\n\r\nvar renderUtil = require(355);\r\n\r\nvar componentsToPath = renderUtil.componentsToPath,\r\n    createLine = renderUtil.createLine;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583);\r\n\r\n// apply default renderer with lowest possible priority\r\n// so that it only kicks in if noone else could render\r\nvar DEFAULT_RENDER_PRIORITY = 1;\r\n\r\n/**\r\n * The default renderer used for shapes and connections.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Styles} styles\r\n */\r\nfunction DefaultRenderer(eventBus, styles) {\r\n  //\r\n  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);\r\n\r\n  this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });\r\n  this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });\r\n}\r\n\r\ninherits(DefaultRenderer, BaseRenderer);\r\n\r\n\r\nDefaultRenderer.prototype.canRender = function() {\r\n  return true;\r\n};\r\n\r\nDefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {\r\n\r\n  var rect = svgCreate('rect');\r\n  svgAttr(rect, {\r\n    x: 0,\r\n    y: 0,\r\n    width: element.width || 0,\r\n    height: element.height || 0\r\n  });\r\n  svgAttr(rect, this.SHAPE_STYLE);\r\n\r\n  svgAppend(visuals, rect);\r\n\r\n  return rect;\r\n};\r\n\r\nDefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {\r\n\r\n  var line = createLine(connection.waypoints, this.CONNECTION_STYLE);\r\n  svgAppend(visuals, line);\r\n\r\n  return line;\r\n};\r\n\r\nDefaultRenderer.prototype.getShapePath = function getShapePath(shape) {\r\n\r\n  var x = shape.x,\r\n      y = shape.y,\r\n      width = shape.width,\r\n      height = shape.height;\r\n\r\n  var shapePath = [\r\n    ['M', x, y],\r\n    ['l', width, 0],\r\n    ['l', 0, height],\r\n    ['l', -width, 0],\r\n    ['z']\r\n  ];\r\n\r\n  return componentsToPath(shapePath);\r\n};\r\n\r\nDefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {\r\n  var waypoints = connection.waypoints;\r\n\r\n  var idx, point, connectionPath = [];\r\n\r\n  for (idx = 0; (point = waypoints[idx]); idx++) {\r\n\r\n    // take invisible docking into account\r\n    // when creating the path\r\n    point = point.original || point;\r\n\r\n    connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);\r\n  }\r\n\r\n  return componentsToPath(connectionPath);\r\n};\r\n\r\n\r\nDefaultRenderer.$inject = [ 'eventBus', 'styles' ];\r\n\r\nmodule.exports = DefaultRenderer;\r\n","'use strict';\r\n\r\nvar isArray = require(506),\r\n    assign = require(516),\r\n    reduce = require(390);\r\n\r\n\r\n/**\r\n * A component that manages shape styles\r\n */\r\nfunction Styles() {\r\n\r\n  var defaultTraits = {\r\n\r\n    'no-fill': {\r\n      fill: 'none'\r\n    },\r\n    'no-border': {\r\n      strokeOpacity: 0.0\r\n    },\r\n    'no-events': {\r\n      pointerEvents: 'none'\r\n    }\r\n  };\r\n\r\n  var self = this;\r\n\r\n  /**\r\n   * Builds a style definition from a className, a list of traits and an object of additional attributes.\r\n   *\r\n   * @param  {String} className\r\n   * @param  {Array<String>} traits\r\n   * @param  {Object} additionalAttrs\r\n   *\r\n   * @return {Object} the style defintion\r\n   */\r\n  this.cls = function(className, traits, additionalAttrs) {\r\n    var attrs = this.style(traits, additionalAttrs);\r\n\r\n    return assign(attrs, { 'class': className });\r\n  };\r\n\r\n  /**\r\n   * Builds a style definition from a list of traits and an object of additional attributes.\r\n   *\r\n   * @param  {Array<String>} traits\r\n   * @param  {Object} additionalAttrs\r\n   *\r\n   * @return {Object} the style defintion\r\n   */\r\n  this.style = function(traits, additionalAttrs) {\r\n\r\n    if (!isArray(traits) && !additionalAttrs) {\r\n      additionalAttrs = traits;\r\n      traits = [];\r\n    }\r\n\r\n    var attrs = reduce(traits, function(attrs, t) {\r\n      return assign(attrs, defaultTraits[t] || {});\r\n    }, {});\r\n\r\n    return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;\r\n  };\r\n\r\n  this.computeStyle = function(custom, traits, defaultStyles) {\r\n    if (!isArray(traits)) {\r\n      defaultStyles = traits;\r\n      traits = [];\r\n    }\r\n\r\n    return self.style(traits || [], assign({}, defaultStyles, custom || {}));\r\n  };\r\n}\r\n\r\nmodule.exports = Styles;\r\n","module.exports = {\r\n  __init__: [ 'defaultRenderer' ],\r\n  defaultRenderer: [ 'type', require(206) ],\r\n  styles: [ 'type', require(207) ]\r\n};\r\n","'use strict';\r\n\r\nvar filter = require(384),\r\n    forEach = require(386),\r\n    sortBy = require(394);\r\n\r\nfunction last(arr) {\r\n  return arr && arr[arr.length - 1];\r\n}\r\n\r\nfunction sortTopOrMiddle(element) {\r\n  return element.y;\r\n}\r\n\r\nfunction sortLeftOrCenter(element) {\r\n  return element.x;\r\n}\r\n\r\n/**\r\n * Sorting functions for different types of alignment\r\n *\r\n * @type {Object}\r\n *\r\n * @return {Function}\r\n */\r\nvar ALIGNMENT_SORTING = {\r\n  left: sortLeftOrCenter,\r\n  center: sortLeftOrCenter,\r\n  right: function(element) {\r\n    return element.x + element.width;\r\n  },\r\n  top: sortTopOrMiddle,\r\n  middle: sortTopOrMiddle,\r\n  bottom: function(element) {\r\n    return element.y + element.height;\r\n  }\r\n};\r\n\r\n\r\nfunction AlignElements(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nmodule.exports = AlignElements;\r\n\r\nAlignElements.$inject = [ 'modeling' ];\r\n\r\n\r\n/**\r\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\r\n *\r\n * @param  {String} type left|right|center|top|bottom|middle\r\n *\r\n * @return {Object} { axis, dimension }\r\n */\r\nAlignElements.prototype._getOrientationDetails = function(type) {\r\n  var vertical = [ 'top', 'bottom', 'middle' ],\r\n      axis = 'x',\r\n      dimension = 'width';\r\n\r\n  if (vertical.indexOf(type) !== -1) {\r\n    axis = 'y';\r\n    dimension = 'height';\r\n  }\r\n\r\n  return {\r\n    axis: axis,\r\n    dimension: dimension\r\n  };\r\n};\r\n\r\nAlignElements.prototype._isType = function(type, types) {\r\n  return types.indexOf(type) !== -1;\r\n};\r\n\r\n/**\r\n * Get a point on the relevant axis where elements should align to\r\n *\r\n * @param  {String} type left|right|center|top|bottom|middle\r\n * @param  {Array} sortedElements\r\n *\r\n * @return {Object}\r\n */\r\nAlignElements.prototype._alignmentPosition = function(type, sortedElements) {\r\n  var orientation = this._getOrientationDetails(type),\r\n      axis = orientation.axis,\r\n      dimension = orientation.dimension,\r\n      alignment = {},\r\n      centers = {},\r\n      hasSharedCenters = false,\r\n      centeredElements,\r\n      firstElement,\r\n      lastElement;\r\n\r\n  function getMiddleOrTop(first, last) {\r\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\r\n  }\r\n\r\n  if (this._isType(type, [ 'left', 'top' ])) {\r\n    alignment[type] = sortedElements[0][axis];\r\n\r\n  } else if (this._isType(type, [ 'right', 'bottom' ])) {\r\n    lastElement = last(sortedElements);\r\n\r\n    alignment[type] = lastElement[axis] + lastElement[dimension];\r\n\r\n  } else if (this._isType(type, [ 'center', 'middle' ])) {\r\n\r\n    // check if there is a center shared by more than one shape\r\n    // if not, just take the middle of the range\r\n    forEach(sortedElements, function(element) {\r\n      var center = element[axis] + Math.round(element[dimension] / 2);\r\n\r\n      if (centers[center]) {\r\n        centers[center].elements.push(element);\r\n      } else {\r\n        centers[center] = {\r\n          elements: [ element ],\r\n          center: center\r\n        };\r\n      }\r\n    });\r\n\r\n    centeredElements = sortBy(centers, function(center) {\r\n      if (center.elements.length > 1) {\r\n        hasSharedCenters = true;\r\n      }\r\n\r\n      return center.elements.length;\r\n    });\r\n\r\n    if (hasSharedCenters) {\r\n      alignment[type] = last(centeredElements).center;\r\n\r\n      return alignment;\r\n    }\r\n\r\n    firstElement = sortedElements[0];\r\n\r\n    sortedElements = sortBy(sortedElements, function(element) {\r\n      return element[axis] + element[dimension];\r\n    });\r\n\r\n    lastElement = last(sortedElements);\r\n\r\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\r\n  }\r\n\r\n  return alignment;\r\n};\r\n\r\n/**\r\n * Executes the alignment of a selection of elements\r\n *\r\n * @param  {Array} elements [description]\r\n * @param  {String} type left|right|center|top|bottom|middle\r\n */\r\nAlignElements.prototype.trigger = function(elements, type) {\r\n  var modeling = this._modeling;\r\n\r\n  var filteredElements = filter(elements, function(element) {\r\n    return !(element.waypoints || element.host || element.labelTarget);\r\n  });\r\n\r\n  var sortFn = ALIGNMENT_SORTING[type];\r\n\r\n  var sortedElements = sortBy(filteredElements, sortFn);\r\n\r\n  var alignment = this._alignmentPosition(type, sortedElements);\r\n\r\n  modeling.alignElements(sortedElements, alignment);\r\n};\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'alignElements' ],\r\n  alignElements: [ 'type', require(209) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    flatten = require(372),\r\n    union = require(376),\r\n    filter = require(384),\r\n    groupBy = require(387),\r\n    map = require(389);\r\n\r\nvar saveClear = require(354).saveClear,\r\n    Collections = require(340);\r\n\r\nvar getNewAttachShapeDelta = require(338).getNewAttachShapeDelta;\r\n\r\nvar inherits = require(368);\r\n\r\nvar HIGH_PRIORITY = 1500;\r\n\r\nvar CommandInterceptor = require(196);\r\n\r\n\r\nfunction AttachSupport(eventBus, modeling, movePreview, rules) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  // remove all the attached elements from the shapes to be validated\r\n  // add all the attached shapes to the overall list of moved shapes\r\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {\r\n\r\n    var context = e.context,\r\n        shapes = context.shapes,\r\n        validatedShapes = context.validatedShapes;\r\n\r\n    context.shapes = addAttached(shapes);\r\n\r\n    context.validatedShapes = removeAttached(validatedShapes);\r\n  });\r\n\r\n\r\n  // move all attachments after the other shapes are done moving\r\n  this.postExecuted([ 'elements.move' ], function(event) {\r\n\r\n    var context = event.context,\r\n        delta = context.delta,\r\n        newParent = context.newParent,\r\n        closure = context.closure,\r\n        enclosedElements = closure.enclosedElements,\r\n        attachers = getAttachers(enclosedElements);\r\n\r\n    // ensure we move all attachers with their hosts\r\n    // if they have not been moved already\r\n    forEach(attachers, function(attacher) {\r\n      if (!enclosedElements[attacher.id]) {\r\n        modeling.moveShape(attacher, delta, newParent);\r\n\r\n        if (attacher.label) {\r\n          modeling.moveShape(attacher.label, delta, newParent);\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  // perform the attaching after shapes are done moving\r\n  this.postExecuted([ 'elements.move' ], function(e) {\r\n\r\n    var context = e.context,\r\n        shapes = context.shapes,\r\n        newHost = context.newHost,\r\n        attachers;\r\n\r\n    // we only support attachment / detachment of one element\r\n    if (shapes.length > 1) {\r\n      return;\r\n    }\r\n\r\n    if (newHost) {\r\n\r\n      attachers = shapes;\r\n    } else {\r\n\r\n      attachers = filter(shapes, function(s) {\r\n        return !!s.host;\r\n      });\r\n    }\r\n\r\n    forEach(attachers, function(attacher) {\r\n      modeling.updateAttachment(attacher, newHost);\r\n    });\r\n  });\r\n\r\n  // ensure invalid attachment connections are removed\r\n  this.postExecuted([ 'elements.move' ], function(e) {\r\n\r\n    var shapes = e.context.shapes;\r\n\r\n    forEach(shapes, function(shape) {\r\n\r\n      forEach(shape.attachers, function(attacher) {\r\n\r\n        // remove invalid outgoing connections\r\n        forEach(attacher.outgoing.slice(), function(connection) {\r\n          var allowed = rules.allowed('connection.reconnectStart', {\r\n            connection: connection,\r\n            source: connection.source,\r\n            target: connection.target\r\n          });\r\n\r\n          if (!allowed) {\r\n            modeling.removeConnection(connection);\r\n          }\r\n        });\r\n\r\n        // remove invalid incoming connections\r\n        forEach(attacher.incoming.slice(), function(connection) {\r\n          var allowed = rules.allowed('connection.reconnectEnd', {\r\n            connection: connection,\r\n            source: connection.source,\r\n            target: connection.target\r\n          });\r\n\r\n          if (!allowed) {\r\n            modeling.removeConnection(connection);\r\n          }\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  this.postExecute([ 'shape.create' ], function(e) {\r\n    var context = e.context,\r\n        shape = context.shape,\r\n        host = context.host;\r\n\r\n    if (host) {\r\n      modeling.updateAttachment(shape, host);\r\n    }\r\n  });\r\n\r\n  // update attachments if the host is replaced\r\n  this.postExecute([ 'shape.replace' ], function(e) {\r\n\r\n    var context = e.context,\r\n        oldShape = context.oldShape,\r\n        newShape = context.newShape;\r\n\r\n    // move the attachers to the new host\r\n    saveClear(oldShape.attachers, function(attacher) {\r\n      var allowed = rules.allowed('elements.move', {\r\n        target: newShape,\r\n        shapes: [attacher]\r\n      });\r\n\r\n      if (allowed === 'attach') {\r\n        modeling.updateAttachment(attacher, newShape);\r\n      } else {\r\n        modeling.removeShape(attacher);\r\n      }\r\n    });\r\n\r\n    // move attachers if new host has different size\r\n    if (newShape.attachers.length) {\r\n\r\n      forEach(newShape.attachers, function(attacher) {\r\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\r\n        modeling.moveShape(attacher, delta, attacher.parent);\r\n      });\r\n    }\r\n\r\n  });\r\n\r\n  // move shape on host resize\r\n  this.postExecute([ 'shape.resize' ], function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        oldBounds = context.oldBounds,\r\n        newBounds = context.newBounds,\r\n        attachers = shape.attachers;\r\n\r\n    if (!attachers.length) {\r\n      return;\r\n    }\r\n\r\n    forEach(attachers, function(attacher) {\r\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\r\n\r\n      modeling.moveShape(attacher, delta, attacher.parent);\r\n\r\n      if (attacher.label) {\r\n        modeling.moveShape(attacher.label, delta, attacher.label.parent);\r\n      }\r\n    });\r\n  });\r\n\r\n  // remove attachments\r\n  this.preExecute([ 'shape.delete' ], function(event) {\r\n\r\n    var shape = event.context.shape;\r\n\r\n    saveClear(shape.attachers, function(attacher) {\r\n      modeling.removeShape(attacher);\r\n    });\r\n\r\n    if (shape.host) {\r\n      modeling.updateAttachment(shape, null);\r\n    }\r\n  });\r\n\r\n\r\n  // Prevent attachers and their labels from moving, when the space tool is performed.\r\n  // Otherwise the attachers and their labels would be moved twice.\r\n  eventBus.on('spaceTool.move', function(event) {\r\n\r\n    var movingShapes = event.context.movingShapes;\r\n\r\n    // Collect all attachers which would be moved using the space tool\r\n    var movingAttachers = filter(movingShapes, function(shape) {\r\n      return shape.host && shape.host.id;\r\n    });\r\n\r\n    forEach(movingAttachers, function(shape) {\r\n      // Remove all attachers and their labels from the movingShapes, because they\r\n      // already will be moved along with the host.\r\n      Collections.remove(movingShapes, shape);\r\n      if (shape.label) {\r\n        Collections.remove(movingShapes, shape.label);\r\n      }\r\n    });\r\n\r\n  });\r\n}\r\n\r\ninherits(AttachSupport, CommandInterceptor);\r\n\r\nAttachSupport.$inject = [ 'eventBus', 'modeling', 'movePreview', 'rules' ];\r\n\r\nmodule.exports = AttachSupport;\r\n\r\n\r\n/**\r\n * Return attachers of the given shapes\r\n *\r\n * @param {Array<djs.model.Base>} shapes\r\n * @return {Array<djs.model.Base>}\r\n */\r\nfunction getAttachers(shapes) {\r\n  return flatten(map(shapes, function(s) {\r\n    return s.attachers || [];\r\n  }));\r\n}\r\n\r\n/**\r\n * Return a combined list of elements and\r\n * attachers.\r\n *\r\n * @param {Array<djs.model.Base>} elements\r\n * @return {Array<djs.model.Base>} filtered\r\n */\r\nfunction addAttached(elements) {\r\n  var attachers = getAttachers(elements);\r\n\r\n  return union(elements, attachers);\r\n}\r\n\r\n/**\r\n * Return a filtered list of elements that do not\r\n * contain attached elements with hosts being part\r\n * of the selection.\r\n *\r\n * @param  {Array<djs.model.Base>} elements\r\n *\r\n * @return {Array<djs.model.Base>} filtered\r\n */\r\nfunction removeAttached(elements) {\r\n\r\n  var ids = groupBy(elements, 'id');\r\n\r\n  return filter(elements, function(element) {\r\n    while (element) {\r\n\r\n      // host in selection\r\n      if (element.host && ids[element.host.id]) {\r\n        return false;\r\n      }\r\n\r\n      element = element.parent;\r\n    }\r\n\r\n    return true;\r\n  });\r\n}\r\n","module.exports = {\r\n  __depends__: [\r\n    require(283),\r\n    require(251)\r\n  ],\r\n  __init__: [ 'attachSupport'],\r\n  attachSupport: [ 'type', require(211) ]\r\n};\r\n","'use strict';\r\n\r\nvar inherits = require(368);\r\n\r\nvar getBoundingBox = require(343).getBBox;\r\n\r\nvar asTRBL = require(329).asTRBL,\r\n    asBounds = require(329).asBounds;\r\n\r\nvar assign = require(516),\r\n    forEach = require(386),\r\n    values = require(526),\r\n    flatten = require(372),\r\n    groupBy = require(387);\r\n\r\nvar CommandInterceptor = require(196);\r\n\r\n\r\n/**\r\n * An auto resize component that takes care of expanding a parent element\r\n * if child elements are created or moved close the parents edge.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {Modeling} modeling\r\n * @param {Rules} rules\r\n */\r\nfunction AutoResize(eventBus, elementRegistry, modeling, rules) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this._elementRegistry = elementRegistry;\r\n  this._modeling = modeling;\r\n  this._rules = rules;\r\n\r\n  var self = this;\r\n\r\n  this.postExecuted([ 'shape.create' ], function(event) {\r\n\r\n    var context = event.context,\r\n        hints = context.hints,\r\n        shape = context.shape,\r\n        parent = context.parent || context.newParent;\r\n\r\n    if (hints && hints.root === false) {\r\n      return;\r\n    }\r\n\r\n    self._expand([ shape ], parent);\r\n  });\r\n\r\n  this.postExecuted([ 'elements.move' ], function(event) {\r\n\r\n    var context = event.context,\r\n        elements = flatten(values(context.closure.topLevel)),\r\n        hints = context.hints;\r\n\r\n    if (hints && hints.autoResize === false) {\r\n      return;\r\n    }\r\n\r\n    var expandings = groupBy(elements, function(element) {\r\n      return element.parent.id;\r\n    });\r\n\r\n    forEach(expandings, function(elements, parentId) {\r\n      self._expand(elements, parentId);\r\n    });\r\n  });\r\n}\r\n\r\nAutoResize.$inject = [ 'eventBus', 'elementRegistry', 'modeling', 'rules' ];\r\n\r\ninherits(AutoResize, CommandInterceptor);\r\n\r\nmodule.exports = AutoResize;\r\n\r\n\r\n/**\r\n * Calculate the new bounds of the target shape, given\r\n * a number of elements have been moved or added into the parent.\r\n *\r\n * This method considers the current size, the added elements as well as\r\n * the provided padding for the new bounds.\r\n *\r\n * @param {Array<djs.model.Shape>} elements\r\n * @param {djs.model.Shape} target\r\n */\r\nAutoResize.prototype._getOptimalBounds = function(elements, target) {\r\n\r\n  var offset = this.getOffset(target),\r\n      padding = this.getPadding(target);\r\n\r\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\r\n      targetTrbl = asTRBL(target);\r\n\r\n  var newTrbl = {};\r\n\r\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\r\n    newTrbl.top = elementsTrbl.top - offset.top;\r\n  }\r\n\r\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\r\n    newTrbl.left = elementsTrbl.left - offset.left;\r\n  }\r\n\r\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\r\n    newTrbl.right = elementsTrbl.right + offset.right;\r\n  }\r\n\r\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\r\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\r\n  }\r\n\r\n  return asBounds(assign({}, targetTrbl, newTrbl));\r\n};\r\n\r\n\r\n/**\r\n * Expand the target shape respecting rules, offset and padding\r\n *\r\n * @param {Array<djs.model.Shape>} elements\r\n * @param {djs.model.Shape|String} target|targetId\r\n */\r\nAutoResize.prototype._expand = function(elements, target) {\r\n\r\n  if (typeof target === 'string') {\r\n    target = this._elementRegistry.get(target);\r\n  }\r\n\r\n  var allowed = this._rules.allowed('element.autoResize', {\r\n    elements: elements,\r\n    target: target\r\n  });\r\n\r\n  if (!allowed) {\r\n    return;\r\n  }\r\n\r\n  // calculate the new bounds\r\n  var newBounds = this._getOptimalBounds(elements, target);\r\n\r\n  if (!boundsChanged(newBounds, target)) {\r\n    return;\r\n  }\r\n\r\n  // resize the parent shape\r\n  this.resize(target, newBounds);\r\n\r\n  var parent = target.parent;\r\n\r\n  // recursively expand parent elements\r\n  if (parent) {\r\n    this._expand([ target ], parent);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Get the amount to expand the given shape in each direction.\r\n *\r\n * @param {djs.model.Shape} shape\r\n *\r\n * @return {Object} {top, bottom, left, right}\r\n */\r\nAutoResize.prototype.getOffset = function(shape) {\r\n  return { top: 60, bottom: 60, left: 100, right: 100 };\r\n};\r\n\r\n\r\n/**\r\n * Get the activation threshold for each side for which\r\n * resize triggers.\r\n *\r\n * @param {djs.model.Shape} shape\r\n *\r\n * @return {Object} {top, bottom, left, right}\r\n */\r\nAutoResize.prototype.getPadding = function(shape) {\r\n  return { top: 2, bottom: 2, left: 15, right: 15 };\r\n};\r\n\r\n\r\n/**\r\n * Perform the actual resize operation.\r\n *\r\n * @param {djs.model.Shape} target\r\n * @param {Object} newBounds\r\n */\r\nAutoResize.prototype.resize = function(target, newBounds) {\r\n  this._modeling.resizeShape(target, newBounds);\r\n};\r\n\r\n\r\nfunction boundsChanged(newBounds, oldBounds) {\r\n  return (\r\n    newBounds.x !== oldBounds.x ||\r\n    newBounds.y !== oldBounds.y ||\r\n    newBounds.width !== oldBounds.width ||\r\n    newBounds.height !== oldBounds.height\r\n  );\r\n}","var RuleProvider = require(302);\r\n\r\nvar inherits = require(368);\r\n\r\n/**\r\n * This is a base rule provider for the element.autoResize rule.\r\n */\r\nfunction AutoResizeProvider(eventBus) {\r\n\r\n  RuleProvider.call(this, eventBus);\r\n\r\n  var self = this;\r\n\r\n  this.addRule('element.autoResize', function(context) {\r\n    return self.canResize(context.elements, context.target);\r\n  });\r\n}\r\n\r\nAutoResizeProvider.$inject = [ 'eventBus' ];\r\n\r\ninherits(AutoResizeProvider, RuleProvider);\r\n\r\nmodule.exports = AutoResizeProvider;\r\n\r\n/**\r\n * Needs to be implemented by sub classes to allow actual auto resize\r\n *\r\n * @param  {Array<djs.model.Shape>} elements\r\n * @param  {djs.model.Shape} target\r\n *\r\n * @return {Boolean}\r\n */\r\nAutoResizeProvider.prototype.canResize = function(elements, target) {\r\n  return false;\r\n};","'use strict';\r\n\r\nvar assign = require(516);\r\n\r\nvar EventUtil = require(344);\r\n\r\n\r\n/**\r\n * Initiates canvas scrolling if current cursor point is close to a border.\r\n * Cancelled when current point moves back inside the scrolling borders\r\n * or cancelled manually.\r\n *\r\n * Default options :\r\n *   scrollThresholdIn: [ 20, 20, 20, 20 ],\r\n *   scrollThresholdOut: [ 0, 0, 0, 0 ],\r\n *   scrollRepeatTimeout: 15,\r\n *   scrollStep: 10\r\n *\r\n * Threshold order:\r\n *   [ left, top, right, bottom ]\r\n */\r\nfunction AutoScroll(config, eventBus, canvas, mouseTracking) {\r\n\r\n  this._canvas = canvas;\r\n  this._mouseTracking = mouseTracking;\r\n\r\n  this._opts = assign({\r\n    scrollThresholdIn: [ 20, 20, 20, 20 ],\r\n    scrollThresholdOut: [ 0, 0, 0, 0 ],\r\n    scrollRepeatTimeout: 15,\r\n    scrollStep: 10\r\n  }, config);\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('drag.move', function(e) {\r\n    var point = self._toBorderPoint(e);\r\n\r\n    self.startScroll(point);\r\n  });\r\n\r\n  eventBus.on([ 'drag.cleanup' ], function() {\r\n    self.stopScroll();\r\n  });\r\n}\r\n\r\nAutoScroll.$inject = [ 'config.autoScroll', 'eventBus', 'canvas', 'mouseTracking'];\r\n\r\nmodule.exports = AutoScroll;\r\n\r\n\r\n/**\r\n * Starts scrolling loop.\r\n * Point is given in global scale in canvas container box plane.\r\n *\r\n * @param  {Object} point { x: X, y: Y }\r\n */\r\nAutoScroll.prototype.startScroll = function(point) {\r\n\r\n  var canvas = this._canvas;\r\n  var opts = this._opts;\r\n  var self = this;\r\n\r\n  var clientRect = canvas.getContainer().getBoundingClientRect();\r\n\r\n  var diff = [\r\n    point.x,\r\n    point.y,\r\n    clientRect.width - point.x,\r\n    clientRect.height - point.y\r\n  ];\r\n\r\n  this.stopScroll();\r\n\r\n  var dx = 0,\r\n      dy = 0;\r\n\r\n  for (var i = 0; i < 4; i++) {\r\n    if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {\r\n      if (i === 0) {\r\n        dx = opts.scrollStep;\r\n      } else if (i == 1) {\r\n        dy = opts.scrollStep;\r\n      } else if (i == 2) {\r\n        dx = -opts.scrollStep;\r\n      } else if (i == 3) {\r\n        dy = -opts.scrollStep;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (dx !== 0 || dy !== 0) {\r\n    canvas.scroll({ dx: dx, dy: dy });\r\n\r\n    this._scrolling = setTimeout(function() {\r\n      self.startScroll(point);\r\n    }, opts.scrollRepeatTimeout);\r\n  }\r\n};\r\n\r\nfunction between(val, start, end) {\r\n  if (start < val && val < end) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n\r\n/**\r\n * Stops scrolling loop.\r\n */\r\nAutoScroll.prototype.stopScroll = function() {\r\n  clearTimeout(this._scrolling);\r\n};\r\n\r\n\r\n/**\r\n * Overrides defaults options.\r\n *\r\n * @param  {Object} options\r\n */\r\nAutoScroll.prototype.setOptions = function(options) {\r\n  this._opts = assign({}, this._opts, options);\r\n};\r\n\r\n\r\n/**\r\n * Converts event to a point in canvas container plane in global scale.\r\n *\r\n * @param  {Event} event\r\n * @return {Point}\r\n */\r\nAutoScroll.prototype._toBorderPoint = function(event) {\r\n  var clientRect = this._canvas._container.getBoundingClientRect();\r\n\r\n  var globalPosition = EventUtil.toPoint(event.originalEvent);\r\n\r\n  return {\r\n    x: globalPosition.x - clientRect.left,\r\n    y: globalPosition.y - clientRect.top\r\n  };\r\n};","module.exports = {\r\n  __depends__: [\r\n    require(239),\r\n    require(280)\r\n  ],\r\n  __init__: [ 'autoScroll' ],\r\n  autoScroll: [ 'type', require(215) ]\r\n};","'use strict';\r\n\r\nvar Geometry = require(345),\r\n    BendpointUtil = require(219);\r\n\r\nvar MARKER_OK = 'connect-ok',\r\n    MARKER_NOT_OK = 'connect-not-ok',\r\n    MARKER_CONNECT_HOVER = 'connect-hover',\r\n    MARKER_CONNECT_UPDATING = 'djs-updating';\r\n\r\nvar COMMAND_BENDPOINT_UPDATE = 'connection.updateWaypoints',\r\n    COMMAND_RECONNECT_START = 'connection.reconnectStart',\r\n    COMMAND_RECONNECT_END = 'connection.reconnectEnd';\r\n\r\nvar round = Math.round;\r\n\r\nvar svgClasses = require(580),\r\n    svgRemove = require(586);\r\n\r\nvar translate = require(356).translate;\r\n\r\n\r\n/**\r\n * A component that implements moving of bendpoints\r\n */\r\nfunction BendpointMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {\r\n\r\n  // optional connection docking integration\r\n  var connectionDocking = injector.get('connectionDocking', false);\r\n\r\n\r\n  // API\r\n\r\n  this.start = function(event, connection, bendpointIndex, insert) {\r\n\r\n    var type,\r\n        context,\r\n        waypoints = connection.waypoints,\r\n        gfx = canvas.getGraphics(connection);\r\n\r\n    if (!insert && bendpointIndex === 0) {\r\n      type = COMMAND_RECONNECT_START;\r\n    } else\r\n    if (!insert && bendpointIndex === waypoints.length - 1) {\r\n      type = COMMAND_RECONNECT_END;\r\n    } else {\r\n      type = COMMAND_BENDPOINT_UPDATE;\r\n    }\r\n\r\n    context = {\r\n      connection: connection,\r\n      bendpointIndex: bendpointIndex,\r\n      insert: insert,\r\n      type: type\r\n    };\r\n\r\n    dragging.init(event, 'bendpoint.move', {\r\n      data: {\r\n        connection: connection,\r\n        connectionGfx: gfx,\r\n        context: context\r\n      }\r\n    });\r\n  };\r\n\r\n\r\n  // DRAGGING IMPLEMENTATION\r\n\r\n\r\n  function redrawConnection(data) {\r\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\r\n  }\r\n\r\n  function filterRedundantWaypoints(waypoints) {\r\n\r\n    // alter copy of waypoints, not original\r\n    waypoints = waypoints.slice();\r\n\r\n    var idx = 0,\r\n        point,\r\n        previousPoint,\r\n        nextPoint;\r\n\r\n    while (waypoints[idx]) {\r\n      point = waypoints[idx];\r\n      previousPoint = waypoints[idx - 1];\r\n      nextPoint = waypoints[idx + 1];\r\n\r\n      if (Geometry.pointDistance(point, nextPoint) === 0 ||\r\n          Geometry.pointsOnLine(previousPoint, nextPoint, point)) {\r\n\r\n        // remove point, if overlapping with {nextPoint}\r\n        // or on line with {previousPoint} -> {point} -> {nextPoint}\r\n        waypoints.splice(idx, 1);\r\n      } else {\r\n        idx++;\r\n      }\r\n    }\r\n\r\n    return waypoints;\r\n  }\r\n\r\n  eventBus.on('bendpoint.move.start', function(e) {\r\n\r\n    var context = e.context,\r\n        connection = context.connection,\r\n        originalWaypoints = connection.waypoints,\r\n        waypoints = originalWaypoints.slice(),\r\n        insert = context.insert,\r\n        idx = context.bendpointIndex;\r\n\r\n    context.originalWaypoints = originalWaypoints;\r\n\r\n    if (insert) {\r\n      // insert placeholder for bendpoint to-be-added\r\n      waypoints.splice(idx, 0, null);\r\n    }\r\n\r\n    connection.waypoints = waypoints;\r\n\r\n    // add dragger gfx\r\n    context.draggerGfx = BendpointUtil.addBendpoint(canvas.getLayer('overlays'));\r\n    svgClasses(context.draggerGfx).add('djs-dragging');\r\n\r\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\r\n  });\r\n\r\n  eventBus.on('bendpoint.move.hover', function(e) {\r\n\r\n    e.context.hover = e.hover;\r\n    canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);\r\n  });\r\n\r\n  eventBus.on([\r\n    'bendpoint.move.out',\r\n    'bendpoint.move.cleanup'\r\n  ], function(e) {\r\n\r\n    // remove connect marker\r\n    // if it was added\r\n    var hover = e.context.hover;\r\n\r\n    if (hover) {\r\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\r\n      canvas.removeMarker(hover, e.context.target ? MARKER_OK : MARKER_NOT_OK);\r\n    }\r\n  });\r\n\r\n  eventBus.on('bendpoint.move.move', function(e) {\r\n\r\n    var context = e.context,\r\n        moveType = context.type,\r\n        connection = e.connection,\r\n        source, target;\r\n\r\n    connection.waypoints[context.bendpointIndex] = { x: e.x, y: e.y };\r\n\r\n    if (connectionDocking) {\r\n\r\n      if (context.hover) {\r\n        if (moveType === COMMAND_RECONNECT_START) {\r\n          source = context.hover;\r\n        }\r\n\r\n        if (moveType === COMMAND_RECONNECT_END) {\r\n          target = context.hover;\r\n        }\r\n      }\r\n\r\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, target);\r\n    }\r\n\r\n    // asks whether reconnect / bendpoint move / bendpoint add\r\n    // is allowed at the given position\r\n    var allowed = context.allowed = rules.allowed(context.type, context);\r\n\r\n    if (allowed) {\r\n\r\n      if (context.hover) {\r\n        canvas.removeMarker(context.hover, MARKER_NOT_OK);\r\n        canvas.addMarker(context.hover, MARKER_OK);\r\n\r\n        context.target = context.hover;\r\n      }\r\n    } else\r\n    if (allowed === false) {\r\n      if (context.hover) {\r\n        canvas.removeMarker(context.hover, MARKER_OK);\r\n        canvas.addMarker(context.hover, MARKER_NOT_OK);\r\n\r\n        context.target = null;\r\n      }\r\n    }\r\n\r\n    // add dragger gfx\r\n    translate(context.draggerGfx, e.x, e.y);\r\n\r\n    redrawConnection(e);\r\n  });\r\n\r\n  eventBus.on([\r\n    'bendpoint.move.end',\r\n    'bendpoint.move.cancel'\r\n  ], function(e) {\r\n\r\n    var context = e.context,\r\n        hover = context.hover,\r\n        connection = context.connection;\r\n\r\n    // remove dragger gfx\r\n    svgRemove(context.draggerGfx);\r\n    context.newWaypoints = connection.waypoints.slice();\r\n    connection.waypoints = context.originalWaypoints;\r\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\r\n\r\n    if (hover) {\r\n      canvas.removeMarker(hover, MARKER_OK);\r\n      canvas.removeMarker(hover, MARKER_NOT_OK);\r\n    }\r\n  });\r\n\r\n  eventBus.on('bendpoint.move.end', function(e) {\r\n\r\n    var context = e.context,\r\n        waypoints = context.newWaypoints,\r\n        bendpointIndex = context.bendpointIndex,\r\n        bendpoint = waypoints[bendpointIndex],\r\n        allowed = context.allowed,\r\n        hints;\r\n\r\n    // ensure we have actual pixel values bendpoint\r\n    // coordinates (important when zoom level was > 1 during move)\r\n    bendpoint.x = round(bendpoint.x);\r\n    bendpoint.y = round(bendpoint.y);\r\n\r\n    if (allowed && context.type === COMMAND_RECONNECT_START) {\r\n      modeling.reconnectStart(context.connection, context.target, bendpoint);\r\n    } else\r\n    if (allowed && context.type === COMMAND_RECONNECT_END) {\r\n      modeling.reconnectEnd(context.connection, context.target, bendpoint);\r\n    } else\r\n    if (allowed !== false && context.type === COMMAND_BENDPOINT_UPDATE) {\r\n\r\n      // pass hints on the actual moved bendpoint\r\n      // this is useful for connection and label layouting\r\n      hints = {\r\n        bendpointMove: {\r\n          insert: e.context.insert,\r\n          bendpointIndex: bendpointIndex\r\n        }\r\n      };\r\n\r\n      modeling.updateWaypoints(context.connection, filterRedundantWaypoints(waypoints), hints);\r\n    } else {\r\n      redrawConnection(e);\r\n\r\n      return false;\r\n    }\r\n  });\r\n\r\n  eventBus.on('bendpoint.move.cancel', function(e) {\r\n    redrawConnection(e);\r\n  });\r\n}\r\n\r\nBendpointMove.$inject = [ 'injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling' ];\r\n\r\nmodule.exports = BendpointMove;\r\n","'use strict';\r\n\r\nvar assign = require(516),\r\n    forEach = require(386),\r\n    isArray = require(506);\r\n\r\nvar abs= Math.abs,\r\n    round = Math.round;\r\n\r\nvar TOLERANCE = 10;\r\n\r\n\r\nfunction BendpointSnapping(eventBus) {\r\n\r\n  function snapTo(values, value) {\r\n\r\n    if (isArray(values)) {\r\n      var i = values.length;\r\n\r\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\r\n        return values[i];\r\n      }\r\n    } else {\r\n      values = +values;\r\n      var rem = value % values;\r\n\r\n      if (rem < TOLERANCE) {\r\n        return value - rem;\r\n      }\r\n\r\n      if (rem > values - TOLERANCE) {\r\n        return value - rem + values;\r\n      }\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  function mid(element) {\r\n    if (element.width) {\r\n      return {\r\n        x: round(element.width / 2 + element.x),\r\n        y: round(element.height / 2 + element.y)\r\n      };\r\n    }\r\n  }\r\n\r\n  ////////// connection segment snapping //////////////////////////////////////\r\n\r\n  function getConnectionSegmentSnaps(context) {\r\n\r\n    var snapPoints = context.snapPoints,\r\n        connection = context.connection,\r\n        waypoints = connection.waypoints,\r\n        segmentStart = context.segmentStart,\r\n        segmentStartIndex = context.segmentStartIndex,\r\n        segmentEnd = context.segmentEnd,\r\n        segmentEndIndex = context.segmentEndIndex,\r\n        axis = context.axis;\r\n\r\n    if (snapPoints) {\r\n      return snapPoints;\r\n    }\r\n\r\n    var referenceWaypoints = [\r\n      waypoints[segmentStartIndex - 1],\r\n      segmentStart,\r\n      segmentEnd,\r\n      waypoints[segmentEndIndex + 1]\r\n    ];\r\n\r\n    if (segmentStartIndex < 2) {\r\n      referenceWaypoints.unshift(mid(connection.source));\r\n    }\r\n\r\n    if (segmentEndIndex > waypoints.length - 3) {\r\n      referenceWaypoints.unshift(mid(connection.target));\r\n    }\r\n\r\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\r\n\r\n    forEach(referenceWaypoints, function(p) {\r\n      // we snap on existing bendpoints only,\r\n      // not placeholders that are inserted during add\r\n      if (p) {\r\n        p = p.original || p;\r\n\r\n        if (axis === 'y') {\r\n          snapPoints.horizontal.push(p.y);\r\n        }\r\n\r\n        if (axis === 'x') {\r\n          snapPoints.vertical.push(p.x);\r\n        }\r\n      }\r\n    });\r\n\r\n    return snapPoints;\r\n  }\r\n\r\n  eventBus.on('connectionSegment.move.move', 1500, function(event) {\r\n    var context = event.context,\r\n        snapPoints = getConnectionSegmentSnaps(context),\r\n        x = event.x,\r\n        y = event.y,\r\n        sx, sy;\r\n\r\n    if (!snapPoints) {\r\n      return;\r\n    }\r\n\r\n    // snap\r\n    sx = snapTo(snapPoints.vertical, x);\r\n    sy = snapTo(snapPoints.horizontal, y);\r\n\r\n\r\n    // correction x/y\r\n    var cx = (x - sx),\r\n        cy = (y - sy);\r\n\r\n    // update delta\r\n    assign(event, {\r\n      dx: event.dx - cx,\r\n      dy: event.dy - cy,\r\n      x: sx,\r\n      y: sy\r\n    });\r\n  });\r\n\r\n\r\n  ///////// bendpoint snapping /////////////////////////////\r\n\r\n  function getBendpointSnaps(context) {\r\n\r\n    var snapPoints = context.snapPoints,\r\n        waypoints = context.connection.waypoints,\r\n        bendpointIndex = context.bendpointIndex;\r\n\r\n    if (snapPoints) {\r\n      return snapPoints;\r\n    }\r\n\r\n    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];\r\n\r\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\r\n\r\n    forEach(referenceWaypoints, function(p) {\r\n      // we snap on existing bendpoints only,\r\n      // not placeholders that are inserted during add\r\n      if (p) {\r\n        p = p.original || p;\r\n\r\n        snapPoints.horizontal.push(p.y);\r\n        snapPoints.vertical.push(p.x);\r\n      }\r\n    });\r\n\r\n    return snapPoints;\r\n  }\r\n\r\n\r\n  eventBus.on('bendpoint.move.move', 1500, function(event) {\r\n\r\n    var context = event.context,\r\n        snapPoints = getBendpointSnaps(context),\r\n        target = context.target,\r\n        targetMid = target && mid(target),\r\n        x = event.x,\r\n        y = event.y,\r\n        sx, sy;\r\n\r\n    if (!snapPoints) {\r\n      return;\r\n    }\r\n\r\n    // snap\r\n    sx = snapTo(targetMid ? snapPoints.vertical.concat([ targetMid.x ]) : snapPoints.vertical, x);\r\n    sy = snapTo(targetMid ? snapPoints.horizontal.concat([ targetMid.y ]) : snapPoints.horizontal, y);\r\n\r\n\r\n    // correction x/y\r\n    var cx = (x - sx),\r\n        cy = (y - sy);\r\n\r\n    // update delta\r\n    assign(event, {\r\n      dx: event.dx - cx,\r\n      dy: event.dy - cy,\r\n      x: event.x - cx,\r\n      y: event.y - cy\r\n    });\r\n  });\r\n}\r\n\r\n\r\nBendpointSnapping.$inject = [ 'eventBus' ];\r\n\r\nmodule.exports = BendpointSnapping;\r\n","'use strict';\r\n\r\nvar Events = require(344),\r\n    Geometry = require(345);\r\n\r\nvar BENDPOINT_CLS = module.exports.BENDPOINT_CLS = 'djs-bendpoint';\r\nvar SEGMENT_DRAGGER_CLS = module.exports.SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583);\r\n\r\nvar rotate = require(356).rotate,\r\n    translate = require(356).translate;\r\n\r\n\r\nmodule.exports.toCanvasCoordinates = function(canvas, event) {\r\n\r\n  var position = Events.toPoint(event),\r\n      clientRect = canvas._container.getBoundingClientRect(),\r\n      offset;\r\n\r\n  // canvas relative position\r\n\r\n  offset = {\r\n    x: clientRect.left,\r\n    y: clientRect.top\r\n  };\r\n\r\n  // update actual event payload with canvas relative measures\r\n\r\n  var viewbox = canvas.viewbox();\r\n\r\n  return {\r\n    x: viewbox.x + (position.x - offset.x) / viewbox.scale,\r\n    y: viewbox.y + (position.y - offset.y) / viewbox.scale\r\n  };\r\n};\r\n\r\nmodule.exports.addBendpoint = function(parentGfx, cls) {\r\n  var groupGfx = svgCreate('g');\r\n  svgClasses(groupGfx).add(BENDPOINT_CLS);\r\n\r\n  svgAppend(parentGfx, groupGfx);\r\n\r\n  var visual = svgCreate('circle');\r\n  svgAttr(visual, {\r\n    cx: 0,\r\n    cy: 0,\r\n    r: 4\r\n  });\r\n  svgClasses(visual).add('djs-visual');\r\n\r\n  svgAppend(groupGfx, visual);\r\n\r\n  var hit = svgCreate('circle');\r\n  svgAttr(hit, {\r\n    cx: 0,\r\n    cy: 0,\r\n    r: 10\r\n  });\r\n  svgClasses(hit).add('djs-hit');\r\n\r\n  svgAppend(groupGfx, hit);\r\n\r\n  if (cls) {\r\n    svgClasses(groupGfx).add(cls);\r\n  }\r\n\r\n  return groupGfx;\r\n};\r\n\r\nfunction createParallelDragger(parentGfx, position, alignment) {\r\n  var draggerGfx = svgCreate('g');\r\n\r\n  svgAppend(parentGfx, draggerGfx);\r\n\r\n  var width = 14,\r\n      height = 3,\r\n      padding = 6,\r\n      hitWidth = width + padding,\r\n      hitHeight = height + padding;\r\n\r\n  var visual = svgCreate('rect');\r\n  svgAttr(visual, {\r\n    x: -width / 2,\r\n    y: -height / 2,\r\n    width: width,\r\n    height: height\r\n  });\r\n  svgClasses(visual).add('djs-visual');\r\n\r\n  svgAppend(draggerGfx, visual);\r\n\r\n  var hit = svgCreate('rect');\r\n  svgAttr(hit, {\r\n    x: -hitWidth / 2,\r\n    y: -hitHeight / 2,\r\n    width: hitWidth,\r\n    height: hitHeight\r\n  });\r\n  svgClasses(hit).add('djs-hit');\r\n\r\n  svgAppend(draggerGfx, hit);\r\n\r\n  rotate(draggerGfx, alignment === 'h' ? 90 : 0, 0, 0);\r\n\r\n  return draggerGfx;\r\n}\r\n\r\n\r\nmodule.exports.addSegmentDragger = function(parentGfx, segmentStart, segmentEnd) {\r\n\r\n  var groupGfx = svgCreate('g'),\r\n      mid = Geometry.getMidPoint(segmentStart, segmentEnd),\r\n      alignment = Geometry.pointsAligned(segmentStart, segmentEnd);\r\n\r\n  svgAppend(parentGfx, groupGfx);\r\n\r\n  createParallelDragger(groupGfx, mid, alignment);\r\n\r\n  svgClasses(groupGfx).add(SEGMENT_DRAGGER_CLS);\r\n  svgClasses(groupGfx).add(alignment === 'h' ? 'vertical' : 'horizontal');\r\n\r\n  translate(groupGfx, mid.x, mid.y);\r\n\r\n  return groupGfx;\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar domEvent = require(536),\r\n    domQuery = require(538),\r\n    BendpointUtil = require(219);\r\n\r\nvar pointsAligned = require(345).pointsAligned,\r\n    getMidPoint = require(345).getMidPoint;\r\n\r\nvar BENDPOINT_CLS = BendpointUtil.BENDPOINT_CLS,\r\n    SEGMENT_DRAGGER_CLS = BendpointUtil.SEGMENT_DRAGGER_CLS;\r\n\r\nvar getApproxIntersection = require(349).getApproxIntersection;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\nvar translate = require(356).translate;\r\n\r\n\r\n/**\r\n * A service that adds editable bendpoints to connections.\r\n */\r\nfunction Bendpoints(eventBus, canvas, interactionEvents,\r\n                    bendpointMove, connectionSegmentMove) {\r\n\r\n  function getConnectionIntersection(waypoints, event) {\r\n    var localPosition = BendpointUtil.toCanvasCoordinates(canvas, event),\r\n        intersection = getApproxIntersection(waypoints, localPosition);\r\n\r\n    return intersection;\r\n  }\r\n\r\n  function isIntersectionMiddle(intersection, waypoints, treshold) {\r\n    var idx = intersection.index,\r\n        p = intersection.point,\r\n        p0, p1, mid, aligned, xDelta, yDelta;\r\n\r\n    if (idx <= 0 || intersection.bendpoint) {\r\n      return false;\r\n    }\r\n\r\n    p0 = waypoints[idx - 1];\r\n    p1 = waypoints[idx];\r\n    mid = getMidPoint(p0, p1),\r\n    aligned = pointsAligned(p0, p1);\r\n    xDelta = Math.abs(p.x - mid.x);\r\n    yDelta = Math.abs(p.y - mid.y);\r\n\r\n    return aligned && xDelta <= treshold && yDelta <= treshold;\r\n  }\r\n\r\n  function activateBendpointMove(event, connection) {\r\n    var waypoints = connection.waypoints,\r\n        intersection = getConnectionIntersection(waypoints, event);\r\n\r\n    if (!intersection) {\r\n      return;\r\n    }\r\n\r\n    if (isIntersectionMiddle(intersection, waypoints, 10)) {\r\n      connectionSegmentMove.start(event, connection, intersection.index);\r\n    } else {\r\n      bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);\r\n    }\r\n  }\r\n\r\n  function bindInteractionEvents(node, eventName, element) {\r\n\r\n    domEvent.bind(node, eventName, function(event) {\r\n      interactionEvents.triggerMouseEvent(eventName, event, element);\r\n      event.stopPropagation();\r\n    });\r\n  }\r\n\r\n  function getBendpointsContainer(element, create) {\r\n\r\n    var layer = canvas.getLayer('overlays'),\r\n        gfx = domQuery('.djs-bendpoints[data-element-id=' + element.id + ']', layer);\r\n\r\n    if (!gfx && create) {\r\n      gfx = svgCreate('g');\r\n      svgAttr(gfx, { 'data-element-id': element.id });\r\n      svgClasses(gfx).add('djs-bendpoints');\r\n\r\n      svgAppend(layer, gfx);\r\n\r\n      bindInteractionEvents(gfx, 'mousedown', element);\r\n      bindInteractionEvents(gfx, 'click', element);\r\n      bindInteractionEvents(gfx, 'dblclick', element);\r\n    }\r\n\r\n    return gfx;\r\n  }\r\n\r\n  function createBendpoints(gfx, connection) {\r\n    connection.waypoints.forEach(function(p, idx) {\r\n      var bendpoint = BendpointUtil.addBendpoint(gfx);\r\n\r\n      svgAppend(gfx, bendpoint);\r\n\r\n      translate(bendpoint, p.x, p.y);\r\n    });\r\n\r\n    // add floating bendpoint\r\n    BendpointUtil.addBendpoint(gfx, 'floating');\r\n  }\r\n\r\n  function createSegmentDraggers(gfx, connection) {\r\n\r\n    var waypoints = connection.waypoints;\r\n\r\n    var segmentStart,\r\n        segmentEnd;\r\n\r\n    for (var i = 1; i < waypoints.length; i++) {\r\n\r\n      segmentStart = waypoints[i - 1];\r\n      segmentEnd = waypoints[i];\r\n\r\n      if (pointsAligned(segmentStart, segmentEnd)) {\r\n        BendpointUtil.addSegmentDragger(gfx, segmentStart, segmentEnd);\r\n      }\r\n    }\r\n  }\r\n\r\n  function clearBendpoints(gfx) {\r\n    forEach(domQuery.all('.' + BENDPOINT_CLS, gfx), function(node) {\r\n      svgRemove(node);\r\n    });\r\n  }\r\n\r\n  function clearSegmentDraggers(gfx) {\r\n    forEach(domQuery.all('.' + SEGMENT_DRAGGER_CLS, gfx), function(node) {\r\n      svgRemove(node);\r\n    });\r\n  }\r\n\r\n  function addHandles(connection) {\r\n\r\n    var gfx = getBendpointsContainer(connection);\r\n\r\n    if (!gfx) {\r\n      gfx = getBendpointsContainer(connection, true);\r\n\r\n      createBendpoints(gfx, connection);\r\n      createSegmentDraggers(gfx, connection);\r\n    }\r\n\r\n    return gfx;\r\n  }\r\n\r\n  function updateHandles(connection) {\r\n\r\n    var gfx = getBendpointsContainer(connection);\r\n\r\n    if (gfx) {\r\n      clearSegmentDraggers(gfx);\r\n      clearBendpoints(gfx);\r\n      createSegmentDraggers(gfx, connection);\r\n      createBendpoints(gfx, connection);\r\n    }\r\n  }\r\n\r\n  eventBus.on('connection.changed', function(event) {\r\n    updateHandles(event.element);\r\n  });\r\n\r\n  eventBus.on('connection.remove', function(event) {\r\n    var gfx = getBendpointsContainer(event.element);\r\n\r\n    if (gfx) {\r\n      svgRemove(gfx);\r\n    }\r\n  });\r\n\r\n  eventBus.on('element.marker.update', function(event) {\r\n\r\n    var element = event.element,\r\n        bendpointsGfx;\r\n\r\n    if (!element.waypoints) {\r\n      return;\r\n    }\r\n\r\n    bendpointsGfx = addHandles(element);\r\n\r\n    if (event.add) {\r\n      svgClasses(bendpointsGfx).add(event.marker);\r\n    } else {\r\n      svgClasses(bendpointsGfx).remove(event.marker);\r\n    }\r\n  });\r\n\r\n  eventBus.on('element.mousemove', function(event) {\r\n\r\n    var element = event.element,\r\n        waypoints = element.waypoints,\r\n        bendpointsGfx,\r\n        floating,\r\n        intersection;\r\n\r\n    if (waypoints) {\r\n      bendpointsGfx = getBendpointsContainer(element, true);\r\n      floating = domQuery('.floating', bendpointsGfx);\r\n\r\n      if (!floating) {\r\n        return;\r\n      }\r\n\r\n      intersection = getConnectionIntersection(waypoints, event.originalEvent);\r\n\r\n      if (intersection) {\r\n        translate(floating, intersection.point.x, intersection.point.y);\r\n      }\r\n    }\r\n  });\r\n\r\n  eventBus.on('element.mousedown', function(event) {\r\n\r\n    var originalEvent = event.originalEvent,\r\n        element = event.element,\r\n        waypoints = element.waypoints;\r\n\r\n    if (!waypoints) {\r\n      return;\r\n    }\r\n\r\n    activateBendpointMove(originalEvent, element, waypoints);\r\n  });\r\n\r\n  eventBus.on('selection.changed', function(event) {\r\n    var newSelection = event.newSelection,\r\n        primary = newSelection[0];\r\n\r\n    if (primary && primary.waypoints) {\r\n      addHandles(primary);\r\n    }\r\n  });\r\n\r\n  eventBus.on('element.hover', function(event) {\r\n    var element = event.element;\r\n\r\n    if (element.waypoints) {\r\n      addHandles(element);\r\n      interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');\r\n    }\r\n  });\r\n\r\n  eventBus.on('element.out', function(event) {\r\n    interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');\r\n  });\r\n\r\n  // update bendpoint container data attribute on element ID change\r\n  eventBus.on('element.updateId', function(context) {\r\n    var element = context.element,\r\n        newId = context.newId;\r\n\r\n    if (element.waypoints) {\r\n      var bendpointContainer = getBendpointsContainer(element);\r\n\r\n      if (bendpointContainer) {\r\n        svgAttr(bendpointContainer, { 'data-element-id': newId });\r\n      }\r\n    }\r\n  });\r\n\r\n  // API\r\n\r\n  this.addHandles = addHandles;\r\n  this.updateHandles = updateHandles;\r\n  this.getBendpointsContainer = getBendpointsContainer;\r\n}\r\n\r\nBendpoints.$inject = [\r\n  'eventBus', 'canvas', 'interactionEvents',\r\n  'bendpointMove', 'connectionSegmentMove'\r\n];\r\n\r\nmodule.exports = Bendpoints;\r\n","'use strict';\r\n\r\nvar Geometry = require(345),\r\n    BendpointUtil = require(219),\r\n    LayoutUtil = require(329);\r\n\r\nvar MARKER_CONNECT_HOVER = 'connect-hover',\r\n    MARKER_CONNECT_UPDATING = 'djs-updating';\r\n\r\nvar svgClasses = require(580),\r\n    svgRemove = require(586);\r\n\r\nvar translate = require(356).translate;\r\n\r\n\r\nfunction axisAdd(point, axis, delta) {\r\n  return axisSet(point, axis, point[axis] + delta);\r\n}\r\n\r\nfunction axisSet(point, axis, value) {\r\n  return {\r\n    x: (axis === 'x' ? value : point.x),\r\n    y: (axis === 'y' ? value : point.y)\r\n  };\r\n}\r\n\r\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\r\n\r\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\r\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\r\n\r\n  var padding = 20;\r\n\r\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\r\n\r\n  return axisSet(segmentStart, axis, fencedValue);\r\n}\r\n\r\nfunction flipAxis(axis) {\r\n  return axis === 'x' ? 'y' : 'x';\r\n}\r\n\r\n/**\r\n * Get the docking point on the given element.\r\n *\r\n * Compute a reasonable docking, if non exists.\r\n *\r\n * @param  {Point} point\r\n * @param  {djs.model.Shape} referenceElement\r\n * @param  {String} moveAxis (x|y)\r\n *\r\n * @return {Point}\r\n */\r\nfunction getDocking(point, referenceElement, moveAxis) {\r\n\r\n  var referenceMid,\r\n      inverseAxis;\r\n\r\n  if (point.original) {\r\n    return point.original;\r\n  } else {\r\n    referenceMid = LayoutUtil.getMid(referenceElement);\r\n    inverseAxis = flipAxis(moveAxis);\r\n\r\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\r\n  }\r\n}\r\n\r\n/**\r\n * A component that implements moving of bendpoints\r\n */\r\nfunction ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {\r\n\r\n  // optional connection docking integration\r\n  var connectionDocking = injector.get('connectionDocking', false);\r\n\r\n\r\n  // API\r\n\r\n  this.start = function(event, connection, idx) {\r\n\r\n    var context,\r\n        gfx = canvas.getGraphics(connection),\r\n        segmentStartIndex = idx - 1,\r\n        segmentEndIndex = idx,\r\n        waypoints = connection.waypoints,\r\n        segmentStart = waypoints[segmentStartIndex],\r\n        segmentEnd = waypoints[segmentEndIndex],\r\n        direction,\r\n        axis;\r\n\r\n    direction = Geometry.pointsAligned(segmentStart, segmentEnd);\r\n\r\n    // do not move diagonal connection\r\n    if (!direction) {\r\n      return;\r\n    }\r\n\r\n    // the axis where we are going to move things\r\n    axis = direction === 'v' ? 'y' : 'x';\r\n\r\n    if (segmentStartIndex === 0) {\r\n      segmentStart = getDocking(segmentStart, connection.source, axis);\r\n    }\r\n\r\n    if (segmentEndIndex === waypoints.length - 1) {\r\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\r\n    }\r\n\r\n    context = {\r\n      connection: connection,\r\n      segmentStartIndex: segmentStartIndex,\r\n      segmentEndIndex: segmentEndIndex,\r\n      segmentStart: segmentStart,\r\n      segmentEnd: segmentEnd,\r\n      axis: axis\r\n    };\r\n\r\n    dragging.init(event, {\r\n      x: (segmentStart.x + segmentEnd.x)/2,\r\n      y: (segmentStart.y + segmentEnd.y)/2\r\n    }, 'connectionSegment.move', {\r\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\r\n      data: {\r\n        connection: connection,\r\n        connectionGfx: gfx,\r\n        context: context\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Crop connection if connection cropping is provided.\r\n   *\r\n   * @param {Connection} connection\r\n   * @param {Array<Point>} newWaypoints\r\n   *\r\n   * @return {Array<Point>} cropped connection waypoints\r\n   */\r\n  function cropConnection(connection, newWaypoints) {\r\n\r\n    // crop connection, if docking service is provided only\r\n    if (!connectionDocking) {\r\n      return newWaypoints;\r\n    }\r\n\r\n    var oldWaypoints = connection.waypoints,\r\n        croppedWaypoints;\r\n\r\n    // temporary set new waypoints\r\n    connection.waypoints = newWaypoints;\r\n\r\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\r\n\r\n    // restore old waypoints\r\n    connection.waypoints = oldWaypoints;\r\n\r\n    return croppedWaypoints;\r\n  }\r\n\r\n  // DRAGGING IMPLEMENTATION\r\n\r\n  function redrawConnection(data) {\r\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\r\n  }\r\n\r\n  function updateDragger(context, segmentOffset, event) {\r\n\r\n    var newWaypoints = context.newWaypoints,\r\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\r\n        segmentStart = newWaypoints[segmentStartIndex],\r\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\r\n        segmentEnd = newWaypoints[segmentEndIndex],\r\n        axis = flipAxis(context.axis);\r\n\r\n    // make sure the dragger does not move\r\n    // outside the connection\r\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\r\n\r\n    // update dragger\r\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\r\n  }\r\n\r\n  /**\r\n   * Filter waypoints for redundant ones (i.e. on the same axis).\r\n   * Returns the filtered waypoints and the offset related to the segment move.\r\n   *\r\n   * @param {Array<Point>} waypoints\r\n   * @param {Integer} segmentStartIndex of moved segment start\r\n   *\r\n   * @return {Object} { filteredWaypoints, segmentOffset }\r\n   */\r\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\r\n\r\n    var segmentOffset = 0;\r\n\r\n    var filteredWaypoints = waypoints.filter(function(r, idx) {\r\n      if (Geometry.pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\r\n\r\n        // remove point and increment offset\r\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\r\n        return false;\r\n      }\r\n\r\n      // dont remove point\r\n      return true;\r\n    });\r\n\r\n    return {\r\n      waypoints: filteredWaypoints,\r\n      segmentOffset: segmentOffset\r\n    };\r\n  }\r\n\r\n  eventBus.on('connectionSegment.move.start', function(e) {\r\n\r\n    var context = e.context,\r\n        connection = e.connection,\r\n        layer = canvas.getLayer('overlays');\r\n\r\n    context.originalWaypoints = connection.waypoints.slice();\r\n\r\n    // add dragger gfx\r\n    context.draggerGfx = BendpointUtil.addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\r\n    svgClasses(context.draggerGfx).add('djs-dragging');\r\n\r\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\r\n  });\r\n\r\n  eventBus.on('connectionSegment.move.move', function(e) {\r\n\r\n    var context = e.context,\r\n        connection = context.connection,\r\n        segmentStartIndex = context.segmentStartIndex,\r\n        segmentEndIndex = context.segmentEndIndex,\r\n        segmentStart = context.segmentStart,\r\n        segmentEnd = context.segmentEnd,\r\n        axis = context.axis;\r\n\r\n    var newWaypoints = context.originalWaypoints.slice(),\r\n        newSegmentStart = axisAdd(segmentStart, axis, e['d' + axis]),\r\n        newSegmentEnd = axisAdd(segmentEnd, axis, e['d' + axis]);\r\n\r\n    // original waypoint count and added / removed\r\n    // from start waypoint delta. We use the later\r\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\r\n    var waypointCount = newWaypoints.length,\r\n        segmentOffset = 0;\r\n\r\n    // move segment start / end by axis delta\r\n    newWaypoints[segmentStartIndex] = newSegmentStart;\r\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\r\n\r\n    var sourceToSegmentOrientation,\r\n        targetToSegmentOrientation;\r\n\r\n    // handle first segment\r\n    if (segmentStartIndex < 2) {\r\n      sourceToSegmentOrientation = LayoutUtil.getOrientation(connection.source, newSegmentStart);\r\n\r\n      // first bendpoint, remove first segment if intersecting\r\n      if (segmentStartIndex === 1) {\r\n\r\n        if (sourceToSegmentOrientation === 'intersect') {\r\n          newWaypoints.shift();\r\n          newWaypoints[0] = newSegmentStart;\r\n          segmentOffset--;\r\n        }\r\n      }\r\n\r\n      // docking point, add segment if not intersecting anymore\r\n      else {\r\n        if (sourceToSegmentOrientation !== 'intersect') {\r\n          newWaypoints.unshift(segmentStart);\r\n          segmentOffset++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // handle last segment\r\n    if (segmentEndIndex > waypointCount - 3) {\r\n      targetToSegmentOrientation = LayoutUtil.getOrientation(connection.target, newSegmentEnd);\r\n\r\n      // last bendpoint, remove last segment if intersecting\r\n      if (segmentEndIndex === waypointCount - 2) {\r\n\r\n        if (targetToSegmentOrientation === 'intersect') {\r\n          newWaypoints.pop();\r\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\r\n        }\r\n      }\r\n\r\n      // last bendpoint, remove last segment if intersecting\r\n      else {\r\n        if (targetToSegmentOrientation !== 'intersect') {\r\n          newWaypoints.push(segmentEnd);\r\n        }\r\n      }\r\n    }\r\n\r\n    // update connection waypoints\r\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\r\n\r\n    // update dragger position\r\n    updateDragger(context, segmentOffset, e);\r\n\r\n    // save segmentOffset in context\r\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\r\n\r\n    // redraw connection\r\n    redrawConnection(e);\r\n  });\r\n\r\n  eventBus.on('connectionSegment.move.hover', function(e) {\r\n\r\n    e.context.hover = e.hover;\r\n    canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);\r\n  });\r\n\r\n  eventBus.on([\r\n    'connectionSegment.move.out',\r\n    'connectionSegment.move.cleanup'\r\n  ], function(e) {\r\n\r\n    // remove connect marker\r\n    // if it was added\r\n    var hover = e.context.hover;\r\n\r\n    if (hover) {\r\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\r\n    }\r\n  });\r\n\r\n  eventBus.on('connectionSegment.move.cleanup', function(e) {\r\n\r\n    var context = e.context,\r\n        connection = context.connection;\r\n\r\n    // remove dragger gfx\r\n    if (context.draggerGfx) {\r\n      svgRemove(context.draggerGfx);\r\n    }\r\n\r\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\r\n  });\r\n\r\n  eventBus.on([\r\n    'connectionSegment.move.cancel',\r\n    'connectionSegment.move.end'\r\n  ], function(e) {\r\n    var context = e.context,\r\n        connection = context.connection;\r\n\r\n    connection.waypoints = context.originalWaypoints;\r\n\r\n    redrawConnection(e);\r\n  });\r\n\r\n  eventBus.on('connectionSegment.move.end', function(e) {\r\n\r\n    var context = e.context,\r\n        connection = context.connection,\r\n        newWaypoints = context.newWaypoints,\r\n        newSegmentStartIndex = context.newSegmentStartIndex;\r\n\r\n    // ensure we have actual pixel values bendpoint\r\n    // coordinates (important when zoom level was > 1 during move)\r\n    newWaypoints = newWaypoints.map(function(p) {\r\n      return {\r\n        original: p.original,\r\n        x: Math.round(p.x),\r\n        y: Math.round(p.y)\r\n      };\r\n    });\r\n\r\n    // apply filter redunant waypoints\r\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\r\n\r\n    // get filtered waypoints\r\n    var filteredWaypoints = filtered.waypoints,\r\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\r\n        segmentOffset = filtered.segmentOffset;\r\n\r\n    var hints = {\r\n      segmentMove: {\r\n        segmentStartIndex: context.segmentStartIndex,\r\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\r\n      }\r\n    };\r\n\r\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\r\n  });\r\n}\r\n\r\nConnectionSegmentMove.$inject = [\r\n  'injector', 'eventBus', 'canvas',\r\n  'dragging', 'graphicsFactory', 'rules',\r\n  'modeling'\r\n];\r\n\r\nmodule.exports = ConnectionSegmentMove;\r\n","module.exports = {\r\n  __depends__: [ require(239), require(304) ],\r\n  __init__: [ 'bendpoints', 'bendpointSnapping' ],\r\n  bendpoints: [ 'type', require(220) ],\r\n  bendpointMove: [ 'type', require(217) ],\r\n  connectionSegmentMove: [ 'type', require(221) ],\r\n  bendpointSnapping: [ 'type', require(218) ]\r\n};\r\n","'use strict';\r\n\r\nvar getElementType = require(343).getType;\r\n\r\n/**\r\n * Adds change support to the diagram, including\r\n *\r\n * <ul>\r\n *   <li>redrawing shapes and connections on change</li>\r\n * </ul>\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {GraphicsFactory} graphicsFactory\r\n */\r\nfunction ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {\r\n\r\n  // redraw shapes / connections on change\r\n\r\n  eventBus.on('element.changed', function(event) {\r\n\r\n    var element = event.element;\r\n\r\n    // element might have been deleted and replaced by new element with same ID\r\n    // thus check for parent of element except for root element\r\n    if (element.parent || element === canvas.getRootElement()) {\r\n      event.gfx = elementRegistry.getGraphics(element);\r\n    }\r\n\r\n    // shape + gfx may have been deleted\r\n    if (!event.gfx) {\r\n      return;\r\n    }\r\n\r\n    eventBus.fire(getElementType(element) + '.changed', event);\r\n  });\r\n\r\n  eventBus.on('elements.changed', function(event) {\r\n\r\n    var elements = event.elements;\r\n\r\n    elements.forEach(function(e) {\r\n      eventBus.fire('element.changed', { element: e });\r\n    });\r\n\r\n    graphicsFactory.updateContainments(elements);\r\n  });\r\n\r\n  eventBus.on('shape.changed', function(event) {\r\n    graphicsFactory.update('shape', event.element, event.gfx);\r\n  });\r\n\r\n  eventBus.on('connection.changed', function(event) {\r\n    graphicsFactory.update('connection', event.element, event.gfx);\r\n  });\r\n}\r\n\r\nChangeSupport.$inject = [ 'eventBus', 'canvas', 'elementRegistry', 'graphicsFactory' ];\r\n\r\nmodule.exports = ChangeSupport;\r\n","module.exports = {\r\n  __init__: [ 'changeSupport'],\r\n  changeSupport: [ 'type', require(223) ]\r\n};","'use strict';\r\n\r\n/**\r\n * A clip board stub\r\n */\r\nfunction Clipboard() {}\r\n\r\nmodule.exports = Clipboard;\r\n\r\n\r\nClipboard.prototype.get = function() {\r\n  return this._data;\r\n};\r\n\r\nClipboard.prototype.set = function(data) {\r\n  this._data = data;\r\n};\r\n\r\nClipboard.prototype.clear = function() {\r\n  var data = this._data;\r\n\r\n  delete this._data;\r\n\r\n  return data;\r\n};\r\n\r\nClipboard.prototype.isEmpty = function() {\r\n  return !this._data;\r\n};","module.exports = {\r\n  clipboard: [ 'type', require(225) ]\r\n};\r\n","'use strict';\r\n\r\nvar LayoutUtil = require(329);\r\n\r\nvar MARKER_OK = 'connect-ok',\r\n    MARKER_NOT_OK = 'connect-not-ok';\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\n\r\nfunction Connect(eventBus, dragging, modeling, rules, canvas, graphicsFactory) {\r\n\r\n  // TODO(nre): separate UI and events\r\n\r\n  // rules\r\n\r\n  function canConnect(source, target) {\r\n    return rules.allowed('connection.create', {\r\n      source: source,\r\n      target: target\r\n    });\r\n  }\r\n\r\n\r\n  // layouting\r\n\r\n  function crop(start, end, source, target) {\r\n\r\n    var sourcePath = graphicsFactory.getShapePath(source),\r\n        targetPath = target && graphicsFactory.getShapePath(target),\r\n        connectionPath = graphicsFactory.getConnectionPath({ waypoints: [ start, end ] });\r\n\r\n    start = LayoutUtil.getElementLineIntersection(sourcePath, connectionPath, true) || start;\r\n    end = (target && LayoutUtil.getElementLineIntersection(targetPath, connectionPath, false)) || end;\r\n\r\n    return [ start, end ];\r\n  }\r\n\r\n\r\n  // event handlers\r\n\r\n  eventBus.on('connect.move', function(event) {\r\n\r\n    var context = event.context,\r\n        source = context.source,\r\n        target = context.target,\r\n        visual = context.visual,\r\n        sourcePosition = context.sourcePosition,\r\n        endPosition,\r\n        waypoints;\r\n\r\n    // update connection visuals during drag\r\n\r\n    endPosition = {\r\n      x: event.x,\r\n      y: event.y\r\n    };\r\n\r\n    waypoints = crop(sourcePosition, endPosition, source, target);\r\n\r\n    svgAttr(visual, { 'points': [ waypoints[0].x, waypoints[0].y, waypoints[1].x, waypoints[1].y ] });\r\n  });\r\n\r\n  eventBus.on('connect.hover', function(event) {\r\n    var context = event.context,\r\n        source = context.source,\r\n        hover = event.hover,\r\n        canExecute;\r\n\r\n    canExecute = context.canExecute = canConnect(source, hover);\r\n\r\n    // simply ignore hover\r\n    if (canExecute === null) {\r\n      return;\r\n    }\r\n\r\n    context.target = hover;\r\n\r\n    canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);\r\n  });\r\n\r\n  eventBus.on([ 'connect.out', 'connect.cleanup' ], function(event) {\r\n    var context = event.context;\r\n\r\n    if (context.target) {\r\n      canvas.removeMarker(context.target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);\r\n    }\r\n\r\n    context.target = null;\r\n  });\r\n\r\n  eventBus.on('connect.cleanup', function(event) {\r\n    var context = event.context;\r\n\r\n    if (context.visual) {\r\n      svgRemove(context.visual);\r\n    }\r\n  });\r\n\r\n  eventBus.on('connect.start', function(event) {\r\n    var context = event.context,\r\n        visual;\r\n\r\n    visual = svgCreate('polyline');\r\n    svgAttr(visual, {\r\n      'stroke': '#333',\r\n      'strokeDasharray': [ 1 ],\r\n      'strokeWidth': 2,\r\n      'pointer-events': 'none'\r\n    });\r\n\r\n    svgAppend(canvas.getDefaultLayer(), visual);\r\n\r\n    context.visual = visual;\r\n  });\r\n\r\n  eventBus.on('connect.end', function(event) {\r\n\r\n    var context = event.context,\r\n        source = context.source,\r\n        sourcePosition = context.sourcePosition,\r\n        target = context.target,\r\n        targetPosition = {\r\n          x: event.x,\r\n          y: event.y\r\n        },\r\n        canExecute = context.canExecute || canConnect(source, target);\r\n\r\n    if (!canExecute) {\r\n      return false;\r\n    }\r\n\r\n    var attrs = null,\r\n        hints = {\r\n          connectionStart: sourcePosition,\r\n          connectionEnd: targetPosition\r\n        };\r\n\r\n    if (typeof canExecute === 'object') {\r\n      attrs = canExecute;\r\n    }\r\n\r\n    modeling.connect(source, target, attrs, hints);\r\n  });\r\n\r\n\r\n  // API\r\n\r\n  /**\r\n   * Start connect operation.\r\n   *\r\n   * @param {DOMEvent} event\r\n   * @param {djs.model.Base} source\r\n   * @param {Point} [sourcePosition]\r\n   * @param {Boolean} [autoActivate=false]\r\n   */\r\n  this.start = function(event, source, sourcePosition, autoActivate) {\r\n\r\n    if (typeof sourcePosition !== 'object') {\r\n      autoActivate = sourcePosition;\r\n      sourcePosition = LayoutUtil.getMid(source);\r\n    }\r\n\r\n    dragging.init(event, 'connect', {\r\n      autoActivate: autoActivate,\r\n      data: {\r\n        shape: source,\r\n        context: {\r\n          source: source,\r\n          sourcePosition: sourcePosition\r\n        }\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nConnect.$inject = [ 'eventBus', 'dragging', 'modeling', 'rules', 'canvas', 'graphicsFactory' ];\r\n\r\nmodule.exports = Connect;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(310),\r\n    require(304),\r\n    require(239)\r\n  ],\r\n  connect: [ 'type', require(227) ]\r\n};\r\n","'use strict';\r\n\r\nvar isFunction = require(508),\r\n    isArray = require(506),\r\n    forEach = require(386),\r\n\r\n    domDelegate = require(534),\r\n    domEvent = require(536),\r\n    domAttr = require(530),\r\n    domQuery = require(538),\r\n    domClasses = require(531),\r\n    domify = require(535);\r\n\r\n\r\nvar entrySelector = '.entry';\r\n\r\n\r\n/**\r\n * A context pad that displays element specific, contextual actions next\r\n * to a diagram element.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Overlays} overlays\r\n */\r\nfunction ContextPad(eventBus, overlays) {\r\n\r\n  this._providers = [];\r\n\r\n  this._eventBus = eventBus;\r\n  this._overlays = overlays;\r\n\r\n  this._current = null;\r\n\r\n  this._init();\r\n}\r\n\r\nContextPad.$inject = [ 'eventBus', 'overlays' ];\r\n\r\nmodule.exports = ContextPad;\r\n\r\n\r\n/**\r\n * Registers events needed for interaction with other components\r\n */\r\nContextPad.prototype._init = function() {\r\n\r\n  var eventBus = this._eventBus;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('selection.changed', function(e) {\r\n\r\n    var selection = e.newSelection;\r\n\r\n    if (selection.length === 1) {\r\n      self.open(selection[0]);\r\n    } else {\r\n      self.close();\r\n    }\r\n  });\r\n\r\n  eventBus.on('elements.delete', function(event) {\r\n    var elements = event.elements;\r\n\r\n    forEach(elements, function(e) {\r\n      if (self.isOpen(e)) {\r\n        self.close();\r\n      }\r\n    });\r\n  });\r\n\r\n  eventBus.on('element.changed', function(event) {\r\n    var element = event.element,\r\n        current = self._current;\r\n\r\n    // force reopen if element for which we are currently opened changed\r\n    if (current && current.element === element) {\r\n      self.open(element, true);\r\n    }\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Register a provider with the context pad\r\n *\r\n * @param  {ContextPadProvider} provider\r\n */\r\nContextPad.prototype.registerProvider = function(provider) {\r\n  this._providers.push(provider);\r\n};\r\n\r\n\r\n/**\r\n * Returns the context pad entries for a given element\r\n *\r\n * @param {djs.element.Base} element\r\n *\r\n * @return {Array<ContextPadEntryDescriptor>} list of entries\r\n */\r\nContextPad.prototype.getEntries = function(element) {\r\n  var entries = {};\r\n\r\n  // loop through all providers and their entries.\r\n  // group entries by id so that overriding an entry is possible\r\n  forEach(this._providers, function(provider) {\r\n    var e = provider.getContextPadEntries(element);\r\n\r\n    forEach(e, function(entry, id) {\r\n      entries[id] = entry;\r\n    });\r\n  });\r\n\r\n  return entries;\r\n};\r\n\r\n\r\n/**\r\n * Trigger an action available on the opened context pad\r\n *\r\n * @param  {String} action\r\n * @param  {Event} event\r\n * @param  {Boolean} [autoActivate=false]\r\n */\r\nContextPad.prototype.trigger = function(action, event, autoActivate) {\r\n\r\n  var element = this._current.element,\r\n      entries = this._current.entries,\r\n      entry,\r\n      handler,\r\n      originalEvent,\r\n      button = event.delegateTarget || event.target;\r\n\r\n  if (!button) {\r\n    return event.preventDefault();\r\n  }\r\n\r\n  entry = entries[domAttr(button, 'data-action')];\r\n  handler = entry.action;\r\n\r\n  originalEvent = event.originalEvent || event;\r\n\r\n  // simple action (via callback function)\r\n  if (isFunction(handler)) {\r\n    if (action === 'click') {\r\n      return handler(originalEvent, element, autoActivate);\r\n    }\r\n  } else {\r\n    if (handler[action]) {\r\n      return handler[action](originalEvent, element, autoActivate);\r\n    }\r\n  }\r\n\r\n  // silence other actions\r\n  event.preventDefault();\r\n};\r\n\r\n\r\n/**\r\n * Open the context pad for the given element\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {Boolean} force if true, force reopening the context pad\r\n */\r\nContextPad.prototype.open = function(element, force) {\r\n  if (!force && this.isOpen(element)) {\r\n    return;\r\n  }\r\n\r\n  this.close();\r\n  this._updateAndOpen(element);\r\n};\r\n\r\n\r\nContextPad.prototype._updateAndOpen = function(element) {\r\n\r\n  var entries = this.getEntries(element),\r\n      pad = this.getPad(element),\r\n      html = pad.html;\r\n\r\n  forEach(entries, function(entry, id) {\r\n    var grouping = entry.group || 'default',\r\n        control = domify(entry.html || '<div class=\"entry\" draggable=\"true\"></div>'),\r\n        container;\r\n\r\n    domAttr(control, 'data-action', id);\r\n\r\n    container = domQuery('[data-group=' + grouping + ']', html);\r\n    if (!container) {\r\n      container = domify('<div class=\"group\" data-group=\"' + grouping + '\"></div>');\r\n      html.appendChild(container);\r\n    }\r\n\r\n    container.appendChild(control);\r\n\r\n    if (entry.className) {\r\n      addClasses(control, entry.className);\r\n    }\r\n\r\n    if (entry.title) {\r\n      domAttr(control, 'title', entry.title);\r\n    }\r\n\r\n    if (entry.imageUrl) {\r\n      control.appendChild(domify('<img src=\"' + entry.imageUrl + '\">'));\r\n    }\r\n  });\r\n\r\n  domClasses(html).add('open');\r\n\r\n  this._current = {\r\n    element: element,\r\n    pad: pad,\r\n    entries: entries\r\n  };\r\n\r\n  this._eventBus.fire('contextPad.open', { current: this._current });\r\n};\r\n\r\n\r\nContextPad.prototype.getPad = function(element) {\r\n  if (this.isOpen()) {\r\n    return this._current.pad;\r\n  }\r\n\r\n  var self = this;\r\n\r\n  var overlays = this._overlays;\r\n\r\n  var html = domify('<div class=\"djs-context-pad\"></div>');\r\n\r\n  domDelegate.bind(html, entrySelector, 'click', function(event) {\r\n    self.trigger('click', event);\r\n  });\r\n\r\n  domDelegate.bind(html, entrySelector, 'dragstart', function(event) {\r\n    self.trigger('dragstart', event);\r\n  });\r\n\r\n  // stop propagation of mouse events\r\n  domEvent.bind(html, 'mousedown', function(event) {\r\n    event.stopPropagation();\r\n  });\r\n\r\n  this._overlayId = overlays.add(element, 'context-pad', {\r\n    position: {\r\n      right: -9,\r\n      top: -6\r\n    },\r\n    html: html\r\n  });\r\n\r\n  var pad = overlays.get(this._overlayId);\r\n\r\n  this._eventBus.fire('contextPad.create', { element: element, pad: pad });\r\n\r\n  return pad;\r\n};\r\n\r\n\r\n/**\r\n * Close the context pad\r\n */\r\nContextPad.prototype.close = function() {\r\n  if (!this.isOpen()) {\r\n    return;\r\n  }\r\n\r\n  this._overlays.remove(this._overlayId);\r\n\r\n  this._overlayId = null;\r\n\r\n  this._eventBus.fire('contextPad.close', { current: this._current });\r\n\r\n  this._current = null;\r\n};\r\n\r\n/**\r\n * Check if pad is open. If element is given, will check\r\n * if pad is opened with given element.\r\n *\r\n * @param {Element} element\r\n * @return {Boolean}\r\n */\r\nContextPad.prototype.isOpen = function(element) {\r\n  return !!this._current && (!element ? true : this._current.element === element);\r\n};\r\n\r\n\r\n\r\n\r\n////////// helpers /////////////////////////////\r\n\r\nfunction addClasses(element, classNames) {\r\n\r\n  var classes = domClasses(element);\r\n\r\n  var actualClassNames = isArray(classNames) ? classNames : classNames.split(//s+/g);\r\n  actualClassNames.forEach(function(cls) {\r\n    classes.add(cls);\r\n  });\r\n}","module.exports = {\r\n  __depends__: [\r\n    require(247),\r\n    require(288)\r\n  ],\r\n  contextPad: [ 'type', require(229) ]\r\n};","'use strict';\r\n\r\nvar isArray = require(506),\r\n    forEach = require(386),\r\n    map = require(389),\r\n    find = require(385),\r\n    findIndex = require(371),\r\n    sortBy = require(394),\r\n    reduce = require(390);\r\n\r\nvar getBBox = require(343).getBBox;\r\n\r\nvar PositionUtil = require(353);\r\n\r\nvar CopyPasteUtil = require(341),\r\n    ElementsUtil = require(343);\r\n\r\n\r\n\r\nfunction CopyPaste(eventBus, modeling, elementFactory, rules, clipboard, canvas) {\r\n  this._eventBus = eventBus;\r\n  this._modeling = modeling;\r\n  this._elementFactory = elementFactory;\r\n  this._rules = rules;\r\n  this._canvas = canvas;\r\n\r\n  this._clipboard = clipboard;\r\n\r\n  this._descriptors = [];\r\n\r\n\r\n  // Element creation priorities:\r\n  // - 1: Independent shapes\r\n  // - 2: Attached shapes\r\n  // - 3: Connections\r\n  // - 4: labels\r\n  this.registerDescriptor(function(element, descriptor) {\r\n    // Base priority\r\n    descriptor.priority = 1;\r\n\r\n    descriptor.id = element.id;\r\n\r\n    if (element.parent) {\r\n      descriptor.parent = element.parent.id;\r\n    }\r\n\r\n    if (element.labelTarget) {\r\n      // Labels priority\r\n      descriptor.priority = 4;\r\n      descriptor.labelTarget = element.labelTarget.id;\r\n    }\r\n\r\n    if (element.host) {\r\n      // Attached shapes priority\r\n      descriptor.priority = 2;\r\n      descriptor.host = element.host.id;\r\n    }\r\n\r\n    if (typeof element.x === 'number') {\r\n      descriptor.x = element.x;\r\n      descriptor.y = element.y;\r\n    }\r\n\r\n    if (element.width) {\r\n      descriptor.width = element.width;\r\n      descriptor.height = element.height;\r\n    }\r\n\r\n    if (element.waypoints) {\r\n      // Connections priority\r\n      descriptor.priority = 3;\r\n      descriptor.waypoints = [];\r\n\r\n      forEach(element.waypoints, function(waypoint) {\r\n        var wp = {\r\n          x: waypoint.x,\r\n          y: waypoint.y\r\n        };\r\n\r\n        if (waypoint.original) {\r\n          wp.original = {\r\n            x: waypoint.original.x,\r\n            y: waypoint.original.y\r\n          };\r\n        }\r\n\r\n        descriptor.waypoints.push(wp);\r\n      });\r\n    }\r\n\r\n    if (element.source && element.target) {\r\n      descriptor.source = element.source.id;\r\n      descriptor.target = element.target.id;\r\n    }\r\n\r\n    return descriptor;\r\n  });\r\n}\r\n\r\nCopyPaste.$inject = [\r\n  'eventBus',\r\n  'modeling',\r\n  'elementFactory',\r\n  'rules',\r\n  'clipboard',\r\n  'canvas'\r\n];\r\n\r\nmodule.exports = CopyPaste;\r\n\r\n/**\r\n * Copy a number of elements.\r\n *\r\n * @param {djs.model.Base} selectedElements\r\n *\r\n * @return {Object} the copied tree\r\n */\r\nCopyPaste.prototype.copy = function(selectedElements) {\r\n  var clipboard = this._clipboard,\r\n      tree, bbox;\r\n\r\n  if (!isArray(selectedElements)) {\r\n    selectedElements = selectedElements ? [ selectedElements ] : [];\r\n  }\r\n\r\n  if (!selectedElements.length) {\r\n    return;\r\n  }\r\n\r\n  tree = this.createTree(selectedElements);\r\n\r\n  bbox = this._bbox = PositionUtil.center(getBBox(tree.allShapes));\r\n\r\n  // not needed after computing the center position of the copied elements\r\n  delete tree.allShapes;\r\n\r\n  forEach(tree, function(elements) {\r\n\r\n    forEach(elements, function(element) {\r\n      var delta, labelTarget;\r\n\r\n      // set label's relative position to their label target\r\n      if (element.labelTarget) {\r\n        labelTarget = find(elements, { id: element.labelTarget });\r\n\r\n        // just grab the delta from the first waypoint\r\n        if (labelTarget.waypoints) {\r\n          delta = PositionUtil.delta(element, labelTarget.waypoints[0]);\r\n        } else {\r\n          delta = PositionUtil.delta(element, labelTarget);\r\n        }\r\n\r\n      } else\r\n      if (element.priority === 3) {\r\n        // connections have priority 3\r\n        delta = [];\r\n\r\n        forEach(element.waypoints, function(waypoint) {\r\n          var waypointDelta = PositionUtil.delta(waypoint, bbox);\r\n\r\n          delta.push(waypointDelta);\r\n        }, this);\r\n      } else {\r\n        delta = PositionUtil.delta(element, bbox);\r\n      }\r\n\r\n      element.delta = delta;\r\n    });\r\n  });\r\n\r\n  this._eventBus.fire('elements.copy', { context: { tree: tree } });\r\n\r\n  // if tree is empty, means that nothing can be or is allowed to be copied\r\n  if (Object.keys(tree).length === 0) {\r\n    clipboard.clear();\r\n  } else {\r\n    clipboard.set(tree);\r\n  }\r\n\r\n  this._eventBus.fire('elements.copied', { context: { tree: tree } });\r\n\r\n  return tree;\r\n};\r\n\r\n\r\n// Allow pasting under the cursor\r\nCopyPaste.prototype.paste = function(context) {\r\n  var clipboard = this._clipboard,\r\n      modeling = this._modeling,\r\n      eventBus = this._eventBus,\r\n      rules = this._rules;\r\n\r\n  var tree = clipboard.get(),\r\n      topParent = context.element,\r\n      position = context.point,\r\n      newTree, canPaste;\r\n\r\n  if (clipboard.isEmpty()) {\r\n    return;\r\n  }\r\n\r\n  newTree = reduce(tree, function(pasteTree, elements, depthStr) {\r\n    var depth = parseInt(depthStr, 10);\r\n\r\n    if (isNaN(depth)) {\r\n      return pasteTree;\r\n    }\r\n\r\n    pasteTree[depth] = elements;\r\n\r\n    return pasteTree;\r\n  }, {}, this);\r\n\r\n\r\n  canPaste = rules.allowed('elements.paste', {\r\n    tree: newTree,\r\n    target: topParent\r\n  });\r\n\r\n  if (!canPaste) {\r\n    eventBus.fire('elements.paste.rejected', {\r\n      context: {\r\n        tree: newTree,\r\n        position: position,\r\n        target: topParent\r\n      }\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  modeling.pasteElements(newTree, topParent, position);\r\n};\r\n\r\n\r\nCopyPaste.prototype._computeDelta = function(elements, element) {\r\n  var bbox = this._bbox,\r\n      delta = {};\r\n\r\n  // set label's relative position to their label target\r\n  if (element.labelTarget) {\r\n    return PositionUtil.delta(element, element.labelTarget);\r\n  }\r\n\r\n  // connections have prority 3\r\n  if (element.priority === 3) {\r\n    delta = [];\r\n\r\n    forEach(element.waypoints, function(waypoint) {\r\n      var waypointDelta = PositionUtil.delta(waypoint, bbox);\r\n\r\n      delta.push(waypointDelta);\r\n    }, this);\r\n  } else {\r\n    delta = PositionUtil.delta(element, bbox);\r\n  }\r\n\r\n  return delta;\r\n};\r\n\r\n\r\n/**\r\n * Checks if the element in question has a relations to other elements.\r\n * Possible dependants: connections, labels, attachers\r\n *\r\n * @param  {Array} elements\r\n * @param  {Object} element\r\n *\r\n * @return {Boolean}\r\n */\r\nCopyPaste.prototype.hasRelations = function(elements, element) {\r\n  var source, target, labelTarget;\r\n\r\n  if (element.waypoints) {\r\n    source = find(elements, { id: element.source.id });\r\n    target = find(elements, { id: element.target.id });\r\n\r\n    if (!source || !target) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (element.labelTarget) {\r\n    labelTarget = find(elements, { id: element.labelTarget.id });\r\n\r\n    if (!labelTarget) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\nCopyPaste.prototype.registerDescriptor = function(descriptor) {\r\n  if (typeof descriptor !== 'function') {\r\n    throw new Error('the descriptor must be a function');\r\n  }\r\n\r\n  if (this._descriptors.indexOf(descriptor) !== -1) {\r\n    throw new Error('this descriptor is already registered');\r\n  }\r\n\r\n  this._descriptors.push(descriptor);\r\n};\r\n\r\n\r\nCopyPaste.prototype._executeDescriptors = function(data) {\r\n  if (!data.descriptor) {\r\n    data.descriptor = {};\r\n  }\r\n\r\n  forEach(this._descriptors, function(descriptor) {\r\n    data.descriptor = descriptor(data.element, data.descriptor);\r\n  });\r\n\r\n  return data;\r\n};\r\n\r\n/**\r\n * Creates a tree like structure from an arbitrary collection of elements\r\n *\r\n * @example\r\n * tree: {\r\n *\t0: [\r\n *\t\t{ id: 'shape_12da', priority: 1, ... },\r\n *\t\t{ id: 'shape_01bj', priority: 1, ... },\r\n *\t\t{ id: 'connection_79fa', source: 'shape_12da', target: 'shape_01bj', priority: 3, ... },\r\n *\t],\r\n *\t1: [ ... ]\r\n * };\r\n *\r\n * @param  {Array} elements\r\n * @return {Object}\r\n */\r\nCopyPaste.prototype.createTree = function(elements) {\r\n  var rules = this._rules;\r\n\r\n  var tree = {},\r\n      includedElements = [],\r\n      _elements;\r\n\r\n  var topLevel = CopyPasteUtil.getTopLevel(elements);\r\n\r\n  tree.allShapes = [];\r\n\r\n  function canCopy(collection, element) {\r\n    return rules.allowed('element.copy', {\r\n      collection: collection,\r\n      element: element\r\n    });\r\n  }\r\n\r\n  function includeElement(data) {\r\n    var idx = findIndex(includedElements, { element: data.element }),\r\n        element;\r\n\r\n    if (idx !== -1) {\r\n      element = includedElements[idx];\r\n    } else {\r\n      return includedElements.push(data);\r\n    }\r\n\r\n    // makes sure that it has the correct depth\r\n    if (element.depth < data.depth) {\r\n      includedElements.splice(idx, 1);\r\n\r\n      includedElements.push(data);\r\n    }\r\n  }\r\n\r\n\r\n  ElementsUtil.eachElement(topLevel, function(element, i, depth) {\r\n    var nestedChildren = element.children;\r\n\r\n    // don't add labels directly\r\n    if (element.labelTarget) {\r\n      return;\r\n    }\r\n\r\n    function getNested(lists) {\r\n      forEach(lists, function(list) {\r\n        if (list && list.length) {\r\n\r\n          forEach(list, function(elem) {\r\n            // fetch element's label\r\n            if (elem.label) {\r\n              includeElement({\r\n                element: elem.label,\r\n                depth: depth\r\n              });\r\n            }\r\n\r\n            includeElement({\r\n              element: elem,\r\n              depth: depth\r\n            });\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // fetch element's label\r\n    if (element.label) {\r\n      includeElement({\r\n        element: element.label,\r\n        depth: depth\r\n      });\r\n    }\r\n\r\n    getNested([ element.attachers, element.incoming, element.outgoing ]);\r\n\r\n    includeElement({\r\n      element: element,\r\n      depth: depth\r\n    });\r\n\r\n    if (nestedChildren) {\r\n      return nestedChildren;\r\n    }\r\n  });\r\n\r\n  includedElements = map(includedElements, function(data) {\r\n    // this is where other registered descriptors hook in\r\n    return this._executeDescriptors(data);\r\n  }, this);\r\n\r\n  // order the elements to check if the ones dependant on others (by relationship)\r\n  // can be copied. f.ex: label needs it's label target\r\n  includedElements = sortBy(includedElements, function(data) {\r\n    return data.descriptor.priority;\r\n  });\r\n\r\n  _elements = map(includedElements, function(data) {\r\n    return data.element;\r\n  });\r\n\r\n  forEach(includedElements, function(data) {\r\n    var depth = data.depth;\r\n\r\n    if (!this.hasRelations(tree.allShapes, data.element)) {\r\n      return;\r\n    }\r\n\r\n    if (!canCopy(_elements, data.element)) {\r\n      return;\r\n    }\r\n\r\n    tree.allShapes.push(data.element);\r\n\r\n    // create depth branches\r\n    if (!tree[depth]) {\r\n      tree[depth] = [];\r\n    }\r\n\r\n    tree[depth].push(data.descriptor);\r\n  }, this);\r\n\r\n  return tree;\r\n};\r\n","module.exports = {\r\n  __depends__: [\r\n    require(226),\r\n    require(304),\r\n    require(280)\r\n  ],\r\n  __init__: [ 'copyPaste' ],\r\n  copyPaste: [ 'type', require(231) ]\r\n};\r\n","'use strict';\r\n\r\nvar LOW_PRIORITY = 750;\r\n\r\nvar MARKER_OK = 'drop-ok',\r\n    MARKER_NOT_OK = 'drop-not-ok',\r\n    MARKER_ATTACH = 'attach-ok',\r\n    MARKER_NEW_PARENT = 'new-parent';\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\nvar translate = require(356).translate;\r\n\r\n\r\nfunction Create(eventBus, dragging, rules, modeling, canvas, styles, graphicsFactory) {\r\n\r\n  // rules\r\n\r\n  function canCreate(shape, target, source, position) {\r\n\r\n    if (source) {\r\n      return rules.allowed('shape.append', {\r\n        source: source,\r\n        shape: shape,\r\n        target: target,\r\n        position: position\r\n      });\r\n    } else {\r\n      return rules.allowed('shape.create', {\r\n        shape: shape,\r\n        target: target,\r\n        position: position\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /** set drop marker on an element */\r\n  function setMarker(element, marker) {\r\n\r\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\r\n\r\n      if (m === marker) {\r\n        canvas.addMarker(element, m);\r\n      } else {\r\n        canvas.removeMarker(element, m);\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n  // visual helpers\r\n\r\n  function createVisual(shape) {\r\n    var group, preview, visual;\r\n\r\n    group = svgCreate('g');\r\n    svgAttr(group, styles.cls('djs-drag-group', [ 'no-events' ]));\r\n\r\n    svgAppend(canvas.getDefaultLayer(), group);\r\n\r\n    preview = svgCreate('g');\r\n    svgClasses(preview).add('djs-dragger');\r\n\r\n    svgAppend(group, preview);\r\n\r\n    translate(preview, shape.width / -2, shape.height / -2);\r\n\r\n    var visualGroup = svgCreate('g');\r\n    svgClasses(visualGroup).add('djs-visual');\r\n\r\n    svgAppend(preview, visualGroup);\r\n\r\n    visual = visualGroup;\r\n\r\n    // hijack renderer to draw preview\r\n    graphicsFactory.drawShape(visual, shape);\r\n\r\n    return group;\r\n  }\r\n\r\n\r\n  // event handlers\r\n\r\n  eventBus.on('create.move', function(event) {\r\n\r\n    var context = event.context,\r\n        hover = event.hover,\r\n        canExecute;\r\n\r\n    var position = {\r\n      x: event.x,\r\n      y: event.y\r\n    };\r\n\r\n    canExecute = context.canExecute = hover && canCreate(context.shape, hover, context.source, position);\r\n\r\n    // ignore hover visually if canExecute is null\r\n    if (hover && canExecute !== null) {\r\n      context.target = hover;\r\n\r\n      if (canExecute === 'attach') {\r\n        setMarker(hover, MARKER_ATTACH);\r\n      } else {\r\n        setMarker(hover, context.canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\r\n      }\r\n    }\r\n  });\r\n\r\n  eventBus.on('create.move', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        visual = context.visual;\r\n\r\n    // lazy init drag visual once we received the first real\r\n    // drag move event (this allows us to get the proper canvas local coordinates)\r\n    if (!visual) {\r\n      visual = context.visual = createVisual(shape);\r\n    }\r\n\r\n    translate(visual, event.x, event.y);\r\n  });\r\n\r\n\r\n  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {\r\n    var context = event.context,\r\n        target = context.target;\r\n\r\n    if (target) {\r\n      setMarker(target, null);\r\n    }\r\n  });\r\n\r\n  eventBus.on('create.end', function(event) {\r\n    var context = event.context,\r\n        source = context.source,\r\n        shape = context.shape,\r\n        target = context.target,\r\n        canExecute = context.canExecute,\r\n        isAttach,\r\n        position = {\r\n          x: event.x,\r\n          y: event.y\r\n        };\r\n\r\n    if (!canExecute) {\r\n      return false;\r\n    }\r\n\r\n    if (source) {\r\n      shape = modeling.appendShape(source, shape, position, target);\r\n    } else {\r\n      isAttach = canExecute === 'attach';\r\n\r\n      shape = modeling.createShape(shape, position, target, isAttach);\r\n    }\r\n\r\n    // make sure we provide the actual attached\r\n    // shape with the context so that selection and\r\n    // other components can use it right after the create\r\n    // operation ends\r\n    context.shape = shape;\r\n  });\r\n\r\n\r\n  eventBus.on('create.cleanup', function(event) {\r\n    var context = event.context;\r\n\r\n    if (context.visual) {\r\n      svgRemove(context.visual);\r\n    }\r\n  });\r\n\r\n  // API\r\n\r\n  this.start = function(event, shape, source) {\r\n\r\n    dragging.init(event, 'create', {\r\n      cursor: 'grabbing',\r\n      autoActivate: true,\r\n      data: {\r\n        shape: shape,\r\n        context: {\r\n          shape: shape,\r\n          source: source\r\n        }\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nCreate.$inject = [ 'eventBus', 'dragging', 'rules', 'modeling', 'canvas', 'styles', 'graphicsFactory' ];\r\n\r\nmodule.exports = Create;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(239),\r\n    require(310),\r\n    require(304)\r\n  ],\r\n  create: [ 'type', require(233) ]\r\n};\r\n","'use strict';\r\n\r\nvar sortBy = require(394),\r\n    forEach = require(386),\r\n    filter = require(384);\r\n\r\nvar AXIS_DIMENSIONS = {\r\n  horizontal: [ 'x', 'width' ],\r\n  vertical: [ 'y', 'height' ]\r\n};\r\n\r\nvar THRESHOLD = 5;\r\n\r\n/**\r\n * Groups and filters elements and then trigger even distribution.\r\n */\r\nfunction DistributeElements(modeling) {\r\n  this._modeling = modeling;\r\n\r\n  this._filters = [];\r\n\r\n  // register filter for filtering big elements\r\n  this.registerFilter(function(elements, axis, dimension) {\r\n    var elementsSize = 0,\r\n        numOfShapes = 0,\r\n        avgDimension;\r\n\r\n    forEach(elements, function(element) {\r\n      if (element.waypoints || element.labelTarget) {\r\n        return;\r\n      }\r\n\r\n      elementsSize += element[dimension];\r\n\r\n      numOfShapes += 1;\r\n    });\r\n\r\n    avgDimension = Math.round(elementsSize / numOfShapes);\r\n\r\n    return filter(elements, function(element) {\r\n      return element[dimension] < (avgDimension + 50);\r\n    });\r\n  });\r\n\r\n}\r\n\r\nmodule.exports = DistributeElements;\r\n\r\nDistributeElements.$inject = [ 'modeling' ];\r\n\r\n\r\n/**\r\n * Registers filter functions that allow external parties to filter\r\n * out certain elements.\r\n *\r\n * @param  {Function} filterFn\r\n */\r\nDistributeElements.prototype.registerFilter = function(filterFn) {\r\n  if (typeof filterFn !== 'function') {\r\n    throw new Error('the filter has to be a function');\r\n  }\r\n\r\n  this._filters.push(filterFn);\r\n};\r\n\r\n/**\r\n * Distributes the elements with a given orientation\r\n *\r\n * @param  {Array} elements    [description]\r\n * @param  {String} orientation [description]\r\n */\r\nDistributeElements.prototype.trigger = function(elements, orientation) {\r\n  var modeling = this._modeling;\r\n\r\n  var groups,\r\n      distributableElements;\r\n\r\n  if (elements.length < 3) {\r\n    return;\r\n  }\r\n\r\n  this._setOrientation(orientation);\r\n\r\n  distributableElements = this._filterElements(elements);\r\n\r\n  groups = this._createGroups(distributableElements);\r\n\r\n  // nothing to distribute\r\n  if (groups.length <= 2) {\r\n    return;\r\n  }\r\n\r\n  modeling.distributeElements(groups, this._axis, this._dimension);\r\n\r\n  return groups;\r\n};\r\n\r\n/**\r\n * Filters the elements with provided filters by external parties\r\n *\r\n * @param  {Array[Elements]} elements\r\n *\r\n * @return {Array[Elements]}\r\n */\r\nDistributeElements.prototype._filterElements = function(elements) {\r\n  var filters = this._filters,\r\n      axis = this._axis,\r\n      dimension = this._dimension,\r\n      distributableElements = [].concat(elements);\r\n\r\n  if (!filters.length) {\r\n    return elements;\r\n  }\r\n\r\n  forEach(filters, function(filterFn) {\r\n    distributableElements = filterFn(distributableElements, axis, dimension);\r\n  });\r\n\r\n  return distributableElements;\r\n};\r\n\r\n\r\n/**\r\n * Create range (min, max) groups. Also tries to group elements\r\n * together that share the same range.\r\n *\r\n * @example\r\n * \tvar distributableElements = [\r\n * \t\t{\r\n * \t\t\trange: {\r\n * \t\t\t\tmin: 100,\r\n * \t\t\t\tmax: 200\r\n * \t\t\t},\r\n * \t\t\telements: [ { id: 'shape1', .. }]\r\n * \t\t}\r\n * \t]\r\n *\r\n * @param  {Array} elements\r\n *\r\n * @return {Array[Objects]}\r\n */\r\nDistributeElements.prototype._createGroups = function(elements) {\r\n  var rangeGroups = [],\r\n      axis = this._axis,\r\n      dimension = this._dimension;\r\n\r\n  if (!axis) {\r\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\r\n  }\r\n\r\n  // sort by 'left->right' or 'top->bottom'\r\n  var sortedElements = sortBy(elements, axis);\r\n\r\n  forEach(sortedElements, function(element, idx) {\r\n    var elementRange = this._findRange(element, axis, dimension),\r\n        range;\r\n\r\n    var previous = rangeGroups[rangeGroups.length - 1];\r\n\r\n    if (previous && this._hasIntersection(previous.range, elementRange)) {\r\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\r\n    } else {\r\n      range = { range: elementRange, elements: [ element ] };\r\n\r\n      rangeGroups.push(range);\r\n    }\r\n  }, this);\r\n\r\n  return rangeGroups;\r\n};\r\n\r\n\r\n/**\r\n * Maps a direction to the according axis and dimension\r\n *\r\n * @param  {String} direction 'horizontal' or 'vertical'\r\n */\r\nDistributeElements.prototype._setOrientation = function(direction) {\r\n  var orientation = AXIS_DIMENSIONS[direction];\r\n\r\n  this._axis = orientation[0];\r\n  this._dimension = orientation[1];\r\n};\r\n\r\n\r\n/**\r\n * Checks if the two ranges intercept each other\r\n *\r\n * @param  {Object} rangeA {min, max}\r\n * @param  {Object} rangeB {min, max}\r\n *\r\n * @return {Boolean}\r\n */\r\nDistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {\r\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) &&\r\n         Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\r\n};\r\n\r\n\r\n/**\r\n * Returns the min and max values for an element\r\n *\r\n * @param  {[type]} element   [description]\r\n * @param  {[type]} axis      [description]\r\n * @param  {[type]} dimension [description]\r\n *\r\n * @return {[type]}           [description]\r\n */\r\nDistributeElements.prototype._findRange = function(element) {\r\n  var axis = element[this._axis],\r\n      dimension = element[this._dimension];\r\n\r\n  return {\r\n    min: axis + THRESHOLD,\r\n    max: axis + dimension - THRESHOLD\r\n  };\r\n};\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'distributeElements' ],\r\n  distributeElements: [ 'type', require(235) ]\r\n};\r\n","'use strict';\r\n\r\n/* global TouchEvent */\r\n\r\nvar round = Math.round;\r\n\r\nvar assign = require(516);\r\n\r\nvar domEvent = require(536),\r\n    Event = require(344),\r\n    ClickTrap = require(339),\r\n    Cursor = require(342);\r\n\r\nvar EventBusEvent = require(202).Event;\r\n\r\nvar DRAG_ACTIVE_CLS = 'djs-drag-active';\r\n\r\n\r\nfunction suppressEvent(event) {\r\n  if (event instanceof MouseEvent) {\r\n    Event.stopEvent(event, true);\r\n  } else {\r\n    Event.preventDefault(event);\r\n  }\r\n}\r\n\r\nfunction getLength(point) {\r\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\r\n}\r\n\r\nfunction substract(p1, p2) {\r\n  return {\r\n    x: p1.x - p2.x,\r\n    y: p1.y - p2.y\r\n  };\r\n}\r\n\r\n/**\r\n * A helper that fires canvas localized drag events and realizes\r\n * the general \"drag-and-drop\" look and feel.\r\n *\r\n * Calling {@link Dragging#activate} activates dragging on a canvas.\r\n *\r\n * It provides the following:\r\n *\r\n *   * emits life cycle events, namespaced with a prefix assigned\r\n *     during dragging activation\r\n *   * sets and restores the cursor\r\n *   * sets and restores the selection\r\n *   * ensures there can be only one drag operation active at a time\r\n *\r\n * Dragging may be canceled manually by calling {@link Dragging#cancel}\r\n * or by pressing ESC.\r\n *\r\n *\r\n * ## Life-cycle events\r\n *\r\n * Dragging can be in three different states, off, initialized\r\n * and active.\r\n *\r\n * (1) off: no dragging operation is in progress\r\n * (2) initialized: a new drag operation got initialized but not yet\r\n *                  started (i.e. because of no initial move)\r\n * (3) started: dragging is in progress\r\n *\r\n * Eventually dragging will be off again after a drag operation has\r\n * been ended or canceled via user click or ESC key press.\r\n *\r\n * To indicate transitions between these states dragging emits generic\r\n * life-cycle events with the `drag.` prefix _and_ events namespaced\r\n * to a prefix choosen by a user during drag initialization.\r\n *\r\n * The following events are emitted (appropriately prefixed) via\r\n * the {@link EventBus}.\r\n *\r\n * * `init`\r\n * * `start`\r\n * * `move`\r\n * * `end`\r\n * * `ended` (dragging already in off state)\r\n * * `cancel` (only if previously started)\r\n * * `canceled` (dragging already in off state, only if previously started)\r\n * * `cleanup`\r\n *\r\n *\r\n * @example\r\n *\r\n * function MyDragComponent(eventBus, dragging) {\r\n *\r\n *   eventBus.on('mydrag.start', function(event) {\r\n *     console.log('yes, we start dragging');\r\n *   });\r\n *\r\n *   eventBus.on('mydrag.move', function(event) {\r\n *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);\r\n *\r\n *     // local drag data is passed with the event\r\n *     event.context.foo; // \"BAR\"\r\n *\r\n *     // the original mouse event, too\r\n *     event.originalEvent; // MouseEvent(...)\r\n *   });\r\n *\r\n *   eventBus.on('element.click', function(event) {\r\n *     dragging.init(event, 'mydrag', {\r\n *       cursor: 'grabbing',\r\n *       data: {\r\n *         context: {\r\n *           foo: \"BAR\"\r\n *         }\r\n *       }\r\n *     });\r\n *   });\r\n * }\r\n */\r\nfunction Dragging(eventBus, canvas, selection) {\r\n\r\n  var defaultOptions = {\r\n    threshold: 5,\r\n    trapClick: true\r\n  };\r\n\r\n  // the currently active drag operation\r\n  // dragging is active as soon as this context exists.\r\n  //\r\n  // it is visually _active_ only when a context.active flag is set to true.\r\n  var context;\r\n\r\n  /* convert a global event into local coordinates */\r\n  function toLocalPoint(globalPosition) {\r\n\r\n    var viewbox = canvas.viewbox();\r\n\r\n    var clientRect = canvas._container.getBoundingClientRect();\r\n\r\n    return {\r\n      x: viewbox.x + round((globalPosition.x - clientRect.left) / viewbox.scale),\r\n      y: viewbox.y + round((globalPosition.y - clientRect.top) / viewbox.scale)\r\n    };\r\n  }\r\n\r\n  // helpers\r\n\r\n  function fire(type, dragContext) {\r\n    dragContext = dragContext || context;\r\n\r\n    var event = assign(new EventBusEvent(), dragContext.payload, dragContext.data);\r\n\r\n    // default integration\r\n    if (eventBus.fire('drag.' + type, event) === false) {\r\n      return false;\r\n    }\r\n\r\n    return eventBus.fire(dragContext.prefix + '.' + type, event);\r\n  }\r\n\r\n  // event listeners\r\n\r\n  function move(event, activate) {\r\n    var payload = context.payload,\r\n        displacement = context.displacement;\r\n\r\n    var globalStart = context.globalStart,\r\n        globalCurrent = Event.toPoint(event),\r\n        globalDelta = substract(globalCurrent, globalStart);\r\n\r\n    var localStart = context.localStart,\r\n        localCurrent = toLocalPoint(globalCurrent),\r\n        localDelta = substract(localCurrent, localStart);\r\n\r\n    // activate context explicitly or once threshold is reached\r\n    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {\r\n\r\n      // fire start event with original\r\n      // starting coordinates\r\n\r\n      assign(payload, {\r\n        x: localStart.x + displacement.x,\r\n        y: localStart.y + displacement.y,\r\n        dx: 0,\r\n        dy: 0\r\n      }, { originalEvent: event });\r\n\r\n      if (false === fire('start')) {\r\n        return cancel();\r\n      }\r\n\r\n      context.active = true;\r\n\r\n      // unset selection and remember old selection\r\n      // the previous (old) selection will always passed\r\n      // with the event via the event.previousSelection property\r\n      if (!context.keepSelection) {\r\n        payload.previousSelection = selection.get();\r\n        selection.select(null);\r\n      }\r\n\r\n      // allow custom cursor\r\n      if (context.cursor) {\r\n        Cursor.set(context.cursor);\r\n      }\r\n\r\n      // indicate dragging via marker on root element\r\n      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\r\n    }\r\n\r\n    suppressEvent(event);\r\n\r\n    if (context.active) {\r\n\r\n      // update payload with actual coordinates\r\n      assign(payload, {\r\n        x: localCurrent.x + displacement.x,\r\n        y: localCurrent.y + displacement.y,\r\n        dx: localDelta.x,\r\n        dy: localDelta.y\r\n      }, { originalEvent: event });\r\n\r\n      // emit move event\r\n      fire('move');\r\n    }\r\n  }\r\n\r\n  function end(event) {\r\n    var previousContext,\r\n        returnValue = true;\r\n\r\n    if (context.active) {\r\n\r\n      if (event) {\r\n        context.payload.originalEvent = event;\r\n\r\n        // suppress original event (click, ...)\r\n        // because we just ended a drag operation\r\n        suppressEvent(event);\r\n      }\r\n\r\n      // implementations may stop restoring the\r\n      // original state (selections, ...) by preventing the\r\n      // end events default action\r\n      returnValue = fire('end');\r\n    }\r\n\r\n    if (returnValue === false) {\r\n      fire('rejected');\r\n    }\r\n\r\n    previousContext = cleanup(returnValue !== true);\r\n\r\n    // last event to be fired when all drag operations are done\r\n    // at this point in time no drag operation is in progress anymore\r\n    fire('ended', previousContext);\r\n  }\r\n\r\n\r\n  // cancel active drag operation if the user presses\r\n  // the ESC key on the keyboard\r\n\r\n  function checkCancel(event) {\r\n\r\n    if (event.which === 27) {\r\n      event.preventDefault();\r\n\r\n      cancel();\r\n    }\r\n  }\r\n\r\n\r\n  // prevent ghost click that might occur after a finished\r\n  // drag and drop session\r\n\r\n  function trapClickAndEnd(event) {\r\n\r\n    var untrap;\r\n\r\n    // trap the click in case we are part of an active\r\n    // drag operation. This will effectively prevent\r\n    // the ghost click that cannot be canceled otherwise.\r\n    if (context.active) {\r\n      untrap = ClickTrap.install();\r\n      setTimeout(untrap, 400);\r\n    }\r\n\r\n    end(event);\r\n  }\r\n\r\n  function trapTouch(event) {\r\n    move(event);\r\n  }\r\n\r\n  // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)\r\n  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties\r\n  // respectively\r\n\r\n  function hover(event) {\r\n    var payload = context.payload;\r\n\r\n    payload.hoverGfx = event.gfx;\r\n    payload.hover = event.element;\r\n\r\n    fire('hover');\r\n  }\r\n\r\n  function out(event) {\r\n    fire('out');\r\n\r\n    var payload = context.payload;\r\n\r\n    payload.hoverGfx = null;\r\n    payload.hover = null;\r\n  }\r\n\r\n\r\n  // life-cycle methods\r\n\r\n  function cancel(restore) {\r\n    var previousContext;\r\n\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    var wasActive = context.active;\r\n\r\n    if (wasActive) {\r\n      fire('cancel');\r\n    }\r\n\r\n    previousContext = cleanup(restore);\r\n\r\n    if (wasActive) {\r\n      // last event to be fired when all drag operations are done\r\n      // at this point in time no drag operation is in progress anymore\r\n      fire('canceled', previousContext);\r\n    }\r\n  }\r\n\r\n  function cleanup(restore) {\r\n    var previousContext,\r\n        endDrag;\r\n\r\n    fire('cleanup');\r\n\r\n    // reset cursor\r\n    Cursor.unset();\r\n\r\n    if (context.trapClick) {\r\n      endDrag = trapClickAndEnd;\r\n    } else {\r\n      endDrag = end;\r\n    }\r\n\r\n    // reset dom listeners\r\n    domEvent.unbind(document, 'mousemove', move);\r\n\r\n    domEvent.unbind(document, 'mousedown', endDrag, true);\r\n    domEvent.unbind(document, 'mouseup', endDrag, true);\r\n\r\n    domEvent.unbind(document, 'keyup', checkCancel);\r\n\r\n    domEvent.unbind(document, 'touchstart', trapTouch, true);\r\n    domEvent.unbind(document, 'touchcancel', cancel, true);\r\n    domEvent.unbind(document, 'touchmove', move, true);\r\n    domEvent.unbind(document, 'touchend', end, true);\r\n\r\n    eventBus.off('element.hover', hover);\r\n    eventBus.off('element.out', out);\r\n\r\n    // remove drag marker on root element\r\n    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\r\n\r\n    // restore selection, unless it has changed\r\n    var previousSelection = context.payload.previousSelection;\r\n\r\n    if (restore !== false && previousSelection && !selection.get().length) {\r\n      selection.select(previousSelection);\r\n    }\r\n\r\n    previousContext = context;\r\n\r\n    context = null;\r\n\r\n    return previousContext;\r\n  }\r\n\r\n  /**\r\n   * Initialize a drag operation.\r\n   *\r\n   * If `localPosition` is given, drag events will be emitted\r\n   * relative to it.\r\n   *\r\n   * @param {MouseEvent|TouchEvent} [event]\r\n   * @param {Point} [localPosition] actual diagram local position this drag operation should start at\r\n   * @param {String} prefix\r\n   * @param {Object} [options]\r\n   */\r\n  function init(event, relativeTo, prefix, options) {\r\n\r\n    // only one drag operation may be active, at a time\r\n    if (context) {\r\n      cancel(false);\r\n    }\r\n\r\n    if (typeof relativeTo === 'string') {\r\n      options = prefix;\r\n      prefix = relativeTo;\r\n      relativeTo = null;\r\n    }\r\n\r\n    options = assign({}, defaultOptions, options || {});\r\n\r\n    var data = options.data || {},\r\n        originalEvent,\r\n        globalStart,\r\n        endDrag;\r\n\r\n    if (options.trapClick) {\r\n      endDrag = trapClickAndEnd;\r\n    } else {\r\n      endDrag = end;\r\n    }\r\n\r\n    if (event) {\r\n      originalEvent = Event.getOriginal(event) || event;\r\n      globalStart = Event.toPoint(event);\r\n\r\n      suppressEvent(event);\r\n    } else {\r\n      originalEvent = null;\r\n      globalStart = { x: 0, y: 0 };\r\n    }\r\n\r\n    var localStart = toLocalPoint(globalStart);\r\n\r\n    if (!relativeTo) {\r\n      relativeTo = localStart;\r\n    }\r\n\r\n    context = assign({\r\n      prefix: prefix,\r\n      data: data,\r\n      payload: {},\r\n      globalStart: globalStart,\r\n      displacement: substract(relativeTo, localStart),\r\n      localStart: localStart\r\n    }, options);\r\n\r\n    // skip dom registration if trigger\r\n    // is set to manual (during testing)\r\n    if (!options.manual) {\r\n\r\n      // add dom listeners\r\n\r\n      // fixes TouchEvent not being available on desktop Firefox\r\n      if (typeof TouchEvent !== 'undefined' && originalEvent instanceof TouchEvent) {\r\n        domEvent.bind(document, 'touchstart', trapTouch, true);\r\n        domEvent.bind(document, 'touchcancel', cancel, true);\r\n        domEvent.bind(document, 'touchmove', move, true);\r\n        domEvent.bind(document, 'touchend', end, true);\r\n      } else {\r\n        // assume we use the mouse to interact per default\r\n        domEvent.bind(document, 'mousemove', move);\r\n\r\n        domEvent.bind(document, 'mousedown', endDrag, true);\r\n        domEvent.bind(document, 'mouseup', endDrag, true);\r\n      }\r\n\r\n      domEvent.bind(document, 'keyup', checkCancel);\r\n\r\n      eventBus.on('element.hover', hover);\r\n      eventBus.on('element.out', out);\r\n    }\r\n\r\n    fire('init');\r\n\r\n    if (options.autoActivate) {\r\n      move(event, true);\r\n    }\r\n  }\r\n\r\n  // cancel on diagram destruction\r\n  eventBus.on('diagram.destroy', cancel);\r\n\r\n\r\n  // API\r\n\r\n  this.init = init;\r\n  this.move = move;\r\n  this.hover = hover;\r\n  this.out = out;\r\n  this.end = end;\r\n\r\n  this.cancel = cancel;\r\n\r\n  // for introspection\r\n\r\n  this.context = function() {\r\n    return context;\r\n  };\r\n\r\n  this.setOptions = function(options) {\r\n    assign(defaultOptions, options);\r\n  };\r\n}\r\n\r\nDragging.$inject = [ 'eventBus', 'canvas', 'selection' ];\r\n\r\nmodule.exports = Dragging;\r\n","'use strict';\r\n\r\nvar domClosest = require(533);\r\n\r\nvar Event = require(344);\r\n\r\nfunction getGfx(target) {\r\n  var node = domClosest(target, 'svg, .djs-element', true);\r\n  return node;\r\n}\r\n\r\n\r\n/**\r\n * Browsers may swallow the hover event if users are to\r\n * fast with the mouse.\r\n *\r\n * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event\r\n *\r\n * The fix implemented in this component ensure that we\r\n * have a hover state after a successive drag.move event.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Dragging} dragging\r\n * @param {ElementRegistry} elementRegistry\r\n */\r\nfunction HoverFix(eventBus, dragging, elementRegistry) {\r\n\r\n  var self = this;\r\n\r\n  // we wait for a specific sequence of events before\r\n  // emitting a fake drag.hover event.\r\n  //\r\n  // Event Sequence:\r\n  //\r\n  // drag.start\r\n  // drag.move\r\n  // drag.move >> ensure we are hovering\r\n  //\r\n  eventBus.on('drag.start', function(event) {\r\n\r\n    eventBus.once('drag.move', function() {\r\n\r\n      eventBus.once('drag.move', function(event) {\r\n\r\n        self.ensureHover(event);\r\n      });\r\n    });\r\n  });\r\n\r\n  /**\r\n   * Make sure we are god damn hovering!\r\n   *\r\n   * @param {Event} dragging event\r\n   */\r\n  this.ensureHover = function(event) {\r\n\r\n    if (event.hover) {\r\n      return;\r\n    }\r\n\r\n    var originalEvent = event.originalEvent,\r\n        position,\r\n        target,\r\n        element,\r\n        gfx;\r\n\r\n    if (!(originalEvent instanceof MouseEvent)) {\r\n      return;\r\n    }\r\n\r\n    position = Event.toPoint(originalEvent);\r\n\r\n    // damn expensive operation, ouch!\r\n    target = document.elementFromPoint(position.x, position.y);\r\n\r\n    gfx = getGfx(target);\r\n\r\n    if (gfx) {\r\n      element = elementRegistry.get(gfx);\r\n\r\n      dragging.hover({ element: element, gfx: gfx });\r\n    }\r\n  };\r\n\r\n}\r\n\r\nHoverFix.$inject = [ 'eventBus', 'dragging', 'elementRegistry' ];\r\n\r\nmodule.exports = HoverFix;\r\n","module.exports = {\r\n  __init__: [\r\n    'hoverFix'\r\n  ],\r\n  __depends__: [\r\n    require(310)\r\n  ],\r\n  dragging: [ 'type', require(237) ],\r\n  hoverFix: [ 'type', require(238) ]\r\n};","'use strict';\r\n\r\nvar forEach = require(386),\r\n    isArray = require(506);\r\n\r\nvar NOT_REGISTERED_ERROR = 'is not a registered action',\r\n    IS_REGISTERED_ERROR = 'is already registered';\r\n\r\n\r\n/**\r\n * An interface that provides access to modeling actions by decoupling\r\n * the one who requests the action to be triggered and the trigger itself.\r\n *\r\n * It's possible to add new actions by registering them with ´registerAction´ and likewise\r\n * unregister existing ones with ´unregisterAction´.\r\n *\r\n */\r\nfunction EditorActions(eventBus, commandStack, modeling, selection,\r\n  zoomScroll, copyPaste, canvas, rules, mouseTracking) {\r\n\r\n  this._actions = {\r\n    undo: function() {\r\n      commandStack.undo();\r\n    },\r\n    redo: function() {\r\n      commandStack.redo();\r\n    },\r\n    copy: function() {\r\n      var selectedElements = selection.get();\r\n\r\n      copyPaste.copy(selectedElements);\r\n    },\r\n    paste: function() {\r\n      var context = mouseTracking.getHoverContext();\r\n\r\n      copyPaste.paste(context);\r\n    },\r\n    stepZoom: function(opts) {\r\n      zoomScroll.stepZoom(opts.value);\r\n    },\r\n    zoom: function(opts) {\r\n      canvas.zoom(opts.value);\r\n    },\r\n    removeSelection: function() {\r\n      var selectedElements = selection.get();\r\n\r\n      if (selectedElements.length) {\r\n        var allowed = rules.allowed('elements.delete', { elements: selectedElements }),\r\n            removableElements;\r\n\r\n        if (allowed === false) {\r\n          return;\r\n        }\r\n        else if (isArray(allowed)) {\r\n          removableElements = allowed;\r\n        }\r\n        else {\r\n          removableElements = selectedElements;\r\n        }\r\n\r\n        if (removableElements.length) {\r\n          modeling.removeElements(removableElements.slice());\r\n        }\r\n      }\r\n    },\r\n    moveCanvas: function(opts) {\r\n      var dx = 0,\r\n          dy = 0,\r\n          invertY = opts.invertY,\r\n          speed = opts.speed;\r\n\r\n      var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);\r\n\r\n      switch (opts.direction) {\r\n      case 'left':    // Left\r\n        dx = actualSpeed;\r\n        break;\r\n      case 'up':    // Up\r\n        dy = actualSpeed;\r\n        break;\r\n      case 'right':    // Right\r\n        dx = -actualSpeed;\r\n        break;\r\n      case 'down':    // Down\r\n        dy = -actualSpeed;\r\n        break;\r\n      }\r\n\r\n      if (dy && invertY) {\r\n        dy = -dy;\r\n      }\r\n\r\n      canvas.scroll({ dx: dx, dy: dy });\r\n    }\r\n  };\r\n}\r\n\r\nEditorActions.$inject = [\r\n  'eventBus',\r\n  'commandStack',\r\n  'modeling',\r\n  'selection',\r\n  'zoomScroll',\r\n  'copyPaste',\r\n  'canvas',\r\n  'rules',\r\n  'mouseTracking'\r\n];\r\n\r\nmodule.exports = EditorActions;\r\n\r\n\r\n/**\r\n * Triggers a registered action\r\n *\r\n * @param  {String} action\r\n * @param  {Object} opts\r\n *\r\n * @return {Unknown} Returns what the registered listener returns\r\n */\r\nEditorActions.prototype.trigger = function(action, opts) {\r\n  if (!this._actions[action]) {\r\n    throw error(action, NOT_REGISTERED_ERROR);\r\n  }\r\n\r\n  return this._actions[action](opts);\r\n};\r\n\r\n\r\n/**\r\n * Registers a collections of actions.\r\n * The key of the object will be the name of the action.\r\n *\r\n * @example\r\n * ´´´\r\n * var actions = {\r\n *   spaceTool: function() {\r\n *     spaceTool.activateSelection();\r\n *   },\r\n *   lassoTool: function() {\r\n *     lassoTool.activateSelection();\r\n *   }\r\n * ];\r\n *\r\n * editorActions.register(actions);\r\n *\r\n * editorActions.isRegistered('spaceTool'); // true\r\n * ´´´\r\n *\r\n * @param  {Object} actions\r\n */\r\nEditorActions.prototype.register = function(actions, listener) {\r\n  if (typeof actions === 'string') {\r\n    return this._registerAction(actions, listener);\r\n  }\r\n\r\n  forEach(actions, function(listener, action) {\r\n    this._registerAction(action, listener);\r\n  }, this);\r\n};\r\n\r\n/**\r\n * Registers a listener to an action key\r\n *\r\n * @param  {String} action\r\n * @param  {Function} listener\r\n */\r\nEditorActions.prototype._registerAction = function(action, listener) {\r\n  if (this.isRegistered(action)) {\r\n    throw error(action, IS_REGISTERED_ERROR);\r\n  }\r\n\r\n  this._actions[action] = listener;\r\n};\r\n\r\n/**\r\n * Unregister an existing action\r\n *\r\n * @param {String} action\r\n */\r\nEditorActions.prototype.unregister = function(action) {\r\n  if (!this.isRegistered(action)) {\r\n    throw error(action, NOT_REGISTERED_ERROR);\r\n  }\r\n\r\n  this._actions[action] = undefined;\r\n};\r\n\r\n/**\r\n * Returns the number of actions that are currently registered\r\n *\r\n * @return {Number}\r\n */\r\nEditorActions.prototype.length = function() {\r\n  return Object.keys(this._actions).length;\r\n};\r\n\r\n/**\r\n * Checks wether the given action is registered\r\n *\r\n * @param {String} action\r\n *\r\n * @return {Boolean}\r\n */\r\nEditorActions.prototype.isRegistered = function(action) {\r\n  return !!this._actions[action];\r\n};\r\n\r\n\r\nfunction error(action, message) {\r\n  return new Error(action + ' ' + message);\r\n}\r\n","module.exports = {\r\n  __depends__: [\r\n    require(310),\r\n    require(232),\r\n    require(337)\r\n  ],\r\n  __init__: [ 'editorActions' ],\r\n  editorActions: [ 'type', require(240) ]\r\n};\r\n","'use strict';\r\n\r\nvar MARKER_OK = 'connect-ok',\r\n    MARKER_NOT_OK = 'connect-not-ok';\r\n\r\n\r\nfunction GlobalConnect(eventBus, dragging, connect, canvas, toolManager) {\r\n  var self = this;\r\n\r\n  this._dragging = dragging;\r\n\r\n  toolManager.registerTool('global-connect', {\r\n    tool: 'global-connect',\r\n    dragging: 'global-connect.drag'\r\n  });\r\n\r\n  eventBus.on('global-connect.hover', function(event) {\r\n    var context = event.context,\r\n        startTarget = event.hover;\r\n\r\n    var canStartConnect = context.canStartConnect = self.canStartConnect(startTarget);\r\n\r\n    // simply ignore hover\r\n    if (canStartConnect === null) {\r\n      return;\r\n    }\r\n\r\n    context.startTarget = startTarget;\r\n\r\n    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);\r\n  });\r\n\r\n\r\n  eventBus.on([ 'global-connect.out', 'global-connect.cleanup' ], function(event) {\r\n    var startTarget = event.context.startTarget,\r\n        canStartConnect = event.context.canStartConnect;\r\n\r\n    if (startTarget) {\r\n      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);\r\n    }\r\n  });\r\n\r\n\r\n  eventBus.on([ 'global-connect.ended' ], function(event) {\r\n    var context = event.context,\r\n        startTarget = context.startTarget,\r\n        startPosition = {\r\n          x: event.x,\r\n          y: event.y\r\n        };\r\n\r\n    var canStartConnect = self.canStartConnect(startTarget);\r\n\r\n    if (!canStartConnect) {\r\n      return;\r\n    }\r\n\r\n    eventBus.once('element.out', function() {\r\n      eventBus.once([ 'connect.ended', 'connect.canceled' ], function() {\r\n        eventBus.fire('global-connect.drag.ended');\r\n      });\r\n\r\n      connect.start(null, startTarget, startPosition);\r\n    });\r\n\r\n    return false;\r\n  });\r\n}\r\n\r\nGlobalConnect.$inject = [ 'eventBus', 'dragging', 'connect', 'canvas', 'toolManager' ];\r\n\r\nmodule.exports = GlobalConnect;\r\n\r\n\r\n/**\r\n * Initiates tool activity.\r\n */\r\nGlobalConnect.prototype.start = function(event) {\r\n  this._dragging.init(event, 'global-connect', {\r\n    trapClick: false,\r\n    data: {\r\n      context: {}\r\n    }\r\n  });\r\n};\r\n\r\n\r\nGlobalConnect.prototype.toggle = function() {\r\n  if (this.isActive()) {\r\n    this._dragging.cancel();\r\n  } else {\r\n    this.start();\r\n  }\r\n};\r\n\r\nGlobalConnect.prototype.isActive = function() {\r\n  var context = this._dragging.context();\r\n\r\n  return context && /^global-connect/.test(context.prefix);\r\n};\r\n\r\n\r\nGlobalConnect.prototype.registerProvider = function(provider) {\r\n  this._provider = provider;\r\n};\r\n\r\n\r\n/**\r\n * Check if source shape can initiate connection.\r\n *\r\n * @param  {Shape} startTarget\r\n * @return {Boolean}\r\n */\r\nGlobalConnect.prototype.canStartConnect = function(startTarget) {\r\n  return this._provider.canStartConnect(startTarget);\r\n};\r\n","module.exports = {\r\n  __depends__: [\r\n    require(228),\r\n    require(304),\r\n    require(239),\r\n    require(319)\r\n  ],\r\n  globalConnect: [ 'type', require(242) ]\r\n};\r\n","'use strict';\r\n\r\nvar hasPrimaryModifier = require(351).hasPrimaryModifier;\r\n\r\n\r\nvar HIGH_PRIORITY = 1500;\r\nvar HAND_CURSOR = 'grab';\r\n\r\nfunction HandTool(eventBus, canvas, dragging, toolManager) {\r\n  this._dragging = dragging;\r\n\r\n\r\n  toolManager.registerTool('hand', {\r\n    tool: 'hand',\r\n    dragging: 'hand.move'\r\n  });\r\n\r\n  eventBus.on('element.mousedown', HIGH_PRIORITY, function(event) {\r\n    if (hasPrimaryModifier(event)) {\r\n      this.activateMove(event.originalEvent);\r\n\r\n      return false;\r\n    }\r\n  }, this);\r\n\r\n\r\n  eventBus.on('hand.end', function(event) {\r\n    var target = event.originalEvent.target;\r\n\r\n    // only reactive on diagram click\r\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\r\n    if (!event.hover && !(target instanceof SVGElement)) {\r\n      return false;\r\n    }\r\n\r\n    eventBus.once('hand.ended', function() {\r\n      this.activateMove(event.originalEvent, { reactivate: true });\r\n    }, this);\r\n\r\n  }, this);\r\n\r\n\r\n  eventBus.on('hand.move.move', function(event) {\r\n    var scale = canvas.viewbox().scale;\r\n\r\n    canvas.scroll({\r\n      dx: event.dx * scale,\r\n      dy: event.dy * scale\r\n    });\r\n  });\r\n\r\n  eventBus.on('hand.move.end', function(event) {\r\n    var context = event.context,\r\n        reactivate = context.reactivate;\r\n\r\n    // Don't reactivate if the user is using the keyboard keybinding\r\n    if (!hasPrimaryModifier(event) && reactivate) {\r\n\r\n      eventBus.once('hand.move.ended', function(event) {\r\n        this.activateHand(event.originalEvent, true, true);\r\n      }, this);\r\n\r\n    }\r\n\r\n    return false;\r\n  }, this);\r\n\r\n}\r\n\r\nHandTool.$inject = [\r\n  'eventBus',\r\n  'canvas',\r\n  'dragging',\r\n  'toolManager'\r\n];\r\n\r\nmodule.exports = HandTool;\r\n\r\n\r\nHandTool.prototype.activateMove = function(event, autoActivate, context) {\r\n  if (typeof autoActivate === 'object') {\r\n    context = autoActivate;\r\n    autoActivate = false;\r\n  }\r\n\r\n  this._dragging.init(event, 'hand.move', {\r\n    autoActivate: autoActivate,\r\n    cursor: HAND_CURSOR,\r\n    data: {\r\n      context: context || {}\r\n    }\r\n  });\r\n};\r\n\r\nHandTool.prototype.activateHand = function(event, autoActivate, reactivate) {\r\n  this._dragging.init(event, 'hand', {\r\n    trapClick: false,\r\n    autoActivate: autoActivate,\r\n    cursor: HAND_CURSOR,\r\n    data: {\r\n      context: {\r\n        reactivate: reactivate\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nHandTool.prototype.toggle = function() {\r\n  if (this.isActive()) {\r\n    this._dragging.cancel();\r\n  } else {\r\n    this.activateHand();\r\n  }\r\n};\r\n\r\nHandTool.prototype.isActive = function() {\r\n  var context = this._dragging.context();\r\n\r\n  return context && /^hand/.test(context.prefix);\r\n};\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __depends__: [ require(319) ],\r\n  __init__: [ 'handTool' ],\r\n  handTool: [ 'type', require(244) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    domDelegate = require(534);\r\n\r\nvar isPrimaryButton = require(351).isPrimaryButton;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583);\r\n\r\nvar domQuery = require(538);\r\n\r\nvar renderUtil = require(355);\r\n\r\nvar createLine = renderUtil.createLine,\r\n    updateLine = renderUtil.updateLine;\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\n/**\r\n * A plugin that provides interaction events for diagram elements.\r\n *\r\n * It emits the following events:\r\n *\r\n *   * element.hover\r\n *   * element.out\r\n *   * element.click\r\n *   * element.dblclick\r\n *   * element.mousedown\r\n *\r\n * Each event is a tuple { element, gfx, originalEvent }.\r\n *\r\n * Canceling the event via Event#preventDefault() prevents the original DOM operation.\r\n *\r\n * @param {EventBus} eventBus\r\n */\r\nfunction InteractionEvents(eventBus, elementRegistry, styles) {\r\n\r\n  var HIT_STYLE = styles.cls('djs-hit', [ 'no-fill', 'no-border' ], {\r\n    stroke: 'white',\r\n    strokeWidth: 15\r\n  });\r\n\r\n  /**\r\n   * Fire an interaction event.\r\n   *\r\n   * @param {String} type local event name, e.g. element.click.\r\n   * @param {DOMEvent} event native event\r\n   * @param {djs.model.Base} [element] the diagram element to emit the event on;\r\n   *                                   defaults to the event target\r\n   */\r\n  function fire(type, event, element) {\r\n\r\n    // only react on left mouse button interactions\r\n    // for interaction events\r\n    if (!isPrimaryButton(event)) {\r\n      return;\r\n    }\r\n\r\n    var target, gfx, returnValue;\r\n\r\n    if (!element) {\r\n      target = event.delegateTarget || event.target;\r\n\r\n      if (target) {\r\n        gfx = target;\r\n        element = elementRegistry.get(gfx);\r\n      }\r\n    } else {\r\n      gfx = elementRegistry.getGraphics(element);\r\n    }\r\n\r\n    if (!gfx || !element) {\r\n      return;\r\n    }\r\n\r\n    returnValue = eventBus.fire(type, { element: element, gfx: gfx, originalEvent: event });\r\n\r\n    if (returnValue === false) {\r\n      event.stopPropagation();\r\n      event.preventDefault();\r\n    }\r\n  }\r\n\r\n  // TODO(nikku): document this\r\n  var handlers = {};\r\n\r\n  function mouseHandler(type) {\r\n\r\n    var fn = handlers[type];\r\n\r\n    if (!fn) {\r\n      fn = handlers[type] = function(event) {\r\n        fire(type, event);\r\n      };\r\n    }\r\n\r\n    return fn;\r\n  }\r\n\r\n  var bindings = {\r\n    mouseover: 'element.hover',\r\n    mouseout: 'element.out',\r\n    click: 'element.click',\r\n    dblclick: 'element.dblclick',\r\n    mousedown: 'element.mousedown',\r\n    mouseup: 'element.mouseup'\r\n  };\r\n\r\n\r\n  ///// manual event trigger\r\n\r\n  /**\r\n   * Trigger an interaction event (based on a native dom event)\r\n   * on the target shape or connection.\r\n   *\r\n   * @param {String} eventName the name of the triggered DOM event\r\n   * @param {MouseEvent} event\r\n   * @param {djs.model.Base} targetElement\r\n   */\r\n  function triggerMouseEvent(eventName, event, targetElement) {\r\n\r\n    // i.e. element.mousedown...\r\n    var localEventName = bindings[eventName];\r\n\r\n    if (!localEventName) {\r\n      throw new Error('unmapped DOM event name <' + eventName + '>');\r\n    }\r\n\r\n    return fire(localEventName, event, targetElement);\r\n  }\r\n\r\n\r\n  var elementSelector = 'svg, .djs-element';\r\n\r\n  ///// event registration\r\n\r\n  function registerEvent(node, event, localEvent) {\r\n    var handler = mouseHandler(localEvent);\r\n    handler.$delegate = domDelegate.bind(node, elementSelector, event, handler);\r\n  }\r\n\r\n  function unregisterEvent(node, event, localEvent) {\r\n    domDelegate.unbind(node, event, mouseHandler(localEvent).$delegate);\r\n  }\r\n\r\n  function registerEvents(svg) {\r\n    forEach(bindings, function(val, key) {\r\n      registerEvent(svg, key, val);\r\n    });\r\n  }\r\n\r\n  function unregisterEvents(svg) {\r\n    forEach(bindings, function(val, key) {\r\n      unregisterEvent(svg, key, val);\r\n    });\r\n  }\r\n\r\n  eventBus.on('canvas.destroy', function(event) {\r\n    unregisterEvents(event.svg);\r\n  });\r\n\r\n  eventBus.on('canvas.init', function(event) {\r\n    registerEvents(event.svg);\r\n  });\r\n\r\n\r\n  eventBus.on([ 'shape.added', 'connection.added' ], function(event) {\r\n    var element = event.element,\r\n        gfx = event.gfx,\r\n        hit;\r\n\r\n    if (element.waypoints) {\r\n      hit = createLine(element.waypoints);\r\n    } else {\r\n      hit = svgCreate('rect');\r\n      svgAttr(hit, {\r\n        x: 0,\r\n        y: 0,\r\n        width: element.width,\r\n        height: element.height\r\n      });\r\n    }\r\n\r\n    svgAttr(hit, HIT_STYLE);\r\n\r\n    svgAppend(gfx, hit);\r\n  });\r\n\r\n  // Update djs-hit on change.\r\n  // A low priortity is necessary, because djs-hit of labels has to be updated\r\n  // after the label bounds have been updated in the renderer.\r\n  eventBus.on('shape.changed', LOW_PRIORITY, function(event) {\r\n\r\n    var element = event.element,\r\n        gfx = event.gfx,\r\n        hit = domQuery('.djs-hit', gfx);\r\n\r\n    svgAttr(hit, {\r\n      width: element.width,\r\n      height: element.height\r\n    });\r\n  });\r\n\r\n  eventBus.on('connection.changed', function(event) {\r\n\r\n    var element = event.element,\r\n        gfx = event.gfx,\r\n        hit = domQuery('.djs-hit', gfx);\r\n\r\n    updateLine(hit, element.waypoints);\r\n  });\r\n\r\n\r\n  // API\r\n\r\n  this.fire = fire;\r\n\r\n  this.triggerMouseEvent = triggerMouseEvent;\r\n\r\n  this.mouseHandler = mouseHandler;\r\n\r\n  this.registerEvent = registerEvent;\r\n  this.unregisterEvent = unregisterEvent;\r\n}\r\n\r\n\r\nInteractionEvents.$inject = [ 'eventBus', 'elementRegistry', 'styles' ];\r\n\r\nmodule.exports = InteractionEvents;\r\n\r\n\r\n/**\r\n * An event indicating that the mouse hovered over an element\r\n *\r\n * @event element.hover\r\n *\r\n * @type {Object}\r\n * @property {djs.model.Base} element\r\n * @property {SVGElement} gfx\r\n * @property {Event} originalEvent\r\n */\r\n\r\n/**\r\n * An event indicating that the mouse has left an element\r\n *\r\n * @event element.out\r\n *\r\n * @type {Object}\r\n * @property {djs.model.Base} element\r\n * @property {SVGElement} gfx\r\n * @property {Event} originalEvent\r\n */\r\n\r\n/**\r\n * An event indicating that the mouse has clicked an element\r\n *\r\n * @event element.click\r\n *\r\n * @type {Object}\r\n * @property {djs.model.Base} element\r\n * @property {SVGElement} gfx\r\n * @property {Event} originalEvent\r\n */\r\n\r\n/**\r\n * An event indicating that the mouse has double clicked an element\r\n *\r\n * @event element.dblclick\r\n *\r\n * @type {Object}\r\n * @property {djs.model.Base} element\r\n * @property {SVGElement} gfx\r\n * @property {Event} originalEvent\r\n */\r\n\r\n/**\r\n * An event indicating that the mouse has gone down on an element.\r\n *\r\n * @event element.mousedown\r\n *\r\n * @type {Object}\r\n * @property {djs.model.Base} element\r\n * @property {SVGElement} gfx\r\n * @property {Event} originalEvent\r\n */\r\n\r\n/**\r\n * An event indicating that the mouse has gone up on an element.\r\n *\r\n * @event element.mouseup\r\n *\r\n * @type {Object}\r\n * @property {djs.model.Base} element\r\n * @property {SVGElement} gfx\r\n * @property {Event} originalEvent\r\n */\r\n","module.exports = {\r\n  __init__: [ 'interactionEvents' ],\r\n  interactionEvents: [ 'type', require(246) ]\r\n};","'use strict';\r\n\r\nvar domEvent = require(536),\r\n    domMatches = require(537);\r\n\r\n/**\r\n * A keyboard abstraction that may be activated and\r\n * deactivated by users at will, consuming key events\r\n * and triggering diagram actions.\r\n *\r\n * The implementation fires the following key events that allow\r\n * other components to hook into key handling:\r\n *\r\n *  - keyboard.bind\r\n *  - keyboard.unbind\r\n *  - keyboard.init\r\n *  - keyboard.destroy\r\n *\r\n * All events contain the fields (node, listeners).\r\n *\r\n * A default binding for the keyboard may be specified via the\r\n * `keyboard.bindTo` configuration option.\r\n *\r\n * @param {Config} config\r\n * @param {EventBus} eventBus\r\n * @param {EditorActions} editorActions\r\n */\r\nfunction Keyboard(config, eventBus, editorActions) {\r\n  var self = this;\r\n\r\n  this._config = config || {};\r\n  this._eventBus = eventBus;\r\n  this._editorActions = editorActions;\r\n\r\n  this._listeners = [];\r\n\r\n  // our key handler is a singleton that passes\r\n  // (keycode, modifiers) to each listener.\r\n  //\r\n  // listeners must indicate that they handled a key event\r\n  // by returning true. This stops the event propagation.\r\n  //\r\n  this._keyHandler = function(event) {\r\n\r\n    var i, l,\r\n        target = event.target,\r\n        listeners = self._listeners,\r\n        code = event.keyCode || event.charCode || -1;\r\n\r\n    if (target && (domMatches(target, 'input, textarea') || target.contentEditable === 'true')) {\r\n      return;\r\n    }\r\n\r\n    for (i = 0; (l = listeners[i]); i++) {\r\n      if (l(code, event)) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n      }\r\n    }\r\n  };\r\n\r\n  // properly clean dom registrations\r\n  eventBus.on('diagram.destroy', function() {\r\n    self._fire('destroy');\r\n\r\n    self.unbind();\r\n    self._listeners = null;\r\n  });\r\n\r\n  eventBus.on('diagram.init', function() {\r\n    self._fire('init');\r\n\r\n    if (config && config.bindTo) {\r\n      self.bind(config.bindTo);\r\n    }\r\n  });\r\n\r\n  this._init();\r\n}\r\n\r\nKeyboard.$inject = [\r\n  'config.keyboard',\r\n  'eventBus',\r\n  'editorActions'\r\n];\r\n\r\nmodule.exports = Keyboard;\r\n\r\n\r\nKeyboard.prototype.bind = function(node) {\r\n  // make sure that the keyboard is only bound once to the DOM\r\n  this.unbind();\r\n\r\n  this._node = node;\r\n\r\n  // bind key events\r\n  domEvent.bind(node, 'keydown', this._keyHandler, true);\r\n\r\n  this._fire('bind');\r\n};\r\n\r\nKeyboard.prototype.getBinding = function() {\r\n  return this._node;\r\n};\r\n\r\nKeyboard.prototype.unbind = function() {\r\n  var node = this._node;\r\n\r\n  if (node) {\r\n    this._fire('unbind');\r\n\r\n    // unbind key events\r\n    domEvent.unbind(node, 'keydown', this._keyHandler, true);\r\n  }\r\n\r\n  this._node = null;\r\n};\r\n\r\nKeyboard.prototype._fire = function(event) {\r\n  this._eventBus.fire('keyboard.' + event, { node: this._node, listeners: this._listeners });\r\n};\r\n\r\nKeyboard.prototype._init = function() {\r\n\r\n  var listeners = this._listeners;\r\n\r\n  var editorActions = this._editorActions,\r\n      config = this._config;\r\n\r\n  // init default listeners\r\n\r\n  // undo\r\n  // (CTRL|CMD) + Z\r\n  function undo(key, modifiers) {\r\n\r\n    if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {\r\n      editorActions.trigger('undo');\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // redo\r\n  // CTRL + Y\r\n  // CMD + SHIFT + Z\r\n  function redo(key, modifiers) {\r\n\r\n    if (isCmd(modifiers) && (key === 89 || (key === 90 && isShift(modifiers)))) {\r\n      editorActions.trigger('redo');\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // copy\r\n  // CTRL/CMD + C\r\n  function copy(key, modifiers) {\r\n\r\n    if (isCmd(modifiers) && (key === 67)) {\r\n      editorActions.trigger('copy');\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // paste\r\n  // CTRL/CMD + V\r\n  function paste(key, modifiers) {\r\n\r\n    if (isCmd(modifiers) && (key === 86)) {\r\n      editorActions.trigger('paste');\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * zoom in one step\r\n   * CTRL + +\r\n   *\r\n   * 107 = numpad plus\r\n   * 187 = regular plus\r\n   * 171 = regular plus in Firefox (german keyboard layout)\r\n   *  61 = regular plus in Firefox (US keyboard layout)\r\n   */\r\n  function zoomIn(key, modifiers) {\r\n\r\n    if ((key === 107 || key === 187 || key === 171 || key === 61) && isCmd(modifiers)) {\r\n      editorActions.trigger('stepZoom', { value: 1 });\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * zoom out one step\r\n   * CTRL + -\r\n   *\r\n   * 109 = numpad minus\r\n   * 189 = regular minus\r\n   * 173 = regular minus in Firefox (US and german keyboard layout)\r\n   */\r\n  function zoomOut(key, modifiers) {\r\n\r\n    if ((key === 109 || key === 189 || key === 173)  && isCmd(modifiers)) {\r\n      editorActions.trigger('stepZoom', { value: -1 });\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * zoom to the default level\r\n   * CTRL + 0\r\n   *\r\n   * 96 = numpad zero\r\n   * 48 = regular zero\r\n   */\r\n  function zoomDefault(key, modifiers) {\r\n\r\n    if ((key === 96 || key === 48) && isCmd(modifiers)) {\r\n      editorActions.trigger('zoom', { value: 1 });\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // delete selected element\r\n  // DEL\r\n  function removeSelection(key, modifiers) {\r\n\r\n    if (key === 46) {\r\n      editorActions.trigger('removeSelection');\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // move canvas left\r\n  // left arrow\r\n  //\r\n  // 37 = Left\r\n  // 38 = Up\r\n  // 39 = Right\r\n  // 40 = Down\r\n  function moveCanvas(key, modifiers) {\r\n\r\n    if ([37, 38, 39, 40].indexOf(key) >= 0) {\r\n\r\n      var opts = {\r\n        invertY: config.invertY,\r\n        speed: (config.speed || 50)\r\n      };\r\n\r\n      switch (key) {\r\n      case 37:    // Left\r\n        opts.direction = 'left';\r\n        break;\r\n      case 38:    // Up\r\n        opts.direction = 'up';\r\n        break;\r\n      case 39:    // Right\r\n        opts.direction = 'right';\r\n        break;\r\n      case 40:    // Down\r\n        opts.direction = 'down';\r\n        break;\r\n      }\r\n\r\n      editorActions.trigger('moveCanvas', opts);\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  listeners.push(undo);\r\n  listeners.push(redo);\r\n  listeners.push(copy);\r\n  listeners.push(paste);\r\n  listeners.push(removeSelection);\r\n  listeners.push(zoomIn);\r\n  listeners.push(zoomOut);\r\n  listeners.push(zoomDefault);\r\n  listeners.push(moveCanvas);\r\n};\r\n\r\n\r\n/**\r\n * Add a listener function that is notified with (key, modifiers) whenever\r\n * the keyboard is bound and the user presses a key.\r\n *\r\n * @param {Function} listenerFn\r\n */\r\nKeyboard.prototype.addListener = function(listenerFn) {\r\n  this._listeners.push(listenerFn);\r\n};\r\n\r\nKeyboard.prototype.hasModifier = hasModifier;\r\nKeyboard.prototype.isCmd = isCmd;\r\nKeyboard.prototype.isShift = isShift;\r\n\r\n\r\nfunction hasModifier(modifiers) {\r\n  return (modifiers.ctrlKey || modifiers.metaKey || modifiers.shiftKey || modifiers.altKey);\r\n}\r\n\r\nfunction isCmd(modifiers) {\r\n  return modifiers.ctrlKey || modifiers.metaKey;\r\n}\r\n\r\nfunction isShift(modifiers) {\r\n  return modifiers.shiftKey;\r\n}\r\n","module.exports = {\r\n  __init__: [ 'keyboard' ],\r\n  keyboard: [ 'type', require(248) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    filter = require(384),\r\n    inherits = require(368);\r\n\r\nvar LOW_PRIORITY = 250,\r\n    HIGH_PRIORITY = 1400;\r\n\r\nvar CommandInterceptor = require(196);\r\n\r\n\r\n/**\r\n * A handler that makes sure labels are properly moved with\r\n * their label targets.\r\n */\r\nfunction LabelSupport(eventBus, modeling, movePreview) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  // remove labels from the collection that are being\r\n  // moved with other elements anyway\r\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {\r\n\r\n    var context = e.context,\r\n        shapes = context.shapes,\r\n        validatedShapes = context.validatedShapes;\r\n\r\n    context.shapes = removeLabels(shapes);\r\n    context.validatedShapes = removeLabels(validatedShapes);\r\n  });\r\n\r\n\r\n  // add labels to visual's group\r\n  eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {\r\n\r\n    var context = e.context,\r\n        shapes = context.shapes;\r\n\r\n    var labels = [];\r\n\r\n    forEach(shapes, function(element) {\r\n      var label = element.label;\r\n\r\n      if (label && !label.hidden && context.shapes.indexOf(label) === -1) {\r\n        labels.push(label);\r\n      }\r\n\r\n      if (element.labelTarget) {\r\n        labels.push(element);\r\n      }\r\n    });\r\n\r\n    forEach(labels, function(label) {\r\n      movePreview.makeDraggable(context, label, true);\r\n    });\r\n\r\n  });\r\n\r\n  // move labels after the other shapes are done moving\r\n  this.postExecuted([ 'elements.move' ], function(e) {\r\n    var context = e.context,\r\n        closure = context.closure,\r\n        enclosedElements = closure.enclosedElements;\r\n\r\n    // ensure we move all labels with their respective elements\r\n    // if they have not been moved already\r\n    forEach(enclosedElements, function(element) {\r\n      if (element.label && !enclosedElements[element.label.id]) {\r\n        modeling.moveShape(element.label, context.delta, element.parent);\r\n      }\r\n    });\r\n\r\n  });\r\n\r\n}\r\n\r\ninherits(LabelSupport, CommandInterceptor);\r\n\r\nLabelSupport.$inject = [ 'eventBus', 'modeling', 'movePreview' ];\r\n\r\nmodule.exports = LabelSupport;\r\n\r\n\r\n/**\r\n * Return a filtered list of elements that do not\r\n * contain attached elements with hosts being part\r\n * of the selection.\r\n *\r\n * @param  {Array<djs.model.Base>} elements\r\n *\r\n * @return {Array<djs.model.Base>} filtered\r\n */\r\nfunction removeLabels(elements) {\r\n\r\n  return filter(elements, function(element) {\r\n\r\n    // filter out labels that are move together\r\n    // with their label targets\r\n    return elements.indexOf(element.labelTarget) === -1;\r\n  });\r\n}\r\n","module.exports = {\r\n  __depends__: [\r\n    require(283)\r\n  ],\r\n  __init__: [ 'labelSupport'],\r\n  labelSupport: [ 'type', require(250) ]\r\n};\r\n","'use strict';\r\n\r\nvar values = require(526);\r\n\r\nvar getEnclosedElements = require(343).getEnclosedElements;\r\n\r\nvar hasSecondaryModifier = require(351).hasSecondaryModifier;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\nvar LASSO_TOOL_CURSOR = 'crosshair';\r\n\r\n\r\nfunction LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager) {\r\n\r\n  this._selection = selection;\r\n  this._dragging = dragging;\r\n\r\n  var self = this;\r\n\r\n  // lasso visuals implementation\r\n\r\n  /**\r\n  * A helper that realizes the selection box visual\r\n  */\r\n  var visuals = {\r\n\r\n    create: function(context) {\r\n      var container = canvas.getDefaultLayer(),\r\n          frame;\r\n\r\n      frame = context.frame = svgCreate('rect');\r\n      svgAttr(frame, {\r\n        class: 'djs-lasso-overlay',\r\n        width:  1,\r\n        height: 1,\r\n        x: 0,\r\n        y: 0\r\n      });\r\n\r\n      svgAppend(container, frame);\r\n    },\r\n\r\n    update: function(context) {\r\n      var frame = context.frame,\r\n          bbox  = context.bbox;\r\n\r\n      svgAttr(frame, {\r\n        x: bbox.x,\r\n        y: bbox.y,\r\n        width: bbox.width,\r\n        height: bbox.height\r\n      });\r\n    },\r\n\r\n    remove: function(context) {\r\n\r\n      if (context.frame) {\r\n        svgRemove(context.frame);\r\n      }\r\n    }\r\n  };\r\n\r\n  toolManager.registerTool('lasso', {\r\n    tool: 'lasso.selection',\r\n    dragging: 'lasso'\r\n  });\r\n\r\n  eventBus.on('lasso.selection.end', function(event) {\r\n    var target = event.originalEvent.target;\r\n\r\n    // only reactive on diagram click\r\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\r\n    if (!event.hover && !(target instanceof SVGElement)) {\r\n      return;\r\n    }\r\n\r\n    eventBus.once('lasso.selection.ended', function() {\r\n      self.activateLasso(event.originalEvent, true);\r\n    });\r\n  });\r\n\r\n  // lasso interaction implementation\r\n\r\n  eventBus.on('lasso.end', function(event) {\r\n\r\n    var bbox = toBBox(event);\r\n\r\n    var elements = elementRegistry.filter(function(element) {\r\n      return element;\r\n    });\r\n\r\n    self.select(elements, bbox);\r\n  });\r\n\r\n  eventBus.on('lasso.start', function(event) {\r\n\r\n    var context = event.context;\r\n\r\n    context.bbox = toBBox(event);\r\n    visuals.create(context);\r\n  });\r\n\r\n  eventBus.on('lasso.move', function(event) {\r\n\r\n    var context = event.context;\r\n\r\n    context.bbox = toBBox(event);\r\n    visuals.update(context);\r\n  });\r\n\r\n  eventBus.on('lasso.cleanup', function(event) {\r\n\r\n    var context = event.context;\r\n\r\n    visuals.remove(context);\r\n  });\r\n\r\n\r\n  // event integration\r\n\r\n  eventBus.on('element.mousedown', 1500, function(event) {\r\n\r\n    if (hasSecondaryModifier(event)) {\r\n      self.activateLasso(event.originalEvent);\r\n\r\n      event.stopPropagation();\r\n    }\r\n  });\r\n}\r\n\r\nLassoTool.$inject = [\r\n  'eventBus',\r\n  'canvas',\r\n  'dragging',\r\n  'elementRegistry',\r\n  'selection',\r\n  'toolManager'\r\n];\r\n\r\nmodule.exports = LassoTool;\r\n\r\n\r\nLassoTool.prototype.activateLasso = function(event, autoActivate) {\r\n\r\n  this._dragging.init(event, 'lasso', {\r\n    autoActivate: autoActivate,\r\n    cursor: LASSO_TOOL_CURSOR,\r\n    data: {\r\n      context: {}\r\n    }\r\n  });\r\n};\r\n\r\nLassoTool.prototype.activateSelection = function(event) {\r\n\r\n  this._dragging.init(event, 'lasso.selection', {\r\n    trapClick: false,\r\n    cursor: LASSO_TOOL_CURSOR,\r\n    data: {\r\n      context: {}\r\n    }\r\n  });\r\n};\r\n\r\nLassoTool.prototype.select = function(elements, bbox) {\r\n  var selectedElements = getEnclosedElements(elements, bbox);\r\n\r\n  this._selection.select(values(selectedElements));\r\n};\r\n\r\nLassoTool.prototype.toggle = function() {\r\n  if (this.isActive()) {\r\n    this._dragging.cancel();\r\n  } else {\r\n    this.activateSelection();\r\n  }\r\n};\r\n\r\nLassoTool.prototype.isActive = function() {\r\n  var context = this._dragging.context();\r\n\r\n  return context && /^lasso/.test(context.prefix);\r\n};\r\n\r\n\r\n\r\nfunction toBBox(event) {\r\n\r\n  var start = {\r\n\r\n    x: event.x - event.dx,\r\n    y: event.y - event.dy\r\n  };\r\n\r\n  var end = {\r\n    x: event.x,\r\n    y: event.y\r\n  };\r\n\r\n  var bbox;\r\n\r\n  if ((start.x <= end.x && start.y < end.y) ||\r\n      (start.x < end.x && start.y <= end.y)) {\r\n\r\n    bbox = {\r\n      x: start.x,\r\n      y: start.y,\r\n      width:  end.x - start.x,\r\n      height: end.y - start.y\r\n    };\r\n  } else if ((start.x >= end.x && start.y < end.y) ||\r\n             (start.x > end.x && start.y <= end.y)) {\r\n\r\n    bbox = {\r\n      x: end.x,\r\n      y: start.y,\r\n      width:  start.x - end.x,\r\n      height: end.y - start.y\r\n    };\r\n  } else if ((start.x <= end.x && start.y > end.y) ||\r\n             (start.x < end.x && start.y >= end.y)) {\r\n\r\n    bbox = {\r\n      x: start.x,\r\n      y: end.y,\r\n      width:  end.x - start.x,\r\n      height: start.y - end.y\r\n    };\r\n  } else if ((start.x >= end.x && start.y > end.y) ||\r\n             (start.x > end.x && start.y >= end.y)) {\r\n\r\n    bbox = {\r\n      x: end.x,\r\n      y: end.y,\r\n      width:  start.x - end.x,\r\n      height: start.y - end.y\r\n    };\r\n  } else {\r\n\r\n    bbox = {\r\n      x: end.x,\r\n      y: end.y,\r\n      width:  0,\r\n      height: 0\r\n    };\r\n  }\r\n  return bbox;\r\n}\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __depends__: [ require(319) ],\r\n  __init__: [ 'lassoTool' ],\r\n  lassoTool: [ 'type', require(252) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar model = require(331);\r\n\r\n\r\n/**\r\n * The basic modeling entry point.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementFactory} elementFactory\r\n * @param {CommandStack} commandStack\r\n */\r\nfunction Modeling(eventBus, elementFactory, commandStack) {\r\n  this._eventBus = eventBus;\r\n  this._elementFactory = elementFactory;\r\n  this._commandStack = commandStack;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('diagram.init', function() {\r\n    // register modeling handlers\r\n    self.registerHandlers(commandStack);\r\n  });\r\n}\r\n\r\nModeling.$inject = [ 'eventBus', 'elementFactory', 'commandStack' ];\r\n\r\nmodule.exports = Modeling;\r\n\r\n\r\nModeling.prototype.getHandlers = function() {\r\n  return {\r\n    'shape.append': require(256),\r\n    'shape.create': require(259),\r\n    'shape.delete': require(262),\r\n    'shape.move': require(267),\r\n    'shape.resize': require(272),\r\n    'shape.replace': require(271),\r\n    'shape.toggleCollapse': require(274),\r\n\r\n    'spaceTool': require(273),\r\n\r\n    'label.create': require(258),\r\n\r\n    'connection.create': require(257),\r\n    'connection.delete': require(260),\r\n    'connection.move': require(265),\r\n    'connection.layout': require(264),\r\n\r\n    'connection.updateWaypoints': require(276),\r\n\r\n    'connection.reconnectStart': require(270),\r\n    'connection.reconnectEnd': require(270),\r\n\r\n    'elements.move': require(266),\r\n    'elements.delete': require(261),\r\n\r\n    'elements.distribute': require(263),\r\n    'elements.align': require(255),\r\n\r\n    'element.updateAttachment': require(275),\r\n\r\n    'elements.paste': require(269)\r\n  };\r\n};\r\n\r\n/**\r\n * Register handlers with the command stack\r\n *\r\n * @param {CommandStack} commandStack\r\n */\r\nModeling.prototype.registerHandlers = function(commandStack) {\r\n  forEach(this.getHandlers(), function(handler, id) {\r\n    commandStack.registerHandler(id, handler);\r\n  });\r\n};\r\n\r\n\r\n///// modeling helpers /////////////////////////////////////////\r\n\r\nModeling.prototype.moveShape = function(shape, delta, newParent, newParentIndex, hints) {\r\n\r\n  if (typeof newParentIndex === 'object') {\r\n    hints = newParentIndex;\r\n    newParentIndex = null;\r\n  }\r\n\r\n  var context = {\r\n    shape: shape,\r\n    delta:  delta,\r\n    newParent: newParent,\r\n    newParentIndex: newParentIndex,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('shape.move', context);\r\n};\r\n\r\n\r\n/**\r\n * Update the attachment of the given shape.\r\n *\r\n * @param  {djs.mode.Base} shape\r\n * @param  {djs.model.Base} [newHost]\r\n */\r\nModeling.prototype.updateAttachment = function(shape, newHost) {\r\n  var context = {\r\n    shape: shape,\r\n    newHost: newHost\r\n  };\r\n\r\n  this._commandStack.execute('element.updateAttachment', context);\r\n};\r\n\r\n/**\r\n * Move a number of shapes to a new target, either setting it as\r\n * the new parent or attaching it.\r\n *\r\n * @param {Array<djs.mode.Base>} shapes\r\n * @param {Point} delta\r\n * @param {djs.model.Base} [target]\r\n * @param {Boolean} [isAttach=false]\r\n * @param {Object} [hints]\r\n */\r\nModeling.prototype.moveElements = function(shapes, delta, target, isAttach, hints) {\r\n  if (typeof isAttach === 'object') {\r\n    hints = isAttach;\r\n    isAttach = undefined;\r\n  }\r\n\r\n  var newParent = target,\r\n      newHost;\r\n\r\n  if (isAttach === true) {\r\n    newHost = target;\r\n    newParent = target.parent;\r\n  }\r\n\r\n  if (isAttach === false) {\r\n    newHost = null;\r\n  }\r\n\r\n  var context = {\r\n    shapes: shapes,\r\n    delta: delta,\r\n    newParent: newParent,\r\n    newHost: newHost,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('elements.move', context);\r\n};\r\n\r\nModeling.prototype.moveConnection = function(connection, delta, newParent, newParentIndex, hints) {\r\n\r\n  if (typeof newParentIndex === 'object') {\r\n    hints = newParentIndex;\r\n    newParentIndex = undefined;\r\n  }\r\n\r\n  var context = {\r\n    connection: connection,\r\n    delta: delta,\r\n    newParent: newParent,\r\n    newParentIndex: newParentIndex,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('connection.move', context);\r\n};\r\n\r\n\r\nModeling.prototype.layoutConnection = function(connection, hints) {\r\n  var context = {\r\n    connection: connection,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('connection.layout', context);\r\n};\r\n\r\n/**\r\n * Create connection.\r\n *\r\n * @param {djs.model.Base} source\r\n * @param {djs.model.Base} target\r\n * @param {Number} [targetIndex]\r\n * @param {Object|djs.model.Connection} connection\r\n * @param {djs.model.Base} parent\r\n * @param {Object} hints\r\n *\r\n * @return {djs.model.Connection} the created connection.\r\n */\r\nModeling.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {\r\n\r\n  if (typeof parentIndex === 'object') {\r\n    hints = parent;\r\n    parent = connection;\r\n    connection = parentIndex;\r\n    parentIndex = undefined;\r\n  }\r\n\r\n  connection = this._create('connection', connection);\r\n\r\n  var context = {\r\n    source: source,\r\n    target: target,\r\n    parent: parent,\r\n    parentIndex: parentIndex,\r\n    connection: connection,\r\n    hints: hints\r\n  };\r\n\r\n  this._commandStack.execute('connection.create', context);\r\n\r\n  return context.connection;\r\n};\r\n\r\nModeling.prototype.createShape = function(shape, position, parent, parentIndex, isAttach, hints) {\r\n\r\n  if (typeof parentIndex !== 'number') {\r\n    hints = isAttach;\r\n    isAttach = parentIndex;\r\n  }\r\n\r\n  if (typeof isAttach !== 'boolean') {\r\n    hints = isAttach;\r\n    isAttach = false;\r\n  }\r\n\r\n  shape = this._create('shape', shape);\r\n\r\n  var context = {\r\n    position: position,\r\n    shape: shape,\r\n    parent: parent,\r\n    parentIndex: parentIndex,\r\n    host: shape.host,\r\n    hints: hints || {}\r\n  };\r\n\r\n  if (isAttach) {\r\n    context.parent = parent.parent;\r\n    context.host = parent;\r\n  }\r\n\r\n  this._commandStack.execute('shape.create', context);\r\n\r\n  return context.shape;\r\n};\r\n\r\n\r\nModeling.prototype.createLabel = function(labelTarget, position, label, parent) {\r\n\r\n  label = this._create('label', label);\r\n\r\n  var context = {\r\n    labelTarget: labelTarget,\r\n    position: position,\r\n    parent: parent || labelTarget.parent,\r\n    shape: label\r\n  };\r\n\r\n  this._commandStack.execute('label.create', context);\r\n\r\n  return context.shape;\r\n};\r\n\r\n\r\nModeling.prototype.appendShape = function(source, shape, position, parent, connection, connectionParent) {\r\n\r\n  shape = this._create('shape', shape);\r\n\r\n  var context = {\r\n    source: source,\r\n    position: position,\r\n    parent: parent,\r\n    shape: shape,\r\n    connection: connection,\r\n    connectionParent: connectionParent\r\n  };\r\n\r\n  this._commandStack.execute('shape.append', context);\r\n\r\n  return context.shape;\r\n};\r\n\r\n\r\nModeling.prototype.removeElements = function(elements) {\r\n  var context = {\r\n    elements: elements\r\n  };\r\n\r\n  this._commandStack.execute('elements.delete', context);\r\n};\r\n\r\n\r\nModeling.prototype.distributeElements = function(groups, axis, dimension) {\r\n  var context = {\r\n    groups: groups,\r\n    axis: axis,\r\n    dimension: dimension\r\n  };\r\n\r\n  this._commandStack.execute('elements.distribute', context);\r\n};\r\n\r\n\r\nModeling.prototype.removeShape = function(shape, hints) {\r\n  var context = {\r\n    shape: shape,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('shape.delete', context);\r\n};\r\n\r\n\r\nModeling.prototype.removeConnection = function(connection, hints) {\r\n  var context = {\r\n    connection: connection,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('connection.delete', context);\r\n};\r\n\r\nModeling.prototype.replaceShape = function(oldShape, newShape, hints) {\r\n  var context = {\r\n    oldShape: oldShape,\r\n    newData: newShape,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('shape.replace', context);\r\n\r\n  return context.newShape;\r\n};\r\n\r\nModeling.prototype.pasteElements = function(tree, topParent, position) {\r\n  var context = {\r\n    tree: tree,\r\n    topParent: topParent,\r\n    position: position\r\n  };\r\n\r\n  this._commandStack.execute('elements.paste', context);\r\n};\r\n\r\nModeling.prototype.alignElements = function(elements, alignment) {\r\n  var context = {\r\n    elements: elements,\r\n    alignment: alignment\r\n  };\r\n\r\n  this._commandStack.execute('elements.align', context);\r\n};\r\n\r\nModeling.prototype.resizeShape = function(shape, newBounds, minBounds) {\r\n  var context = {\r\n    shape: shape,\r\n    newBounds: newBounds,\r\n    minBounds: minBounds\r\n  };\r\n\r\n  this._commandStack.execute('shape.resize', context);\r\n};\r\n\r\nModeling.prototype.createSpace = function(movingShapes, resizingShapes, delta, direction) {\r\n  var context = {\r\n    movingShapes: movingShapes,\r\n    resizingShapes: resizingShapes,\r\n    delta: delta,\r\n    direction: direction\r\n  };\r\n\r\n  this._commandStack.execute('spaceTool', context);\r\n};\r\n\r\nModeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {\r\n  var context = {\r\n    connection: connection,\r\n    newWaypoints: newWaypoints,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('connection.updateWaypoints', context);\r\n};\r\n\r\nModeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints) {\r\n  var context = {\r\n    connection: connection,\r\n    newSource: newSource,\r\n    dockingOrPoints: dockingOrPoints\r\n  };\r\n\r\n  this._commandStack.execute('connection.reconnectStart', context);\r\n};\r\n\r\nModeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints) {\r\n  var context = {\r\n    connection: connection,\r\n    newTarget: newTarget,\r\n    dockingOrPoints: dockingOrPoints\r\n  };\r\n\r\n  this._commandStack.execute('connection.reconnectEnd', context);\r\n};\r\n\r\nModeling.prototype.connect = function(source, target, attrs, hints) {\r\n  return this.createConnection(source, target, attrs || {}, source.parent, hints);\r\n};\r\n\r\nModeling.prototype._create = function(type, attrs) {\r\n  if (attrs instanceof model.Base) {\r\n    return attrs;\r\n  } else {\r\n    return this._elementFactory.create(type, attrs);\r\n  }\r\n};\r\n\r\nModeling.prototype.toggleCollapse = function(shape, hints) {\r\n  var context = {\r\n    shape: shape,\r\n    hints: hints || {}\r\n  };\r\n\r\n  this._commandStack.execute('shape.toggleCollapse', context);\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\n/**\r\n * A handler that align elements in a certain way.\r\n *\r\n */\r\nfunction AlignElements(modeling, canvas) {\r\n  this._modeling = modeling;\r\n  this._canvas = canvas;\r\n}\r\n\r\nAlignElements.$inject = [ 'modeling', 'canvas' ];\r\n\r\nmodule.exports = AlignElements;\r\n\r\n\r\nAlignElements.prototype.preExecute = function(context) {\r\n  var modeling = this._modeling;\r\n\r\n  var elements = context.elements,\r\n      alignment = context.alignment;\r\n\r\n\r\n  forEach(elements, function(element) {\r\n    var delta = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n\r\n    if (alignment.left) {\r\n      delta.x = alignment.left - element.x;\r\n\r\n    } else if (alignment.right) {\r\n      delta.x = (alignment.right - element.width) - element.x;\r\n\r\n    } else if (alignment.center) {\r\n      delta.x = (alignment.center - Math.round(element.width / 2)) - element.x;\r\n\r\n    } else if (alignment.top) {\r\n      delta.y = alignment.top - element.y;\r\n\r\n    } else if (alignment.bottom) {\r\n      delta.y = (alignment.bottom - element.height) - element.y;\r\n\r\n    } else if (alignment.middle) {\r\n      delta.y = (alignment.middle - Math.round(element.height / 2)) - element.y;\r\n    }\r\n\r\n    modeling.moveElements([ element ], delta, element.parent);\r\n  });\r\n};\r\n\r\nAlignElements.prototype.postExecute = function(context) {\r\n\r\n};\r\n","'use strict';\r\n\r\nvar any = require(382);\r\n\r\nvar inherits = require(368);\r\n\r\n\r\n/**\r\n * A handler that implements reversible appending of shapes\r\n * to a source shape.\r\n *\r\n * @param {canvas} Canvas\r\n * @param {elementFactory} ElementFactory\r\n * @param {modeling} Modeling\r\n */\r\nfunction AppendShapeHandler(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\ninherits(AppendShapeHandler, require(268));\r\n\r\n\r\nAppendShapeHandler.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = AppendShapeHandler;\r\n\r\n\r\n////// api /////////////////////////////////////////////\r\n\r\n/**\r\n * Creates a new shape\r\n *\r\n * @param {Object} context\r\n * @param {ElementDescriptor} context.shape the new shape\r\n * @param {ElementDescriptor} context.source the source object\r\n * @param {ElementDescriptor} context.parent the parent object\r\n * @param {Point} context.position position of the new element\r\n */\r\nAppendShapeHandler.prototype.preExecute = function(context) {\r\n\r\n  if (!context.source) {\r\n    throw new Error('source required');\r\n  }\r\n\r\n  var parent = context.parent || context.source.parent,\r\n      shape = this._modeling.createShape(context.shape, context.position, parent);\r\n\r\n  context.shape = shape;\r\n};\r\n\r\nAppendShapeHandler.prototype.postExecute = function(context) {\r\n  var parent = context.connectionParent || context.shape.parent;\r\n\r\n  if (!existsConnection(context.source, context.shape)) {\r\n\r\n    // create connection\r\n    this._modeling.connect(context.source, context.shape, context.connection, parent);\r\n  }\r\n};\r\n\r\n\r\nfunction existsConnection(source, target) {\r\n  return any(source.outgoing, function(c) {\r\n    return c.target === target;\r\n  });\r\n}","'use strict';\r\n\r\n\r\nfunction CreateConnectionHandler(canvas, layouter) {\r\n  this._canvas = canvas;\r\n  this._layouter = layouter;\r\n}\r\n\r\nCreateConnectionHandler.$inject = [ 'canvas', 'layouter' ];\r\n\r\nmodule.exports = CreateConnectionHandler;\r\n\r\n\r\n\r\n////// api /////////////////////////////////////////\r\n\r\n/**\r\n * Appends a shape to a target shape\r\n *\r\n * @param {Object} context\r\n * @param {djs.element.Base} context.source the source object\r\n * @param {djs.element.Base} context.target the parent object\r\n * @param {Point} context.position position of the new element\r\n */\r\nCreateConnectionHandler.prototype.execute = function(context) {\r\n\r\n  var connection = context.connection,\r\n      source = context.source,\r\n      target = context.target,\r\n      parent = context.parent,\r\n      parentIndex = context.parentIndex,\r\n      hints = context.hints;\r\n\r\n  if (!source || !target) {\r\n    throw new Error('source and target required');\r\n  }\r\n\r\n  if (!parent) {\r\n    throw new Error('parent required');\r\n  }\r\n\r\n  connection.source = source;\r\n  connection.target = target;\r\n\r\n  if (!connection.waypoints) {\r\n    connection.waypoints = this._layouter.layoutConnection(connection, hints);\r\n  }\r\n\r\n  // add connection\r\n  this._canvas.addConnection(connection, parent, parentIndex);\r\n\r\n  return connection;\r\n};\r\n\r\nCreateConnectionHandler.prototype.revert = function(context) {\r\n  var connection = context.connection;\r\n\r\n  this._canvas.removeConnection(connection);\r\n\r\n  connection.source = null;\r\n  connection.target = null;\r\n};","'use strict';\r\n\r\nvar inherits = require(368);\r\n\r\nvar CreateShapeHandler = require(259);\r\n\r\n\r\n/**\r\n * A handler that attaches a label to a given target shape.\r\n *\r\n * @param {canvas} Canvas\r\n */\r\nfunction CreateLabelHandler(canvas) {\r\n  CreateShapeHandler.call(this, canvas);\r\n}\r\n\r\ninherits(CreateLabelHandler, CreateShapeHandler);\r\n\r\nCreateLabelHandler.$inject = [ 'canvas' ];\r\n\r\nmodule.exports = CreateLabelHandler;\r\n\r\n\r\n\r\n////// api /////////////////////////////////////////\r\n\r\n\r\nvar originalExecute = CreateShapeHandler.prototype.execute;\r\n\r\n/**\r\n * Appends a label to a target shape.\r\n *\r\n * @method CreateLabelHandler#execute\r\n *\r\n * @param {Object} context\r\n * @param {ElementDescriptor} context.target the element the label is attached to\r\n * @param {ElementDescriptor} context.parent the parent object\r\n * @param {Point} context.position position of the new element\r\n */\r\nCreateLabelHandler.prototype.execute = function(context) {\r\n\r\n  var label = context.shape;\r\n\r\n  ensureValidDimensions(label);\r\n\r\n  label.labelTarget = context.labelTarget;\r\n\r\n  return originalExecute.call(this, context);\r\n};\r\n\r\nvar originalRevert = CreateShapeHandler.prototype.revert;\r\n\r\n/**\r\n * Undo append by removing the shape\r\n */\r\nCreateLabelHandler.prototype.revert = function(context) {\r\n  context.shape.labelTarget = null;\r\n\r\n  return originalRevert.call(this, context);\r\n};\r\n\r\n\r\n////// helpers /////////////////////////////////////////\r\n\r\nfunction ensureValidDimensions(label) {\r\n  // make sure a label has valid { width, height } dimensions\r\n  [ 'width', 'height' ].forEach(function(prop) {\r\n    if (typeof label[prop] === 'undefined') {\r\n      label[prop] = 0;\r\n    }\r\n  });\r\n}","'use strict';\r\n\r\nvar assign = require(516);\r\n\r\nvar round = Math.round;\r\n\r\n\r\n/**\r\n * A handler that implements reversible addition of shapes.\r\n *\r\n * @param {canvas} Canvas\r\n */\r\nfunction CreateShapeHandler(canvas) {\r\n  this._canvas = canvas;\r\n}\r\n\r\nCreateShapeHandler.$inject = [ 'canvas' ];\r\n\r\nmodule.exports = CreateShapeHandler;\r\n\r\n\r\n\r\n////// api /////////////////////////////////////////\r\n\r\n\r\n/**\r\n * Appends a shape to a target shape\r\n *\r\n * @param {Object} context\r\n * @param {djs.model.Base} context.parent the parent object\r\n * @param {Point} context.position position of the new element\r\n */\r\nCreateShapeHandler.prototype.execute = function(context) {\r\n\r\n  var shape = context.shape,\r\n      positionOrBounds = context.position,\r\n      parent = context.parent,\r\n      parentIndex = context.parentIndex;\r\n\r\n  if (!parent) {\r\n    throw new Error('parent required');\r\n  }\r\n\r\n  if (!positionOrBounds) {\r\n    throw new Error('position required');\r\n  }\r\n\r\n  // (1) add at event center position _or_ at given bounds\r\n  if (positionOrBounds.width !== undefined) {\r\n    assign(shape, positionOrBounds);\r\n  } else {\r\n    assign(shape, {\r\n      x: positionOrBounds.x - round(shape.width / 2),\r\n      y: positionOrBounds.y - round(shape.height / 2)\r\n    });\r\n  }\r\n\r\n  // (2) add to canvas\r\n  this._canvas.addShape(shape, parent, parentIndex);\r\n\r\n  return shape;\r\n};\r\n\r\n\r\n/**\r\n * Undo append by removing the shape\r\n */\r\nCreateShapeHandler.prototype.revert = function(context) {\r\n\r\n  // (3) remove form canvas\r\n  this._canvas.removeShape(context.shape);\r\n};","'use strict';\r\n\r\nvar Collections = require(340);\r\n\r\n\r\n/**\r\n * A handler that implements reversible deletion of Connections.\r\n *\r\n */\r\nfunction DeleteConnectionHandler(canvas, modeling) {\r\n  this._canvas = canvas;\r\n  this._modeling = modeling;\r\n}\r\n\r\nDeleteConnectionHandler.$inject = [ 'canvas', 'modeling' ];\r\n\r\nmodule.exports = DeleteConnectionHandler;\r\n\r\n\r\n/**\r\n * - Remove attached label\r\n */\r\nDeleteConnectionHandler.prototype.preExecute = function(context) {\r\n\r\n  var connection = context.connection;\r\n\r\n  // Remove label\r\n  if (connection.label) {\r\n    this._modeling.removeShape(connection.label);\r\n  }\r\n};\r\n\r\nDeleteConnectionHandler.prototype.execute = function(context) {\r\n\r\n  var connection = context.connection,\r\n      parent = connection.parent;\r\n\r\n  context.parent = parent;\r\n  context.parentIndex = Collections.indexOf(parent.children, connection);\r\n\r\n  context.source = connection.source;\r\n  context.target = connection.target;\r\n\r\n  this._canvas.removeConnection(connection);\r\n\r\n  connection.source = null;\r\n  connection.target = null;\r\n  connection.label  = null;\r\n\r\n  return connection;\r\n};\r\n\r\n/**\r\n * Command revert implementation.\r\n */\r\nDeleteConnectionHandler.prototype.revert = function(context) {\r\n\r\n  var connection = context.connection,\r\n      parent = context.parent,\r\n      parentIndex = context.parentIndex;\r\n\r\n  connection.source = context.source;\r\n  connection.target = context.target;\r\n\r\n  // restore previous location in old parent\r\n  Collections.add(parent.children, connection, parentIndex);\r\n\r\n  this._canvas.addConnection(connection, parent);\r\n\r\n  return connection;\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    inherits = require(368);\r\n\r\n\r\nfunction DeleteElementsHandler(modeling, elementRegistry) {\r\n  this._modeling = modeling;\r\n  this._elementRegistry = elementRegistry;\r\n}\r\n\r\ninherits(DeleteElementsHandler, require(268));\r\n\r\nDeleteElementsHandler.$inject = [ 'modeling', 'elementRegistry' ];\r\n\r\nmodule.exports = DeleteElementsHandler;\r\n\r\n\r\nDeleteElementsHandler.prototype.postExecute = function(context) {\r\n\r\n  var modeling = this._modeling,\r\n      elementRegistry = this._elementRegistry,\r\n      elements = context.elements;\r\n\r\n  forEach(elements, function(element) {\r\n\r\n    // element may have been removed with previous\r\n    // remove operations already (e.g. in case of nesting)\r\n    if (!elementRegistry.get(element.id)) {\r\n      return;\r\n    }\r\n\r\n    if (element.waypoints) {\r\n      modeling.removeConnection(element);\r\n    } else {\r\n      modeling.removeShape(element);\r\n    }\r\n  });\r\n};","'use strict';\r\n\r\nvar Collections = require(340);\r\n\r\nvar saveClear = require(354).saveClear;\r\n\r\n\r\n/**\r\n * A handler that implements reversible deletion of shapes.\r\n *\r\n */\r\nfunction DeleteShapeHandler(canvas, modeling) {\r\n  this._canvas = canvas;\r\n  this._modeling = modeling;\r\n}\r\n\r\nDeleteShapeHandler.$inject = [ 'canvas', 'modeling' ];\r\n\r\nmodule.exports = DeleteShapeHandler;\r\n\r\n\r\n/**\r\n * - Remove connections\r\n * - Remove all direct children\r\n */\r\nDeleteShapeHandler.prototype.preExecute = function(context) {\r\n\r\n  var modeling = this._modeling;\r\n\r\n  var shape = context.shape,\r\n      label = shape.label;\r\n\r\n  // Clean up on removeShape(label)\r\n  if (shape.labelTarget) {\r\n    context.labelTarget = shape.labelTarget;\r\n    shape.labelTarget = null;\r\n  }\r\n\r\n  // Remove label\r\n  if (label) {\r\n    this._modeling.removeShape(label, { nested: true });\r\n  }\r\n\r\n  // remove connections\r\n  saveClear(shape.incoming, function(connection) {\r\n    // To make sure that the connection isn't removed twice\r\n    // For example if a container is removed\r\n    modeling.removeConnection(connection, { nested: true });\r\n  });\r\n\r\n  saveClear(shape.outgoing, function(connection) {\r\n    modeling.removeConnection(connection, { nested: true });\r\n  });\r\n\r\n  // remove child shapes and connections\r\n  saveClear(shape.children, function(child) {\r\n    if (isConnection(child)) {\r\n      modeling.removeConnection(child, { nested: true });\r\n    } else {\r\n      modeling.removeShape(child, { nested: true });\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Remove shape and remember the parent\r\n */\r\nDeleteShapeHandler.prototype.execute = function(context) {\r\n  var canvas = this._canvas;\r\n\r\n  var shape = context.shape,\r\n      oldParent = shape.parent;\r\n\r\n  context.oldParent = oldParent;\r\n  context.oldParentIndex = Collections.indexOf(oldParent.children, shape);\r\n\r\n  shape.label = null;\r\n\r\n  canvas.removeShape(shape);\r\n\r\n  return shape;\r\n};\r\n\r\n\r\n/**\r\n * Command revert implementation\r\n */\r\nDeleteShapeHandler.prototype.revert = function(context) {\r\n\r\n  var canvas = this._canvas;\r\n\r\n  var shape = context.shape,\r\n      oldParent = context.oldParent,\r\n      oldParentIndex = context.oldParentIndex,\r\n      labelTarget = context.labelTarget;\r\n\r\n  // restore previous location in old oldParent\r\n  Collections.add(oldParent.children, shape, oldParentIndex);\r\n\r\n  if (labelTarget) {\r\n    labelTarget.label = shape;\r\n  }\r\n\r\n  canvas.addShape(shape, oldParent);\r\n\r\n  return shape;\r\n};\r\n\r\nfunction isConnection(element) {\r\n  return element.waypoints;\r\n}\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    sortBy = require(394);\r\n\r\n/**\r\n * A handler that distributes elements evenly.\r\n */\r\nfunction DistributeElements(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nDistributeElements.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = DistributeElements;\r\n\r\nvar OFF_AXIS = {\r\n  x: 'y',\r\n  y: 'x'\r\n};\r\n\r\nDistributeElements.prototype.preExecute = function(context) {\r\n  var modeling = this._modeling;\r\n\r\n  var groups = context.groups,\r\n      axis = context.axis,\r\n      dimension = context.dimension;\r\n\r\n  function updateRange(group, element) {\r\n    group.range.min = Math.min(element[axis], group.range.min);\r\n    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);\r\n  }\r\n\r\n  function center(element) {\r\n    return element[axis] + element[dimension] / 2;\r\n  }\r\n\r\n  function lastIdx(arr) {\r\n    return arr.length - 1;\r\n  }\r\n\r\n  function rangeDiff(range) {\r\n    return range.max - range.min;\r\n  }\r\n\r\n  function centerElement(refCenter, element) {\r\n    var delta = { y: 0 };\r\n\r\n    delta[axis] = refCenter - center(element);\r\n\r\n    if (delta[axis]) {\r\n\r\n      delta[OFF_AXIS[axis]] = 0;\r\n\r\n      modeling.moveElements([ element ], delta, element.parent);\r\n    }\r\n  }\r\n\r\n  var firstGroup = groups[0],\r\n      lastGroupIdx = lastIdx(groups),\r\n      lastGroup = groups[ lastGroupIdx ];\r\n\r\n  var margin,\r\n      spaceInBetween,\r\n      groupsSize = 0; // the size of each range\r\n\r\n  forEach(groups, function(group, idx) {\r\n    var sortedElements,\r\n        refElem,\r\n        refCenter;\r\n\r\n    if (group.elements.length < 2) {\r\n      if (idx && idx !== groups.length - 1) {\r\n        updateRange(group, group.elements[0]);\r\n\r\n        groupsSize += rangeDiff(group.range);\r\n      }\r\n      return;\r\n    }\r\n\r\n    sortedElements = sortBy(group.elements, axis);\r\n\r\n    refElem = sortedElements[0];\r\n\r\n    if (idx === lastGroupIdx) {\r\n      refElem = sortedElements[lastIdx(sortedElements)];\r\n    }\r\n\r\n    refCenter = center(refElem);\r\n\r\n    // wanna update the ranges after the shapes have been centered\r\n    group.range = null;\r\n\r\n    forEach(sortedElements, function(element) {\r\n\r\n      centerElement(refCenter, element);\r\n\r\n      if (group.range === null) {\r\n        group.range = {\r\n          min: element[axis],\r\n          max: element[axis] + element[dimension]\r\n        };\r\n\r\n        return;\r\n      }\r\n\r\n      // update group's range after centering the range elements\r\n      updateRange(group, element);\r\n    });\r\n\r\n    if (idx && idx !== groups.length - 1) {\r\n      groupsSize += rangeDiff(group.range);\r\n    }\r\n  });\r\n\r\n  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);\r\n\r\n  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));\r\n\r\n  if (margin < groups.length - 1) {\r\n    return;\r\n  }\r\n\r\n  forEach(groups, function(group, groupIdx) {\r\n    var delta = {},\r\n        prevGroup;\r\n\r\n    if (group === firstGroup || group === lastGroup) {\r\n      return;\r\n    }\r\n\r\n    prevGroup = groups[groupIdx - 1];\r\n\r\n    group.range.max = 0;\r\n\r\n    forEach(group.elements, function(element, idx) {\r\n      delta[OFF_AXIS[axis]] = 0;\r\n      delta[axis] = (prevGroup.range.max - element[axis]) + margin;\r\n\r\n      if (group.range.min !== element[axis]) {\r\n        delta[axis] += element[axis] - group.range.min;\r\n      }\r\n\r\n      if (delta[axis]) {\r\n        modeling.moveElements([ element ], delta, element.parent);\r\n      }\r\n\r\n      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);\r\n    });\r\n  });\r\n};\r\n\r\nDistributeElements.prototype.postExecute = function(context) {\r\n\r\n};\r\n","'use strict';\r\n\r\nvar assign = require(516);\r\n\r\n\r\n/**\r\n * A handler that implements reversible moving of shapes.\r\n */\r\nfunction LayoutConnectionHandler(layouter, canvas) {\r\n  this._layouter = layouter;\r\n  this._canvas = canvas;\r\n}\r\n\r\nLayoutConnectionHandler.$inject = [ 'layouter', 'canvas' ];\r\n\r\nmodule.exports = LayoutConnectionHandler;\r\n\r\nLayoutConnectionHandler.prototype.execute = function(context) {\r\n\r\n  var connection = context.connection;\r\n\r\n  var oldWaypoints = connection.waypoints;\r\n\r\n  assign(context, {\r\n    oldWaypoints: oldWaypoints\r\n  });\r\n\r\n  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);\r\n\r\n  return connection;\r\n};\r\n\r\nLayoutConnectionHandler.prototype.revert = function(context) {\r\n\r\n  var connection = context.connection;\r\n\r\n  connection.waypoints = context.oldWaypoints;\r\n\r\n  return connection;\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar Collections = require(340);\r\n\r\n\r\n/**\r\n * A handler that implements reversible moving of connections.\r\n *\r\n * The handler differs from the layout connection handler in a sense\r\n * that it preserves the connection layout.\r\n */\r\nfunction MoveConnectionHandler() { }\r\n\r\nmodule.exports = MoveConnectionHandler;\r\n\r\n\r\nMoveConnectionHandler.prototype.execute = function(context) {\r\n\r\n  var connection = context.connection,\r\n      delta = context.delta;\r\n\r\n  var newParent = context.newParent || connection.parent,\r\n      newParentIndex = context.newParentIndex,\r\n      oldParent = connection.parent;\r\n\r\n  // save old parent in context\r\n  context.oldParent = oldParent;\r\n  context.oldParentIndex = Collections.remove(oldParent.children, connection);\r\n\r\n  // add to new parent at position\r\n  Collections.add(newParent.children, connection, newParentIndex);\r\n\r\n  // update parent\r\n  connection.parent = newParent;\r\n\r\n  // update waypoint positions\r\n  forEach(connection.waypoints, function(p) {\r\n    p.x += delta.x;\r\n    p.y += delta.y;\r\n\r\n    if (p.original) {\r\n      p.original.x += delta.x;\r\n      p.original.y += delta.y;\r\n    }\r\n  });\r\n\r\n  return connection;\r\n};\r\n\r\nMoveConnectionHandler.prototype.revert = function(context) {\r\n\r\n  var connection = context.connection,\r\n      newParent = connection.parent,\r\n      oldParent = context.oldParent,\r\n      oldParentIndex = context.oldParentIndex,\r\n      delta = context.delta;\r\n\r\n  // remove from newParent\r\n  Collections.remove(newParent.children, connection);\r\n\r\n  // restore previous location in old parent\r\n  Collections.add(oldParent.children, connection, oldParentIndex);\r\n\r\n  // restore parent\r\n  connection.parent = oldParent;\r\n\r\n  // revert to old waypoint positions\r\n  forEach(connection.waypoints, function(p) {\r\n    p.x -= delta.x;\r\n    p.y -= delta.y;\r\n\r\n    if (p.original) {\r\n      p.original.x -= delta.x;\r\n      p.original.y -= delta.y;\r\n    }\r\n  });\r\n\r\n  return connection;\r\n};","'use strict';\r\n\r\nvar MoveHelper = require(278);\r\n\r\n\r\n/**\r\n * A handler that implements reversible moving of shapes.\r\n */\r\nfunction MoveElementsHandler(modeling) {\r\n  this._helper = new MoveHelper(modeling);\r\n}\r\n\r\nMoveElementsHandler.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = MoveElementsHandler;\r\n\r\nMoveElementsHandler.prototype.preExecute = function(context) {\r\n  context.closure = this._helper.getClosure(context.shapes);\r\n};\r\n\r\nMoveElementsHandler.prototype.postExecute = function(context) {\r\n\r\n  var hints = context.hints,\r\n      primaryShape;\r\n\r\n  if (hints && hints.primaryShape) {\r\n    primaryShape = hints.primaryShape;\r\n    hints.oldParent = primaryShape.parent;\r\n  }\r\n\r\n  this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);\r\n};\r\n\r\n\r\nMoveElementsHandler.prototype.execute = function(context) { };\r\nMoveElementsHandler.prototype.revert = function(context) { };\r\n","'use strict';\r\n\r\nvar assign = require(516),\r\n    forEach = require(386),\r\n    pick = require(524);\r\n\r\nvar MoveHelper = require(278),\r\n    Collections = require(340);\r\n\r\nvar getMovedSourceAnchor = require(277).getMovedSourceAnchor,\r\n    getMovedTargetAnchor = require(277).getMovedTargetAnchor;\r\n\r\n\r\n/**\r\n * A handler that implements reversible moving of shapes.\r\n */\r\nfunction MoveShapeHandler(modeling) {\r\n  this._modeling = modeling;\r\n\r\n  this._helper = new MoveHelper(modeling);\r\n}\r\n\r\nMoveShapeHandler.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = MoveShapeHandler;\r\n\r\n\r\nMoveShapeHandler.prototype.execute = function(context) {\r\n\r\n  var shape = context.shape,\r\n      delta = context.delta,\r\n      newParent = context.newParent || shape.parent,\r\n      newParentIndex = context.newParentIndex,\r\n      oldParent = shape.parent;\r\n\r\n  context.oldBounds = pick(shape, [ 'x', 'y', 'width', 'height']);\r\n\r\n  // save old parent in context\r\n  context.oldParent = oldParent;\r\n  context.oldParentIndex = Collections.remove(oldParent.children, shape);\r\n\r\n  // add to new parent at position\r\n  Collections.add(newParent.children, shape, newParentIndex);\r\n\r\n  // update shape parent + position\r\n  assign(shape, {\r\n    parent: newParent,\r\n    x: shape.x + delta.x,\r\n    y: shape.y + delta.y\r\n  });\r\n\r\n  return shape;\r\n};\r\n\r\nMoveShapeHandler.prototype.postExecute = function(context) {\r\n\r\n  var shape = context.shape,\r\n      delta = context.delta,\r\n      hints = context.hints;\r\n\r\n  var modeling = this._modeling;\r\n\r\n  if (hints.layout !== false) {\r\n\r\n    forEach(shape.incoming, function(c) {\r\n      modeling.layoutConnection(c, {\r\n        connectionEnd: getMovedTargetAnchor(c, shape, delta)\r\n      });\r\n    });\r\n\r\n    forEach(shape.outgoing, function(c) {\r\n      modeling.layoutConnection(c, {\r\n        connectionStart: getMovedSourceAnchor(c, shape, delta)\r\n      });\r\n    });\r\n  }\r\n\r\n  if (hints.recurse !== false) {\r\n    this.moveChildren(context);\r\n  }\r\n};\r\n\r\nMoveShapeHandler.prototype.revert = function(context) {\r\n\r\n  var shape = context.shape,\r\n      oldParent = context.oldParent,\r\n      oldParentIndex = context.oldParentIndex,\r\n      delta = context.delta;\r\n\r\n  // restore previous location in old parent\r\n  Collections.add(oldParent.children, shape, oldParentIndex);\r\n\r\n  // revert to old position and parent\r\n  assign(shape, {\r\n    parent: oldParent,\r\n    x: shape.x - delta.x,\r\n    y: shape.y - delta.y\r\n  });\r\n\r\n  return shape;\r\n};\r\n\r\nMoveShapeHandler.prototype.moveChildren = function(context) {\r\n\r\n  var delta = context.delta,\r\n      shape = context.shape;\r\n\r\n  this._helper.moveRecursive(shape.children, delta, null);\r\n};\r\n\r\nMoveShapeHandler.prototype.getNewParent = function(context) {\r\n  return context.newParent || context.shape.parent;\r\n};\r\n","'use strict';\r\n\r\nfunction NoopHandler() {}\r\n\r\nmodule.exports = NoopHandler;\r\n\r\nNoopHandler.prototype.execute = function() {};\r\nNoopHandler.prototype.revert = function() {};","'use strict';\r\n\r\nvar forEach = require(386),\r\n    map = require(389),\r\n    sortBy = require(394),\r\n    clone = require(504);\r\n\r\nvar inherits = require(368);\r\n\r\n\r\n\r\nfunction removeProperties(element, properties) {\r\n  forEach(properties, function(prop) {\r\n    if (element[prop]) {\r\n      delete element[prop];\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * A handler that implements pasting of elements onto the diagram.\r\n *\r\n * @param {eventBus} EventBus\r\n * @param {canvas} Canvas\r\n * @param {selection} Selection\r\n * @param {elementFactory} ElementFactory\r\n * @param {modeling} Modeling\r\n * @param {rules} Rules\r\n */\r\nfunction PasteHandler(eventBus, canvas, selection, elementFactory, modeling, rules) {\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n  this._selection = selection;\r\n  this._elementFactory = elementFactory;\r\n  this._modeling = modeling;\r\n  this._rules = rules;\r\n}\r\n\r\ninherits(PasteHandler, require(268));\r\n\r\n\r\nPasteHandler.$inject = [\r\n  'eventBus',\r\n  'canvas',\r\n  'selection',\r\n  'elementFactory',\r\n  'modeling',\r\n  'rules'\r\n];\r\n\r\nmodule.exports = PasteHandler;\r\n\r\n\r\n////// api /////////////////////////////////////////////\r\n\r\n/**\r\n * Creates a new shape\r\n *\r\n * @param {Object} context\r\n * @param {Object} context.tree the new shape\r\n * @param {Element} context.topParent the paste target\r\n */\r\nPasteHandler.prototype.preExecute = function(context) {\r\n  var eventBus = this._eventBus;\r\n\r\n  var tree = context.tree,\r\n      topParent = context.topParent,\r\n      position = context.position;\r\n\r\n  tree.createdElements = {};\r\n\r\n  tree.labels = [];\r\n\r\n  forEach(tree, function(elements, depthStr) {\r\n    var depth = parseInt(depthStr, 10);\r\n\r\n    if (isNaN(depth)) {\r\n      return;\r\n    }\r\n\r\n    // set the parent on the top level elements\r\n    if (!depth) {\r\n      elements = map(elements, function(descriptor) {\r\n        descriptor.parent = topParent;\r\n\r\n        return descriptor;\r\n      });\r\n    }\r\n\r\n    // Order by priority for element creation\r\n    elements = sortBy(elements, 'priority');\r\n\r\n    forEach(elements, function(descriptor) {\r\n      var id = descriptor.id,\r\n          parent = descriptor.parent,\r\n          isAttach = false,\r\n          hints,\r\n          newPosition;\r\n\r\n      var element = clone(descriptor);\r\n\r\n      if (depth) {\r\n        element.parent = this._getCreatedElement(parent, tree);\r\n      }\r\n\r\n      // this happens when shapes have not been created due to rules\r\n      if (!parent) {\r\n        return;\r\n      }\r\n\r\n      eventBus.fire('element.paste', {\r\n        createdElements: tree.createdElements,\r\n        descriptor: element\r\n      });\r\n\r\n      // in case the parent changed during 'element.paste'\r\n      parent = element.parent;\r\n\r\n      if (element.waypoints) {\r\n        element = this._createConnection(element, parent, position, tree);\r\n\r\n        if (element) {\r\n          tree.createdElements[id] = {\r\n            element: element,\r\n            descriptor: descriptor\r\n          };\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      // supply not-root information as hint\r\n      if (element.parent !== topParent) {\r\n        hints = { root: false };\r\n      }\r\n\r\n      // set host\r\n      if (element.host) {\r\n        isAttach = true;\r\n\r\n        parent = this._getCreatedElement(element.host, tree);\r\n      }\r\n\r\n      // handle labels\r\n      if (element.labelTarget) {\r\n        return tree.labels.push(element);\r\n      }\r\n\r\n      newPosition = {\r\n        x: Math.round(position.x + element.delta.x + (element.width / 2)),\r\n        y: Math.round(position.y + element.delta.y + (element.height / 2))\r\n      };\r\n\r\n      removeProperties(element, [ 'id', 'parent', 'delta', 'host', 'priority' ]);\r\n\r\n      element = this._createShape(element, parent, newPosition, isAttach, hints);\r\n\r\n      if (element) {\r\n        tree.createdElements[id] = {\r\n          element: element,\r\n          descriptor: descriptor\r\n        };\r\n      }\r\n    }, this);\r\n  }, this);\r\n};\r\n\r\n// move label's to their relative position\r\nPasteHandler.prototype.postExecute = function(context) {\r\n  var modeling = this._modeling,\r\n      selection = this._selection;\r\n\r\n  var tree = context.tree,\r\n      labels = tree.labels,\r\n      topLevelElements = [];\r\n\r\n  forEach(labels, function(labelDescriptor) {\r\n    var labelTarget = this._getCreatedElement(labelDescriptor.labelTarget, tree),\r\n        label, labelTargetPos, newPosition;\r\n\r\n    if (!labelTarget) {\r\n      return;\r\n    }\r\n\r\n    label = labelTarget.label;\r\n\r\n    if (!label) {\r\n      return;\r\n    }\r\n\r\n    labelTargetPos = {\r\n      x: labelTarget.x,\r\n      y: labelTarget.y\r\n    };\r\n\r\n    if (labelTarget.waypoints) {\r\n      labelTargetPos = labelTarget.waypoints[0];\r\n    }\r\n\r\n    newPosition = {\r\n      x: Math.round((labelTargetPos.x - label.x) + labelDescriptor.delta.x),\r\n      y: Math.round((labelTargetPos.y - label.y) + labelDescriptor.delta.y)\r\n    };\r\n\r\n    modeling.moveShape(label, newPosition, labelTarget.parent);\r\n  }, this);\r\n\r\n  forEach(tree[0], function(descriptor) {\r\n    var id = descriptor.id,\r\n        toplevel = tree.createdElements[id];\r\n\r\n    if (toplevel) {\r\n      topLevelElements.push(toplevel.element);\r\n    }\r\n  });\r\n\r\n  selection.select(topLevelElements);\r\n};\r\n\r\n\r\nPasteHandler.prototype._createConnection = function(element, parent, parentCenter, tree) {\r\n  var modeling = this._modeling,\r\n      rules = this._rules;\r\n\r\n  var connection, source, target, canPaste;\r\n\r\n  element.waypoints = map(element.waypoints, function(waypoint, idx) {\r\n    return {\r\n      x: Math.round(parentCenter.x + element.delta[idx].x),\r\n      y: Math.round(parentCenter.y + element.delta[idx].y)\r\n    };\r\n  });\r\n\r\n  source = this._getCreatedElement(element.source, tree);\r\n  target = this._getCreatedElement(element.target, tree);\r\n\r\n  if (!source || !target) {\r\n    return null;\r\n  }\r\n\r\n  canPaste = rules.allowed('element.paste', {\r\n    source: source,\r\n    target: target\r\n  });\r\n\r\n  if (!canPaste) {\r\n    return null;\r\n  }\r\n\r\n  removeProperties(element, [ 'id', 'parent', 'delta', 'source', 'target', 'width', 'height', 'priority' ]);\r\n\r\n  connection = modeling.createConnection(source, target, element, parent);\r\n\r\n  return connection;\r\n};\r\n\r\n\r\nPasteHandler.prototype._createShape = function(element, parent, position, isAttach, hints) {\r\n  var modeling = this._modeling,\r\n      elementFactory = this._elementFactory,\r\n      rules = this._rules;\r\n\r\n  var canPaste = rules.allowed('element.paste', {\r\n    element: element,\r\n    position: position,\r\n    parent: parent\r\n  });\r\n\r\n  if (!canPaste) {\r\n    return null;\r\n  }\r\n\r\n  var shape = elementFactory.createShape(element);\r\n\r\n  modeling.createShape(shape, position, parent, isAttach, hints);\r\n\r\n  return shape;\r\n};\r\n\r\n\r\nPasteHandler.prototype._getCreatedElement = function(id, tree) {\r\n  return tree.createdElements[id] && tree.createdElements[id].element;\r\n};\r\n","'use strict';\r\n\r\nvar isArray = require(506);\r\n\r\n\r\n/**\r\n * Reconnect connection handler\r\n */\r\nfunction ReconnectConnectionHandler() { }\r\n\r\nReconnectConnectionHandler.$inject = [ ];\r\n\r\nmodule.exports = ReconnectConnectionHandler;\r\n\r\nReconnectConnectionHandler.prototype.execute = function(context) {\r\n\r\n  var newSource = context.newSource,\r\n      newTarget = context.newTarget,\r\n      connection = context.connection,\r\n      dockingOrPoints = context.dockingOrPoints,\r\n      oldWaypoints = connection.waypoints,\r\n      newWaypoints;\r\n\r\n  if (!newSource && !newTarget) {\r\n    throw new Error('newSource or newTarget are required');\r\n  }\r\n\r\n  if (newSource && newTarget) {\r\n    throw new Error('must specify either newSource or newTarget');\r\n  }\r\n\r\n  context.oldWaypoints = oldWaypoints;\r\n\r\n  if (isArray(dockingOrPoints)) {\r\n    newWaypoints = dockingOrPoints;\r\n  } else {\r\n    newWaypoints = oldWaypoints.slice();\r\n\r\n    newWaypoints.splice(newSource ? 0 : -1, 1, dockingOrPoints);\r\n  }\r\n\r\n  if (newSource) {\r\n    context.oldSource = connection.source;\r\n    connection.source = newSource;\r\n  }\r\n\r\n  if (newTarget) {\r\n    context.oldTarget = connection.target;\r\n    connection.target = newTarget;\r\n  }\r\n\r\n  connection.waypoints = newWaypoints;\r\n\r\n  return connection;\r\n};\r\n\r\nReconnectConnectionHandler.prototype.revert = function(context) {\r\n\r\n  var newSource = context.newSource,\r\n      newTarget = context.newTarget,\r\n      connection = context.connection;\r\n\r\n  if (newSource) {\r\n    connection.source = context.oldSource;\r\n  }\r\n\r\n  if (newTarget) {\r\n    connection.target = context.oldTarget;\r\n  }\r\n\r\n  connection.waypoints = context.oldWaypoints;\r\n\r\n  return connection;\r\n};","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\n\r\n/**\r\n * A handler that implements reversible replacing of shapes.\r\n * Internally the old shape will be removed and the new shape will be added.\r\n *\r\n *\r\n * @class\r\n * @constructor\r\n *\r\n * @param {canvas} Canvas\r\n */\r\nfunction ReplaceShapeHandler(modeling, rules) {\r\n  this._modeling = modeling;\r\n  this._rules = rules;\r\n}\r\n\r\nReplaceShapeHandler.$inject = [ 'modeling', 'rules' ];\r\n\r\nmodule.exports = ReplaceShapeHandler;\r\n\r\n\r\n\r\n////// api /////////////////////////////////////////\r\n\r\n\r\n/**\r\n * Replaces a shape with an replacement Element.\r\n *\r\n * The newData object should contain type, x, y.\r\n *\r\n * If possible also the incoming/outgoing connection\r\n * will be restored.\r\n *\r\n * @param {Object} context\r\n */\r\nReplaceShapeHandler.prototype.preExecute = function(context) {\r\n\r\n  var self = this,\r\n      modeling = this._modeling,\r\n      rules = this._rules;\r\n\r\n  var oldShape = context.oldShape,\r\n      newData = context.newData,\r\n      hints = context.hints,\r\n      newShape;\r\n\r\n  function canReconnect(type, source, target, connection) {\r\n    return rules.allowed(type, {\r\n      source: source,\r\n      target: target,\r\n      connection: connection\r\n    });\r\n  }\r\n\r\n\r\n  // (1) place a new shape at the given position\r\n\r\n  var position = {\r\n    x: newData.x,\r\n    y: newData.y\r\n  };\r\n\r\n  newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent);\r\n\r\n\r\n  // (2) update the host\r\n\r\n  if (oldShape.host) {\r\n    modeling.updateAttachment(newShape, oldShape.host);\r\n  }\r\n\r\n\r\n  // (3) adopt all children from the old shape\r\n\r\n  var children;\r\n\r\n  if (hints.moveChildren !== false) {\r\n    children = oldShape.children.slice();\r\n\r\n    modeling.moveElements(children, { x: 0, y: 0 }, newShape);\r\n  }\r\n\r\n  // (4) reconnect connections to the new shape (where allowed)\r\n\r\n  var incoming = oldShape.incoming.slice(),\r\n      outgoing = oldShape.outgoing.slice();\r\n\r\n  forEach(incoming, function(connection) {\r\n    var waypoints = connection.waypoints,\r\n        docking = waypoints[waypoints.length - 1],\r\n        source = connection.source,\r\n        allowed = canReconnect('connection.reconnectEnd', source, newShape, connection);\r\n\r\n    if (allowed) {\r\n      self.reconnectEnd(connection, newShape, docking);\r\n    }\r\n  });\r\n\r\n  forEach(outgoing, function(connection) {\r\n    var waypoints = connection.waypoints,\r\n        docking = waypoints[0],\r\n        target = connection.target,\r\n        allowed = canReconnect('connection.reconnectStart', newShape, target, connection);\r\n\r\n    if (allowed) {\r\n      self.reconnectStart(connection, newShape, docking);\r\n    }\r\n\r\n  });\r\n};\r\n\r\n\r\nReplaceShapeHandler.prototype.postExecute = function(context) {\r\n  var modeling = this._modeling;\r\n\r\n  var oldShape = context.oldShape,\r\n      newShape = context.newShape;\r\n\r\n  // if an element gets resized on replace, layout the connection again\r\n  forEach(newShape.incoming, function(c) {\r\n    modeling.layoutConnection(c, { endChanged: true });\r\n  });\r\n\r\n  forEach(newShape.outgoing, function(c) {\r\n    modeling.layoutConnection(c, { startChanged: true });\r\n  });\r\n\r\n  modeling.removeShape(oldShape);\r\n};\r\n\r\n\r\nReplaceShapeHandler.prototype.execute = function(context) {};\r\n\r\nReplaceShapeHandler.prototype.revert = function(context) {};\r\n\r\n\r\nReplaceShapeHandler.prototype.createShape = function(shape, position, target) {\r\n  var modeling = this._modeling;\r\n  return modeling.createShape(shape, position, target);\r\n};\r\n\r\n\r\nReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint) {\r\n  var modeling = this._modeling;\r\n  modeling.reconnectStart(connection, newSource, dockingPoint);\r\n};\r\n\r\n\r\nReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint) {\r\n  var modeling = this._modeling;\r\n  modeling.reconnectEnd(connection, newTarget, dockingPoint);\r\n};\r\n","'use strict';\r\n\r\nvar assign = require(516),\r\n    forEach = require(386);\r\n\r\nvar getResizedSourceAnchor = require(277).getResizedSourceAnchor,\r\n    getResizedTargetAnchor = require(277).getResizedTargetAnchor;\r\n\r\n/**\r\n * A handler that implements reversible resizing of shapes.\r\n *\r\n * @param {Modeling} modeling\r\n */\r\nfunction ResizeShapeHandler(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nResizeShapeHandler.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = ResizeShapeHandler;\r\n\r\n/**\r\n * {\r\n *   shape: {....}\r\n *   newBounds: {\r\n *     width:  20,\r\n *     height: 40,\r\n *     x:       5,\r\n *     y:      10\r\n *   }\r\n *\r\n * }\r\n */\r\nResizeShapeHandler.prototype.execute = function(context) {\r\n  var shape = context.shape,\r\n      newBounds = context.newBounds,\r\n      minBounds = context.minBounds;\r\n\r\n  if (newBounds.x === undefined || newBounds.y === undefined ||\r\n      newBounds.width === undefined || newBounds.height === undefined) {\r\n    throw new Error('newBounds must have {x, y, width, height} properties');\r\n  }\r\n\r\n  if (minBounds && (newBounds.width < minBounds.width\r\n    || newBounds.height < minBounds.height)) {\r\n    throw new Error('width and height cannot be less than minimum height and width');\r\n  } else if (!minBounds\r\n    && newBounds.width < 10 || newBounds.height < 10) {\r\n    throw new Error('width and height cannot be less than 10px');\r\n  }\r\n\r\n  // save old bbox in context\r\n  context.oldBounds = {\r\n    width:  shape.width,\r\n    height: shape.height,\r\n    x:      shape.x,\r\n    y:      shape.y\r\n  };\r\n\r\n  // update shape\r\n  assign(shape, {\r\n    width:  newBounds.width,\r\n    height: newBounds.height,\r\n    x:      newBounds.x,\r\n    y:      newBounds.y\r\n  });\r\n\r\n  return shape;\r\n};\r\n\r\nResizeShapeHandler.prototype.postExecute = function(context) {\r\n\r\n  var shape = context.shape,\r\n      oldBounds = context.oldBounds;\r\n\r\n  var modeling = this._modeling;\r\n\r\n  forEach(shape.incoming, function(c) {\r\n    modeling.layoutConnection(c, {\r\n      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)\r\n    });\r\n  });\r\n\r\n  forEach(shape.outgoing, function(c) {\r\n    modeling.layoutConnection(c, {\r\n      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)\r\n    });\r\n  });\r\n\r\n};\r\n\r\nResizeShapeHandler.prototype.revert = function(context) {\r\n\r\n  var shape = context.shape,\r\n      oldBounds = context.oldBounds;\r\n\r\n  // restore previous bbox\r\n  assign(shape, {\r\n    width:  oldBounds.width,\r\n    height: oldBounds.height,\r\n    x:      oldBounds.x,\r\n    y:      oldBounds.y\r\n  });\r\n\r\n  return shape;\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar SpaceUtil = require(316);\r\n\r\n/**\r\n * A handler that implements reversible creating and removing of space.\r\n *\r\n * It executes in two phases:\r\n *\r\n *  (1) resize all affected resizeShapes\r\n *  (2) move all affected moveElements\r\n */\r\nfunction SpaceToolHandler(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nSpaceToolHandler.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = SpaceToolHandler;\r\n\r\n\r\nSpaceToolHandler.prototype.preExecute = function(context) {\r\n\r\n  // resize\r\n  var modeling = this._modeling,\r\n      resizingShapes = context.resizingShapes,\r\n      delta = context.delta,\r\n      direction = context.direction;\r\n\r\n  forEach(resizingShapes, function(shape) {\r\n    var newBounds = SpaceUtil.resizeBounds(shape, direction, delta);\r\n\r\n    modeling.resizeShape(shape, newBounds);\r\n  });\r\n};\r\n\r\nSpaceToolHandler.prototype.postExecute = function(context) {\r\n  // move\r\n  var modeling = this._modeling,\r\n      movingShapes = context.movingShapes,\r\n      delta = context.delta;\r\n\r\n  modeling.moveElements(movingShapes, delta, undefined, false, { autoResize: false });\r\n};\r\n\r\nSpaceToolHandler.prototype.execute = function(context) {};\r\nSpaceToolHandler.prototype.revert = function(context) {};\r\n","'use strict';\r\n\r\n/**\r\n * A handler that toggles the collapsed state of an element\r\n * and the visibility of all its children.\r\n *\r\n * @param {Modeling} modeling\r\n */\r\nfunction ToggleShapeCollapseHandler(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nToggleShapeCollapseHandler.$inject = [ 'modeling' ];\r\n\r\nmodule.exports = ToggleShapeCollapseHandler;\r\n\r\n\r\nToggleShapeCollapseHandler.prototype.execute = function(context) {\r\n\r\n  var shape = context.shape,\r\n      children = shape.children;\r\n\r\n  // remember previous visibility of children\r\n  context.oldChildrenVisibility = getElementsVisibility(children);\r\n\r\n  // toggle state\r\n  shape.collapsed = !shape.collapsed;\r\n\r\n  // hide/show children\r\n  setHidden(children, shape.collapsed);\r\n\r\n  return [shape].concat(children);\r\n};\r\n\r\n\r\nToggleShapeCollapseHandler.prototype.revert = function(context) {\r\n\r\n  var shape = context.shape,\r\n      oldChildrenVisibility = context.oldChildrenVisibility;\r\n\r\n  var children = shape.children;\r\n\r\n  // set old visability of children\r\n  restoreVisibility(children, oldChildrenVisibility);\r\n\r\n  // retoggle state\r\n  shape.collapsed = !shape.collapsed;\r\n\r\n  return [shape].concat(children);\r\n};\r\n\r\n\r\n/////// helpers ///////////////////////////////\r\n\r\n/**\r\n * Return a map { elementId -> hiddenState}.\r\n *\r\n * @param {Array<djs.model.Shape>} elements\r\n *\r\n * @return {Object}\r\n */\r\nfunction getElementsVisibility(elements) {\r\n\r\n  var result = {};\r\n\r\n  elements.forEach(function(e) {\r\n    result[e.id] = e.hidden;\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n\r\nfunction setHidden(elements, newHidden) {\r\n  elements.forEach(function(element) {\r\n    element.hidden = newHidden;\r\n  });\r\n}\r\n\r\nfunction restoreVisibility(elements, lastState) {\r\n  elements.forEach(function(e) {\r\n    e.hidden = lastState[e.id];\r\n  });\r\n}\r\n","'use strict';\r\n\r\nvar Collections = require(340);\r\n\r\n/**\r\n * A handler that implements reversible attaching/detaching of shapes.\r\n */\r\nfunction UpdateAttachmentHandler(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nmodule.exports = UpdateAttachmentHandler;\r\n\r\nUpdateAttachmentHandler.$inject = [ 'modeling' ];\r\n\r\n\r\nUpdateAttachmentHandler.prototype.execute = function(context) {\r\n  var shape = context.shape,\r\n      newHost = context.newHost,\r\n      oldHost = shape.host;\r\n\r\n  // (0) detach from old host\r\n  context.oldHost = oldHost;\r\n  context.attacherIdx = removeAttacher(oldHost, shape);\r\n\r\n  // (1) attach to new host\r\n  addAttacher(newHost, shape);\r\n\r\n  // (2) update host\r\n  shape.host = newHost;\r\n\r\n  return shape;\r\n};\r\n\r\nUpdateAttachmentHandler.prototype.revert = function(context) {\r\n  var shape = context.shape,\r\n      newHost = context.newHost,\r\n      oldHost = context.oldHost,\r\n      attacherIdx = context.attacherIdx;\r\n\r\n  // (2) update host\r\n  shape.host = oldHost;\r\n\r\n  // (1) attach to new host\r\n  removeAttacher(newHost, shape);\r\n\r\n  // (0) detach from old host\r\n  addAttacher(oldHost, shape, attacherIdx);\r\n\r\n  return shape;\r\n};\r\n\r\n\r\nfunction removeAttacher(host, attacher) {\r\n  // remove attacher from host\r\n  return Collections.remove(host && host.attachers, attacher);\r\n}\r\n\r\nfunction addAttacher(host, attacher, idx) {\r\n\r\n  if (!host) {\r\n    return;\r\n  }\r\n\r\n  var attachers = host.attachers;\r\n\r\n  if (!attachers) {\r\n    host.attachers = attachers = [];\r\n  }\r\n\r\n  Collections.add(attachers, attacher, idx);\r\n}\r\n","'use strict';\r\n\r\nfunction UpdateWaypointsHandler() { }\r\n\r\nmodule.exports = UpdateWaypointsHandler;\r\n\r\nUpdateWaypointsHandler.prototype.execute = function(context) {\r\n\r\n  var connection = context.connection,\r\n      newWaypoints = context.newWaypoints;\r\n\r\n  context.oldWaypoints = connection.waypoints;\r\n\r\n  connection.waypoints = newWaypoints;\r\n\r\n  return connection;\r\n};\r\n\r\nUpdateWaypointsHandler.prototype.revert = function(context) {\r\n\r\n  var connection = context.connection,\r\n      oldWaypoints = context.oldWaypoints;\r\n\r\n  connection.waypoints = oldWaypoints;\r\n\r\n  return connection;\r\n};","'use strict';\r\n\r\nvar getNewAttachPoint = require(338).getNewAttachPoint;\r\n\r\nfunction getResizedSourceAnchor(connection, shape, oldBounds) {\r\n\r\n  var waypoints = safeGetWaypoints(connection),\r\n      oldAnchor = waypoints[0];\r\n\r\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\r\n}\r\n\r\nmodule.exports.getResizedSourceAnchor = getResizedSourceAnchor;\r\n\r\n\r\nfunction getResizedTargetAnchor(connection, shape, oldBounds) {\r\n\r\n  var waypoints = safeGetWaypoints(connection),\r\n      oldAnchor = waypoints[waypoints.length - 1];\r\n\r\n  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);\r\n}\r\n\r\nmodule.exports.getResizedTargetAnchor = getResizedTargetAnchor;\r\n\r\n\r\nfunction getMovedSourceAnchor(connection, source, moveDelta) {\r\n  return getResizedSourceAnchor(connection, source, substractPosition(source, moveDelta));\r\n}\r\n\r\nmodule.exports.getMovedSourceAnchor = getMovedSourceAnchor;\r\n\r\n\r\nfunction getMovedTargetAnchor(connection, target, moveDelta) {\r\n  return getResizedTargetAnchor(connection, target, substractPosition(target, moveDelta));\r\n}\r\n\r\nmodule.exports.getMovedTargetAnchor = getMovedTargetAnchor;\r\n\r\n\r\n//////// helpers ////////////////////////////////////\r\n\r\nfunction substractPosition(bounds, delta) {\r\n  return {\r\n    x: bounds.x - delta.x,\r\n    y: bounds.y - delta.y,\r\n    width: bounds.width,\r\n    height: bounds.height\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Return waypoints of given connection; throw if non exists (should not happen!!).\r\n *\r\n * @param {Connection} connection\r\n *\r\n * @return {Array<Point>}\r\n */\r\nfunction safeGetWaypoints(connection) {\r\n\r\n  var waypoints = connection.waypoints;\r\n\r\n  if (!waypoints.length) {\r\n    throw new Error('connection#' + connection.id + ': no waypoints');\r\n  }\r\n\r\n  return waypoints;\r\n}\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar Elements = require(343);\r\n\r\nvar getMovedSourceAnchor = require(277).getMovedSourceAnchor,\r\n    getMovedTargetAnchor = require(277).getMovedTargetAnchor;\r\n\r\n/**\r\n * A helper that is able to carry out serialized move operations on multiple elements.\r\n *\r\n * @param {Modeling} modeling\r\n */\r\nfunction MoveHelper(modeling) {\r\n  this._modeling = modeling;\r\n}\r\n\r\nmodule.exports = MoveHelper;\r\n\r\n/**\r\n * Move the specified elements and all children by the given delta.\r\n *\r\n * This moves all enclosed connections, too and layouts all affected\r\n * external connections.\r\n *\r\n * @param  {Array<djs.model.Base>} elements\r\n * @param  {Point} delta\r\n * @param  {djs.model.Base} newParent applied to the first level of shapes\r\n *\r\n * @return {Array<djs.model.Base>} list of touched elements\r\n */\r\nMoveHelper.prototype.moveRecursive = function(elements, delta, newParent) {\r\n  if (!elements) {\r\n    return [];\r\n  } else {\r\n    return this.moveClosure(this.getClosure(elements), delta, newParent);\r\n  }\r\n};\r\n\r\n/**\r\n * Move the given closure of elmements.\r\n *\r\n * @param {Object} closure\r\n * @param {Point} delta\r\n * @param {djs.model.Base} [newParent]\r\n * @param {djs.model.Base} [newHost]\r\n */\r\nMoveHelper.prototype.moveClosure = function(closure, delta, newParent, newHost, primaryShape) {\r\n  var modeling = this._modeling;\r\n\r\n  var allShapes = closure.allShapes,\r\n      allConnections = closure.allConnections,\r\n      enclosedConnections = closure.enclosedConnections,\r\n      topLevel = closure.topLevel,\r\n      keepParent = false;\r\n\r\n  if (primaryShape && primaryShape.parent === newParent) {\r\n    keepParent = true;\r\n  }\r\n\r\n  // move all shapes\r\n  forEach(allShapes, function(shape) {\r\n\r\n    // move the element according to the given delta\r\n    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {\r\n      recurse: false,\r\n      layout: false\r\n    });\r\n  });\r\n\r\n  // move all child connections / layout external connections\r\n  forEach(allConnections, function(c) {\r\n\r\n    var sourceMoved = !!allShapes[c.source.id],\r\n        targetMoved = !!allShapes[c.target.id];\r\n\r\n    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {\r\n      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);\r\n    } else {\r\n      modeling.layoutConnection(c, {\r\n        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),\r\n        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Returns the closure for the selected elements\r\n *\r\n * @param  {Array<djs.model.Base>} elements\r\n * @return {Object} closure\r\n */\r\nMoveHelper.prototype.getClosure = function(elements) {\r\n  return Elements.getClosure(elements);\r\n};\r\n","'use strict';\r\n\r\nvar bind = require(396);\r\n\r\n\r\nfunction MouseTracking(eventBus, canvas) {\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n\r\n  this._init();\r\n}\r\n\r\nMouseTracking.$inject = [\r\n  'eventBus',\r\n  'canvas'\r\n];\r\n\r\nmodule.exports = MouseTracking;\r\n\r\n\r\nMouseTracking.prototype.getHoverContext = function() {\r\n  var viewbox = this._canvas.viewbox();\r\n\r\n  return {\r\n    element: this._hoverElement,\r\n    point: {\r\n      x: viewbox.x + Math.round(this._mouseX / viewbox.scale),\r\n      y: viewbox.y + Math.round(this._mouseY / viewbox.scale)\r\n    }\r\n  };\r\n};\r\n\r\nMouseTracking.prototype._init = function() {\r\n  var eventBus = this._eventBus,\r\n      canvas = this._canvas;\r\n\r\n  var container = canvas.getContainer();\r\n\r\n  this._setMousePosition = bind(this._setMousePosition, this);\r\n\r\n  container.addEventListener('mousemove', this._setMousePosition);\r\n\r\n  eventBus.on('diagram.destroy', function() {\r\n    container.removeEventListener('mousemove', this._setMousePosition);\r\n  }, this);\r\n\r\n  eventBus.on('element.hover', this._setHoverElement, this);\r\n};\r\n\r\n\r\nMouseTracking.prototype._setHoverElement = function(event) {\r\n  this._hoverElement = event.element;\r\n};\r\n\r\n\r\nMouseTracking.prototype._setMousePosition = function(event) {\r\n  this._mouseX = event.layerX;\r\n  this._mouseY = event.layerY;\r\n};\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'mouseTracking' ],\r\n  mouseTracking: [ 'type', require(279) ]\r\n};\r\n","'use strict';\r\n\r\nvar assign = require(516),\r\n    filter = require(384),\r\n    groupBy = require(387);\r\n\r\nvar LOW_PRIORITY = 500,\r\n    MEDIUM_PRIORITY = 1250,\r\n    HIGH_PRIORITY = 1500;\r\n\r\nvar getOriginalEvent = require(344).getOriginal;\r\n\r\nvar round = Math.round;\r\n\r\nfunction mid(element) {\r\n  return {\r\n    x: element.x + round(element.width / 2),\r\n    y: element.y + round(element.height / 2)\r\n  };\r\n}\r\n\r\n/**\r\n * A plugin that makes shapes draggable / droppable.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Dragging} dragging\r\n * @param {Modeling} modeling\r\n * @param {Selection} selection\r\n * @param {Rules} rules\r\n */\r\nfunction MoveEvents(eventBus, dragging, modeling, selection, rules) {\r\n\r\n  // rules\r\n\r\n  function canMove(shapes, delta, position, target) {\r\n\r\n    return rules.allowed('elements.move', {\r\n      shapes: shapes,\r\n      delta: delta,\r\n      position: position,\r\n      target: target\r\n    });\r\n  }\r\n\r\n\r\n  // move events\r\n\r\n  // assign a high priority to this handler to setup the environment\r\n  // others may hook up later, e.g. at default priority and modify\r\n  // the move environment.\r\n  //\r\n  // This sets up the context with\r\n  //\r\n  // * shape: the primary shape being moved\r\n  // * shapes: a list of shapes to be moved\r\n  // * validatedShapes: a list of shapes that are being checked\r\n  //                    against the rules before and during move\r\n  //\r\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        shape = event.shape,\r\n        shapes = selection.get().slice();\r\n\r\n    // move only single shape if the dragged element\r\n    // is not part of the current selection\r\n    if (shapes.indexOf(shape) === -1) {\r\n      shapes = [ shape ];\r\n    }\r\n\r\n    // ensure we remove nested elements in the collection\r\n    // and add attachers for a proper dragger\r\n    shapes = removeNested(shapes);\r\n\r\n    // attach shapes to drag context\r\n    assign(context, {\r\n      shapes: shapes,\r\n      validatedShapes: shapes,\r\n      shape: shape\r\n    });\r\n  });\r\n\r\n\r\n  // assign a high priority to this handler to setup the environment\r\n  // others may hook up later, e.g. at default priority and modify\r\n  // the move environment\r\n  //\r\n  eventBus.on('shape.move.start', MEDIUM_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        validatedShapes = context.validatedShapes,\r\n        canExecute;\r\n\r\n    canExecute = context.canExecute = canMove(validatedShapes);\r\n\r\n    // check if we can move the elements\r\n    if (!canExecute) {\r\n      // suppress move operation\r\n      event.stopPropagation();\r\n\r\n      return false;\r\n    }\r\n  });\r\n\r\n  // assign a low priority to this handler\r\n  // to let others modify the move event before we update\r\n  // the context\r\n  //\r\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        validatedShapes = context.validatedShapes,\r\n        hover = event.hover,\r\n        delta = { x: event.dx, y: event.dy },\r\n        position = { x: event.x, y: event.y },\r\n        canExecute;\r\n\r\n    // check if we can move the elements\r\n    canExecute = canMove(validatedShapes, delta, position, hover);\r\n\r\n    context.delta = delta;\r\n    context.canExecute = canExecute;\r\n\r\n    // simply ignore move over\r\n    if (canExecute === null) {\r\n      context.target = null;\r\n\r\n      return;\r\n    }\r\n\r\n    context.target = hover;\r\n  });\r\n\r\n  eventBus.on('shape.move.end', function(event) {\r\n\r\n    var context = event.context;\r\n\r\n    var delta = context.delta,\r\n        canExecute = context.canExecute,\r\n        isAttach = canExecute === 'attach',\r\n        shapes = context.shapes;\r\n\r\n    if (!canExecute) {\r\n      return false;\r\n    }\r\n\r\n    // ensure we have actual pixel values deltas\r\n    // (important when zoom level was > 1 during move)\r\n    delta.x = round(delta.x);\r\n    delta.y = round(delta.y);\r\n\r\n    modeling.moveElements(shapes, delta, context.target, isAttach, { primaryShape: context.shape });\r\n  });\r\n\r\n\r\n  // move activation\r\n\r\n  eventBus.on('element.mousedown', function(event) {\r\n\r\n    var originalEvent = getOriginalEvent(event);\r\n\r\n    if (!originalEvent) {\r\n      throw new Error('must supply DOM mousedown event');\r\n    }\r\n\r\n    start(originalEvent, event.element);\r\n  });\r\n\r\n\r\n  function start(event, element, activate) {\r\n\r\n    // do not move connections or the root element\r\n    if (element.waypoints || !element.parent) {\r\n      return;\r\n    }\r\n\r\n    var referencePoint = mid(element);\r\n\r\n    dragging.init(event, referencePoint, 'shape.move', {\r\n      cursor: 'grabbing',\r\n      autoActivate: activate,\r\n      data: {\r\n        shape: element,\r\n        context: {}\r\n      }\r\n    });\r\n  }\r\n\r\n  // API\r\n\r\n  this.start = start;\r\n}\r\n\r\nMoveEvents.$inject = [ 'eventBus', 'dragging', 'modeling', 'selection', 'rules' ];\r\n\r\nmodule.exports = MoveEvents;\r\n\r\n\r\n/**\r\n * Return a filtered list of elements that do not contain\r\n * those nested into others.\r\n *\r\n * @param  {Array<djs.model.Base>} elements\r\n *\r\n * @return {Array<djs.model.Base>} filtered\r\n */\r\nfunction removeNested(elements) {\r\n\r\n  var ids = groupBy(elements, 'id');\r\n\r\n  return filter(elements, function(element) {\r\n    while ((element = element.parent)) {\r\n\r\n      // parent in selection\r\n      if (ids[element.id]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  });\r\n}\r\n","'use strict';\r\n\r\nvar flatten = require(372),\r\n    forEach = require(386),\r\n    filter = require(384),\r\n    find = require(385),\r\n    size = require(392),\r\n    groupBy = require(387),\r\n    map = require(389);\r\n\r\nvar Elements = require(343);\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClear = require(581),\r\n    svgCreate = require(583);\r\n\r\nvar translate = require(356).translate;\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\nvar MARKER_DRAGGING = 'djs-dragging',\r\n    MARKER_OK = 'drop-ok',\r\n    MARKER_NOT_OK = 'drop-not-ok',\r\n    MARKER_NEW_PARENT = 'new-parent',\r\n    MARKER_ATTACH = 'attach-ok';\r\n\r\n/**\r\n * Provides previews for moving shapes when moving.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {Canvas} canvas\r\n * @param {Styles} styles\r\n */\r\nfunction MovePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\r\n\r\n  function getVisualDragShapes(shapes) {\r\n    var elements = getAllDraggedElements(shapes);\r\n\r\n    var filteredElements = removeEdges(elements);\r\n\r\n    return filteredElements;\r\n  }\r\n\r\n  function getAllDraggedElements(shapes) {\r\n    var allShapes = Elements.selfAndAllChildren(shapes, true);\r\n\r\n    var allConnections = map(allShapes, function(shape) {\r\n      return (shape.incoming || []).concat(shape.outgoing || []);\r\n    });\r\n\r\n    return flatten(allShapes.concat(allConnections), true);\r\n  }\r\n\r\n  /**\r\n   * Sets drop marker on an element.\r\n   */\r\n  function setMarker(element, marker) {\r\n\r\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\r\n\r\n      if (m === marker) {\r\n        canvas.addMarker(element, m);\r\n      } else {\r\n        canvas.removeMarker(element, m);\r\n      }\r\n    });\r\n  }\r\n\r\n  function makeDraggable(context, element, addMarker) {\r\n\r\n    previewSupport.addDragger(element, context.dragGroup);\r\n\r\n    if (addMarker) {\r\n      canvas.addMarker(element, MARKER_DRAGGING);\r\n    }\r\n\r\n    if (context.allDraggedElements) {\r\n      context.allDraggedElements.push(element);\r\n    } else {\r\n      context.allDraggedElements = [ element ];\r\n    }\r\n  }\r\n\r\n  // expose to other components\r\n  // that plug into the drag behavior\r\n  this.makeDraggable = makeDraggable;\r\n\r\n  // add previews\r\n  eventBus.on('shape.move.start', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        dragShapes = context.shapes,\r\n        allDraggedElements = context.allDraggedElements;\r\n\r\n    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);\r\n\r\n    if (!context.dragGroup) {\r\n      var dragGroup = svgCreate('g');\r\n      svgAttr(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));\r\n\r\n      var defaultLayer = canvas.getDefaultLayer();\r\n\r\n      svgAppend(defaultLayer, dragGroup);\r\n\r\n      context.dragGroup = dragGroup;\r\n    }\r\n\r\n    // add previews\r\n    visuallyDraggedShapes.forEach(function(shape) {\r\n      previewSupport.addDragger(shape, context.dragGroup);\r\n    });\r\n\r\n    // cache all dragged elements / gfx\r\n    // so that we can quickly undo their state changes later\r\n    if (!allDraggedElements) {\r\n      allDraggedElements = getAllDraggedElements(dragShapes);\r\n    } else {\r\n      allDraggedElements = flatten(allDraggedElements, getAllDraggedElements(dragShapes));\r\n    }\r\n\r\n    // add dragging marker\r\n    forEach(allDraggedElements, function(e) {\r\n      canvas.addMarker(e, MARKER_DRAGGING);\r\n    });\r\n\r\n    context.allDraggedElements = allDraggedElements;\r\n\r\n    // determine, if any of the dragged elements have different parents\r\n    context.differentParents = haveDifferentParents(dragShapes);\r\n  });\r\n\r\n  // update previews\r\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        dragGroup = context.dragGroup,\r\n        target = context.target,\r\n        parent = context.shape.parent,\r\n        canExecute = context.canExecute;\r\n\r\n    if (target) {\r\n      if (canExecute === 'attach') {\r\n        setMarker(target, MARKER_ATTACH);\r\n      } else if (context.canExecute && target && target.id !== parent.id) {\r\n        setMarker(target, MARKER_NEW_PARENT);\r\n      } else {\r\n        setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);\r\n      }\r\n    }\r\n\r\n    translate(dragGroup, event.dx, event.dy);\r\n  });\r\n\r\n  eventBus.on([ 'shape.move.out', 'shape.move.cleanup' ], function(event) {\r\n    var context = event.context,\r\n        target = context.target;\r\n\r\n    if (target) {\r\n      setMarker(target, null);\r\n    }\r\n  });\r\n\r\n  // remove previews\r\n  eventBus.on('shape.move.cleanup', function(event) {\r\n\r\n    var context = event.context,\r\n        allDraggedElements = context.allDraggedElements,\r\n        dragGroup = context.dragGroup;\r\n\r\n\r\n    // remove dragging marker\r\n    forEach(allDraggedElements, function(e) {\r\n      canvas.removeMarker(e, MARKER_DRAGGING);\r\n    });\r\n\r\n    if (dragGroup) {\r\n      svgClear(dragGroup);\r\n    }\r\n  });\r\n}\r\n\r\nMovePreview.$inject = [ 'eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport' ];\r\n\r\nmodule.exports = MovePreview;\r\n\r\n////////// helpers //////////\r\n\r\n// returns elements minus all connections\r\n// where source or target is not elements\r\nfunction removeEdges(elements) {\r\n\r\n  var filteredElements = filter(elements, function(element) {\r\n\r\n    if (!isConnection(element)) {\r\n      return true;\r\n    } else {\r\n      var srcFound = find(elements, element.source);\r\n      var targetFound = find(elements, element.target);\r\n\r\n      return srcFound && targetFound;\r\n    }\r\n  });\r\n\r\n  return filteredElements;\r\n}\r\n\r\nfunction haveDifferentParents(elements) {\r\n  return size(groupBy(elements, function(e) { return e.parent && e.parent.id; })) !== 1;\r\n}\r\n\r\n/**\r\n * Checks if an element is a connection.\r\n */\r\nfunction isConnection(element) {\r\n  return element.waypoints;\r\n}\r\n","module.exports = {\r\n  __depends__: [\r\n    require(247),\r\n    require(310),\r\n    require(286),\r\n    require(304),\r\n    require(239),\r\n    require(294)\r\n  ],\r\n  __init__: [ 'move', 'movePreview' ],\r\n  move: [ 'type', require(281) ],\r\n  movePreview: [ 'type', require(282) ]\r\n};\r\n","'use strict';\r\n\r\nvar inherits = require(368);\r\n\r\nvar CommandInterceptor = require(196);\r\n\r\n\r\n/**\r\n * An abstract provider that allows modelers to implement a custom\r\n * ordering of diagram elements on the canvas.\r\n *\r\n * It makes sure that the order is always preserved during element\r\n * creation and move operations.\r\n *\r\n * In order to use this behavior, inherit from it and override\r\n * the method {@link OrderingProvider#getOrdering}.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * function CustomOrderingProvider(eventBus) {\r\n *   OrderingProvider.call(this, eventBus);\r\n *\r\n *   this.getOrdering = function(element, newParent) {\r\n *     // always insert elements at the front\r\n *     // when moving\r\n *     return {\r\n *       index: 0,\r\n *       parent: newParent\r\n *     };\r\n *   };\r\n * }\r\n * ```\r\n *\r\n * @param {EventBus} eventBus\r\n */\r\nfunction OrderingProvider(eventBus) {\r\n\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n\r\n  var self = this;\r\n\r\n  this.preExecute([ 'shape.create', 'connection.create' ], function(event) {\r\n\r\n    var context = event.context,\r\n        element = context.shape || context.connection,\r\n        parent = context.parent;\r\n\r\n    var ordering = self.getOrdering(element, parent);\r\n\r\n    if (ordering) {\r\n\r\n      if (ordering.parent !== undefined) {\r\n        context.parent = ordering.parent;\r\n      }\r\n\r\n      context.parentIndex = ordering.index;\r\n    }\r\n  });\r\n\r\n  this.preExecute([ 'shape.move', 'connection.move' ], function(event) {\r\n\r\n    var context = event.context,\r\n        element = context.shape || context.connection,\r\n        parent = context.newParent || element.parent;\r\n\r\n    var ordering = self.getOrdering(element, parent);\r\n\r\n    if (ordering) {\r\n\r\n      if (ordering.parent !== undefined) {\r\n        context.newParent = ordering.parent;\r\n      }\r\n\r\n      context.newParentIndex = ordering.index;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Return a custom ordering of the element, both in terms\r\n * of parent element and index in the new parent.\r\n *\r\n * Implementors of this method must return an object with\r\n * `parent` _and_ `index` in it.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {djs.model.Shape} newParent\r\n *\r\n * @return {Object} ordering descriptor\r\n */\r\nOrderingProvider.prototype.getOrdering = function(element, newParent) {\r\n  return null;\r\n};\r\n\r\ninherits(OrderingProvider, CommandInterceptor);\r\n\r\nmodule.exports = OrderingProvider;","'use strict';\r\n\r\nvar getBBox = require(343).getBBox;\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583);\r\n\r\nvar domQuery = require(538);\r\n\r\nvar assign = require(516);\r\n\r\n\r\n/**\r\n * @class\r\n *\r\n * A plugin that adds an outline to shapes and connections that may be activated and styled\r\n * via CSS classes.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Styles} styles\r\n * @param {ElementRegistry} elementRegistry\r\n */\r\nfunction Outline(eventBus, styles, elementRegistry) {\r\n\r\n  this.offset = 6;\r\n\r\n  var OUTLINE_STYLE = styles.cls('djs-outline', [ 'no-fill' ]);\r\n\r\n  var self = this;\r\n\r\n  function createOutline(gfx, bounds) {\r\n    var outline = svgCreate('rect');\r\n\r\n    svgAttr(outline, assign({\r\n      x: 10,\r\n      y: 10,\r\n      width: 100,\r\n      height: 100\r\n    }, OUTLINE_STYLE));\r\n\r\n    svgAppend(gfx, outline);\r\n\r\n    return outline;\r\n  }\r\n\r\n  // A low priortity is necessary, because outlines of labels have to be updated\r\n  // after the label bounds have been updated in the renderer.\r\n  eventBus.on([ 'shape.added', 'shape.changed' ], LOW_PRIORITY, function(event) {\r\n    var element = event.element,\r\n        gfx     = event.gfx;\r\n\r\n    var outline = domQuery('.djs-outline', gfx);\r\n\r\n    if (!outline) {\r\n      outline = createOutline(gfx, element);\r\n    }\r\n\r\n    self.updateShapeOutline(outline, element);\r\n  });\r\n\r\n  eventBus.on([ 'connection.added', 'connection.changed' ], function(event) {\r\n    var element = event.element,\r\n        gfx     = event.gfx;\r\n\r\n    var outline = domQuery('.djs-outline', gfx);\r\n\r\n    if (!outline) {\r\n      outline = createOutline(gfx, element);\r\n    }\r\n\r\n    self.updateConnectionOutline(outline, element);\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Updates the outline of a shape respecting the dimension of the\r\n * element and an outline offset.\r\n *\r\n * @param  {SVGElement} outline\r\n * @param  {djs.model.Base} element\r\n */\r\nOutline.prototype.updateShapeOutline = function(outline, element) {\r\n\r\n  svgAttr(outline, {\r\n    x: -this.offset,\r\n    y: -this.offset,\r\n    width: element.width + this.offset * 2,\r\n    height: element.height + this.offset * 2\r\n  });\r\n\r\n};\r\n\r\n\r\n/**\r\n * Updates the outline of a connection respecting the bounding box of\r\n * the connection and an outline offset.\r\n *\r\n * @param  {SVGElement} outline\r\n * @param  {djs.model.Base} element\r\n */\r\nOutline.prototype.updateConnectionOutline = function(outline, connection) {\r\n\r\n  var bbox = getBBox(connection);\r\n\r\n  svgAttr(outline, {\r\n    x: bbox.x - this.offset,\r\n    y: bbox.y - this.offset,\r\n    width: bbox.width + this.offset * 2,\r\n    height: bbox.height + this.offset * 2\r\n  });\r\n\r\n};\r\n\r\n\r\nOutline.$inject = ['eventBus', 'styles', 'elementRegistry'];\r\n\r\nmodule.exports = Outline;\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'outline' ],\r\n  outline: [ 'type', require(285) ]\r\n};","'use strict';\r\n\r\nvar isArray = require(506),\r\n    isString = require(513),\r\n    isObject = require(511),\r\n    assign = require(516),\r\n    forEach = require(386),\r\n    find = require(385),\r\n    filter = require(384);\r\n\r\nvar domify = require(535),\r\n    domClasses = require(531),\r\n    domAttr = require(530),\r\n    domRemove = require(539),\r\n    domClear = require(532);\r\n\r\nvar getBBox = require(343).getBBox;\r\n\r\n// document wide unique overlay ids\r\nvar ids = new (require(347))('ov');\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\n\r\nfunction createRoot(parent) {\r\n  var root = domify('<div class=\"djs-overlay-container\" style=\"position: absolute; width: 0; height: 0;\" />');\r\n  parent.insertBefore(root, parent.firstChild);\r\n\r\n  return root;\r\n}\r\n\r\n\r\nfunction setPosition(el, x, y) {\r\n  assign(el.style, { left: x + 'px', top: y + 'px' });\r\n}\r\n\r\nfunction setVisible(el, visible) {\r\n  el.style.display = visible === false ? 'none' : '';\r\n}\r\n\r\n/**\r\n * A service that allows users to attach overlays to diagram elements.\r\n *\r\n * The overlay service will take care of overlay positioning during updates.\r\n *\r\n * @example\r\n *\r\n * // add a pink badge on the top left of the shape\r\n * overlays.add(someShape, {\r\n *   position: {\r\n *     top: -5,\r\n *     left: -5\r\n *   },\r\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\r\n * });\r\n *\r\n * // or add via shape id\r\n *\r\n * overlays.add('some-element-id', {\r\n *   position: {\r\n *     top: -5,\r\n *     left: -5\r\n *   }\r\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\r\n * });\r\n *\r\n * // or add with optional type\r\n *\r\n * overlays.add(someShape, 'badge', {\r\n *   position: {\r\n *     top: -5,\r\n *     left: -5\r\n *   }\r\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\r\n * });\r\n *\r\n *\r\n * // remove an overlay\r\n *\r\n * var id = overlays.add(...);\r\n * overlays.remove(id);\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {ElementRegistry} elementRegistry\r\n */\r\nfunction Overlays(eventBus, canvas, elementRegistry) {\r\n\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n  this._elementRegistry = elementRegistry;\r\n\r\n  this._ids = ids;\r\n\r\n  this._overlayDefaults = {\r\n    show: {\r\n      minZoom: 0.7,\r\n      maxZoom: 5.0\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Mapping overlayId -> overlay\r\n   */\r\n  this._overlays = {};\r\n\r\n  /**\r\n   * Mapping elementId -> overlay container\r\n   */\r\n  this._overlayContainers = [];\r\n\r\n  // root html element for all overlays\r\n  this._overlayRoot = createRoot(canvas.getContainer());\r\n\r\n  this._init();\r\n}\r\n\r\n\r\nOverlays.$inject = [ 'eventBus', 'canvas', 'elementRegistry' ];\r\n\r\nmodule.exports = Overlays;\r\n\r\n\r\n/**\r\n * Returns the overlay with the specified id or a list of overlays\r\n * for an element with a given type.\r\n *\r\n * @example\r\n *\r\n * // return the single overlay with the given id\r\n * overlays.get('some-id');\r\n *\r\n * // return all overlays for the shape\r\n * overlays.get({ element: someShape });\r\n *\r\n * // return all overlays on shape with type 'badge'\r\n * overlays.get({ element: someShape, type: 'badge' });\r\n *\r\n * // shape can also be specified as id\r\n * overlays.get({ element: 'element-id', type: 'badge' });\r\n *\r\n *\r\n * @param {Object} search\r\n * @param {String} [search.id]\r\n * @param {String|djs.model.Base} [search.element]\r\n * @param {String} [search.type]\r\n *\r\n * @return {Object|Array<Object>} the overlay(s)\r\n */\r\nOverlays.prototype.get = function(search) {\r\n\r\n  if (isString(search)) {\r\n    search = { id: search };\r\n  }\r\n\r\n  if (isString(search.element)) {\r\n    search.element = this._elementRegistry.get(search.element);\r\n  }\r\n\r\n  if (search.element) {\r\n    var container = this._getOverlayContainer(search.element, true);\r\n\r\n    // return a list of overlays when searching by element (+type)\r\n    if (container) {\r\n      return search.type ? filter(container.overlays, { type: search.type }) : container.overlays.slice();\r\n    } else {\r\n      return [];\r\n    }\r\n  } else\r\n  if (search.type) {\r\n    return filter(this._overlays, { type: search.type });\r\n  } else {\r\n    // return single element when searching by id\r\n    return search.id ? this._overlays[search.id] : null;\r\n  }\r\n};\r\n\r\n/**\r\n * Adds a HTML overlay to an element.\r\n *\r\n * @param {String|djs.model.Base}   element   attach overlay to this shape\r\n * @param {String}                  [type]    optional type to assign to the overlay\r\n * @param {Object}                  overlay   the overlay configuration\r\n *\r\n * @param {String|DOMElement}       overlay.html                 html element to use as an overlay\r\n * @param {Object}                  [overlay.show]               show configuration\r\n * @param {Number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay\r\n * @param {Number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay\r\n * @param {Object}                  overlay.position             where to attach the overlay\r\n * @param {Number}                  [overlay.position.left]      relative to element bbox left attachment\r\n * @param {Number}                  [overlay.position.top]       relative to element bbox top attachment\r\n * @param {Number}                  [overlay.position.bottom]    relative to element bbox bottom attachment\r\n * @param {Number}                  [overlay.position.right]     relative to element bbox right attachment\r\n *\r\n * @return {String}                 id that may be used to reference the overlay for update or removal\r\n */\r\nOverlays.prototype.add = function(element, type, overlay) {\r\n\r\n  if (isObject(type)) {\r\n    overlay = type;\r\n    type = null;\r\n  }\r\n\r\n  if (!element.id) {\r\n    element = this._elementRegistry.get(element);\r\n  }\r\n\r\n  if (!overlay.position) {\r\n    throw new Error('must specifiy overlay position');\r\n  }\r\n\r\n  if (!overlay.html) {\r\n    throw new Error('must specifiy overlay html');\r\n  }\r\n\r\n  if (!element) {\r\n    throw new Error('invalid element specified');\r\n  }\r\n\r\n  var id = this._ids.next();\r\n\r\n  overlay = assign({}, this._overlayDefaults, overlay, {\r\n    id: id,\r\n    type: type,\r\n    element: element,\r\n    html: overlay.html\r\n  });\r\n\r\n  this._addOverlay(overlay);\r\n\r\n  return id;\r\n};\r\n\r\n\r\n/**\r\n * Remove an overlay with the given id or all overlays matching the given filter.\r\n *\r\n * @see Overlays#get for filter options.\r\n *\r\n * @param {String} [id]\r\n * @param {Object} [filter]\r\n */\r\nOverlays.prototype.remove = function(filter) {\r\n\r\n  var overlays = this.get(filter) || [];\r\n\r\n  if (!isArray(overlays)) {\r\n    overlays = [ overlays ];\r\n  }\r\n\r\n  var self = this;\r\n\r\n  forEach(overlays, function(overlay) {\r\n\r\n    var container = self._getOverlayContainer(overlay.element, true);\r\n\r\n    if (overlay) {\r\n      domRemove(overlay.html);\r\n      domRemove(overlay.htmlContainer);\r\n\r\n      delete overlay.htmlContainer;\r\n      delete overlay.element;\r\n\r\n      delete self._overlays[overlay.id];\r\n    }\r\n\r\n    if (container) {\r\n      var idx = container.overlays.indexOf(overlay);\r\n      if (idx !== -1) {\r\n        container.overlays.splice(idx, 1);\r\n      }\r\n    }\r\n  });\r\n\r\n};\r\n\r\n\r\nOverlays.prototype.show = function() {\r\n  setVisible(this._overlayRoot);\r\n};\r\n\r\n\r\nOverlays.prototype.hide = function() {\r\n  setVisible(this._overlayRoot, false);\r\n};\r\n\r\nOverlays.prototype.clear = function() {\r\n  this._overlays = {};\r\n\r\n  this._overlayContainers = [];\r\n\r\n  domClear(this._overlayRoot);\r\n};\r\n\r\nOverlays.prototype._updateOverlayContainer = function(container) {\r\n  var element = container.element,\r\n      html = container.html;\r\n\r\n  // update container left,top according to the elements x,y coordinates\r\n  // this ensures we can attach child elements relative to this container\r\n\r\n  var x = element.x,\r\n      y = element.y;\r\n\r\n  if (element.waypoints) {\r\n    var bbox = getBBox(element);\r\n    x = bbox.x;\r\n    y = bbox.y;\r\n  }\r\n\r\n  setPosition(html, x, y);\r\n\r\n  domAttr(container.html, 'data-container-id', element.id);\r\n};\r\n\r\n\r\nOverlays.prototype._updateOverlay = function(overlay) {\r\n\r\n  var position = overlay.position,\r\n      htmlContainer = overlay.htmlContainer,\r\n      element = overlay.element;\r\n\r\n  // update overlay html relative to shape because\r\n  // it is already positioned on the element\r\n\r\n  // update relative\r\n  var left = position.left,\r\n      top = position.top;\r\n\r\n  if (position.right !== undefined) {\r\n\r\n    var width;\r\n\r\n    if (element.waypoints) {\r\n      width = getBBox(element).width;\r\n    } else {\r\n      width = element.width;\r\n    }\r\n\r\n    left = position.right * -1 + width;\r\n  }\r\n\r\n  if (position.bottom !== undefined) {\r\n\r\n    var height;\r\n\r\n    if (element.waypoints) {\r\n      height = getBBox(element).height;\r\n    } else {\r\n      height = element.height;\r\n    }\r\n\r\n    top = position.bottom * -1 + height;\r\n  }\r\n\r\n  setPosition(htmlContainer, left || 0, top || 0);\r\n};\r\n\r\nOverlays.prototype._createOverlayContainer = function(element) {\r\n  var html = domify('<div class=\"djs-overlays\" style=\"position: absolute\" />');\r\n\r\n  this._overlayRoot.appendChild(html);\r\n\r\n  var container = {\r\n    html: html,\r\n    element: element,\r\n    overlays: []\r\n  };\r\n\r\n  this._updateOverlayContainer(container);\r\n\r\n  this._overlayContainers.push(container);\r\n\r\n  return container;\r\n};\r\n\r\n\r\nOverlays.prototype._updateRoot = function(viewbox) {\r\n  var a = viewbox.scale || 1;\r\n  var d = viewbox.scale || 1;\r\n\r\n  var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';\r\n\r\n  this._overlayRoot.style.transform = matrix;\r\n  this._overlayRoot.style['-ms-transform'] = matrix;\r\n  this._overlayRoot.style['-webkit-transform'] = matrix;\r\n};\r\n\r\n\r\nOverlays.prototype._getOverlayContainer = function(element, raw) {\r\n  var container = find(this._overlayContainers, function(c) {\r\n    return c.element === element;\r\n  });\r\n\r\n\r\n  if (!container && !raw) {\r\n    return this._createOverlayContainer(element);\r\n  }\r\n\r\n  return container;\r\n};\r\n\r\n\r\n\r\n\r\n\r\nOverlays.prototype._addOverlay = function(overlay) {\r\n\r\n  var id = overlay.id,\r\n      element = overlay.element,\r\n      html = overlay.html,\r\n      htmlContainer,\r\n      overlayContainer;\r\n\r\n  // unwrap jquery (for those who need it)\r\n  if (html.get && html.constructor.prototype.jquery) {\r\n    html = html.get(0);\r\n  }\r\n\r\n  // create proper html elements from\r\n  // overlay HTML strings\r\n  if (isString(html)) {\r\n    html = domify(html);\r\n  }\r\n\r\n  overlayContainer = this._getOverlayContainer(element);\r\n\r\n  htmlContainer = domify('<div class=\"djs-overlay\" data-overlay-id=\"' + id + '\" style=\"position: absolute\">');\r\n\r\n  htmlContainer.appendChild(html);\r\n\r\n  if (overlay.type) {\r\n    domClasses(htmlContainer).add('djs-overlay-' + overlay.type);\r\n  }\r\n\r\n  overlay.htmlContainer = htmlContainer;\r\n\r\n  overlayContainer.overlays.push(overlay);\r\n  overlayContainer.html.appendChild(htmlContainer);\r\n\r\n  this._overlays[id] = overlay;\r\n\r\n  this._updateOverlay(overlay);\r\n  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());\r\n};\r\n\r\nOverlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {\r\n  var show = overlay.show,\r\n      htmlContainer = overlay.htmlContainer,\r\n      visible = true;\r\n\r\n  if (show) {\r\n    if (show.minZoom > viewbox.scale ||\r\n        show.maxZoom < viewbox.scale) {\r\n      visible = false;\r\n    }\r\n\r\n    setVisible(htmlContainer, visible);\r\n  }\r\n};\r\n\r\nOverlays.prototype._updateOverlaysVisibilty = function(viewbox) {\r\n\r\n  var self = this;\r\n\r\n  forEach(this._overlays, function(overlay) {\r\n    self._updateOverlayVisibilty(overlay, viewbox);\r\n  });\r\n};\r\n\r\n\r\nOverlays.prototype._init = function() {\r\n\r\n  var eventBus = this._eventBus;\r\n\r\n  var self = this;\r\n\r\n\r\n  // scroll/zoom integration\r\n\r\n  function updateViewbox(viewbox) {\r\n    self._updateRoot(viewbox);\r\n    self._updateOverlaysVisibilty(viewbox);\r\n\r\n    self.show();\r\n  }\r\n\r\n  eventBus.on('canvas.viewbox.changing', function(event) {\r\n    self.hide();\r\n  });\r\n\r\n  eventBus.on('canvas.viewbox.changed', function(event) {\r\n    updateViewbox(event.viewbox);\r\n  });\r\n\r\n\r\n  // remove integration\r\n\r\n  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {\r\n    var element = e.element;\r\n    var overlays = self.get({ element: element });\r\n\r\n    forEach(overlays, function(o) {\r\n      self.remove(o.id);\r\n    });\r\n\r\n    var container = self._getOverlayContainer(element);\r\n\r\n    if (container) {\r\n      domRemove(container.html);\r\n      var i = self._overlayContainers.indexOf(container);\r\n      if (i !== -1) {\r\n        self._overlayContainers.splice(i, 1);\r\n      }\r\n    }\r\n  });\r\n\r\n\r\n  // move integration\r\n\r\n  eventBus.on('element.changed', LOW_PRIORITY, function(e) {\r\n    var element = e.element;\r\n\r\n    var container = self._getOverlayContainer(element, true);\r\n\r\n    if (container) {\r\n      forEach(container.overlays, function(overlay) {\r\n        self._updateOverlay(overlay);\r\n      });\r\n\r\n      self._updateOverlayContainer(container);\r\n    }\r\n  });\r\n\r\n\r\n  // marker integration, simply add them on the overlays as classes, too.\r\n\r\n  eventBus.on('element.marker.update', function(e) {\r\n    var container = self._getOverlayContainer(e.element, true);\r\n    if (container) {\r\n      domClasses(container.html)[e.add ? 'add' : 'remove'](e.marker);\r\n    }\r\n  });\r\n\r\n\r\n  // clear overlays with diagram\r\n\r\n  eventBus.on('diagram.clear', this.clear, this);\r\n};\r\n","module.exports = {\r\n  __init__: [ 'overlays' ],\r\n  overlays: [ 'type', require(287) ]\r\n};","'use strict';\r\n\r\nvar isFunction = require(508),\r\n    isArray = require(506),\r\n    forEach = require(386);\r\n\r\nvar domify = require(535),\r\n    domQuery = require(538),\r\n    domAttr = require(530),\r\n    domClear = require(532),\r\n    domClasses = require(531),\r\n    domMatches = require(537),\r\n    domDelegate = require(534),\r\n    domEvent = require(536);\r\n\r\n\r\nvar toggleSelector = '.djs-palette-toggle',\r\n    entrySelector = '.entry',\r\n    elementSelector = toggleSelector + ', ' + entrySelector;\r\n\r\n\r\n/**\r\n * A palette containing modeling elements.\r\n */\r\nfunction Palette(eventBus, canvas, dragging) {\r\n\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n  this._dragging = dragging;\r\n\r\n  this._providers = [];\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('tool-manager.update', function(event) {\r\n    var tool = event.tool;\r\n\r\n    self.updateToolHighlight(tool);\r\n  });\r\n\r\n  eventBus.on('i18n.changed', function() {\r\n    self._update();\r\n  });\r\n}\r\n\r\nPalette.$inject = [ 'eventBus', 'canvas', 'dragging' ];\r\n\r\nmodule.exports = Palette;\r\n\r\n\r\n/**\r\n * Register a provider with the palette\r\n *\r\n * @param  {PaletteProvider} provider\r\n */\r\nPalette.prototype.registerProvider = function(provider) {\r\n  this._providers.push(provider);\r\n\r\n  if (!this._container) {\r\n    this._init();\r\n  }\r\n\r\n  this._update();\r\n};\r\n\r\n\r\n/**\r\n * Returns the palette entries for a given element\r\n *\r\n * @return {Array<PaletteEntryDescriptor>} list of entries\r\n */\r\nPalette.prototype.getEntries = function() {\r\n\r\n  var entries = {};\r\n\r\n  // loop through all providers and their entries.\r\n  // group entries by id so that overriding an entry is possible\r\n  forEach(this._providers, function(provider) {\r\n    var e = provider.getPaletteEntries();\r\n\r\n    forEach(e, function(entry, id) {\r\n      entries[id] = entry;\r\n    });\r\n  });\r\n\r\n  return entries;\r\n};\r\n\r\n\r\n/**\r\n * Initialize\r\n */\r\nPalette.prototype._init = function() {\r\n  var canvas = this._canvas,\r\n      eventBus = this._eventBus;\r\n\r\n  var parent = canvas.getContainer(),\r\n      container = this._container = domify(Palette.HTML_MARKUP),\r\n      self = this;\r\n\r\n  parent.appendChild(container);\r\n\r\n  domDelegate.bind(container, elementSelector, 'click', function(event) {\r\n\r\n    var target = event.delegateTarget;\r\n\r\n    if (domMatches(target, toggleSelector)) {\r\n      return self.toggle();\r\n    }\r\n\r\n    self.trigger('click', event);\r\n  });\r\n\r\n  // prevent drag propagation\r\n  domEvent.bind(container, 'mousedown', function(event) {\r\n    event.stopPropagation();\r\n  });\r\n\r\n  // prevent drag propagation\r\n  domDelegate.bind(container, entrySelector, 'dragstart', function(event) {\r\n    self.trigger('dragstart', event);\r\n  });\r\n\r\n  eventBus.fire('palette.create', {\r\n    html: container\r\n  });\r\n\r\n  eventBus.on('canvas.resized', this.triggerTwoColumn, this);\r\n};\r\n\r\n\r\nPalette.prototype._update = function() {\r\n\r\n  var entriesContainer = domQuery('.djs-palette-entries', this._container),\r\n      entries = this._entries = this.getEntries();\r\n\r\n  domClear(entriesContainer);\r\n\r\n  forEach(entries, function(entry, id) {\r\n\r\n    var grouping = entry.group || 'default';\r\n\r\n    var container = domQuery('[data-group=' + grouping + ']', entriesContainer);\r\n    if (!container) {\r\n      container = domify('<div class=\"group\" data-group=\"' + grouping + '\"></div>');\r\n      entriesContainer.appendChild(container);\r\n    }\r\n\r\n    var html = entry.html || (\r\n      entry.separator ?\r\n        '<hr class=\"separator\" />' :\r\n        '<div class=\"entry\" draggable=\"true\"></div>');\r\n\r\n\r\n    var control = domify(html);\r\n    container.appendChild(control);\r\n\r\n    if (!entry.separator) {\r\n      domAttr(control, 'data-action', id);\r\n\r\n      if (entry.title) {\r\n        domAttr(control, 'title', entry.title);\r\n      }\r\n\r\n      if (entry.className) {\r\n        addClasses(control, entry.className);\r\n      }\r\n\r\n      if (entry.imageUrl) {\r\n        control.appendChild(domify('<img src=\"' + entry.imageUrl + '\">'));\r\n      }\r\n    }\r\n  });\r\n\r\n  // open after update\r\n  this.open(true);\r\n};\r\n\r\n\r\n/**\r\n * Trigger an action available on the palette\r\n *\r\n * @param  {String} action\r\n * @param  {Event} event\r\n */\r\nPalette.prototype.trigger = function(action, event, autoActivate) {\r\n  var entries = this._entries,\r\n      entry,\r\n      handler,\r\n      originalEvent,\r\n      button = event.delegateTarget || event.target;\r\n\r\n  if (!button) {\r\n    return event.preventDefault();\r\n  }\r\n\r\n  entry = entries[domAttr(button, 'data-action')];\r\n\r\n  // when user clicks on the palette and not on an action\r\n  if (!entry) {\r\n    return;\r\n  }\r\n\r\n  handler = entry.action;\r\n\r\n  originalEvent = event.originalEvent || event;\r\n\r\n  // simple action (via callback function)\r\n  if (isFunction(handler)) {\r\n    if (action === 'click') {\r\n      handler(originalEvent, autoActivate);\r\n    }\r\n  } else {\r\n    if (handler[action]) {\r\n      handler[action](originalEvent, autoActivate);\r\n    }\r\n  }\r\n\r\n  // silence other actions\r\n  event.preventDefault();\r\n};\r\n\r\nPalette.prototype.triggerTwoColumn = function() {\r\n  var canvas = this._canvas;\r\n\r\n  var parent = canvas.getContainer();\r\n\r\n  if (parent.clientHeight < 650) {\r\n    domClasses(parent).add('two-column');\r\n  } else {\r\n    domClasses(parent).remove('two-column');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Close the palette\r\n */\r\nPalette.prototype.close = function() {\r\n  var canvas = this._canvas;\r\n\r\n  var parent = canvas.getContainer();\r\n\r\n  domClasses(this._container).remove('open');\r\n\r\n  domClasses(parent).remove('two-column');\r\n};\r\n\r\n\r\n/**\r\n * Open the palette\r\n */\r\nPalette.prototype.open = function() {\r\n  domClasses(this._container).add('open');\r\n\r\n  this.triggerTwoColumn();\r\n};\r\n\r\n\r\nPalette.prototype.toggle = function(open) {\r\n  if (this.isOpen()) {\r\n    this.close();\r\n  } else {\r\n    this.open();\r\n  }\r\n};\r\n\r\nPalette.prototype.isActiveTool = function(tool) {\r\n  return tool && this._activeTool === tool;\r\n};\r\n\r\nPalette.prototype.updateToolHighlight = function(name) {\r\n  var entriesContainer,\r\n      toolsContainer;\r\n\r\n  if (!this._toolsContainer) {\r\n    entriesContainer = domQuery('.djs-palette-entries', this._container);\r\n\r\n    this._toolsContainer = domQuery('[data-group=tools]', entriesContainer);\r\n  }\r\n\r\n  toolsContainer = this._toolsContainer;\r\n\r\n  forEach(toolsContainer.children, function(tool) {\r\n    var actionName = tool.getAttribute('data-action');\r\n\r\n    if (!actionName) {\r\n      return;\r\n    }\r\n\r\n    actionName = actionName.replace('-tool', '');\r\n\r\n    if (tool.classList.contains('entry') && actionName === name) {\r\n      domClasses(tool).add('highlighted-entry');\r\n    } else {\r\n      domClasses(tool).remove('highlighted-entry');\r\n    }\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Return true if the palette is opened.\r\n *\r\n * @example\r\n *\r\n * palette.open();\r\n *\r\n * if (palette.isOpen()) {\r\n *   // yes, we are open\r\n * }\r\n *\r\n * @return {boolean} true if palette is opened\r\n */\r\nPalette.prototype.isOpen = function() {\r\n  return this._container && domClasses(this._container).has('open');\r\n};\r\n\r\n\r\n/* markup definition */\r\n\r\nPalette.HTML_MARKUP =\r\n  '<div class=\"djs-palette\">' +\r\n    '<div class=\"djs-palette-entries\"></div>' +\r\n    '<div class=\"djs-palette-toggle\"></div>' +\r\n  '</div>';\r\n\r\n\r\n////////// helpers /////////////////////////////\r\n\r\nfunction addClasses(element, classNames) {\r\n\r\n  var classes = domClasses(element);\r\n\r\n  var actualClassNames = isArray(classNames) ? classNames : classNames.split(//s+/g);\r\n  actualClassNames.forEach(function(cls) {\r\n    classes.add(cls);\r\n  });\r\n}\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __depends__: [ require(319) ],\r\n  __init__: [ 'palette' ],\r\n  palette: [ 'type', require(289) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    assign = require(516),\r\n    find = require(385);\r\n\r\nvar domDelegate = require(534),\r\n    domify = require(535),\r\n    domClasses = require(531),\r\n    domAttr = require(530),\r\n    domRemove = require(539);\r\n\r\nvar DATA_REF = 'data-id';\r\n\r\n/**\r\n * A popup menu that can be used to display a list of actions anywhere in the canvas.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n *\r\n * @class\r\n * @constructor\r\n */\r\nfunction PopupMenu(eventBus, canvas) {\r\n\r\n  this._eventBus = eventBus;\r\n  this._canvas  = canvas;\r\n  this._providers = {};\r\n}\r\n\r\nPopupMenu.$inject = [ 'eventBus', 'canvas' ];\r\n\r\n/**\r\n * Registers a popup menu provider\r\n *\r\n * @param  {String} id\r\n * @param  {Object} provider\r\n *\r\n * @example\r\n * popupMenu.registerProvider('myMenuID', {\r\n *   getEntries: function(element) {\r\n *     return [\r\n *       {\r\n *          id: 'entry-1',\r\n *          label: 'My Entry',\r\n *          action: 'alert(\"I have been clicked!\")'\r\n *        }\r\n *      ];\r\n *    }\r\n *  });\r\n * })\r\n */\r\nPopupMenu.prototype.registerProvider = function(id, provider) {\r\n  this._providers[id] = provider;\r\n};\r\n\r\n\r\n/**\r\n * Create a popup menu according to a given element. The id refers to the ID\r\n * of the provider that must be registered before.\r\n *\r\n * @param  {String} id provider id\r\n * @param  {Object} element\r\n *\r\n * @return {PopupMenu} popup menu instance\r\n */\r\nPopupMenu.prototype.create = function(id, element) {\r\n\r\n  var provider = this._providers[id];\r\n\r\n  if (!provider) {\r\n    throw new Error('Provider is not registered: ' + id);\r\n  }\r\n\r\n  if (!element) {\r\n    throw new Error('Element is missing');\r\n  }\r\n\r\n  var current = this._current = {\r\n    provider: provider,\r\n    className: id,\r\n    element: element\r\n  };\r\n\r\n  if (provider.getHeaderEntries) {\r\n    current.headerEntries = provider.getHeaderEntries(element);\r\n  }\r\n\r\n  current.entries = provider.getEntries(element);\r\n\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * Determine if the popup menu has entries.\r\n *\r\n * @return {Boolean} true if empty\r\n */\r\nPopupMenu.prototype.isEmpty = function() {\r\n\r\n  var current = this._current;\r\n\r\n  return current.entries.length === 0 && current.headerEntries && current.headerEntries.length === 0;\r\n};\r\n\r\n\r\n/**\r\n * Open popup menu at given position\r\n *\r\n * @param {Object} position\r\n *\r\n * @return {Object} popup menu instance\r\n */\r\nPopupMenu.prototype.open = function(position) {\r\n\r\n  if (!position) {\r\n    throw new Error('the position argument is missing');\r\n  }\r\n\r\n  // make sure, only one popup menu is open at a time\r\n  if (this.isOpen()) {\r\n    this.close();\r\n  }\r\n\r\n  var current = this._current,\r\n      canvas = this._canvas,\r\n      parent = canvas.getContainer();\r\n\r\n  current.position = position;\r\n\r\n  current.container = this._createContainer();\r\n\r\n  if (current.headerEntries) {\r\n    var headerEntriesContainer = this._createEntries(current.headerEntries, 'djs-popup-header');\r\n\r\n    current.container.appendChild(headerEntriesContainer);\r\n  }\r\n\r\n  if (current.entries) {\r\n    var entriesContainer = this._createEntries(current.entries, 'djs-popup-body');\r\n\r\n    current.container.appendChild(entriesContainer);\r\n  }\r\n\r\n  this._attachContainer(current.container, parent, position.cursor);\r\n\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * Removes the popup menu and unbinds the event handlers.\r\n */\r\nPopupMenu.prototype.close = function() {\r\n\r\n  if (!this.isOpen()) {\r\n    return;\r\n  }\r\n\r\n  this._unbindHandlers();\r\n  domRemove(this._current.container);\r\n  this._current.container = null;\r\n};\r\n\r\n\r\n/**\r\n * Determine if an open popup menu exist.\r\n *\r\n * @return {Boolean} true if open\r\n */\r\nPopupMenu.prototype.isOpen = function() {\r\n  return !!this._current.container;\r\n};\r\n\r\n\r\n/**\r\n * Trigger an action associated with an entry.\r\n *\r\n * @param {Object} event\r\n *\r\n * @return the result of the action callback, if any\r\n */\r\nPopupMenu.prototype.trigger = function(event) {\r\n\r\n  // silence other actions\r\n  event.preventDefault();\r\n\r\n  var element = event.delegateTarget || event.target,\r\n      entryId = domAttr(element, DATA_REF);\r\n\r\n  var entry = this._getEntry(entryId);\r\n\r\n  if (entry.action) {\r\n    return entry.action.call(null, event, entry);\r\n  }\r\n};\r\n\r\n/**\r\n * Gets an entry instance (either entry or headerEntry) by id.\r\n *\r\n * @param  {String} entryId\r\n *\r\n * @return {Object} entry instance\r\n */\r\nPopupMenu.prototype._getEntry = function(entryId) {\r\n\r\n  var search = { id: entryId };\r\n\r\n  var entry = find(this._current.entries, search) || find(this._current.headerEntries, search);\r\n\r\n  if (!entry) {\r\n    throw new Error('entry not found');\r\n  }\r\n\r\n  return entry;\r\n};\r\n\r\n\r\n/**\r\n * Creates the popup menu container.\r\n *\r\n * @return {Object} a DOM container\r\n */\r\nPopupMenu.prototype._createContainer = function() {\r\n  var container = domify('<div class=\"djs-popup\">'),\r\n      position = this._current.position,\r\n      className = this._current.className;\r\n\r\n  assign(container.style, {\r\n    position: 'absolute',\r\n    left: position.x + 'px',\r\n    top: position.y + 'px',\r\n    visibility: 'hidden'\r\n  });\r\n\r\n  domClasses(container).add(className);\r\n\r\n  return container;\r\n};\r\n\r\n\r\n/**\r\n * Attaches the container to the DOM and binds the event handlers.\r\n *\r\n * @param {Object} container\r\n * @param {Object} parent\r\n */\r\nPopupMenu.prototype._attachContainer = function(container, parent, cursor) {\r\n  var self = this;\r\n\r\n   // Event handler\r\n  domDelegate.bind(container, '.entry' ,'click', function(event) {\r\n    self.trigger(event);\r\n  });\r\n\r\n  // apply canvas zoom level\r\n  var zoom = this._canvas.zoom();\r\n\r\n  container.style.transformOrigin = 'top left';\r\n  container.style.transform = 'scale(' + zoom + ')';\r\n\r\n  // Attach to DOM\r\n  parent.appendChild(container);\r\n\r\n  if (cursor) {\r\n    this._assureIsInbounds(container, cursor);\r\n  }\r\n\r\n  // Add Handler\r\n  this._bindHandlers();\r\n};\r\n\r\n\r\n/**\r\n * Make sure that the menu is always fully shown\r\n *\r\n * @method function\r\n *\r\n * @param  {Object} container\r\n * @param  {Position} cursor {x, y}\r\n */\r\nPopupMenu.prototype._assureIsInbounds = function(container, cursor) {\r\n  var canvas = this._canvas,\r\n      clientRect = canvas._container.getBoundingClientRect();\r\n\r\n  var containerX = container.offsetLeft,\r\n      containerY = container.offsetTop,\r\n      containerWidth = container.scrollWidth,\r\n      containerHeight = container.scrollHeight,\r\n      overAxis = {},\r\n      left, top;\r\n\r\n  var cursorPosition = {\r\n    x: cursor.x - clientRect.left,\r\n    y: cursor.y - clientRect.top\r\n  };\r\n\r\n  if (containerX + containerWidth > clientRect.width) {\r\n    overAxis.x = true;\r\n  }\r\n\r\n  if (containerY + containerHeight > clientRect.height) {\r\n    overAxis.y = true;\r\n  }\r\n\r\n  if (overAxis.x && overAxis.y) {\r\n    left = cursorPosition.x - containerWidth + 'px';\r\n    top = cursorPosition.y - containerHeight + 'px';\r\n  } else if (overAxis.x) {\r\n    left = cursorPosition.x - containerWidth + 'px';\r\n    top = cursorPosition.y + 'px';\r\n  } else if (overAxis.y && cursorPosition.y < containerHeight) {\r\n    left = cursorPosition.x + 'px';\r\n    top = 10 + 'px';\r\n  } else if (overAxis.y) {\r\n    left = cursorPosition.x + 'px';\r\n    top = cursorPosition.y - containerHeight + 'px';\r\n  }\r\n\r\n  assign(container.style, { left: left, top: top }, { visibility: 'visible', 'z-index': 1000 });\r\n};\r\n\r\n\r\n/**\r\n * Creates a list of entries and returns them as a DOM container.\r\n *\r\n * @param {Array<Object>} entries an array of entry objects\r\n * @param {String} className the class name of the entry container\r\n *\r\n * @return {Object} a DOM container\r\n */\r\nPopupMenu.prototype._createEntries = function(entries, className) {\r\n\r\n  var entriesContainer = domify('<div>'),\r\n      self = this;\r\n\r\n  domClasses(entriesContainer).add(className);\r\n\r\n  forEach(entries, function(entry) {\r\n    var entryContainer = self._createEntry(entry, entriesContainer);\r\n    entriesContainer.appendChild(entryContainer);\r\n  });\r\n\r\n  return entriesContainer;\r\n};\r\n\r\n\r\n/**\r\n * Creates a single entry and returns it as a DOM container.\r\n *\r\n * @param  {Object} entry\r\n *\r\n * @return {Object} a DOM container\r\n */\r\nPopupMenu.prototype._createEntry = function(entry) {\r\n\r\n  if (!entry.id) {\r\n    throw new Error ('every entry must have the id property set');\r\n  }\r\n\r\n  var entryContainer = domify('<div>'),\r\n      entryClasses = domClasses(entryContainer);\r\n\r\n  entryClasses.add('entry');\r\n\r\n  if (entry.className) {\r\n    entryClasses.add(entry.className);\r\n  }\r\n\r\n  domAttr(entryContainer, DATA_REF, entry.id);\r\n\r\n  if (entry.label) {\r\n    var label = domify('<span>');\r\n    label.textContent = entry.label;\r\n    entryContainer.appendChild(label);\r\n  }\r\n\r\n  if (entry.imageUrl) {\r\n    entryContainer.appendChild(domify('<img src=\"' + entry.imageUrl + '\" />'));\r\n  }\r\n\r\n  if (entry.active === true) {\r\n    entryClasses.add('active');\r\n  }\r\n\r\n  if (entry.disabled === true) {\r\n    entryClasses.add('disabled');\r\n  }\r\n\r\n  if (entry.title) {\r\n    entryContainer.title = entry.title;\r\n  }\r\n\r\n  return entryContainer;\r\n};\r\n\r\n\r\n/**\r\n * Binds the `close` method to 'contextPad.close' & 'canvas.viewbox.changed'.\r\n */\r\nPopupMenu.prototype._bindHandlers = function() {\r\n\r\n  var eventBus = this._eventBus,\r\n      self = this;\r\n\r\n  function close() {\r\n    self.close();\r\n  }\r\n\r\n  eventBus.once('contextPad.close', close);\r\n  eventBus.once('canvas.viewbox.changing', close);\r\n  eventBus.once('commandStack.changed', close);\r\n};\r\n\r\n\r\n/**\r\n * Unbinds the `close` method to 'contextPad.close' & 'canvas.viewbox.changing'.\r\n */\r\nPopupMenu.prototype._unbindHandlers = function() {\r\n\r\n  var eventBus = this._eventBus,\r\n      self = this;\r\n\r\n  function close() {\r\n    self.close();\r\n  }\r\n\r\n  eventBus.off('contextPad.close', close);\r\n  eventBus.off('canvas.viewbox.changed', close);\r\n  eventBus.off('commandStack.changed', close);\r\n};\r\n\r\nmodule.exports = PopupMenu;\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'popupMenu' ],\r\n  popupMenu: [ 'type', require(291) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClone = require(582),\r\n    svgCreate = require(583);\r\n\r\n/**\r\n * Adds support for previews of moving/resizing elements.\r\n */\r\nfunction PreviewSupport(elementRegistry, canvas, styles) {\r\n  this._elementRegistry = elementRegistry;\r\n  this._canvas = canvas;\r\n  this._styles = styles;\r\n}\r\n\r\nmodule.exports = PreviewSupport;\r\n\r\nPreviewSupport.$inject = [ 'elementRegistry', 'canvas', 'styles' ];\r\n\r\n\r\n/**\r\n * Returns graphics of an element.\r\n *\r\n * @param {djs.model.Base} element\r\n *\r\n * @return {SVGElement}\r\n */\r\nPreviewSupport.prototype.getGfx = function(element) {\r\n  return this._elementRegistry.getGraphics(element);\r\n};\r\n\r\n/**\r\n * Adds a move preview of a given shape to a given svg group.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {SVGElement} group\r\n *\r\n * @return {SVGElement} dragger\r\n */\r\nPreviewSupport.prototype.addDragger = function(shape, group) {\r\n  var gfx = this.getGfx(shape);\r\n\r\n  // clone is not included in tsvg for some reason\r\n  var dragger = svgClone(gfx);\r\n  var bbox = gfx.getBoundingClientRect();\r\n\r\n  // remove markers from connections\r\n  if (isConnection(shape)) {\r\n    removeMarkers(dragger);\r\n  }\r\n\r\n  svgAttr(dragger, this._styles.cls('djs-dragger', [], {\r\n    x: bbox.top,\r\n    y: bbox.left\r\n  }));\r\n\r\n  svgAppend(group, dragger);\r\n\r\n  return dragger;\r\n};\r\n\r\n/**\r\n * Adds a resize preview of a given shape to a given svg group.\r\n *\r\n * @param {djs.model.Base} element\r\n * @param {SVGElement} group\r\n *\r\n * @return {SVGElement} frame\r\n */\r\nPreviewSupport.prototype.addFrame = function(shape, group) {\r\n\r\n  var frame = svgCreate('rect', {\r\n    class: 'djs-resize-overlay',\r\n    width:  shape.width,\r\n    height: shape.height,\r\n    x: shape.x,\r\n    y: shape.y\r\n  });\r\n\r\n  svgAppend(group, frame);\r\n\r\n  return frame;\r\n};\r\n\r\n////////// helpers //////////\r\n\r\n/**\r\n * Removes all svg marker references from an SVG.\r\n *\r\n * @param {SVGElement} gfx\r\n */\r\nfunction removeMarkers(gfx) {\r\n\r\n  if (gfx.children) {\r\n\r\n    forEach(gfx.children, function(child) {\r\n\r\n      // recursion\r\n      removeMarkers(child);\r\n\r\n    });\r\n\r\n  }\r\n\r\n  gfx.style.markerStart = '';\r\n  gfx.style.markerEnd = '';\r\n\r\n}\r\n\r\n/**\r\n * Checks if an element is a connection.\r\n */\r\nfunction isConnection(element) {\r\n  return element.waypoints;\r\n}\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'previewSupport' ],\r\n  previewSupport: [ 'type', require(293) ]\r\n};\r\n","'use strict';\r\n\r\n\r\n/**\r\n * Service that allow replacing of elements.\r\n *\r\n *\r\n * @class\r\n * @constructor\r\n */\r\nfunction Replace(modeling) {\r\n\r\n  this._modeling = modeling;\r\n}\r\n\r\nmodule.exports = Replace;\r\n\r\nReplace.$inject = [ 'modeling' ];\r\n\r\n/**\r\n * @param {Element} oldElement - Element to be replaced\r\n * @param {Object}  newElementData - Containing information about the new Element, for example height, width, type.\r\n * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data\r\n *                            that is needed in the command chain. For example it could be used in\r\n *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after\r\n *                            shape creation.\r\n */\r\nReplace.prototype.replaceElement = function(oldElement, newElementData, options) {\r\n\r\n  var modeling = this._modeling;\r\n\r\n  var newElement = null;\r\n\r\n  if (oldElement.waypoints) {\r\n    // TODO\r\n    // modeling.replaceConnection\r\n  } else {\r\n    // set center of element for modeling API\r\n    // if no new width / height is given use old elements size\r\n    newElementData.x = Math.ceil(oldElement.x + (newElementData.width || oldElement.width) / 2);\r\n    newElementData.y = Math.ceil(oldElement.y + (newElementData.height || oldElement.height) / 2);\r\n\r\n    newElement = modeling.replaceShape(oldElement, newElementData, options);\r\n  }\r\n\r\n  return newElement;\r\n};\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: [ 'replace' ],\r\n  replace: [ 'type', require(295) ]\r\n};\r\n","'use strict';\r\n\r\nvar pick = require(524),\r\n    assign = require(516);\r\n\r\nvar ResizeUtil = require(300);\r\n\r\nvar asTRBL = require(329).asTRBL,\r\n    roundBounds = require(329).roundBounds;\r\n\r\nvar DEFAULT_MIN_WIDTH = 10;\r\n\r\n\r\n/**\r\n * A component that provides resizing of shapes on the canvas.\r\n *\r\n * The following components are part of shape resize:\r\n *\r\n *  * adding resize handles,\r\n *  * creating a visual during resize\r\n *  * checking resize rules\r\n *  * committing a change once finished\r\n *\r\n *\r\n * ## Customizing\r\n *\r\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\r\n * and providing the following parameters through the 'context':\r\n *\r\n *   * minDimensions ({ width, height }): minimum shape dimensions\r\n *\r\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\r\n *     gap between the minimum bounding box and the container\r\n *\r\n * f.ex:\r\n *\r\n * ```javascript\r\n * eventBus.on('resize.start', 1500, function(event) {\r\n *   var context = event.context,\r\n *\r\n *  context.minDimensions = { width: 140, height: 120 };\r\n *\r\n *  // Passing general padding\r\n *  context.childrenBoxPadding = 30;\r\n *\r\n *  // Passing padding to a specific side\r\n *  context.childrenBoxPadding.left = 20;\r\n * });\r\n * ```\r\n */\r\nfunction Resize(eventBus, rules, modeling, dragging) {\r\n\r\n  this._dragging = dragging;\r\n  this._rules = rules;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('resize.start', function(event) {\r\n\r\n    var context = event.context,\r\n        resizeConstraints = context.resizeConstraints,\r\n        // evaluate minBounds for backwards compatibility\r\n        minBounds = context.minBounds;\r\n\r\n    if (resizeConstraints === undefined) {\r\n\r\n      if (minBounds === undefined) {\r\n        minBounds = self.computeMinResizeBox(context);\r\n      }\r\n\r\n      context.resizeConstraints = {\r\n        min: asTRBL(minBounds)\r\n      };\r\n    }\r\n  });\r\n\r\n  eventBus.on('resize.move', function(event) {\r\n\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        direction = context.direction,\r\n        resizeConstraints = context.resizeConstraints,\r\n        delta,\r\n        newBounds;\r\n\r\n    delta = {\r\n      x: event.dx,\r\n      y: event.dy\r\n    };\r\n\r\n    context.delta = delta;\r\n\r\n    newBounds = ResizeUtil.resizeBounds(shape, direction, delta);\r\n\r\n    // ensure constraints during resize\r\n    context.newBounds = ResizeUtil.ensureConstraints(newBounds, resizeConstraints);\r\n\r\n    // update + cache executable state\r\n    context.canExecute = self.canResize(context);\r\n  });\r\n\r\n  eventBus.on('resize.end', function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        canExecute = context.canExecute,\r\n        newBounds = context.newBounds;\r\n\r\n    if (canExecute) {\r\n      // ensure we have actual pixel values for new bounds\r\n      // (important when zoom level was > 1 during move)\r\n      newBounds = roundBounds(newBounds);\r\n\r\n      // perform the actual resize\r\n      modeling.resizeShape(shape, newBounds);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nResize.prototype.canResize = function(context) {\r\n  var rules = this._rules;\r\n\r\n  var ctx = pick(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);\r\n\r\n  return rules.allowed('shape.resize', ctx);\r\n};\r\n\r\n/**\r\n * Activate a resize operation\r\n *\r\n * You may specify additional contextual information and must specify a\r\n * resize direction during activation of the resize event.\r\n *\r\n * @param {MouseEvent} event\r\n * @param {djs.model.Shape} shape\r\n * @param {Object|String} contextOrDirection\r\n */\r\nResize.prototype.activate = function(event, shape, contextOrDirection) {\r\n  var dragging = this._dragging,\r\n      context,\r\n      direction;\r\n\r\n  if (typeof contextOrDirection === 'string') {\r\n    contextOrDirection = {\r\n      direction: contextOrDirection\r\n    };\r\n  }\r\n\r\n  context = assign({ shape: shape }, contextOrDirection);\r\n\r\n  direction = context.direction;\r\n\r\n  if (!direction) {\r\n    throw new Error('must provide a direction (nw|se|ne|sw)');\r\n  }\r\n\r\n  dragging.init(event, 'resize', {\r\n    autoActivate: true,\r\n    cursor: 'resize-' + (/nw|se/.test(direction) ? 'nwse' : 'nesw'),\r\n    data: {\r\n      shape: shape,\r\n      context: context\r\n    }\r\n  });\r\n};\r\n\r\nResize.prototype.computeMinResizeBox = function(context) {\r\n  var shape = context.shape,\r\n      direction = context.direction,\r\n      minDimensions,\r\n      childrenBounds;\r\n\r\n  minDimensions = context.minDimensions || {\r\n    width: DEFAULT_MIN_WIDTH,\r\n    height: DEFAULT_MIN_WIDTH\r\n  };\r\n\r\n  // get children bounds\r\n  childrenBounds = ResizeUtil.computeChildrenBBox(shape, context.childrenBoxPadding);\r\n\r\n  // get correct minimum bounds from given resize direction\r\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\r\n  return ResizeUtil.getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\r\n};\r\n\r\n\r\nResize.$inject = [ 'eventBus', 'rules', 'modeling', 'dragging' ];\r\n\r\nmodule.exports = Resize;\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar HANDLE_OFFSET = -2,\r\n    HANDLE_SIZE  = 5,\r\n    HANDLE_HIT_SIZE = 20;\r\n\r\nvar CLS_RESIZER   = 'djs-resizer';\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgClear = require(581),\r\n    svgCreate = require(583);\r\n\r\nvar domEvent = require(536);\r\n\r\nvar isPrimaryButton = require(351).isPrimaryButton;\r\n\r\nvar asTRBL = require(329).asTRBL;\r\n\r\nvar transform = require(356).transform;\r\n\r\n\r\n/**\r\n * This component is responsible for adding resize handles.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {Selection} selection\r\n * @param {Resize} resize\r\n */\r\nfunction ResizeHandles(eventBus, canvas, selection, resize) {\r\n\r\n  this._resize = resize;\r\n  this._canvas = canvas;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('selection.changed', function(e) {\r\n    var newSelection = e.newSelection;\r\n\r\n    // remove old selection markers\r\n    self.removeResizers();\r\n\r\n    // add new selection markers ONLY if single selection\r\n    if (newSelection.length === 1) {\r\n      forEach(newSelection, self.addResizer, self);\r\n    }\r\n  });\r\n\r\n  eventBus.on('shape.changed', function(e) {\r\n    var shape = e.element;\r\n\r\n    if (selection.isSelected(shape)) {\r\n      self.removeResizers();\r\n\r\n      self.addResizer(shape);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {\r\n  var resize = this._resize;\r\n\r\n  function startResize(event) {\r\n    // only trigger on left mouse button\r\n    if (isPrimaryButton(event)) {\r\n      resize.activate(event, element, direction);\r\n    }\r\n  }\r\n\r\n  domEvent.bind(gfx, 'mousedown', startResize);\r\n  domEvent.bind(gfx, 'touchstart', startResize);\r\n};\r\n\r\n\r\nResizeHandles.prototype._createResizer = function(element, x, y, rotation, direction) {\r\n  var resizersParent = this._getResizersParent();\r\n\r\n  var group = svgCreate('g');\r\n  svgClasses(group).add(CLS_RESIZER);\r\n  svgClasses(group).add(CLS_RESIZER + '-' + element.id);\r\n  svgClasses(group).add(CLS_RESIZER + '-' + direction);\r\n\r\n  svgAppend(resizersParent, group);\r\n\r\n  var origin = -HANDLE_SIZE + HANDLE_OFFSET;\r\n\r\n  // Create four drag indicators on the outline\r\n  var visual = svgCreate('rect');\r\n  svgAttr(visual, {\r\n    x: origin,\r\n    y: origin,\r\n    width: HANDLE_SIZE,\r\n    height: HANDLE_SIZE\r\n  });\r\n  svgClasses(visual).add(CLS_RESIZER + '-visual');\r\n\r\n  svgAppend(group, visual);\r\n\r\n  var hit = svgCreate('rect');\r\n  svgAttr(hit, {\r\n    x: origin,\r\n    y: origin,\r\n    width: HANDLE_HIT_SIZE,\r\n    height: HANDLE_HIT_SIZE\r\n  });\r\n  svgClasses(hit).add(CLS_RESIZER + '-hit');\r\n\r\n  svgAppend(group, hit);\r\n\r\n  transform(group, x, y, rotation);\r\n\r\n  return group;\r\n};\r\n\r\nResizeHandles.prototype.createResizer = function(element, direction) {\r\n  var resizer;\r\n\r\n  var trbl = asTRBL(element);\r\n\r\n  if (direction === 'nw') {\r\n    resizer = this._createResizer(element, trbl.left, trbl.top, 0, direction);\r\n  } else if (direction === 'ne') {\r\n    resizer = this._createResizer(element, trbl.right, trbl.top, 90, direction);\r\n  } else if (direction === 'se') {\r\n    resizer = this._createResizer(element, trbl.right, trbl.bottom, 180, direction);\r\n  } else {\r\n    resizer = this._createResizer(element, trbl.left, trbl.bottom, 270, direction);\r\n  }\r\n\r\n  this.makeDraggable(element, resizer, direction);\r\n};\r\n\r\n// resize handles implementation ///////////////////////////////\r\n\r\n/**\r\n * Add resizers for a given element.\r\n *\r\n * @param {djs.model.Shape} shape\r\n */\r\nResizeHandles.prototype.addResizer = function(shape) {\r\n  var resize = this._resize;\r\n\r\n  if (!resize.canResize({ shape: shape })) {\r\n    return;\r\n  }\r\n\r\n  this.createResizer(shape, 'nw');\r\n  this.createResizer(shape, 'ne');\r\n  this.createResizer(shape, 'se');\r\n  this.createResizer(shape, 'sw');\r\n};\r\n\r\n/**\r\n * Remove all resizers\r\n */\r\nResizeHandles.prototype.removeResizers = function() {\r\n  var resizersParent = this._getResizersParent();\r\n\r\n  svgClear(resizersParent);\r\n};\r\n\r\nResizeHandles.prototype._getResizersParent = function() {\r\n  return this._canvas.getLayer('resizers');\r\n};\r\n\r\nResizeHandles.$inject = [ 'eventBus', 'canvas', 'selection', 'resize' ];\r\n\r\nmodule.exports = ResizeHandles;\r\n","'use strict';\r\n\r\nvar MARKER_RESIZING = 'djs-resizing',\r\n    MARKER_RESIZE_NOT_OK = 'resize-not-ok';\r\n\r\nvar LOW_PRIORITY = 500;\r\n\r\nvar svgAttr = require(579),\r\n    svgRemove = require(586);\r\n\r\nvar svgClasses = require(580);\r\n\r\n\r\n/**\r\n * Provides previews for resizing shapes when resizing.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {Canvas} canvas\r\n * @param {Styles} styles\r\n */\r\nfunction ResizePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\r\n\r\n  // add and update previews\r\n  eventBus.on('resize.move', LOW_PRIORITY, function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        bounds = context.newBounds,\r\n        frame = context.frame;\r\n\r\n    if (!frame) {\r\n      frame = context.frame = previewSupport.addFrame(shape, canvas.getDefaultLayer());\r\n\r\n      canvas.addMarker(shape, MARKER_RESIZING);\r\n    }\r\n\r\n    if (bounds.width > 5) {\r\n      svgAttr(frame, { x: bounds.x, width: bounds.width });\r\n    }\r\n\r\n    if (bounds.height > 5) {\r\n      svgAttr(frame, { y: bounds.y, height: bounds.height });\r\n    }\r\n\r\n    if (context.canExecute) {\r\n      svgClasses(frame).remove(MARKER_RESIZE_NOT_OK);\r\n    } else {\r\n      svgClasses(frame).add(MARKER_RESIZE_NOT_OK);\r\n    }\r\n\r\n  });\r\n\r\n  // remove previews\r\n  eventBus.on('resize.cleanup', function(event) {\r\n    var context = event.context,\r\n        shape = context.shape,\r\n        frame = context.frame;\r\n\r\n    if (frame) {\r\n      svgRemove(context.frame);\r\n    }\r\n\r\n    canvas.removeMarker(shape, MARKER_RESIZING);\r\n  });\r\n}\r\n\r\nResizePreview.$inject = [ 'eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];\r\n\r\nmodule.exports = ResizePreview;\r\n","'use strict';\r\n\r\nvar filter = require(384);\r\n\r\nvar max = Math.max,\r\n    min = Math.min;\r\n\r\nvar DEFAULT_CHILD_BOX_PADDING = 20;\r\n\r\nvar getBBox = require(343).getBBox;\r\n\r\n\r\nvar asTRBL = require(329).asTRBL,\r\n    asBounds = require(329).asBounds;\r\n\r\nfunction isNumber(a) {\r\n  return typeof a === 'number';\r\n}\r\n\r\n/**\r\n * Substract a TRBL from another\r\n *\r\n * @param  {TRBL} trblA\r\n * @param  {TRBL} trblB\r\n *\r\n * @return {TRBL}\r\n */\r\nmodule.exports.substractTRBL = function(trblA, trblB) {\r\n  return {\r\n    top: trblA.top - trblB.top,\r\n    right: trblA.right - trblB.right,\r\n    bottom: trblA.bottom - trblB.bottom,\r\n    left: trblA.left - trblB.left\r\n  };\r\n};\r\n\r\n/**\r\n * Resize the given bounds by the specified delta from a given anchor point.\r\n *\r\n * @param {Bounds} bounds the bounding box that should be resized\r\n * @param {String} direction in which the element is resized (nw, ne, se, sw)\r\n * @param {Point} delta of the resize operation\r\n *\r\n * @return {Bounds} resized bounding box\r\n */\r\nmodule.exports.resizeBounds = function(bounds, direction, delta) {\r\n\r\n  var dx = delta.x,\r\n      dy = delta.y;\r\n\r\n  switch (direction) {\r\n\r\n  case 'nw':\r\n    return {\r\n      x: bounds.x + dx,\r\n      y: bounds.y + dy,\r\n      width: bounds.width - dx,\r\n      height: bounds.height - dy\r\n    };\r\n\r\n  case 'sw':\r\n    return {\r\n      x: bounds.x + dx,\r\n      y: bounds.y,\r\n      width: bounds.width - dx,\r\n      height: bounds.height + dy\r\n    };\r\n\r\n  case 'ne':\r\n    return {\r\n      x: bounds.x,\r\n      y: bounds.y + dy,\r\n      width: bounds.width + dx,\r\n      height: bounds.height - dy\r\n    };\r\n\r\n  case 'se':\r\n    return {\r\n      x: bounds.x,\r\n      y: bounds.y,\r\n      width: bounds.width + dx,\r\n      height: bounds.height + dy\r\n    };\r\n\r\n  default:\r\n    throw new Error('unrecognized direction: ' + direction);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Resize the given bounds by applying the passed\r\n * { top, right, bottom, left } delta.\r\n *\r\n * @param {Bounds} bounds\r\n * @param {TRBL} trblResize\r\n *\r\n * @return {Bounds}\r\n */\r\nmodule.exports.resizeTRBL = function(bounds, resize) {\r\n  return {\r\n    x: bounds.x + (resize.left || 0),\r\n    y: bounds.y + (resize.top || 0),\r\n    width: bounds.width - (resize.left || 0) + (resize.right || 0),\r\n    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)\r\n  };\r\n};\r\n\r\n\r\nmodule.exports.reattachPoint = function(bounds, newBounds, point) {\r\n\r\n  var sx = bounds.width / newBounds.width,\r\n      sy = bounds.height / newBounds.height;\r\n\r\n  return {\r\n    x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),\r\n    y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)\r\n  };\r\n};\r\n\r\n\r\nfunction applyConstraints(attr, trbl, resizeConstraints) {\r\n\r\n  var value = trbl[attr],\r\n      minValue = resizeConstraints.min && resizeConstraints.min[attr],\r\n      maxValue = resizeConstraints.max && resizeConstraints.max[attr];\r\n\r\n  if (isNumber(minValue)) {\r\n    value = (/top|left/.test(attr) ? min : max)(value, minValue);\r\n  }\r\n\r\n  if (isNumber(maxValue)) {\r\n    value = (/top|left/.test(attr) ? max : min)(value, maxValue);\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nmodule.exports.ensureConstraints = function(currentBounds, resizeConstraints) {\r\n\r\n  if (!resizeConstraints) {\r\n    return currentBounds;\r\n  }\r\n\r\n  var currentTrbl = asTRBL(currentBounds);\r\n\r\n  return asBounds({\r\n    top: applyConstraints('top', currentTrbl, resizeConstraints),\r\n    right: applyConstraints('right', currentTrbl, resizeConstraints),\r\n    bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),\r\n    left: applyConstraints('left', currentTrbl, resizeConstraints)\r\n  });\r\n};\r\n\r\n\r\nmodule.exports.getMinResizeBounds = function(direction, currentBounds, minDimensions, childrenBounds) {\r\n\r\n  var currentBox = asTRBL(currentBounds);\r\n\r\n  var minBox = {\r\n    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,\r\n    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,\r\n    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,\r\n    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right\r\n  };\r\n\r\n  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;\r\n\r\n  var combinedBox = {\r\n    top: min(minBox.top, childrenBox.top),\r\n    left: min(minBox.left, childrenBox.left),\r\n    bottom: max(minBox.bottom, childrenBox.bottom),\r\n    right: max(minBox.right, childrenBox.right)\r\n  };\r\n\r\n  return asBounds(combinedBox);\r\n};\r\n\r\nfunction asPadding(mayBePadding, defaultValue) {\r\n  if (typeof mayBePadding !== 'undefined') {\r\n    return mayBePadding;\r\n  } else {\r\n    return DEFAULT_CHILD_BOX_PADDING;\r\n  }\r\n}\r\n\r\nfunction addPadding(bbox, padding) {\r\n  var left, right, top, bottom;\r\n\r\n  if (typeof padding === 'object') {\r\n    left = asPadding(padding.left);\r\n    right = asPadding(padding.right);\r\n    top = asPadding(padding.top);\r\n    bottom = asPadding(padding.bottom);\r\n  } else {\r\n    left = right = top = bottom = asPadding(padding);\r\n  }\r\n\r\n  return {\r\n    x: bbox.x - left,\r\n    y: bbox.y - top,\r\n    width: bbox.width + left + right,\r\n    height: bbox.height + top + bottom\r\n  };\r\n}\r\n\r\nmodule.exports.addPadding = addPadding;\r\n\r\n\r\n/**\r\n * Is the given element part of the resize\r\n * targets min boundary box?\r\n *\r\n * This is the default implementation which excludes\r\n * connections and labels.\r\n *\r\n * @param {djs.model.Base} element\r\n */\r\nfunction isBBoxChild(element) {\r\n\r\n  // exclude connections\r\n  if (element.waypoints) {\r\n    return false;\r\n  }\r\n\r\n  // exclude labels\r\n  if (element.type === 'label') {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Return children bounding computed from a shapes children\r\n * or a list of prefiltered children.\r\n *\r\n * @param  {djs.model.Shape|Array<djs.model.Shape>} shapeOrChildren\r\n * @param  {Number|Object} padding\r\n *\r\n * @return {Bounds}\r\n */\r\nfunction computeChildrenBBox(shapeOrChildren, padding) {\r\n\r\n  var elements;\r\n\r\n  // compute based on shape\r\n  if (shapeOrChildren.length === undefined) {\r\n    // grab all the children that are part of the\r\n    // parents children box\r\n    elements = filter(shapeOrChildren.children, isBBoxChild);\r\n\r\n  } else {\r\n    elements = shapeOrChildren;\r\n  }\r\n\r\n  if (elements.length) {\r\n    return addPadding(getBBox(elements), padding);\r\n  }\r\n}\r\n\r\nmodule.exports.computeChildrenBBox = computeChildrenBBox;\r\n","module.exports = {\r\n  __depends__: [\r\n    require(304),\r\n    require(239),\r\n    require(294)\r\n  ],\r\n  __init__: [ 'resize', 'resizePreview', 'resizeHandles' ],\r\n  resize: [ 'type', require(297) ],\r\n  resizePreview: [ 'type', require(299) ],\r\n  resizeHandles: [ 'type', require(298) ]\r\n};\r\n","\r\n'use strict';\r\n\r\nvar inherits = require(368);\r\n\r\nvar CommandInterceptor = require(196);\r\n\r\n/**\r\n * A basic provider that may be extended to implement modeling rules.\r\n *\r\n * Extensions should implement the init method to actually add their custom\r\n * modeling checks. Checks may be added via the #addRule(action, fn) method.\r\n *\r\n * @param {EventBus} eventBus\r\n */\r\nfunction RuleProvider(eventBus) {\r\n  CommandInterceptor.call(this, eventBus);\r\n\r\n  this.init();\r\n}\r\n\r\nRuleProvider.$inject = [ 'eventBus' ];\r\n\r\ninherits(RuleProvider, CommandInterceptor);\r\n\r\nmodule.exports = RuleProvider;\r\n\r\n\r\n/**\r\n * Adds a modeling rule for the given action, implemented through\r\n * a callback function.\r\n *\r\n * The function will receive the modeling specific action context\r\n * to perform its check. It must return `false` to disallow the\r\n * action from happening or `true` to allow the action.\r\n *\r\n * A rule provider may pass over the evaluation to lower priority\r\n * rules by returning return nothing (or <code>undefined</code>).\r\n *\r\n * @example\r\n *\r\n * ResizableRules.prototype.init = function() {\r\n *\r\n *   //**\r\n *    * Return `true`, `false` or nothing to denote\r\n *    * _allowed_, _not allowed_ and _continue evaluating_.\r\n *    *//\r\n *   this.addRule('shape.resize', function(context) {\r\n *\r\n *     var shape = context.shape;\r\n *\r\n *     if (!context.newBounds) {\r\n *       // check general resizability\r\n *       if (!shape.resizable) {\r\n *         return false;\r\n *       }\r\n *\r\n *       // not returning anything (read: undefined)\r\n *       // will continue the evaluation of other rules\r\n *       // (with lower priority)\r\n *       return;\r\n *     } else {\r\n *       // element must have minimum size of 10*10 points\r\n *       return context.newBounds.width > 10 && context.newBounds.height > 10;\r\n *     }\r\n *   });\r\n * };\r\n *\r\n * @param {String|Array<String>} actions the identifier for the modeling action to check\r\n * @param {Number} [priority] the priority at which this rule is being applied\r\n * @param {Function} fn the callback function that performs the actual check\r\n */\r\nRuleProvider.prototype.addRule = function(actions, priority, fn) {\r\n\r\n  var self = this;\r\n\r\n  if (typeof actions === 'string') {\r\n    actions = [ actions ];\r\n  }\r\n\r\n  actions.forEach(function(action) {\r\n\r\n    self.canExecute(action, priority, function(context, action, event) {\r\n      return fn(context);\r\n    }, true);\r\n  });\r\n};\r\n\r\n/**\r\n * Implement this method to add new rules during provider initialization.\r\n */\r\nRuleProvider.prototype.init = function() {};","'use strict';\r\n\r\n/**\r\n * A service that provides rules for certain diagram actions.\r\n *\r\n * The default implementation will hook into the {@link CommandStack}\r\n * to perform the actual rule evaluation. Make sure to provide the\r\n * `commandStack` service with this module if you plan to use it.\r\n *\r\n * Together with this implementation you may use the {@link RuleProvider}\r\n * to implement your own rule checkers.\r\n *\r\n * This module is ment to be easily replaced, thus the tiny foot print.\r\n *\r\n * @param {Injector} injector\r\n */\r\nfunction Rules(injector) {\r\n  this._commandStack = injector.get('commandStack', false);\r\n}\r\n\r\nRules.$inject = [ 'injector' ];\r\n\r\nmodule.exports = Rules;\r\n\r\n\r\n/**\r\n * Returns whether or not a given modeling action can be executed\r\n * in the specified context.\r\n *\r\n * This implementation will respond with allow unless anyone\r\n * objects.\r\n *\r\n * @param {String} action the action to be checked\r\n * @param {Object} [context] the context to check the action in\r\n *\r\n * @return {Boolean} returns true, false or null depending on whether the\r\n *                   operation is allowed, not allowed or should be ignored.\r\n */\r\nRules.prototype.allowed = function(action, context) {\r\n  var allowed = true;\r\n\r\n  var commandStack = this._commandStack;\r\n\r\n  if (commandStack) {\r\n    allowed = commandStack.canExecute(action, context);\r\n  }\r\n\r\n  // map undefined to true, i.e. no rules\r\n  return allowed === undefined ? true : allowed;\r\n};","module.exports = {\r\n  __init__: [ 'rules' ],\r\n  rules: [ 'type', require(303) ]\r\n};\r\n","'use strict';\r\n\r\nvar domClear = require(532),\r\n    domDelegate = require(534),\r\n    domQuery = require(538),\r\n    domClasses = require(531),\r\n    domAttr = require(530),\r\n    domify = require(535);\r\n\r\nvar getBoundingBox = require(343).getBBox;\r\n\r\n\r\n/**\r\n * Provides searching infrastructure\r\n */\r\nfunction SearchPad(canvas, eventBus, overlays, selection) {\r\n  this._open = false;\r\n  this._results = [];\r\n  this._eventMaps = [];\r\n\r\n  this._canvas = canvas;\r\n  this._eventBus = eventBus;\r\n  this._overlays = overlays;\r\n  this._selection = selection;\r\n\r\n  // setup elements\r\n  this._container = domify(SearchPad.BOX_HTML);\r\n  this._searchInput = domQuery(SearchPad.INPUT_SELECTOR, this._container);\r\n  this._resultsContainer = domQuery(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);\r\n\r\n  // attach search pad\r\n  this._canvas.getContainer().appendChild(this._container);\r\n\r\n  // cleanup on destroy\r\n  eventBus.on([ 'canvas.destroy', 'diagram.destroy' ], this.close, this);\r\n}\r\n\r\n\r\nSearchPad.$inject = [\r\n  'canvas',\r\n  'eventBus',\r\n  'overlays',\r\n  'selection'\r\n];\r\n\r\n\r\n/**\r\n * Binds and keeps track of all event listereners\r\n */\r\nSearchPad.prototype._bindEvents = function() {\r\n  var self = this;\r\n\r\n  function listen(el, selector, type, fn) {\r\n    self._eventMaps.push({\r\n      el: el,\r\n      type: type,\r\n      listener: domDelegate.bind(el, selector, type, fn)\r\n    });\r\n  }\r\n\r\n  // close search on clicking anywhere outside\r\n  listen(document, 'html', 'click', function(e) {\r\n    self.close();\r\n  }, true);\r\n\r\n  // stop event from propagating and closing search\r\n  // focus on input\r\n  listen(this._container, SearchPad.INPUT_SELECTOR, 'click', function(e) {\r\n    e.stopPropagation();\r\n    e.delegateTarget.focus();\r\n  });\r\n\r\n  // preselect result on hover\r\n  listen(this._container, SearchPad.RESULT_SELECTOR, 'mouseover', function(e) {\r\n    e.stopPropagation();\r\n    self._scrollToNode(e.delegateTarget);\r\n    self._preselect(e.delegateTarget);\r\n  });\r\n\r\n  // selects desired result on mouse click\r\n  listen(this._container, SearchPad.RESULT_SELECTOR, 'click', function(e) {\r\n    e.stopPropagation();\r\n    self._select(e.delegateTarget);\r\n  });\r\n\r\n  // prevent cursor in input from going left and right when using up/down to\r\n  // navigate results\r\n  listen(this._container, SearchPad.INPUT_SELECTOR, 'keydown', function(e) {\r\n    // up\r\n    if (e.keyCode === 38) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    // down\r\n    if (e.keyCode === 40) {\r\n      e.preventDefault();\r\n    }\r\n  });\r\n\r\n  // handle keyboard input\r\n  listen(this._container, SearchPad.INPUT_SELECTOR, 'keyup', function(e) {\r\n    // escape\r\n    if (e.keyCode === 27) {\r\n      return self.close();\r\n    }\r\n\r\n    // enter\r\n    if (e.keyCode === 13) {\r\n      var selected = self._getCurrentResult();\r\n\r\n      return selected ? self._select(selected) : self.close();\r\n    }\r\n\r\n    // up\r\n    if (e.keyCode === 38) {\r\n      return self._scrollToDirection(true);\r\n    }\r\n\r\n    // down\r\n    if (e.keyCode === 40) {\r\n      return self._scrollToDirection();\r\n    }\r\n\r\n    // left && right\r\n    // do not search while navigating text input\r\n    if (e.keyCode === 37 || e.keyCode === 39) {\r\n      return;\r\n    }\r\n\r\n    // anything else\r\n    self._search(e.delegateTarget.value);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Unbinds all previously established listeners\r\n */\r\nSearchPad.prototype._unbindEvents = function() {\r\n  this._eventMaps.forEach(function(m) {\r\n    domDelegate.unbind(m.el, m.type, m.listener);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Performs a search for the given pattern.\r\n *\r\n * @param  {String} pattern\r\n */\r\nSearchPad.prototype._search = function(pattern) {\r\n  var self = this;\r\n\r\n  this._clearResults();\r\n\r\n  // do not search on empty query\r\n  if (!pattern || pattern === '') {\r\n    return;\r\n  }\r\n\r\n  var searchResults = this._searchProvider.find(pattern);\r\n\r\n  if (!searchResults.length) {\r\n    return;\r\n  }\r\n\r\n  // append new results\r\n  searchResults.forEach(function(result) {\r\n    var id = result.element.id;\r\n    var node = self._createResultNode(result, id);\r\n    self._results[id] = {\r\n      element: result.element,\r\n      node: node\r\n    };\r\n  });\r\n\r\n  // preselect first result\r\n  var node = domQuery(SearchPad.RESULT_SELECTOR, this._resultsContainer);\r\n  this._scrollToNode(node);\r\n  this._preselect(node);\r\n};\r\n\r\n\r\n/**\r\n * Navigate to the previous/next result. Defaults to next result.\r\n * @param  {Boolean} previous\r\n */\r\nSearchPad.prototype._scrollToDirection = function(previous) {\r\n  var selected = this._getCurrentResult();\r\n  if (!selected) {\r\n    return;\r\n  }\r\n\r\n  var node = previous ? selected.previousElementSibling : selected.nextElementSibling;\r\n  if (node) {\r\n    this._scrollToNode(node);\r\n    this._preselect(node);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Scroll to the node if it is not visible.\r\n *\r\n * @param  {Element} node\r\n */\r\nSearchPad.prototype._scrollToNode = function(node) {\r\n  if (!node || node === this._getCurrentResult()) {\r\n    return;\r\n  }\r\n\r\n  var nodeOffset = node.offsetTop;\r\n  var containerScroll = this._resultsContainer.scrollTop;\r\n\r\n  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node.clientHeight;\r\n\r\n  if (nodeOffset < containerScroll) {\r\n    this._resultsContainer.scrollTop = nodeOffset;\r\n  } else if (containerScroll < bottomScroll) {\r\n    this._resultsContainer.scrollTop = bottomScroll;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Clears all results data.\r\n */\r\nSearchPad.prototype._clearResults = function() {\r\n  domClear(this._resultsContainer);\r\n\r\n  this._results = [];\r\n\r\n  this._resetOverlay();\r\n\r\n  this._eventBus.fire('searchPad.cleared');\r\n};\r\n\r\n\r\n/**\r\n * Get currently selected result.\r\n *\r\n * @return {Element}\r\n */\r\nSearchPad.prototype._getCurrentResult = function() {\r\n  return domQuery(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);\r\n};\r\n\r\n\r\n/**\r\n * Create result DOM element within results container\r\n * that corresponds to a search result.\r\n *\r\n * 'result' : one of the elements returned by SearchProvider\r\n * 'id' : id attribute value to assign to the new DOM node\r\n * return : created DOM element\r\n *\r\n * @param  {SearchResult} result\r\n * @param  {String} id\r\n * @return {Element}\r\n */\r\nSearchPad.prototype._createResultNode = function(result, id) {\r\n  var node = domify(SearchPad.RESULT_HTML);\r\n\r\n  // create only if available\r\n  if (result.primaryTokens.length > 0) {\r\n    createInnerTextNode(node, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);\r\n  }\r\n\r\n  // secondary tokens (represent element ID) are allways available\r\n  createInnerTextNode(node, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);\r\n\r\n  domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE, id);\r\n\r\n  this._resultsContainer.appendChild(node);\r\n\r\n  return node;\r\n};\r\n\r\n\r\n/**\r\n * Register search element provider.\r\n *\r\n * SearchProvider.find - provides search function over own elements\r\n *  (pattern) => [{ text: <String>, element: <Element>}, ...]\r\n *\r\n * @param  {SearchProvider} provider\r\n */\r\nSearchPad.prototype.registerProvider = function(provider) {\r\n  this._searchProvider = provider;\r\n};\r\n\r\n\r\n/**\r\n * Open search pad.\r\n */\r\nSearchPad.prototype.open = function() {\r\n  if (!this._searchProvider) {\r\n    throw new Error('no search provider registered');\r\n  }\r\n\r\n  if (this.isOpen()) {\r\n    return;\r\n  }\r\n\r\n  this._bindEvents();\r\n\r\n  this._open = true;\r\n\r\n  domClasses(this._container).add('open');\r\n\r\n  this._searchInput.focus();\r\n\r\n  this._eventBus.fire('searchPad.opened');\r\n};\r\n\r\n\r\n/**\r\n * Close search pad.\r\n */\r\nSearchPad.prototype.close = function() {\r\n  if (!this.isOpen()) {\r\n    return;\r\n  }\r\n\r\n  this._unbindEvents();\r\n\r\n  this._open = false;\r\n\r\n  domClasses(this._container).remove('open');\r\n\r\n  this._clearResults();\r\n\r\n  this._searchInput.value = '';\r\n  this._searchInput.blur();\r\n\r\n  this._resetOverlay();\r\n\r\n  this._eventBus.fire('searchPad.closed');\r\n};\r\n\r\n\r\n/**\r\n * Toggles search pad on/off.\r\n */\r\nSearchPad.prototype.toggle = function() {\r\n  this.isOpen() ? this.close() : this.open();\r\n};\r\n\r\n\r\n/**\r\n * Report state of search pad.\r\n */\r\nSearchPad.prototype.isOpen = function() {\r\n  return this._open;\r\n};\r\n\r\n\r\n/**\r\n * Preselect result entry.\r\n *\r\n * @param  {Element} element\r\n */\r\nSearchPad.prototype._preselect = function(node) {\r\n  var selectedNode = this._getCurrentResult();\r\n\r\n  // already selected\r\n  if (node === selectedNode) {\r\n    return;\r\n  }\r\n\r\n  // removing preselection from current node\r\n  if (selectedNode) {\r\n    domClasses(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);\r\n  }\r\n\r\n  var id = domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE);\r\n  var element = this._results[id].element;\r\n\r\n  domClasses(node).add(SearchPad.RESULT_SELECTED_CLASS);\r\n\r\n  this._resetOverlay(element);\r\n\r\n  this._centerViewbox(element);\r\n\r\n  this._selection.select(element);\r\n\r\n  this._eventBus.fire('searchPad.preselected', element);\r\n};\r\n\r\n\r\n/**\r\n * Select result node.\r\n *\r\n * @param  {Element} element\r\n */\r\nSearchPad.prototype._select = function(node) {\r\n  var id = domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE);\r\n  var element = this._results[id].element;\r\n\r\n  this.close();\r\n\r\n  this._resetOverlay();\r\n\r\n  this._centerViewbox(element);\r\n\r\n  this._selection.select(element);\r\n\r\n  this._eventBus.fire('searchPad.selected', element);\r\n};\r\n\r\n\r\n/**\r\n * Center viewbox on the element middle point.\r\n *\r\n * @param  {Element} element\r\n */\r\nSearchPad.prototype._centerViewbox = function(element) {\r\n  var viewbox = this._canvas.viewbox();\r\n\r\n  var box = getBoundingBox(element);\r\n\r\n  var newViewbox = {\r\n    x: (box.x + box.width/2) - viewbox.outer.width/2,\r\n    y: (box.y + box.height/2) - viewbox.outer.height/2,\r\n    width: viewbox.outer.width,\r\n    height: viewbox.outer.height\r\n  };\r\n\r\n  this._canvas.viewbox(newViewbox);\r\n\r\n  this._canvas.zoom(viewbox.scale);\r\n};\r\n\r\n\r\n/**\r\n * Reset overlay removes and, optionally, set\r\n * overlay to a new element.\r\n *\r\n * @param  {Element} element\r\n */\r\nSearchPad.prototype._resetOverlay = function(element) {\r\n  if (this._overlayId) {\r\n    this._overlays.remove(this._overlayId);\r\n  }\r\n\r\n  if (element) {\r\n    var box = getBoundingBox(element);\r\n    var overlay = constructOverlay(box);\r\n    this._overlayId = this._overlays.add(element, overlay);\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = SearchPad;\r\n\r\n/**\r\n * Construct overlay object for the given bounding box.\r\n *\r\n * @param  {BoundingBox} box\r\n * @return {Object}\r\n */\r\nfunction constructOverlay(box) {\r\n\r\n  var offset = 6;\r\n  var w = box.width + offset * 2;\r\n  var h = box.height + offset * 2;\r\n\r\n  var styles = [\r\n    'width: '+ w +'px',\r\n    'height: '+ h + 'px'\r\n  ].join('; ');\r\n\r\n  return {\r\n    position: {\r\n      bottom: h - offset,\r\n      right: w - offset\r\n    },\r\n    show: true,\r\n    html: '<div style=\"' + styles + '\" class=\"' + SearchPad.OVERLAY_CLASS + '\"></div>'\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Creates and appends child node from result tokens and HTML template.\r\n *\r\n * @param  {Element} node\r\n * @param  {Array<Object>} tokens\r\n * @param  {String} template\r\n */\r\nfunction createInnerTextNode(parentNode, tokens, template) {\r\n  var text = createHtmlText(tokens);\r\n  var childNode = domify(template);\r\n  childNode.innerHTML = text;\r\n  parentNode.appendChild(childNode);\r\n}\r\n\r\n/**\r\n * Create internal HTML markup from result tokens.\r\n * Caters for highlighting pattern matched tokens.\r\n *\r\n * @param  {Array<Object>} tokens\r\n * @return {String}\r\n */\r\nfunction createHtmlText(tokens) {\r\n  var htmlText = '';\r\n\r\n  tokens.forEach(function(t) {\r\n    if (t.matched) {\r\n      htmlText += '<strong class=\"' + SearchPad.RESULT_HIGHLIGHT_CLASS + '\">' + t.matched + '</strong>';\r\n    } else {\r\n      htmlText += t.normal;\r\n    }\r\n  });\r\n\r\n  return htmlText !== '' ? htmlText : null;\r\n}\r\n\r\n\r\n/**\r\n * CONSTANTS\r\n */\r\nSearchPad.CONTAINER_SELECTOR = '.djs-search-container';\r\nSearchPad.INPUT_SELECTOR = '.djs-search-input input';\r\nSearchPad.RESULTS_CONTAINER_SELECTOR = '.djs-search-results';\r\nSearchPad.RESULT_SELECTOR = '.djs-search-result';\r\nSearchPad.RESULT_SELECTED_CLASS = 'djs-search-result-selected';\r\nSearchPad.RESULT_SELECTED_SELECTOR = '.' + SearchPad.RESULT_SELECTED_CLASS;\r\nSearchPad.RESULT_ID_ATTRIBUTE = 'data-result-id';\r\nSearchPad.RESULT_HIGHLIGHT_CLASS = 'djs-search-highlight';\r\nSearchPad.OVERLAY_CLASS = 'djs-search-overlay';\r\n\r\nSearchPad.BOX_HTML =\r\n  '<div class=\"djs-search-container djs-draggable djs-scrollable\">' +\r\n    '<div class=\"djs-search-input\">' +\r\n      '<input type=\"text\"/>' +\r\n    '</div>' +\r\n    '<div class=\"djs-search-results\"></div>' +\r\n  '</div>';\r\n\r\nSearchPad.RESULT_HTML =\r\n  '<div class=\"djs-search-result\"></div>';\r\n\r\nSearchPad.RESULT_PRIMARY_HTML =\r\n  '<div class=\"djs-search-result-primary\"></div>';\r\n\r\nSearchPad.RESULT_SECONDARY_HTML =\r\n  '<p class=\"djs-search-result-secondary\"></p>';\r\n","module.exports = {\r\n  __depends__: [\r\n    require(288),\r\n    require(310)\r\n  ],\r\n  searchPad: [ 'type', require(305) ]\r\n};\r\n","'use strict';\r\n\r\nvar isArray = require(506),\r\n    forEach = require(386);\r\n\r\n\r\n/**\r\n * A service that offers the current selection in a diagram.\r\n * Offers the api to control the selection, too.\r\n *\r\n * @class\r\n *\r\n * @param {EventBus} eventBus the event bus\r\n */\r\nfunction Selection(eventBus) {\r\n\r\n  this._eventBus = eventBus;\r\n\r\n  this._selectedElements = [];\r\n\r\n  var self = this;\r\n\r\n  eventBus.on([ 'shape.remove', 'connection.remove' ], function(e) {\r\n    var element = e.element;\r\n    self.deselect(element);\r\n  });\r\n\r\n  eventBus.on([ 'diagram.clear' ], function(e) {\r\n    self.select(null);\r\n  });\r\n}\r\n\r\nSelection.$inject = [ 'eventBus' ];\r\n\r\nmodule.exports = Selection;\r\n\r\n\r\nSelection.prototype.deselect = function(element) {\r\n  var selectedElements = this._selectedElements;\r\n\r\n  var idx = selectedElements.indexOf(element);\r\n\r\n  if (idx !== -1) {\r\n    var oldSelection = selectedElements.slice();\r\n\r\n    selectedElements.splice(idx, 1);\r\n\r\n    this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });\r\n  }\r\n};\r\n\r\n\r\nSelection.prototype.get = function() {\r\n  return this._selectedElements;\r\n};\r\n\r\nSelection.prototype.isSelected = function(element) {\r\n  return this._selectedElements.indexOf(element) !== -1;\r\n};\r\n\r\n\r\n/**\r\n * This method selects one or more elements on the diagram.\r\n *\r\n * By passing an additional add parameter you can decide whether or not the element(s)\r\n * should be added to the already existing selection or not.\r\n *\r\n * @method Selection#select\r\n *\r\n * @param  {Object|Object[]} elements element or array of elements to be selected\r\n * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false\r\n */\r\nSelection.prototype.select = function(elements, add) {\r\n  var selectedElements = this._selectedElements,\r\n      oldSelection = selectedElements.slice();\r\n\r\n  if (!isArray(elements)) {\r\n    elements = elements ? [ elements ] : [];\r\n  }\r\n\r\n  // selection may be cleared by passing an empty array or null\r\n  // to the method\r\n  if (add) {\r\n    forEach(elements, function(element) {\r\n      if (selectedElements.indexOf(element) !== -1) {\r\n        // already selected\r\n        return;\r\n      } else {\r\n        selectedElements.push(element);\r\n      }\r\n    });\r\n  } else {\r\n    this._selectedElements = selectedElements = elements.slice();\r\n  }\r\n\r\n  this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });\r\n};\r\n","'use strict';\r\n\r\nvar hasPrimaryModifier = require(351).hasPrimaryModifier;\r\n\r\nvar find = require(385);\r\n\r\n\r\nfunction SelectionBehavior(eventBus, selection, canvas, elementRegistry) {\r\n\r\n  eventBus.on('create.end', 500, function(e) {\r\n\r\n    // select the created shape after a\r\n    // successful create operation\r\n    if (e.context.canExecute) {\r\n      selection.select(e.context.shape);\r\n    }\r\n  });\r\n\r\n  eventBus.on('connect.end', 500, function(e) {\r\n\r\n    // select the connect end target\r\n    // after a connect operation\r\n    if (e.context.canExecute && e.context.target) {\r\n      selection.select(e.context.target);\r\n    }\r\n  });\r\n\r\n  eventBus.on('shape.move.end', 500, function(e) {\r\n    var previousSelection = e.previousSelection || [];\r\n\r\n    var shape = elementRegistry.get(e.context.shape.id);\r\n\r\n    // make sure at least the main moved element is being\r\n    // selected after a move operation\r\n    var inSelection = find(previousSelection, function(selectedShape) {\r\n      return shape.id === selectedShape.id;\r\n    });\r\n\r\n    if (!inSelection) {\r\n      selection.select(shape);\r\n    }\r\n  });\r\n\r\n  // Shift + click selection\r\n  eventBus.on('element.click', function(event) {\r\n\r\n    var element = event.element;\r\n\r\n    // do not select the root element\r\n    // or connections\r\n    if (element === canvas.getRootElement()) {\r\n      element = null;\r\n    }\r\n\r\n    var isSelected = selection.isSelected(element),\r\n        isMultiSelect = selection.get().length > 1;\r\n\r\n    // mouse-event: SELECTION_KEY\r\n    var add = hasPrimaryModifier(event);\r\n\r\n    // select OR deselect element in multi selection\r\n    if (isSelected && isMultiSelect) {\r\n      if (add) {\r\n        return selection.deselect(element);\r\n      } else {\r\n        return selection.select(element);\r\n      }\r\n    } else\r\n    if (!isSelected) {\r\n      selection.select(element, add);\r\n    } else {\r\n      selection.deselect(element);\r\n    }\r\n  });\r\n}\r\n\r\nSelectionBehavior.$inject = [ 'eventBus', 'selection', 'canvas', 'elementRegistry' ];\r\nmodule.exports = SelectionBehavior;\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar MARKER_HOVER = 'hover',\r\n    MARKER_SELECTED = 'selected';\r\n\r\n\r\n/**\r\n * A plugin that adds a visible selection UI to shapes and connections\r\n * by appending the <code>hover</code> and <code>selected</code> classes to them.\r\n *\r\n * @class\r\n *\r\n * Makes elements selectable, too.\r\n *\r\n * @param {EventBus} events\r\n * @param {SelectionService} selection\r\n * @param {Canvas} canvas\r\n */\r\nfunction SelectionVisuals(events, canvas, selection, styles) {\r\n\r\n  this._multiSelectionBox = null;\r\n\r\n  function addMarker(e, cls) {\r\n    canvas.addMarker(e, cls);\r\n  }\r\n\r\n  function removeMarker(e, cls) {\r\n    canvas.removeMarker(e, cls);\r\n  }\r\n\r\n  events.on('element.hover', function(event) {\r\n    addMarker(event.element, MARKER_HOVER);\r\n  });\r\n\r\n  events.on('element.out', function(event) {\r\n    removeMarker(event.element, MARKER_HOVER);\r\n  });\r\n\r\n  events.on('selection.changed', function(event) {\r\n\r\n    function deselect(s) {\r\n      removeMarker(s, MARKER_SELECTED);\r\n    }\r\n\r\n    function select(s) {\r\n      addMarker(s, MARKER_SELECTED);\r\n    }\r\n\r\n    var oldSelection = event.oldSelection,\r\n        newSelection = event.newSelection;\r\n\r\n    forEach(oldSelection, function(e) {\r\n      if (newSelection.indexOf(e) === -1) {\r\n        deselect(e);\r\n      }\r\n    });\r\n\r\n    forEach(newSelection, function(e) {\r\n      if (oldSelection.indexOf(e) === -1) {\r\n        select(e);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nSelectionVisuals.$inject = [\r\n  'eventBus',\r\n  'canvas',\r\n  'selection',\r\n  'styles'\r\n];\r\n\r\nmodule.exports = SelectionVisuals;\r\n","module.exports = {\r\n  __init__: [ 'selectionVisuals', 'selectionBehavior' ],\r\n  __depends__: [\r\n    require(247),\r\n    require(286)\r\n  ],\r\n  selection: [ 'type', require(307) ],\r\n  selectionVisuals: [ 'type', require(309) ],\r\n  selectionBehavior: [ 'type', require(308) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar snapTo = require(312).snapTo;\r\n\r\n\r\n/**\r\n * A snap context, containing the (possibly incomplete)\r\n * mappings of drop targets (to identify the snapping)\r\n * to computed snap points.\r\n */\r\nfunction SnapContext() {\r\n\r\n  /**\r\n   * Map<String, SnapPoints> mapping drop targets to\r\n   * a list of possible snappings.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this._targets = {};\r\n\r\n  /**\r\n   * Map<String, Point> initial positioning of element\r\n   * regarding various snap directions.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this._snapOrigins = {};\r\n\r\n  /**\r\n   * List of snap locations\r\n   *\r\n   * @type {Array<String>}\r\n   */\r\n  this._snapLocations = [];\r\n\r\n  /**\r\n   * Map<String, Array<Point>> of default snapping locations\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this._defaultSnaps = {};\r\n}\r\n\r\n\r\nSnapContext.prototype.getSnapOrigin = function(snapLocation) {\r\n  return this._snapOrigins[snapLocation];\r\n};\r\n\r\n\r\nSnapContext.prototype.setSnapOrigin = function(snapLocation, initialValue) {\r\n  this._snapOrigins[snapLocation] = initialValue;\r\n\r\n  if (this._snapLocations.indexOf(snapLocation) === -1) {\r\n    this._snapLocations.push(snapLocation);\r\n  }\r\n};\r\n\r\n\r\nSnapContext.prototype.addDefaultSnap = function(type, point) {\r\n\r\n  var snapValues = this._defaultSnaps[type];\r\n\r\n  if (!snapValues) {\r\n    snapValues = this._defaultSnaps[type] = [];\r\n  }\r\n\r\n  snapValues.push(point);\r\n};\r\n\r\n/**\r\n * Return a number of initialized snaps, i.e. snap locations such as\r\n * top-left, mid, bottom-right and so forth.\r\n *\r\n * @return {Array<String>} snapLocations\r\n */\r\nSnapContext.prototype.getSnapLocations = function() {\r\n  return this._snapLocations;\r\n};\r\n\r\n/**\r\n * Set the snap locations for this context.\r\n *\r\n * The order of locations determines precedence.\r\n *\r\n * @param {Array<String>} snapLocations\r\n */\r\nSnapContext.prototype.setSnapLocations = function(snapLocations) {\r\n  this._snapLocations = snapLocations;\r\n};\r\n\r\n/**\r\n * Get snap points for a given target\r\n *\r\n * @param {Element|String} target\r\n */\r\nSnapContext.prototype.pointsForTarget = function(target) {\r\n\r\n  var targetId = target.id || target;\r\n\r\n  var snapPoints = this._targets[targetId];\r\n\r\n  if (!snapPoints) {\r\n    snapPoints = this._targets[targetId] = new SnapPoints();\r\n    snapPoints.initDefaults(this._defaultSnaps);\r\n  }\r\n\r\n  return snapPoints;\r\n};\r\n\r\nmodule.exports = SnapContext;\r\n\r\n\r\n/**\r\n * Creates the snap points and initializes them with the\r\n * given default values.\r\n *\r\n * @param {Object<String, Array<Point>>} [defaultPoints]\r\n */\r\nfunction SnapPoints(defaultSnaps) {\r\n\r\n  /**\r\n   * Map<String, Map<(x|y), Array<Number>>> mapping snap locations,\r\n   * i.e. top-left, bottom-right, center to actual snap values.\r\n   *\r\n   * @type {Object}\r\n   */\r\n  this._snapValues = {};\r\n}\r\n\r\nSnapPoints.prototype.add = function(snapLocation, point) {\r\n\r\n  var snapValues = this._snapValues[snapLocation];\r\n\r\n  if (!snapValues) {\r\n    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };\r\n  }\r\n\r\n  if (snapValues.x.indexOf(point.x) === -1) {\r\n    snapValues.x.push(point.x);\r\n  }\r\n\r\n  if (snapValues.y.indexOf(point.y) === -1) {\r\n    snapValues.y.push(point.y);\r\n  }\r\n};\r\n\r\n\r\nSnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {\r\n  var snappingValues = this._snapValues[snapLocation];\r\n  \r\n  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);\r\n};\r\n\r\n/**\r\n * Initialize a number of default snapping points.\r\n *\r\n * @param  {Object} defaultSnaps\r\n */\r\nSnapPoints.prototype.initDefaults = function(defaultSnaps) {\r\n\r\n  var self = this;\r\n\r\n  forEach(defaultSnaps || {}, function(snapPoints, snapLocation) {\r\n    forEach(snapPoints, function(point) {\r\n      self.add(snapLocation, point);\r\n    });\r\n  });\r\n};","'use strict';\r\n\r\nvar abs = Math.abs,\r\n    round = Math.round;\r\n\r\n\r\n/**\r\n * Snap value to a collection of reference values.\r\n *\r\n * @param  {Number} value\r\n * @param  {Array<Number>} values\r\n * @param  {Number} [tolerance=10]\r\n *\r\n * @return {Number} the value we snapped to or null, if none snapped\r\n */\r\nfunction snapTo(value, values, tolerance) {\r\n  tolerance = tolerance === undefined ? 10 : tolerance;\r\n\r\n  var idx, snapValue;\r\n\r\n  for (idx = 0; idx < values.length; idx++) {\r\n    snapValue = values[idx];\r\n\r\n    if (abs(snapValue - value) <= tolerance) {\r\n      return snapValue;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports.snapTo = snapTo;\r\n\r\n\r\nfunction topLeft(bounds) {\r\n  return {\r\n    x: bounds.x,\r\n    y: bounds.y\r\n  };\r\n}\r\n\r\nmodule.exports.topLeft = topLeft;\r\n\r\n\r\nfunction mid(bounds, defaultValue) {\r\n\r\n  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {\r\n    return defaultValue;\r\n  }\r\n\r\n  return {\r\n    x: round(bounds.x + bounds.width / 2),\r\n    y: round(bounds.y + bounds.height / 2)\r\n  };\r\n}\r\n\r\nmodule.exports.mid = mid;\r\n\r\n\r\nfunction bottomRight(bounds) {\r\n  return {\r\n    x: bounds.x + bounds.width,\r\n    y: bounds.y + bounds.height\r\n  };\r\n}\r\n\r\nmodule.exports.bottomRight = bottomRight;\r\n\r\n\r\n/**\r\n * Retrieve the snap state of the given event.\r\n *\r\n * @param  {Event} event\r\n * @param  {String} axis\r\n *\r\n * @return {Boolean} the snapped state\r\n *\r\n */\r\nmodule.exports.isSnapped = function(event, axis) {\r\n  var snapped = event.snapped;\r\n\r\n  if (!snapped) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof axis === 'string') {\r\n    return snapped[axis];\r\n  }\r\n\r\n  return snapped.x && snapped.y;\r\n};\r\n\r\n/**\r\n * Set the given event as snapped.\r\n *\r\n * This method may change the x and/or y position of the shape\r\n * from the given event!\r\n *\r\n * @param {Event} event\r\n * @param {String} axis\r\n * @param {Number|Boolean} value\r\n *\r\n * @return {Number} old value\r\n */\r\nmodule.exports.setSnapped = function(event, axis, value) {\r\n  if (typeof axis !== 'string') {\r\n    throw new Error('axis must be in [x, y]');\r\n  }\r\n\r\n  if (typeof value !== 'number' && value !== false) {\r\n    throw new Error('value must be Number or false');\r\n  }\r\n\r\n  var delta,\r\n      previousValue = event[axis];\r\n\r\n  var snapped = event.snapped = (event.snapped || {});\r\n\r\n\r\n  if (value === false) {\r\n    snapped[axis] = false;\r\n  } else {\r\n    snapped[axis] = true;\r\n\r\n    delta = value - previousValue;\r\n\r\n    event[axis] += delta;\r\n    event['d' + axis] += delta;\r\n  }\r\n\r\n  return previousValue;\r\n};","'use strict';\r\n\r\nvar filter = require(384),\r\n    forEach = require(386),\r\n    debounce = require(397);\r\n\r\nvar mid = require(312).mid;\r\n\r\nvar SnapContext = require(311);\r\n\r\nvar SnapUtil = require(312);\r\n\r\nvar HIGHER_PRIORITY = 1250;\r\n\r\nvar isSnapped = SnapUtil.isSnapped,\r\n    setSnapped = SnapUtil.setSnapped;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583);\r\n\r\n\r\n/**\r\n * A general purpose snapping component for diagram elements.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n */\r\nfunction Snapping(eventBus, canvas) {\r\n\r\n  this._canvas = canvas;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on([ 'shape.move.start', 'create.start' ], function(event) {\r\n    self.initSnap(event);\r\n  });\r\n\r\n  eventBus.on([ 'shape.move.move', 'shape.move.end', 'create.move', 'create.end' ], HIGHER_PRIORITY, function(event) {\r\n\r\n    if (event.originalEvent && event.originalEvent.ctrlKey) {\r\n      return;\r\n    }\r\n\r\n    if (isSnapped(event)) {\r\n      return;\r\n    }\r\n\r\n    self.snap(event);\r\n  });\r\n\r\n  eventBus.on([ 'shape.move.cleanup', 'create.cleanup' ], function(event) {\r\n    self.hide();\r\n  });\r\n\r\n  // delay hide by 1000 seconds since last match\r\n  this._asyncHide = debounce(this.hide, 1000);\r\n}\r\n\r\nSnapping.$inject = [ 'eventBus', 'canvas' ];\r\n\r\nmodule.exports = Snapping;\r\n\r\n\r\nSnapping.prototype.initSnap = function(event) {\r\n\r\n  var context = event.context,\r\n      shape = context.shape,\r\n      snapContext = context.snapContext;\r\n\r\n  if (!snapContext) {\r\n    snapContext = context.snapContext = new SnapContext();\r\n  }\r\n\r\n  var snapMid = mid(shape, event);\r\n\r\n  snapContext.setSnapOrigin('mid', {\r\n    x: snapMid.x - event.x,\r\n    y: snapMid.y - event.y\r\n  });\r\n\r\n  return snapContext;\r\n};\r\n\r\n\r\nSnapping.prototype.snap = function(event) {\r\n\r\n  var context = event.context,\r\n      snapContext = context.snapContext,\r\n      shape = context.shape,\r\n      target = context.target,\r\n      snapLocations = snapContext.getSnapLocations();\r\n\r\n  if (!target) {\r\n    return;\r\n  }\r\n\r\n  var snapPoints = snapContext.pointsForTarget(target);\r\n\r\n  if (!snapPoints.initialized) {\r\n    this.addTargetSnaps(snapPoints, shape, target);\r\n\r\n    snapPoints.initialized = true;\r\n  }\r\n\r\n\r\n  var snapping = {\r\n    x: isSnapped(event, 'x'),\r\n    y: isSnapped(event, 'y')\r\n  };\r\n\r\n\r\n  forEach(snapLocations, function(location) {\r\n\r\n    var snapOrigin = snapContext.getSnapOrigin(location);\r\n\r\n    var snapCurrent = {\r\n      x: event.x + snapOrigin.x,\r\n      y: event.y + snapOrigin.y\r\n    };\r\n\r\n    // snap on both axis, if not snapped already\r\n    forEach([ 'x', 'y' ], function(axis) {\r\n      var locationSnapping;\r\n\r\n      if (!snapping[axis]) {\r\n        locationSnapping = snapPoints.snap(snapCurrent, location, axis, 7);\r\n\r\n        if (locationSnapping !== undefined) {\r\n          snapping[axis] = {\r\n            value: locationSnapping,\r\n            originValue: locationSnapping - snapOrigin[axis]\r\n          };\r\n        }\r\n      }\r\n    });\r\n\r\n    // no more need to snap, drop out of interation\r\n    if (snapping.x && snapping.y) {\r\n      return false;\r\n    }\r\n  });\r\n\r\n\r\n  // show snap visuals\r\n\r\n  this.showSnapLine('vertical', snapping.x && snapping.x.value);\r\n  this.showSnapLine('horizontal', snapping.y && snapping.y.value);\r\n\r\n\r\n  // adjust event { x, y, dx, dy } and mark as snapping\r\n  forEach([ 'x', 'y' ], function(axis) {\r\n\r\n    var axisSnapping = snapping[axis];\r\n\r\n    if (typeof axisSnapping === 'object') {\r\n      // set as snapped and adjust the x and/or y position of the event\r\n      setSnapped(event, axis, axisSnapping.originValue);\r\n    }\r\n  });\r\n};\r\n\r\n\r\nSnapping.prototype._createLine = function(orientation) {\r\n\r\n  var root = this._canvas.getLayer('snap');\r\n\r\n  // var line = root.path('M0,0 L0,0').addClass('djs-snap-line');\r\n\r\n  var line = svgCreate('path');\r\n  svgAttr(line, { d: 'M0,0 L0,0' });\r\n  svgClasses(line).add('djs-snap-line');\r\n\r\n  svgAppend(root, line);\r\n\r\n  return {\r\n    update: function(position) {\r\n\r\n      if (typeof position !== 'number') {\r\n        svgAttr(line, { display: 'none' });\r\n      } else {\r\n        if (orientation === 'horizontal') {\r\n          svgAttr(line, {\r\n            d: 'M-100000,' + position + ' L+100000,' + position,\r\n            display: ''\r\n          });\r\n        } else {\r\n          svgAttr(line, {\r\n            d: 'M ' + position + ',-100000 L ' + position + ', +100000',\r\n            display: ''\r\n          });\r\n        }\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n\r\nSnapping.prototype._createSnapLines = function() {\r\n\r\n  this._snapLines = {\r\n    horizontal: this._createLine('horizontal'),\r\n    vertical: this._createLine('vertical')\r\n  };\r\n};\r\n\r\nSnapping.prototype.showSnapLine = function(orientation, position) {\r\n\r\n  var line = this.getSnapLine(orientation);\r\n\r\n  if (line) {\r\n    line.update(position);\r\n  }\r\n\r\n  this._asyncHide();\r\n};\r\n\r\nSnapping.prototype.getSnapLine = function(orientation) {\r\n  if (!this._snapLines) {\r\n    this._createSnapLines();\r\n  }\r\n\r\n  return this._snapLines[orientation];\r\n};\r\n\r\nSnapping.prototype.hide = function() {\r\n  forEach(this._snapLines, function(l) {\r\n    l.update();\r\n  });\r\n};\r\n\r\nSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\r\n\r\n  var siblings = this.getSiblings(shape, target);\r\n\r\n  forEach(siblings, function(s) {\r\n    snapPoints.add('mid', mid(s));\r\n  });\r\n\r\n};\r\n\r\nSnapping.prototype.getSiblings = function(element, target) {\r\n\r\n  // snap to all siblings that are not hidden, labels, attached to element or element itself\r\n  return target && filter(target.children, function(e) {\r\n    return !e.hidden && !e.labelTarget && e.host !== element && e !== element;\r\n  });\r\n};\r\n","'use strict';\r\n\r\nvar SpaceUtil = require(316);\r\n\r\nvar Cursor = require(342);\r\n\r\nvar hasPrimaryModifier = require(351).hasPrimaryModifier;\r\n\r\nvar abs = Math.abs,\r\n    round = Math.round;\r\n\r\nvar HIGH_PRIORITY = 1500,\r\n    SPACE_TOOL_CURSOR = 'crosshair';\r\n\r\nvar AXIS_TO_DIMENSION = { x: 'width', y: 'height' },\r\n    AXIS_INVERTED = { x: 'y', y: 'x' };\r\n\r\nvar getAllChildren = require(343).selfAndAllChildren;\r\n\r\nvar assign = require(516),\r\n    forEach = require(386);\r\n\r\n\r\n/**\r\n * A tool that allows users to create and remove space in a diagram.\r\n *\r\n * The tool needs to be activated manually via {@link SpaceTool#activate(MouseEvent)}.\r\n */\r\nfunction SpaceTool(eventBus, dragging, canvas, modeling, rules, toolManager) {\r\n\r\n  this._canvas = canvas;\r\n  this._dragging = dragging;\r\n  this._modeling = modeling;\r\n  this._rules = rules;\r\n  this._toolManager = toolManager;\r\n\r\n  var self = this;\r\n\r\n  toolManager.registerTool('space', {\r\n    tool: 'spaceTool.selection',\r\n    dragging: 'spaceTool'\r\n  });\r\n\r\n  eventBus.on('spaceTool.selection.end', function(event) {\r\n    var target = event.originalEvent.target;\r\n\r\n    // only reactive on diagram click\r\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\r\n    if (!event.hover && !(target instanceof SVGElement)) {\r\n      return;\r\n    }\r\n\r\n    eventBus.once('spaceTool.selection.ended', function() {\r\n      self.activateMakeSpace(event.originalEvent);\r\n    });\r\n  });\r\n\r\n\r\n  eventBus.on('spaceTool.move', HIGH_PRIORITY , function(event) {\r\n\r\n    var context = event.context;\r\n\r\n    if (!context.initialized) {\r\n      context.initialized = self.initializeMakeSpace(event, context);\r\n    }\r\n  });\r\n\r\n\r\n  eventBus.on('spaceTool.end', function(event) {\r\n\r\n    var context = event.context,\r\n        axis = context.axis,\r\n        direction = context.direction,\r\n        movingShapes = context.movingShapes,\r\n        resizingShapes = context.resizingShapes;\r\n\r\n    // skip if create space has not been initialized yet\r\n    if (!context.initialized) {\r\n      return;\r\n    }\r\n\r\n    var delta = { x: round(event.dx), y: round(event.dy) };\r\n    delta[ AXIS_INVERTED[ axis ] ] = 0;\r\n\r\n    var insideBounds = true;\r\n\r\n    // check if the space tool cursor is inside of bounds of\r\n    // any of the shapes that would be resized.\r\n    forEach(resizingShapes, function(shape) {\r\n\r\n      if ((direction === 'w' && event.x > shape.x + shape.width) ||\r\n          (direction === 'e' && event.x < shape.x) ||\r\n          (direction === 'n' && event.y > shape.y + shape.height) ||\r\n          (direction === 's' && event.y < shape.y)) {\r\n\r\n        insideBounds = false;\r\n        return;\r\n      }\r\n    });\r\n\r\n    if (insideBounds) {\r\n      // make space only if the cursor is inside bounds\r\n      self.makeSpace(movingShapes, resizingShapes, delta, direction);\r\n    }\r\n\r\n    eventBus.once('spaceTool.ended', function(event) {\r\n      // reactivate space tool after usage\r\n      self.activateSelection(event.originalEvent, true, true);\r\n    });\r\n\r\n  });\r\n}\r\n\r\nSpaceTool.$inject = [ 'eventBus', 'dragging', 'canvas', 'modeling', 'rules', 'toolManager' ];\r\n\r\nmodule.exports = SpaceTool;\r\n\r\n\r\n/**\r\n * Activate space tool selection\r\n *\r\n * @param  {MouseEvent} event\r\n * @param  {Boolean} autoActivate\r\n */\r\nSpaceTool.prototype.activateSelection = function(event, autoActivate, reactivate) {\r\n  this._dragging.init(event, 'spaceTool.selection', {\r\n    trapClick: false,\r\n    cursor: SPACE_TOOL_CURSOR,\r\n    autoActivate: autoActivate,\r\n    data: {\r\n      context: {\r\n        reactivate: reactivate\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Activate make space\r\n *\r\n * @param  {MouseEvent} event\r\n */\r\nSpaceTool.prototype.activateMakeSpace = function(event) {\r\n  this._dragging.init(event, 'spaceTool', {\r\n    autoActivate: true,\r\n    cursor: SPACE_TOOL_CURSOR,\r\n    data: {\r\n      context: {}\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Actually make space on the diagram\r\n *\r\n * @param  {Array<djs.model.Shape>} movingShapes\r\n * @param  {Array<djs.model.Shape>} resizingShapes\r\n * @param  {Point} delta\r\n * @param  {String} direction\r\n */\r\nSpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta, direction) {\r\n  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction);\r\n};\r\n\r\n/**\r\n * Initialize make space and return true if that was successful.\r\n *\r\n * @param {Event} event\r\n * @param {Object} context\r\n *\r\n * @return {Boolean} true, if successful\r\n */\r\nSpaceTool.prototype.initializeMakeSpace = function(event, context) {\r\n\r\n  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',\r\n      offset = event['d' + axis],\r\n      // start point of create space operation\r\n      spacePos = event[axis] - offset;\r\n\r\n  if (abs(offset) < 5) {\r\n    return false;\r\n  }\r\n\r\n  // invert the offset in order to remove space when moving left\r\n  if (offset < 0) {\r\n    offset *= -1;\r\n  }\r\n\r\n  // inverts the offset to choose the shapes\r\n  // on the opposite side of the resizer if\r\n  // a key modifier is pressed\r\n  if (hasPrimaryModifier(event)) {\r\n    offset *= -1;\r\n  }\r\n\r\n  var rootShape = this._canvas.getRootElement();\r\n\r\n  var allShapes = getAllChildren(rootShape, true);\r\n\r\n  var adjustments = this.calculateAdjustments(allShapes, axis, offset, spacePos);\r\n\r\n  // store data in context\r\n  assign(context, adjustments, {\r\n    axis: axis,\r\n    direction: SpaceUtil.getDirection(axis, offset)\r\n  });\r\n\r\n  Cursor.set('resize-' + (axis === 'x' ? 'ew' : 'ns'));\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Calculate adjustments needed when making space\r\n *\r\n * @param  {Array<djs.model.Shape>} elements\r\n * @param  {String} axis\r\n * @param  {Number} offset\r\n * @param  {Number} spacePos\r\n *\r\n * @return {Object}\r\n */\r\nSpaceTool.prototype.calculateAdjustments = function(elements, axis, offset, spacePos) {\r\n\r\n  var movingShapes = [],\r\n      resizingShapes = [];\r\n\r\n  var rules = this._rules;\r\n\r\n  // collect all elements that need to be moved _AND_\r\n  // resized given on the initial create space position\r\n  elements.forEach(function(shape) {\r\n\r\n    var shapeStart = shape[axis],\r\n        shapeEnd = shapeStart + shape[AXIS_TO_DIMENSION[axis]];\r\n\r\n    // checking if it's root\r\n    if (!shape.parent) {\r\n      return;\r\n    }\r\n\r\n    // checking if it's a shape\r\n    if (shape.waypoints) {\r\n      return;\r\n    }\r\n\r\n    // shape after spacePos\r\n    if (offset > 0 && shapeStart > spacePos) {\r\n      return movingShapes.push(shape);\r\n    }\r\n\r\n    // shape before spacePos\r\n    if (offset < 0 && shapeEnd < spacePos) {\r\n      return movingShapes.push(shape);\r\n    }\r\n\r\n    // shape on top of spacePos, resize only if allowed\r\n    if (shapeStart < spacePos &&\r\n        shapeEnd > spacePos &&\r\n        rules.allowed('shape.resize', { shape: shape })) {\r\n\r\n      return resizingShapes.push(shape);\r\n    }\r\n  });\r\n\r\n  return {\r\n    movingShapes: movingShapes,\r\n    resizingShapes: resizingShapes\r\n  };\r\n};\r\n\r\nSpaceTool.prototype.toggle = function() {\r\n  if (this.isActive()) {\r\n    this._dragging.cancel();\r\n  } else {\r\n    this.activateSelection();\r\n  }\r\n};\r\n\r\nSpaceTool.prototype.isActive = function() {\r\n  var context = this._dragging.context();\r\n\r\n  return context && /^spaceTool/.test(context.prefix);\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar MARKER_DRAGGING = 'djs-dragging',\r\n    MARKER_RESIZING = 'djs-resizing';\r\n\r\nvar LOW_PRIORITY = 250;\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgClasses = require(580),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\nvar translate = require(356).translate;\r\n\r\n\r\n/**\r\n * Provides previews for selecting/moving/resizing shapes when creating/removing space.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {Canvas} canvas\r\n * @param {Styles} styles\r\n */\r\n\r\nfunction SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {\r\n\r\n  function addPreviewGfx(collection, dragGroup) {\r\n    forEach(collection, function(element) {\r\n      previewSupport.addDragger(element, dragGroup);\r\n\r\n      canvas.addMarker(element, MARKER_DRAGGING);\r\n    });\r\n  }\r\n\r\n  // add crosshair\r\n  eventBus.on('spaceTool.selection.start', function(event) {\r\n    var space = canvas.getLayer('space'),\r\n        context = event.context;\r\n\r\n    var orientation = {\r\n      x: 'M 0,-10000 L 0,10000',\r\n      y: 'M -10000,0 L 10000,0'\r\n    };\r\n\r\n    var crosshairGroup = svgCreate('g');\r\n    svgAttr(crosshairGroup, styles.cls('djs-crosshair-group', [ 'no-events' ]));\r\n\r\n    svgAppend(space, crosshairGroup);\r\n\r\n    // horizontal path\r\n    var pathX = svgCreate('path');\r\n    svgAttr(pathX, 'd', orientation.x);\r\n    svgClasses(pathX).add('djs-crosshair');\r\n\r\n    svgAppend(crosshairGroup, pathX);\r\n\r\n    // vertical path\r\n    var pathY = svgCreate('path');\r\n    svgAttr(pathY, 'd', orientation.y);\r\n    svgClasses(pathY).add('djs-crosshair');\r\n\r\n    svgAppend(crosshairGroup, pathY);\r\n\r\n    context.crosshairGroup = crosshairGroup;\r\n  });\r\n\r\n  // update crosshair\r\n  eventBus.on('spaceTool.selection.move', function(event) {\r\n    var crosshairGroup = event.context.crosshairGroup;\r\n\r\n    translate(crosshairGroup, event.x, event.y);\r\n  });\r\n\r\n  // remove crosshair\r\n  eventBus.on('spaceTool.selection.cleanup', function(event) {\r\n    var context = event.context,\r\n        crosshairGroup = context.crosshairGroup;\r\n\r\n    if (crosshairGroup) {\r\n      svgRemove(crosshairGroup);\r\n    }\r\n  });\r\n\r\n  // add and update move/resize previews\r\n  eventBus.on('spaceTool.move', LOW_PRIORITY, function(event) {\r\n\r\n    var context = event.context,\r\n        line = context.line,\r\n        axis = context.axis,\r\n        movingShapes = context.movingShapes,\r\n        resizingShapes = context.resizingShapes;\r\n\r\n    if (!context.initialized) {\r\n      return;\r\n    }\r\n\r\n    if (!context.dragGroup) {\r\n      var spaceLayer = canvas.getLayer('space');\r\n\r\n      line = svgCreate('path');\r\n      svgAttr(line, 'd', 'M0,0 L0,0');\r\n      svgClasses(line).add('djs-crosshair');\r\n\r\n      svgAppend(spaceLayer, line);\r\n\r\n      context.line  = line;\r\n\r\n      var dragGroup = svgCreate('g');\r\n      svgAttr(dragGroup, styles.cls('djs-drag-group', [ 'no-events' ]));\r\n\r\n      svgAppend(canvas.getDefaultLayer(), dragGroup);\r\n\r\n      // shapes\r\n      addPreviewGfx(movingShapes, dragGroup);\r\n\r\n      // connections\r\n      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {\r\n        var sourceIsMoving = false;\r\n\r\n        forEach(movingShapes, function(shape) {\r\n          forEach(shape.outgoing, function(connection) {\r\n            if (element === connection) {\r\n              sourceIsMoving = true;\r\n            }\r\n          });\r\n        });\r\n\r\n        var targetIsMoving = false;\r\n\r\n        forEach(movingShapes, function(shape) {\r\n          forEach(shape.incoming, function(connection) {\r\n            if (element === connection) {\r\n              targetIsMoving = true;\r\n            }\r\n          });\r\n        });\r\n\r\n        var sourceIsResizing = false;\r\n\r\n        forEach(resizingShapes, function(shape) {\r\n          forEach(shape.outgoing, function(connection) {\r\n            if (element === connection) {\r\n              sourceIsResizing = true;\r\n            }\r\n          });\r\n        });\r\n\r\n        var targetIsResizing = false;\r\n\r\n        forEach(resizingShapes, function(shape) {\r\n          forEach(shape.incoming, function(connection) {\r\n            if (element === connection) {\r\n              targetIsResizing = true;\r\n            }\r\n          });\r\n        });\r\n\r\n        return isConnection(element)\r\n          && (sourceIsMoving || sourceIsResizing)\r\n          && (targetIsMoving || targetIsResizing);\r\n      });\r\n\r\n\r\n      addPreviewGfx(movingConnections, dragGroup);\r\n\r\n      context.dragGroup = dragGroup;\r\n    }\r\n\r\n    if (!context.frameGroup) {\r\n      var frameGroup = svgCreate('g');\r\n      svgAttr(frameGroup, styles.cls('djs-frame-group', [ 'no-events' ]));\r\n\r\n      svgAppend(canvas.getDefaultLayer(), frameGroup);\r\n\r\n      var frames = [];\r\n\r\n      forEach(resizingShapes, function(shape) {\r\n        var frame = previewSupport.addFrame(shape, frameGroup);\r\n\r\n        frames.push({\r\n          element: frame,\r\n          initialWidth: frame.getBBox().width,\r\n          initialHeight: frame.getBBox().height\r\n        });\r\n\r\n        canvas.addMarker(shape, MARKER_RESIZING);\r\n      });\r\n\r\n      context.frameGroup = frameGroup;\r\n      context.frames = frames;\r\n    }\r\n\r\n    var orientation = {\r\n      x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',\r\n      y: 'M -10000, ' + event.y + ' L 10000, ' + event.y\r\n    };\r\n\r\n    svgAttr(line, { path: orientation[ axis ], display: '' });\r\n\r\n    var opposite = { x: 'y', y: 'x' };\r\n    var delta = { x: event.dx, y: event.dy };\r\n    delta[ opposite[ context.axis ] ] = 0;\r\n\r\n    // update move previews\r\n    translate(context.dragGroup, delta.x, delta.y);\r\n\r\n    // update resize previews\r\n    forEach(context.frames, function(frame) {\r\n      if (frame.initialWidth + delta.x > 5) {\r\n        svgAttr(frame.element, { width: frame.initialWidth + delta.x });\r\n      }\r\n\r\n      if (frame.initialHeight + delta.y > 5) {\r\n        svgAttr(frame.element, { height: frame.initialHeight + delta.y });\r\n      }\r\n    });\r\n\r\n  });\r\n\r\n  // remove move/resize previews\r\n  eventBus.on('spaceTool.cleanup', function(event) {\r\n\r\n    var context = event.context,\r\n        movingShapes = context.movingShapes,\r\n        movingConnections = context.movingConnections,\r\n        resizingShapes = context.resizingShapes,\r\n        line = context.line,\r\n        dragGroup = context.dragGroup,\r\n        frameGroup = context.frameGroup;\r\n\r\n    // moving shapes\r\n    forEach(movingShapes, function(shape) {\r\n      canvas.removeMarker(shape, MARKER_DRAGGING);\r\n    });\r\n\r\n    // moving connections\r\n    forEach(movingConnections, function(connection) {\r\n      canvas.removeMarker(connection, MARKER_DRAGGING);\r\n    });\r\n\r\n    if (dragGroup) {\r\n      svgRemove(line);\r\n      svgRemove(dragGroup);\r\n    }\r\n\r\n    forEach(resizingShapes, function(shape) {\r\n      canvas.removeMarker(shape, MARKER_RESIZING);\r\n    });\r\n\r\n    if (frameGroup) {\r\n      svgRemove(frameGroup);\r\n    }\r\n  });\r\n}\r\n\r\nSpaceToolPreview.$inject = [ 'eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport' ];\r\n\r\nmodule.exports = SpaceToolPreview;\r\n\r\n////////// helpers //////////\r\n\r\n/**\r\n * Checks if an element is a connection.\r\n */\r\nfunction isConnection(element) {\r\n  return element.waypoints;\r\n}\r\n","'use strict';\r\n\r\n/**\r\n * Get Resize direction given axis + offset\r\n *\r\n * @param {String} axis (x|y)\r\n * @param {Number} offset\r\n *\r\n * @return {String} (e|w|n|s)\r\n */\r\nfunction getDirection(axis, offset) {\r\n\r\n  if (axis === 'x') {\r\n    if (offset > 0) {\r\n      return 'e';\r\n    }\r\n\r\n    if (offset < 0) {\r\n      return 'w';\r\n    }\r\n  }\r\n\r\n  if (axis === 'y') {\r\n    if (offset > 0) {\r\n      return 's';\r\n    }\r\n\r\n    if (offset < 0) {\r\n      return 'n';\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nmodule.exports.getDirection = getDirection;\r\n\r\n/**\r\n * Resize the given bounds by the specified delta from a given anchor point.\r\n *\r\n * @param {Bounds} bounds the bounding box that should be resized\r\n * @param {String} direction in which the element is resized (n, s, e, w)\r\n * @param {Point} delta of the resize operation\r\n *\r\n * @return {Bounds} resized bounding box\r\n */\r\nmodule.exports.resizeBounds = function(bounds, direction, delta) {\r\n\r\n  var dx = delta.x,\r\n      dy = delta.y;\r\n\r\n  switch (direction) {\r\n\r\n  case 'n':\r\n    return {\r\n      x: bounds.x,\r\n      y: bounds.y + dy,\r\n      width: bounds.width,\r\n      height: bounds.height - dy\r\n    };\r\n\r\n  case 's':\r\n    return {\r\n      x: bounds.x,\r\n      y: bounds.y,\r\n      width: bounds.width,\r\n      height: bounds.height + dy\r\n    };\r\n\r\n  case 'w':\r\n    return {\r\n      x: bounds.x + dx,\r\n      y: bounds.y,\r\n      width: bounds.width - dx,\r\n      height: bounds.height\r\n    };\r\n\r\n  case 'e':\r\n    return {\r\n      x: bounds.x,\r\n      y: bounds.y,\r\n      width: bounds.width + dx,\r\n      height: bounds.height\r\n    };\r\n\r\n  default:\r\n    throw new Error('unrecognized direction: ' + direction);\r\n  }\r\n};","'use strict';\r\n\r\nmodule.exports = {\r\n  __init__: ['spaceToolPreview'],\r\n  __depends__: [\r\n    require(239),\r\n    require(304),\r\n    require(319),\r\n    require(294)\r\n  ],\r\n  spaceTool: ['type', require(314)],\r\n  spaceToolPreview: ['type', require(315) ]\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nvar LOW_PRIORITY = 250;\r\n\r\n/**\r\n * The tool manager acts as middle-man between the available tool's and the Palette,\r\n * it takes care of making sure that the correct active state is set.\r\n *\r\n * @param  {Object}    eventBus\r\n * @param  {Object}    dragging\r\n */\r\nfunction ToolManager(eventBus, dragging) {\r\n  this._eventBus = eventBus;\r\n  this._dragging = dragging;\r\n\r\n  this._tools = [];\r\n  this._active = null;\r\n}\r\n\r\nToolManager.$inject = [ 'eventBus', 'dragging' ];\r\n\r\nmodule.exports = ToolManager;\r\n\r\nToolManager.prototype.registerTool = function(name, events) {\r\n  var tools = this._tools;\r\n\r\n  if (!events) {\r\n    throw new Error('A tool has to be registered with it/'s \"events\"');\r\n  }\r\n\r\n  tools.push(name);\r\n\r\n  this.bindEvents(name, events);\r\n};\r\n\r\nToolManager.prototype.isActive = function(tool) {\r\n  return tool && this._active === tool;\r\n};\r\n\r\nToolManager.prototype.length = function(tool) {\r\n  return this._tools.length;\r\n};\r\n\r\nToolManager.prototype.setActive = function(tool) {\r\n  var eventBus = this._eventBus;\r\n\r\n  if (this._active !== tool) {\r\n    this._active = tool;\r\n\r\n    eventBus.fire('tool-manager.update', { tool: tool });\r\n  }\r\n};\r\n\r\nToolManager.prototype.bindEvents = function(name, events) {\r\n  var eventBus = this._eventBus,\r\n      dragging = this._dragging;\r\n\r\n  var eventsToRegister = [];\r\n\r\n  eventBus.on(events.tool + '.init', function(event) {\r\n    var context = event.context;\r\n\r\n    // Active tools that want to reactivate themselves must do this explicitly\r\n    if (!context.reactivate && this.isActive(name)) {\r\n      this.setActive(null);\r\n\r\n      dragging.cancel();\r\n      return;\r\n    }\r\n\r\n    this.setActive(name);\r\n\r\n  }, this);\r\n\r\n  // Todo[ricardo]: add test cases\r\n  forEach(events, function(event) {\r\n    eventsToRegister.push(event + '.ended');\r\n    eventsToRegister.push(event + '.canceled');\r\n  });\r\n\r\n  eventBus.on(eventsToRegister, LOW_PRIORITY, function(event) {\r\n    var originalEvent = event.originalEvent;\r\n\r\n    // We defer the de-activation of the tool to the .activate phase,\r\n    // so we're able to check if we want to toggle off the current active tool or switch to a new one\r\n    if (!this._active ||\r\n        (originalEvent && originalEvent.target.parentNode.getAttribute('data-group') === 'tools')) {\r\n      return;\r\n    }\r\n\r\n    this.setActive(null);\r\n  }, this);\r\n};\r\n","'use strict';\r\n\r\nmodule.exports = {\r\n  __depends__: [ require(239) ],\r\n  __init__: [ 'toolManager' ],\r\n  toolManager: [ 'type', require(318) ]\r\n};\r\n","'use strict';\r\n\r\nvar isString = require(513),\r\n    assign = require(516),\r\n    forEach = require(386);\r\n\r\nvar domify = require(535),\r\n    domAttr = require(530),\r\n    domClasses = require(531),\r\n    domRemove = require(539),\r\n    domDelegate = require(534);\r\n\r\n\r\n// document wide unique tooltip ids\r\nvar ids = new (require(347))('tt');\r\n\r\n\r\nfunction createRoot(parent) {\r\n  var root = domify('<div class=\"djs-tooltip-container\" style=\"position: absolute; width: 0; height: 0;\" />');\r\n  parent.insertBefore(root, parent.firstChild);\r\n\r\n  return root;\r\n}\r\n\r\n\r\nfunction setPosition(el, x, y) {\r\n  assign(el.style, { left: x + 'px', top: y + 'px' });\r\n}\r\n\r\nfunction setVisible(el, visible) {\r\n  el.style.display = visible === false ? 'none' : '';\r\n}\r\n\r\n\r\nvar tooltipClass = 'djs-tooltip',\r\n    tooltipSelector = '.' + tooltipClass;\r\n\r\n/**\r\n * A service that allows users to render tool tips on the diagram.\r\n *\r\n * The tooltip service will take care of updating the tooltip positioning\r\n * during navigation + zooming.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n *\r\n * // add a pink badge on the top left of the shape\r\n * tooltips.add({\r\n *   position: {\r\n *     x: 50,\r\n *     y: 100\r\n *   },\r\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>'\r\n * });\r\n *\r\n * // or with optional life span\r\n * tooltips.add({\r\n *   position: {\r\n *     top: -5,\r\n *     left: -5\r\n *   },\r\n *   html: '<div style=\"width: 10px; background: fuchsia; color: white;\">0</div>',\r\n *   ttl: 2000\r\n * });\r\n *\r\n * // remove a tool tip\r\n * var id = tooltips.add(...);\r\n * tooltips.remove(id);\r\n * ```\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n */\r\nfunction Tooltips(eventBus, canvas) {\r\n\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n\r\n  this._ids = ids;\r\n\r\n  this._tooltipDefaults = {\r\n    show: {\r\n      minZoom: 0.7,\r\n      maxZoom: 5.0\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Mapping tooltipId -> tooltip\r\n   */\r\n  this._tooltips = {};\r\n\r\n  // root html element for all tooltips\r\n  this._tooltipRoot = createRoot(canvas.getContainer());\r\n\r\n\r\n  var self = this;\r\n\r\n  domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function(event) {\r\n    event.stopPropagation();\r\n  });\r\n\r\n  domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function(event) {\r\n    self.trigger('mouseover', event);\r\n  });\r\n\r\n  domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function(event) {\r\n    self.trigger('mouseout', event);\r\n  });\r\n\r\n  this._init();\r\n}\r\n\r\n\r\nTooltips.$inject = [ 'eventBus', 'canvas' ];\r\n\r\nmodule.exports = Tooltips;\r\n\r\n\r\n/**\r\n * Adds a HTML tooltip to the diagram\r\n *\r\n * @param {Object}               tooltip   the tooltip configuration\r\n *\r\n * @param {String|DOMElement}    tooltip.html                 html element to use as an tooltip\r\n * @param {Object}               [tooltip.show]               show configuration\r\n * @param {Number}               [tooltip.show.minZoom]       minimal zoom level to show the tooltip\r\n * @param {Number}               [tooltip.show.maxZoom]       maximum zoom level to show the tooltip\r\n * @param {Object}               tooltip.position             where to attach the tooltip\r\n * @param {Number}               [tooltip.position.left]      relative to element bbox left attachment\r\n * @param {Number}               [tooltip.position.top]       relative to element bbox top attachment\r\n * @param {Number}               [tooltip.position.bottom]    relative to element bbox bottom attachment\r\n * @param {Number}               [tooltip.position.right]     relative to element bbox right attachment\r\n * @param {Number}               [tooltip.timeout=-1]\r\n *\r\n * @return {String}              id that may be used to reference the tooltip for update or removal\r\n */\r\nTooltips.prototype.add = function(tooltip) {\r\n\r\n  if (!tooltip.position) {\r\n    throw new Error('must specifiy tooltip position');\r\n  }\r\n\r\n  if (!tooltip.html) {\r\n    throw new Error('must specifiy tooltip html');\r\n  }\r\n\r\n  var id = this._ids.next();\r\n\r\n  tooltip = assign({}, this._tooltipDefaults, tooltip, {\r\n    id: id\r\n  });\r\n\r\n  this._addTooltip(tooltip);\r\n\r\n  if (tooltip.timeout) {\r\n    this.setTimeout(tooltip);\r\n  }\r\n\r\n  return id;\r\n};\r\n\r\nTooltips.prototype.trigger = function(action, event) {\r\n\r\n  var node = event.delegateTarget || event.target;\r\n\r\n  var tooltip = this.get(domAttr(node, 'data-tooltip-id'));\r\n\r\n  if (!tooltip) {\r\n    return;\r\n  }\r\n\r\n  if (action === 'mouseover' && tooltip.timeout) {\r\n    this.clearTimeout(tooltip);\r\n  }\r\n\r\n  if (action === 'mouseout' && tooltip.timeout) {\r\n    // cut timeout after mouse out\r\n    tooltip.timeout = 1000;\r\n\r\n    this.setTimeout(tooltip);\r\n  }\r\n};\r\n\r\n/**\r\n * Get a tooltip with the given id\r\n *\r\n * @param {String} id\r\n */\r\nTooltips.prototype.get = function(id) {\r\n\r\n  if (typeof id !== 'string') {\r\n    id = id.id;\r\n  }\r\n\r\n  return this._tooltips[id];\r\n};\r\n\r\nTooltips.prototype.clearTimeout = function(tooltip) {\r\n\r\n  tooltip = this.get(tooltip);\r\n\r\n  if (!tooltip) {\r\n    return;\r\n  }\r\n\r\n  var removeTimer = tooltip.removeTimer;\r\n\r\n  if (removeTimer) {\r\n    clearTimeout(removeTimer);\r\n    tooltip.removeTimer = null;\r\n  }\r\n};\r\n\r\nTooltips.prototype.setTimeout = function(tooltip) {\r\n\r\n  tooltip = this.get(tooltip);\r\n\r\n  if (!tooltip) {\r\n    return;\r\n  }\r\n\r\n  this.clearTimeout(tooltip);\r\n\r\n  var self = this;\r\n\r\n  tooltip.removeTimer = setTimeout(function() {\r\n    self.remove(tooltip);\r\n  }, tooltip.timeout);\r\n};\r\n\r\n/**\r\n * Remove an tooltip with the given id\r\n *\r\n * @param {String} id\r\n */\r\nTooltips.prototype.remove = function(id) {\r\n\r\n  var tooltip = this.get(id);\r\n\r\n  if (tooltip) {\r\n    domRemove(tooltip.html);\r\n    domRemove(tooltip.htmlContainer);\r\n\r\n    delete tooltip.htmlContainer;\r\n\r\n    delete this._tooltips[tooltip.id];\r\n  }\r\n};\r\n\r\n\r\nTooltips.prototype.show = function() {\r\n  setVisible(this._tooltipRoot);\r\n};\r\n\r\n\r\nTooltips.prototype.hide = function() {\r\n  setVisible(this._tooltipRoot, false);\r\n};\r\n\r\n\r\nTooltips.prototype._updateRoot = function(viewbox) {\r\n  var a = viewbox.scale || 1;\r\n  var d = viewbox.scale || 1;\r\n\r\n  var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';\r\n\r\n  this._tooltipRoot.style.transform = matrix;\r\n  this._tooltipRoot.style['-ms-transform'] = matrix;\r\n};\r\n\r\n\r\nTooltips.prototype._addTooltip = function(tooltip) {\r\n\r\n  var id = tooltip.id,\r\n      html = tooltip.html,\r\n      htmlContainer,\r\n      tooltipRoot = this._tooltipRoot;\r\n\r\n  // unwrap jquery (for those who need it)\r\n  if (html.get && html.constructor.prototype.jquery) {\r\n    html = html.get(0);\r\n  }\r\n\r\n  // create proper html elements from\r\n  // tooltip HTML strings\r\n  if (isString(html)) {\r\n    html = domify(html);\r\n  }\r\n\r\n  htmlContainer = domify('<div data-tooltip-id=\"' + id + '\" class=\"' + tooltipClass + '\" style=\"position: absolute\">');\r\n\r\n  htmlContainer.appendChild(html);\r\n\r\n  if (tooltip.type) {\r\n    domClasses(htmlContainer).add('djs-tooltip-' + tooltip.type);\r\n  }\r\n\r\n  if (tooltip.className) {\r\n    domClasses(htmlContainer).add(tooltip.className);\r\n  }\r\n\r\n  tooltip.htmlContainer = htmlContainer;\r\n\r\n  tooltipRoot.appendChild(htmlContainer);\r\n\r\n  this._tooltips[id] = tooltip;\r\n\r\n  this._updateTooltip(tooltip);\r\n};\r\n\r\n\r\nTooltips.prototype._updateTooltip = function(tooltip) {\r\n\r\n  var position = tooltip.position,\r\n      htmlContainer = tooltip.htmlContainer;\r\n\r\n  // update overlay html based on tooltip x, y\r\n\r\n  setPosition(htmlContainer, position.x, position.y);\r\n};\r\n\r\n\r\nTooltips.prototype._updateTooltipVisibilty = function(viewbox) {\r\n\r\n  forEach(this._tooltips, function(tooltip) {\r\n    var show = tooltip.show,\r\n        htmlContainer = tooltip.htmlContainer,\r\n        visible = true;\r\n\r\n    if (show) {\r\n      if (show.minZoom > viewbox.scale ||\r\n          show.maxZoom < viewbox.scale) {\r\n        visible = false;\r\n      }\r\n\r\n      setVisible(htmlContainer, visible);\r\n    }\r\n  });\r\n};\r\n\r\nTooltips.prototype._init = function() {\r\n\r\n  var self = this;\r\n\r\n  // scroll/zoom integration\r\n\r\n  function updateViewbox(viewbox) {\r\n    self._updateRoot(viewbox);\r\n    self._updateTooltipVisibilty(viewbox);\r\n\r\n    self.show();\r\n  }\r\n\r\n  this._eventBus.on('canvas.viewbox.changing', function(event) {\r\n    self.hide();\r\n  });\r\n\r\n  this._eventBus.on('canvas.viewbox.changed', function(event) {\r\n    updateViewbox(event.viewbox);\r\n  });\r\n};\r\n","module.exports = {\r\n  __init__: [ 'tooltips' ],\r\n  tooltips: [ 'type', require(320) ]\r\n};","'use strict';\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583);\r\n\r\n\r\nfunction TouchFix(canvas, eventBus) {\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('canvas.init', function(e) {\r\n    self.addBBoxMarker(e.svg);\r\n  });\r\n}\r\n\r\nTouchFix.$inject = [ 'canvas', 'eventBus' ];\r\n\r\nmodule.exports = TouchFix;\r\n\r\n\r\n/**\r\n * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element\r\n * if there is no shape between 0,0 and viewport elements origin.\r\n *\r\n * So touchstart event is only fired when the <g class=\"viewport\"> element was hit.\r\n * Putting an element over and below the 'viewport' fixes that behavior.\r\n */\r\nTouchFix.prototype.addBBoxMarker = function(svg) {\r\n\r\n  var markerStyle = {\r\n    fill: 'none',\r\n    class: 'outer-bound-marker'\r\n  };\r\n\r\n  var rect1 = svgCreate('rect');\r\n  svgAttr(rect1, {\r\n    x: -10000,\r\n    y: 10000,\r\n    width: 10,\r\n    height: 10\r\n  });\r\n  svgAttr(rect1, markerStyle);\r\n\r\n  svgAppend(svg, rect1);\r\n\r\n  var rect2 = svgCreate('rect');\r\n  svgAttr(rect2, {\r\n    x: 10000,\r\n    y: 10000,\r\n    width: 10,\r\n    height: 10\r\n  });\r\n  svgAttr(rect2, markerStyle);\r\n\r\n  svgAppend(svg, rect2);\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386),\r\n    domEvent = require(536),\r\n    domClosest = require(533),\r\n    Hammer = require(364),\r\n    Event = require(344);\r\n\r\nvar MIN_ZOOM = 0.2,\r\n    MAX_ZOOM = 4;\r\n\r\nvar mouseEvents = [\r\n  'mousedown',\r\n  'mouseup',\r\n  'mouseover',\r\n  'mouseout',\r\n  'click',\r\n  'dblclick'\r\n];\r\n\r\nfunction log() {\r\n  // console.log.apply(console, arguments);\r\n}\r\n\r\nfunction get(service, injector) {\r\n  return injector.get(service, false);\r\n}\r\n\r\nfunction createTouchRecognizer(node) {\r\n\r\n  function stopEvent(event) {\r\n    Event.stopEvent(event, true);\r\n  }\r\n\r\n  function stopMouse(event) {\r\n\r\n    forEach(mouseEvents, function(e) {\r\n      domEvent.bind(node, e, stopEvent, true);\r\n    });\r\n  }\r\n\r\n  function allowMouse(event) {\r\n    setTimeout(function() {\r\n      forEach(mouseEvents, function(e) {\r\n        domEvent.unbind(node, e, stopEvent, true);\r\n      });\r\n    }, 500);\r\n  }\r\n\r\n  domEvent.bind(node, 'touchstart', stopMouse, true);\r\n  domEvent.bind(node, 'touchend', allowMouse, true);\r\n  domEvent.bind(node, 'touchcancel', allowMouse, true);\r\n\r\n  // A touch event recognizer that handles\r\n  // touch events only (we know, we can already handle\r\n  // mouse events out of the box)\r\n\r\n  var recognizer = new Hammer.Manager(node, {\r\n    inputClass: Hammer.TouchInput,\r\n    recognizers: []\r\n  });\r\n\r\n\r\n  var tap = new Hammer.Tap();\r\n  var pan = new Hammer.Pan({ threshold: 10 });\r\n  var press = new Hammer.Press();\r\n  var pinch = new Hammer.Pinch();\r\n\r\n  var doubleTap = new Hammer.Tap({ event: 'doubletap', taps: 2 });\r\n\r\n  pinch.requireFailure(pan);\r\n  pinch.requireFailure(press);\r\n\r\n  recognizer.add([ pan, press, pinch, doubleTap, tap ]);\r\n\r\n  recognizer.reset = function(force) {\r\n    var recognizers = this.recognizers,\r\n        session = this.session;\r\n\r\n    if (session.stopped) {\r\n      return;\r\n    }\r\n\r\n    log('recognizer', 'stop');\r\n\r\n    recognizer.stop(force);\r\n\r\n    setTimeout(function() {\r\n      var i, r;\r\n\r\n      log('recognizer', 'reset');\r\n      for (i = 0; (r = recognizers[i]); i++) {\r\n        r.reset();\r\n        r.state = 8; // FAILED STATE\r\n      }\r\n\r\n      session.curRecognizer = null;\r\n    }, 0);\r\n  };\r\n\r\n  recognizer.on('hammer.input', function(event) {\r\n    if (event.srcEvent.defaultPrevented) {\r\n      recognizer.reset(true);\r\n    }\r\n  });\r\n\r\n  return recognizer;\r\n}\r\n\r\n/**\r\n * A plugin that provides touch events for elements.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {InteractionEvents} interactionEvents\r\n */\r\nfunction TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {\r\n\r\n  // optional integrations\r\n  var dragging = get('dragging', injector),\r\n      move = get('move', injector),\r\n      contextPad = get('contextPad', injector),\r\n      palette = get('palette', injector);\r\n\r\n  // the touch recognizer\r\n  var recognizer;\r\n\r\n  function handler(type) {\r\n\r\n    return function(event) {\r\n      log('element', type, event);\r\n\r\n      interactionEvents.fire(type, event);\r\n    };\r\n  }\r\n\r\n  function getGfx(target) {\r\n    var node = domClosest(target, 'svg, .djs-element', true);\r\n    return node;\r\n  }\r\n\r\n  function initEvents(svg) {\r\n\r\n    // touch recognizer\r\n    recognizer = createTouchRecognizer(svg);\r\n\r\n    recognizer.on('doubletap', handler('element.dblclick'));\r\n\r\n    recognizer.on('tap', handler('element.click'));\r\n\r\n    function startGrabCanvas(event) {\r\n\r\n      log('canvas', 'grab start');\r\n\r\n      var lx = 0, ly = 0;\r\n\r\n      function update(e) {\r\n\r\n        var dx = e.deltaX - lx,\r\n            dy = e.deltaY - ly;\r\n\r\n        canvas.scroll({ dx: dx, dy: dy });\r\n\r\n        lx = e.deltaX;\r\n        ly = e.deltaY;\r\n      }\r\n\r\n      function end(e) {\r\n        recognizer.off('panmove', update);\r\n        recognizer.off('panend', end);\r\n        recognizer.off('pancancel', end);\r\n\r\n        log('canvas', 'grab end');\r\n      }\r\n\r\n      recognizer.on('panmove', update);\r\n      recognizer.on('panend', end);\r\n      recognizer.on('pancancel', end);\r\n    }\r\n\r\n    function startGrab(event) {\r\n\r\n      var gfx = getGfx(event.target),\r\n          element = gfx && elementRegistry.get(gfx);\r\n\r\n      // recognizer\r\n      if (move && canvas.getRootElement() !== element) {\r\n        log('element', 'move start', element, event, true);\r\n        return move.start(event, element, true);\r\n      } else {\r\n        startGrabCanvas(event);\r\n      }\r\n    }\r\n\r\n    function startZoom(e) {\r\n\r\n      log('canvas', 'zoom start');\r\n\r\n      var zoom = canvas.zoom(),\r\n          mid = e.center;\r\n\r\n      function update(e) {\r\n\r\n        var ratio = 1 - (1 - e.scale) / 1.50,\r\n            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));\r\n\r\n        canvas.zoom(newZoom, mid);\r\n\r\n        Event.stopEvent(e, true);\r\n      }\r\n\r\n      function end(e) {\r\n        recognizer.off('pinchmove', update);\r\n        recognizer.off('pinchend', end);\r\n        recognizer.off('pinchcancel', end);\r\n\r\n        recognizer.reset(true);\r\n\r\n        log('canvas', 'zoom end');\r\n      }\r\n\r\n      recognizer.on('pinchmove', update);\r\n      recognizer.on('pinchend', end);\r\n      recognizer.on('pinchcancel', end);\r\n    }\r\n\r\n    recognizer.on('panstart', startGrab);\r\n    recognizer.on('press', startGrab);\r\n\r\n    recognizer.on('pinchstart', startZoom);\r\n  }\r\n\r\n  if (dragging) {\r\n\r\n    // simulate hover during dragging\r\n    eventBus.on('drag.move', function(event) {\r\n\r\n      var originalEvent = event.originalEvent;\r\n\r\n      if (!originalEvent || originalEvent instanceof MouseEvent) {\r\n        return;\r\n      }\r\n\r\n      var position = Event.toPoint(originalEvent);\r\n\r\n      // this gets really expensive ...\r\n      var node = document.elementFromPoint(position.x, position.y),\r\n          gfx = getGfx(node),\r\n          element = gfx && elementRegistry.get(gfx);\r\n\r\n      if (element !== event.hover) {\r\n        if (event.hover) {\r\n          dragging.out(event);\r\n        }\r\n\r\n        if (element) {\r\n          dragging.hover({ element: element, gfx: gfx });\r\n\r\n          event.hover = element;\r\n          event.hoverGfx = gfx;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  if (contextPad) {\r\n\r\n    eventBus.on('contextPad.create', function(event) {\r\n      var node = event.pad.html;\r\n\r\n      // touch recognizer\r\n      var padRecognizer = createTouchRecognizer(node);\r\n\r\n      padRecognizer.on('panstart', function(event) {\r\n        log('context-pad', 'panstart', event);\r\n        contextPad.trigger('dragstart', event, true);\r\n      });\r\n\r\n      padRecognizer.on('press', function(event) {\r\n        log('context-pad', 'press', event);\r\n        contextPad.trigger('dragstart', event, true);\r\n      });\r\n\r\n      padRecognizer.on('tap', function(event) {\r\n        log('context-pad', 'tap', event);\r\n        contextPad.trigger('click', event);\r\n      });\r\n    });\r\n  }\r\n\r\n  if (palette) {\r\n    eventBus.on('palette.create', function(event) {\r\n      var node = event.html;\r\n\r\n      // touch recognizer\r\n      var padRecognizer = createTouchRecognizer(node);\r\n\r\n      padRecognizer.on('panstart', function(event) {\r\n        log('palette', 'panstart', event);\r\n        palette.trigger('dragstart', event, true);\r\n      });\r\n\r\n      padRecognizer.on('press', function(event) {\r\n        log('palette', 'press', event);\r\n        palette.trigger('dragstart', event, true);\r\n      });\r\n\r\n      padRecognizer.on('tap', function(event) {\r\n        log('palette', 'tap', event);\r\n        palette.trigger('click', event);\r\n      });\r\n    });\r\n  }\r\n\r\n  eventBus.on('canvas.init', function(event) {\r\n    initEvents(event.svg);\r\n  });\r\n}\r\n\r\n\r\nTouchInteractionEvents.$inject = [\r\n  'injector',\r\n  'canvas',\r\n  'eventBus',\r\n  'elementRegistry',\r\n  'interactionEvents',\r\n  'touchFix'\r\n];\r\n\r\nmodule.exports = TouchInteractionEvents;\r\n","module.exports = {\r\n  __depends__: [ require(247) ],\r\n  __init__: [ 'touchInteractionEvents' ],\r\n  touchInteractionEvents: [ 'type', require(323) ],\r\n  touchFix: [ 'type', require(322) ]\r\n};","module.exports = {\r\n  translate: [ 'value', require(326) ]\r\n};","'use strict';\r\n\r\n/**\r\n * A simple translation stub to be used for multi-language support\r\n * in diagrams. Can be easily replaced with a more sophisticated\r\n * solution.\r\n *\r\n * @example\r\n *\r\n * // use it inside any diagram component by injecting `translate`.\r\n *\r\n * function MyService(translate) {\r\n *   alert(translate('HELLO {you}', { you: 'You!' }));\r\n * }\r\n *\r\n * @param {String} template to interpolate\r\n * @param {Object} [replacements] a map with substitutes\r\n *\r\n * @return {String} the translated string\r\n */\r\nmodule.exports = function translate(template, replacements) {\r\n\r\n  replacements = replacements || {};\r\n\r\n  return template.replace(/{([^}]+)}/g, function(_, key) {\r\n    return replacements[key] || '{' + key + '}';\r\n  });\r\n};","'use strict';\r\n\r\nvar getMid = require(329).getMid;\r\n\r\n\r\n/**\r\n * A base connection layouter implementation\r\n * that layouts the connection by directly connecting\r\n * mid(source) + mid(target).\r\n */\r\nfunction BaseLayouter() {}\r\n\r\nmodule.exports = BaseLayouter;\r\n\r\n\r\n/**\r\n * Return the new layouted waypoints for the given connection.\r\n *\r\n * The connection passed is still unchanged; you may figure out about\r\n * the new connection start / end via the layout hints provided.\r\n *\r\n * @param {djs.model.Connection} connection\r\n * @param {Object} [hints]\r\n * @param {Point} [hints.connectionStart]\r\n * @param {Point} [hints.connectionEnd]\r\n *\r\n * @return {Array<Point>} the layouted connection waypoints\r\n */\r\nBaseLayouter.prototype.layoutConnection = function(connection, hints) {\r\n\r\n  hints = hints || {};\r\n\r\n  return [\r\n    hints.connectionStart || getMid(connection.source),\r\n    hints.connectionEnd || getMid(connection.target)\r\n  ];\r\n};\r\n","'use strict';\r\n\r\nvar assign = require(516);\r\n\r\nvar LayoutUtil = require(329);\r\n\r\n\r\nfunction dockingToPoint(docking) {\r\n  // use the dockings actual point and\r\n  // retain the original docking\r\n  return assign({ original: docking.point.original || docking.point }, docking.actual);\r\n}\r\n\r\n\r\n/**\r\n * A {@link ConnectionDocking} that crops connection waypoints based on\r\n * the path(s) of the connection source and target.\r\n *\r\n * @param {djs.core.ElementRegistry} elementRegistry\r\n */\r\nfunction CroppingConnectionDocking(elementRegistry, graphicsFactory) {\r\n  this._elementRegistry = elementRegistry;\r\n  this._graphicsFactory = graphicsFactory;\r\n}\r\n\r\nCroppingConnectionDocking.$inject = [ 'elementRegistry', 'graphicsFactory' ];\r\n\r\nmodule.exports = CroppingConnectionDocking;\r\n\r\n\r\n/**\r\n * @inheritDoc ConnectionDocking#getCroppedWaypoints\r\n */\r\nCroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {\r\n\r\n  source = source || connection.source;\r\n  target = target || connection.target;\r\n\r\n  var sourceDocking = this.getDockingPoint(connection, source, true),\r\n      targetDocking = this.getDockingPoint(connection, target);\r\n\r\n  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);\r\n\r\n  croppedWaypoints.unshift(dockingToPoint(sourceDocking));\r\n  croppedWaypoints.push(dockingToPoint(targetDocking));\r\n\r\n  return croppedWaypoints;\r\n};\r\n\r\n/**\r\n * Return the connection docking point on the specified shape\r\n *\r\n * @inheritDoc ConnectionDocking#getDockingPoint\r\n */\r\nCroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {\r\n\r\n  var waypoints = connection.waypoints,\r\n      dockingIdx,\r\n      dockingPoint,\r\n      croppedPoint;\r\n\r\n  dockingIdx = dockStart ? 0 : waypoints.length - 1;\r\n  dockingPoint = waypoints[dockingIdx];\r\n\r\n  croppedPoint = this._getIntersection(shape, connection, dockStart);\r\n\r\n  return {\r\n    point: dockingPoint,\r\n    actual: croppedPoint || dockingPoint,\r\n    idx: dockingIdx\r\n  };\r\n};\r\n\r\n\r\n////// helper methods ///////////////////////////////////////////////////\r\n\r\nCroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {\r\n\r\n  var shapePath = this._getShapePath(shape),\r\n      connectionPath = this._getConnectionPath(connection);\r\n\r\n  return LayoutUtil.getElementLineIntersection(shapePath, connectionPath, takeFirst);\r\n};\r\n\r\nCroppingConnectionDocking.prototype._getConnectionPath = function(connection) {\r\n  return this._graphicsFactory.getConnectionPath(connection);\r\n};\r\n\r\nCroppingConnectionDocking.prototype._getShapePath = function(shape) {\r\n  return this._graphicsFactory.getShapePath(shape);\r\n};\r\n\r\nCroppingConnectionDocking.prototype._getGfx = function(element) {\r\n  return this._elementRegistry.getGraphics(element);\r\n};\r\n","'use strict';\r\n\r\nvar isObject = require(511),\r\n    sortBy = require(394),\r\n    pointDistance = require(345).pointDistance;\r\n\r\nvar intersection = require(348).intersection;\r\n\r\n\r\nfunction roundBounds(bounds) {\r\n  return {\r\n    x: Math.round(bounds.x),\r\n    y: Math.round(bounds.y),\r\n    width: Math.round(bounds.width),\r\n    height: Math.round(bounds.height)\r\n  };\r\n}\r\n\r\nmodule.exports.roundBounds = roundBounds;\r\n\r\n\r\nfunction roundPoint(point) {\r\n\r\n  return {\r\n    x: Math.round(point.x),\r\n    y: Math.round(point.y)\r\n  };\r\n}\r\n\r\nmodule.exports.roundPoint = roundPoint;\r\n\r\n\r\n/**\r\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\r\n *\r\n * @param {Bounds|Point} bounds\r\n *\r\n * @return {Object}\r\n */\r\nfunction asTRBL(bounds) {\r\n  return {\r\n    top: bounds.y,\r\n    right: bounds.x + (bounds.width || 0),\r\n    bottom: bounds.y + (bounds.height || 0),\r\n    left: bounds.x\r\n  };\r\n}\r\n\r\nmodule.exports.asTRBL = asTRBL;\r\n\r\n/**\r\n * Convert a { top, left, bottom, right } to an objects bounds.\r\n *\r\n * @param {Object} trbl\r\n *\r\n * @return {Bounds}\r\n */\r\nfunction asBounds(trbl) {\r\n  return {\r\n    x: trbl.left,\r\n    y: trbl.top,\r\n    width: trbl.right - trbl.left,\r\n    height: trbl.bottom - trbl.top\r\n  };\r\n}\r\n\r\nmodule.exports.asBounds = asBounds;\r\n\r\n\r\n/**\r\n * Get the mid of the given bounds or point.\r\n *\r\n * @param {Bounds|Point} bounds\r\n *\r\n * @return {Point}\r\n */\r\nfunction getMid(bounds) {\r\n  return roundPoint({\r\n    x: bounds.x + (bounds.width || 0) / 2,\r\n    y: bounds.y + (bounds.height || 0) / 2\r\n  });\r\n}\r\n\r\nmodule.exports.getMid = getMid;\r\n\r\n\r\n////// orientation utils //////////////////////////////\r\n\r\n/**\r\n * Get orientation of the given rectangle with respect to\r\n * the reference rectangle.\r\n *\r\n * A padding (positive or negative) may be passed to influence\r\n * horizontal / vertical orientation and intersection.\r\n *\r\n * @param {Bounds} rect\r\n * @param {Bounds} reference\r\n * @param {Point|Number} padding\r\n *\r\n * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\r\n */\r\nfunction getOrientation(rect, reference, padding) {\r\n\r\n  padding = padding || 0;\r\n\r\n  // make sure we can use an object, too\r\n  // for individual { x, y } padding\r\n  if (!isObject(padding)) {\r\n    padding = { x: padding, y: padding };\r\n  }\r\n\r\n\r\n  var rectOrientation = asTRBL(rect),\r\n      referenceOrientation = asTRBL(reference);\r\n\r\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\r\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\r\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\r\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\r\n\r\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\r\n      horizontal = left ? 'left' : (right ? 'right' : null);\r\n\r\n  if (horizontal && vertical) {\r\n    return vertical + '-' + horizontal;\r\n  } else {\r\n    return horizontal || vertical || 'intersect';\r\n  }\r\n}\r\n\r\nmodule.exports.getOrientation = getOrientation;\r\n\r\n\r\n////// intersection utils //////////////////////////////\r\n\r\n/**\r\n * Get intersection between an element and a line path.\r\n *\r\n * @param {PathDef} elementPath\r\n * @param {PathDef} linePath\r\n * @param {Boolean} cropStart crop from start or end\r\n *\r\n * @return {Point}\r\n */\r\nfunction getElementLineIntersection(elementPath, linePath, cropStart) {\r\n\r\n  var intersections = getIntersections(elementPath, linePath);\r\n\r\n  // recognize intersections\r\n  // only one -> choose\r\n  // two close together -> choose first\r\n  // two or more distinct -> pull out appropriate one\r\n  // none -> ok (fallback to point itself)\r\n  if (intersections.length === 1) {\r\n    return roundPoint(intersections[0]);\r\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\r\n    return roundPoint(intersections[0]);\r\n  } else if (intersections.length > 1) {\r\n\r\n    // sort by intersections based on connection segment +\r\n    // distance from start\r\n    intersections = sortBy(intersections, function(i) {\r\n      var distance = Math.floor(i.t2 * 100) || 1;\r\n\r\n      distance = 100 - distance;\r\n\r\n      distance = (distance < 10 ? '0' : '') + distance;\r\n\r\n      // create a sort string that makes sure we sort\r\n      // line segment ASC + line segment position DESC (for cropStart)\r\n      // line segment ASC + line segment position ASC (for cropEnd)\r\n      return i.segment2 + '#' + distance;\r\n    });\r\n\r\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nmodule.exports.getElementLineIntersection = getElementLineIntersection;\r\n\r\n\r\nfunction getIntersections(a, b) {\r\n  return intersection(a, b);\r\n}\r\n\r\nmodule.exports.getIntersections = getIntersections;\r\n","'use strict';\r\n\r\nvar isArray = require(506),\r\n    find = require(385),\r\n    without = require(379),\r\n    assign = require(516);\r\n\r\nvar LayoutUtil = require(329),\r\n    Geometry = require(345);\r\n\r\nvar getOrientation = LayoutUtil.getOrientation,\r\n    getMid = LayoutUtil.getMid,\r\n    pointsAligned = Geometry.pointsAligned;\r\n\r\nvar pointInRect = Geometry.pointInRect,\r\n    pointDistance = Geometry.pointDistance;\r\n\r\nvar INTERSECTION_THRESHOLD = 20,\r\n    ORIENTATION_THRESHOLD = {\r\n      'h:h': 20,\r\n      'v:v': 20,\r\n      'h:v': -10,\r\n      'v:h': -10\r\n    };\r\n\r\n\r\n/**\r\n * Returns the mid points for a manhattan connection between two points.\r\n *\r\n * @example\r\n *\r\n * [a]----[x]\r\n *         |\r\n *        [x]----[b]\r\n *\r\n * @example\r\n *\r\n * [a]----[x]\r\n *         |\r\n *        [b]\r\n *\r\n * @param  {Point} a\r\n * @param  {Point} b\r\n * @param  {String} directions\r\n *\r\n * @return {Array<Point>}\r\n */\r\nmodule.exports.getBendpoints = function(a, b, directions) {\r\n\r\n  directions = directions || 'h:h';\r\n\r\n  var xmid, ymid;\r\n\r\n  // one point, next to a\r\n  if (directions === 'h:v') {\r\n    return [ { x: b.x, y: a.y } ];\r\n  } else\r\n  // one point, above a\r\n  if (directions === 'v:h') {\r\n    return [ { x: a.x, y: b.y } ];\r\n  } else\r\n  // vertical edge xmid\r\n  if (directions === 'h:h') {\r\n    xmid = Math.round((b.x - a.x) / 2 + a.x);\r\n\r\n    return [\r\n      { x: xmid, y: a.y },\r\n      { x: xmid, y: b.y }\r\n    ];\r\n  } else\r\n  // horizontal edge ymid\r\n  if (directions === 'v:v') {\r\n    ymid = Math.round((b.y - a.y) / 2 + a.y);\r\n\r\n    return [\r\n      { x: a.x, y: ymid },\r\n      { x: b.x, y: ymid }\r\n    ];\r\n  } else {\r\n    throw new Error(\r\n      'unknown directions: <' + directions + '>: ' +\r\n      'directions must be specified as {a direction}:{b direction} (direction in h|v)');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Create a connection between the two points according\r\n * to the manhattan layout (only horizontal and vertical) edges.\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n *\r\n * @param {String} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\r\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\r\n *\r\n * @return {Array<Point>}\r\n */\r\nmodule.exports.connectPoints = function(a, b, directions) {\r\n\r\n  var points = [];\r\n\r\n  if (!pointsAligned(a, b)) {\r\n    points = this.getBendpoints(a, b, directions);\r\n  }\r\n\r\n  points.unshift(a);\r\n  points.push(b);\r\n\r\n  return points;\r\n};\r\n\r\n\r\n/**\r\n * Connect two rectangles using a manhattan layouted connection.\r\n *\r\n * @param {Bounds} source source rectangle\r\n * @param {Bounds} target target rectangle\r\n * @param {Point} [start] source docking\r\n * @param {Point} [end] target docking\r\n *\r\n * @param {Object} [hints]\r\n * @param {String} [hints.preserveDocking=source] preserve docking on selected side\r\n * @param {Array<String>} [hints.preferredLayouts]\r\n * @param {Point|Boolean} [hints.connectionStart] whether the start changed\r\n * @param {Point|Boolean} [hints.connectionEnd] whether the end changed\r\n *\r\n * @return {Array<Point>} connection points\r\n */\r\nmodule.exports.connectRectangles = function(source, target, start, end, hints) {\r\n\r\n  var preferredLayouts = hints && hints.preferredLayouts || [];\r\n\r\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\r\n\r\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\r\n\r\n  var orientation = getOrientation(source, target, threshold);\r\n\r\n  var directions = getDirections(orientation, preferredLayout);\r\n\r\n  start = start || getMid(source);\r\n  end = end || getMid(target);\r\n\r\n  // overlapping elements\r\n  if (!directions) {\r\n    return;\r\n  }\r\n\r\n  if (directions === 'h:h') {\r\n\r\n    switch (orientation) {\r\n    case 'top-right':\r\n    case 'right':\r\n    case 'bottom-right':\r\n      start = { original: start, x: source.x, y: start.y };\r\n      end = { original: end, x: target.x + target.width, y: end.y };\r\n      break;\r\n    case 'top-left':\r\n    case 'left':\r\n    case 'bottom-left':\r\n      start = { original: start, x: source.x + source.width, y: start.y };\r\n      end = { original: end, x: target.x, y: end.y };\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (directions === 'v:v') {\r\n\r\n    switch (orientation) {\r\n    case 'top-left':\r\n    case 'top':\r\n    case 'top-right':\r\n      start = { original: start, x: start.x, y: source.y + source.height };\r\n      end = { original: end, x: end.x, y: target.y };\r\n      break;\r\n    case 'bottom-left':\r\n    case 'bottom':\r\n    case 'bottom-right':\r\n      start = { original: start, x: start.x, y: source.y };\r\n      end = { original: end, x: end.x, y: target.y + target.height };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return this.connectPoints(start, end, directions);\r\n};\r\n\r\n/**\r\n * Repair the connection between two rectangles, of which one has been updated.\r\n *\r\n * @param {Bounds} source\r\n * @param {Bounds} target\r\n * @param {Point} [start]\r\n * @param {Point} [end]\r\n * @param {Array<Point>} waypoints\r\n * @param {Object} [hints]\r\n * @param {Array<String>} [hints.preferredLayouts] list of preferred layouts\r\n * @param {Boolean} [hints.connectionStart]\r\n * @param {Boolean} [hints.connectionEnd]\r\n *\r\n * @return {Array<Point>} repaired waypoints\r\n */\r\nmodule.exports.repairConnection = function(source, target, start, end, waypoints, hints) {\r\n\r\n  if (isArray(start)) {\r\n    waypoints = start;\r\n    hints = end;\r\n\r\n    start = getMid(source);\r\n    end = getMid(target);\r\n  }\r\n\r\n  hints = assign({ preferredLayouts: [] }, hints);\r\n  waypoints = waypoints || [];\r\n\r\n  var preferredLayouts = hints.preferredLayouts,\r\n      layoutStraight = preferredLayouts.indexOf('straight') !== -1,\r\n      repairedWaypoints;\r\n\r\n  // just layout non-existing or simple connections\r\n  // attempt to render straight lines, if required\r\n\r\n  if (layoutStraight) {\r\n    // attempt to layout a straight line\r\n    repairedWaypoints = this.layoutStraight(source, target, start, end, hints);\r\n  }\r\n\r\n  if (!repairedWaypoints) {\r\n    // check if we layout from start or end\r\n    if (hints.connectionEnd) {\r\n      repairedWaypoints = this._repairConnectionSide(target, source, end, waypoints.slice().reverse());\r\n      repairedWaypoints = repairedWaypoints && repairedWaypoints.reverse();\r\n    } else\r\n    if (hints.connectionStart) {\r\n      repairedWaypoints = this._repairConnectionSide(source, target, start, waypoints);\r\n    } else\r\n    // or whether nothing seems to have changed\r\n    if (waypoints && waypoints.length) {\r\n      repairedWaypoints = waypoints;\r\n    }\r\n  }\r\n\r\n  // simply reconnect if nothing else worked\r\n  if (!repairedWaypoints) {\r\n    repairedWaypoints = this.connectRectangles(source, target, start, end, hints);\r\n  }\r\n\r\n  return repairedWaypoints;\r\n};\r\n\r\n\r\nfunction inRange(a, start, end) {\r\n  return a >= start && a <= end;\r\n}\r\n\r\nfunction isInRange(axis, a, b) {\r\n  var size = {\r\n    x: 'width',\r\n    y: 'height'\r\n  };\r\n\r\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\r\n}\r\n\r\n/**\r\n * Layout a straight connection\r\n *\r\n * @param {Bounds} source\r\n * @param {Bounds} target\r\n * @param {Point} start\r\n * @param {Point} end\r\n * @param {Object} [hints]\r\n *\r\n * @return {Array<Point>} waypoints if straight layout worked\r\n */\r\nmodule.exports.layoutStraight = function(source, target, start, end, hints) {\r\n  var axis = {},\r\n      primaryAxis,\r\n      orientation;\r\n\r\n  orientation = getOrientation(source, target);\r\n\r\n  // We're only interested in layouting a straight connection\r\n  // if the shapes are horizontally or vertically aligned\r\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\r\n    return null;\r\n  }\r\n\r\n  if (/top|bottom/.test(orientation)) {\r\n    primaryAxis = 'x';\r\n  }\r\n\r\n  if (/left|right/.test(orientation)) {\r\n    primaryAxis = 'y';\r\n  }\r\n\r\n  if (hints.preserveDocking === 'target') {\r\n\r\n    if (!isInRange(primaryAxis, end, source)) {\r\n      return null;\r\n    }\r\n\r\n    axis[primaryAxis] = end[primaryAxis];\r\n\r\n    return [\r\n      {\r\n        x: axis.x !== undefined ? axis.x : start.x,\r\n        y: axis.y !== undefined ? axis.y : start.y,\r\n        original: {\r\n          x: axis.x !== undefined ? axis.x : start.x,\r\n          y: axis.y !== undefined ? axis.y : start.y\r\n        }\r\n      },\r\n      {\r\n        x: end.x,\r\n        y: end.y\r\n      }\r\n    ];\r\n\r\n  } else {\r\n\r\n    if (!isInRange(primaryAxis, start, target)) {\r\n      return null;\r\n    }\r\n\r\n    axis[primaryAxis] = start[primaryAxis];\r\n\r\n    return [\r\n      {\r\n        x: start.x,\r\n        y: start.y\r\n      },\r\n      {\r\n        x: axis.x !== undefined ? axis.x : end.x,\r\n        y: axis.y !== undefined ? axis.y : end.y,\r\n        original: {\r\n          x: axis.x !== undefined ? axis.x : end.x,\r\n          y: axis.y !== undefined ? axis.y : end.y\r\n        }\r\n      }\r\n    ];\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * Repair a connection from one side that moved.\r\n *\r\n * @param {Bounds} moved\r\n * @param {Bounds} other\r\n * @param {Point} newDocking\r\n * @param {Array<Point>} points originalPoints from moved to other\r\n *\r\n * @return {Array<Point>} the repaired points between the two rectangles\r\n */\r\nmodule.exports._repairConnectionSide = function(moved, other, newDocking, points) {\r\n\r\n  function needsRelayout(moved, other, points) {\r\n\r\n    if (points.length < 3) {\r\n      return true;\r\n    }\r\n\r\n    if (points.length > 4) {\r\n      return false;\r\n    }\r\n\r\n    // relayout if two points overlap\r\n    // this is most likely due to\r\n    return !!find(points, function(p, idx) {\r\n      var q = points[idx - 1];\r\n\r\n      return q && pointDistance(p, q) < 3;\r\n    });\r\n  }\r\n\r\n  function repairBendpoint(candidate, oldPeer, newPeer) {\r\n\r\n    var alignment = pointsAligned(oldPeer, candidate);\r\n\r\n    switch (alignment) {\r\n    case 'v':\r\n        // repair vertical alignment\r\n      return { x: candidate.x, y: newPeer.y };\r\n    case 'h':\r\n        // repair horizontal alignment\r\n      return { x: newPeer.x, y: candidate.y };\r\n    }\r\n\r\n    return { x: candidate.x, y: candidate. y };\r\n  }\r\n\r\n  function removeOverlapping(points, a, b) {\r\n    var i;\r\n\r\n    for (i = points.length - 2; i !== 0; i--) {\r\n\r\n      // intersects (?) break, remove all bendpoints up to this one and relayout\r\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) ||\r\n          pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\r\n\r\n        // return sliced old connection\r\n        return points.slice(i);\r\n      }\r\n    }\r\n\r\n    return points;\r\n  }\r\n\r\n\r\n  // (0) only repair what has layoutable bendpoints\r\n\r\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\r\n  //     (horizontally / vertically), relayout\r\n\r\n  if (needsRelayout(moved, other, points)) {\r\n    return null;\r\n  }\r\n\r\n  var oldDocking = points[0],\r\n      newPoints = points.slice(),\r\n      slicedPoints;\r\n\r\n  // (2) repair only last line segment and only if it was layouted before\r\n\r\n  newPoints[0] = newDocking;\r\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\r\n\r\n\r\n  // (3) if shape intersects with any bendpoint after repair,\r\n  //     remove all segments up to this bendpoint and repair from there\r\n\r\n  slicedPoints = removeOverlapping(newPoints, moved, other);\r\n\r\n  if (slicedPoints !== newPoints) {\r\n    return this._repairConnectionSide(moved, other, newDocking, slicedPoints);\r\n  }\r\n\r\n  return newPoints;\r\n};\r\n\r\n/**\r\n * Returns the manhattan directions connecting two rectangles\r\n * with the given orientation.\r\n *\r\n * @example\r\n *\r\n * getDirections('top'); // -> 'v:v'\r\n *\r\n * getDirections('top-right', 'v:h'); // -> 'v:h'\r\n * getDirections('top-right', 'h:h'); // -> 'h:h'\r\n *\r\n *\r\n * @param {String} orientation\r\n * @param {String} defaultLayout\r\n *\r\n * @return {String}\r\n */\r\nfunction getDirections(orientation, defaultLayout) {\r\n\r\n  switch (orientation) {\r\n  case 'intersect':\r\n    return null;\r\n\r\n  case 'top':\r\n  case 'bottom':\r\n    return 'v:v';\r\n\r\n  case 'left':\r\n  case 'right':\r\n    return 'h:h';\r\n\r\n    // 'top-left'\r\n    // 'top-right'\r\n    // 'bottom-left'\r\n    // 'bottom-right'\r\n  default:\r\n    return defaultLayout;\r\n  }\r\n}\r\n","'use strict';\r\n\r\nvar assign = require(516),\r\n    inherits = require(368);\r\n\r\nvar Refs = require(552);\r\n\r\nvar parentRefs = new Refs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),\r\n    labelRefs = new Refs({ name: 'label', enumerable: true }, { name: 'labelTarget' }),\r\n    attacherRefs = new Refs({ name: 'attachers', collection: true }, { name: 'host' }),\r\n    outgoingRefs = new Refs({ name: 'outgoing', collection: true }, { name: 'source' }),\r\n    incomingRefs = new Refs({ name: 'incoming', collection: true }, { name: 'target' });\r\n\r\n/**\r\n * @namespace djs.model\r\n */\r\n\r\n/**\r\n * @memberOf djs.model\r\n */\r\n\r\n/**\r\n * The basic graphical representation\r\n *\r\n * @class\r\n *\r\n * @abstract\r\n */\r\nfunction Base() {\r\n\r\n  /**\r\n   * The object that backs up the shape\r\n   *\r\n   * @name Base#businessObject\r\n   * @type Object\r\n   */\r\n  Object.defineProperty(this, 'businessObject', {\r\n    writable: true\r\n  });\r\n\r\n  /**\r\n   * The parent shape\r\n   *\r\n   * @name Base#parent\r\n   * @type Shape\r\n   */\r\n  parentRefs.bind(this, 'parent');\r\n\r\n  /**\r\n   * @name Base#label\r\n   * @type Label\r\n   */\r\n  labelRefs.bind(this, 'label');\r\n\r\n  /**\r\n   * The list of outgoing connections\r\n   *\r\n   * @name Base#outgoing\r\n   * @type Array<Connection>\r\n   */\r\n  outgoingRefs.bind(this, 'outgoing');\r\n\r\n  /**\r\n   * The list of incoming connections\r\n   *\r\n   * @name Base#incoming\r\n   * @type Array<Connection>\r\n   */\r\n  incomingRefs.bind(this, 'incoming');\r\n}\r\n\r\n\r\n/**\r\n * A graphical object\r\n *\r\n * @class\r\n * @constructor\r\n *\r\n * @extends Base\r\n */\r\nfunction Shape() {\r\n  Base.call(this);\r\n\r\n  /**\r\n   * The list of children\r\n   *\r\n   * @name Shape#children\r\n   * @type Array<Base>\r\n   */\r\n  parentRefs.bind(this, 'children');\r\n\r\n  /**\r\n   * @name Shape#host\r\n   * @type Shape\r\n   */\r\n  attacherRefs.bind(this, 'host');\r\n\r\n  /**\r\n   * @name Shape#attachers\r\n   * @type Shape\r\n   */\r\n  attacherRefs.bind(this, 'attachers');\r\n}\r\n\r\ninherits(Shape, Base);\r\n\r\n\r\n/**\r\n * A root graphical object\r\n *\r\n * @class\r\n * @constructor\r\n *\r\n * @extends Shape\r\n */\r\nfunction Root() {\r\n  Shape.call(this);\r\n}\r\n\r\ninherits(Root, Shape);\r\n\r\n\r\n/**\r\n * A label for an element\r\n *\r\n * @class\r\n * @constructor\r\n *\r\n * @extends Shape\r\n */\r\nfunction Label() {\r\n  Shape.call(this);\r\n\r\n  /**\r\n   * The labeled element\r\n   *\r\n   * @name Label#labelTarget\r\n   * @type Base\r\n   */\r\n  labelRefs.bind(this, 'labelTarget');\r\n}\r\n\r\ninherits(Label, Shape);\r\n\r\n\r\n/**\r\n * A connection between two elements\r\n *\r\n * @class\r\n * @constructor\r\n *\r\n * @extends Base\r\n */\r\nfunction Connection() {\r\n  Base.call(this);\r\n\r\n  /**\r\n   * The element this connection originates from\r\n   *\r\n   * @name Connection#source\r\n   * @type Base\r\n   */\r\n  outgoingRefs.bind(this, 'source');\r\n\r\n  /**\r\n   * The element this connection points to\r\n   *\r\n   * @name Connection#target\r\n   * @type Base\r\n   */\r\n  incomingRefs.bind(this, 'target');\r\n}\r\n\r\ninherits(Connection, Base);\r\n\r\n\r\nvar types = {\r\n  connection: Connection,\r\n  shape: Shape,\r\n  label: Label,\r\n  root: Root\r\n};\r\n\r\n/**\r\n * Creates a new model element of the specified type\r\n *\r\n * @method create\r\n *\r\n * @example\r\n *\r\n * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });\r\n * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });\r\n *\r\n * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });\r\n *\r\n * @param  {String} type lower-cased model name\r\n * @param  {Object} attrs attributes to initialize the new model instance with\r\n *\r\n * @return {Base} the new model instance\r\n */\r\nmodule.exports.create = function(type, attrs) {\r\n  var Type = types[type];\r\n  if (!Type) {\r\n    throw new Error('unknown type: <' + type + '>');\r\n  }\r\n  return assign(new Type(), attrs);\r\n};\r\n\r\n\r\nmodule.exports.Base = Base;\r\nmodule.exports.Root = Root;\r\nmodule.exports.Shape = Shape;\r\nmodule.exports.Connection = Connection;\r\nmodule.exports.Label = Label;\r\n","'use strict';\r\n\r\nvar Cursor = require(342),\r\n    ClickTrap = require(339),\r\n    substract = require(350).substract,\r\n    domEvent = require(536),\r\n    domClosest = require(533),\r\n    EventUtil = require(344);\r\n\r\n\r\nfunction length(point) {\r\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\r\n}\r\n\r\n\r\nvar THRESHOLD = 15;\r\n\r\n\r\nfunction MoveCanvas(eventBus, canvas) {\r\n\r\n  var container = canvas._container,\r\n      context;\r\n\r\n\r\n  function handleMove(event) {\r\n\r\n    var start = context.start,\r\n        position = EventUtil.toPoint(event),\r\n        delta = substract(position, start);\r\n\r\n    if (!context.dragging && length(delta) > THRESHOLD) {\r\n      context.dragging = true;\r\n\r\n      // prevent mouse click in this\r\n      // interaction sequence\r\n      ClickTrap.install();\r\n\r\n      Cursor.set('grab');\r\n    }\r\n\r\n    if (context.dragging) {\r\n\r\n      var lastPosition = context.last || context.start;\r\n\r\n      delta = substract(position, lastPosition);\r\n\r\n      canvas.scroll({\r\n        dx: delta.x,\r\n        dy: delta.y\r\n      });\r\n\r\n      context.last = position;\r\n    }\r\n\r\n    // prevent select\r\n    event.preventDefault();\r\n  }\r\n\r\n\r\n  function handleEnd(event) {\r\n    domEvent.unbind(document, 'mousemove', handleMove);\r\n    domEvent.unbind(document, 'mouseup', handleEnd);\r\n\r\n    context = null;\r\n\r\n    Cursor.unset();\r\n  }\r\n\r\n  function handleStart(event) {\r\n    // event is already handled by '.djs-draggable'\r\n    if (domClosest(event.target, '.djs-draggable')) {\r\n      return;\r\n    }\r\n\r\n\r\n    // reject non-left left mouse button or modifier key\r\n    if (event.button || event.ctrlKey || event.shiftKey || event.altKey) {\r\n      return;\r\n    }\r\n\r\n    context = {\r\n      start: EventUtil.toPoint(event)\r\n    };\r\n\r\n    domEvent.bind(document, 'mousemove', handleMove);\r\n    domEvent.bind(document, 'mouseup', handleEnd);\r\n  }\r\n\r\n  domEvent.bind(container, 'mousedown', handleStart);\r\n}\r\n\r\n\r\nMoveCanvas.$inject = [ 'eventBus', 'canvas' ];\r\n\r\nmodule.exports = MoveCanvas;\r\n","module.exports = {\r\n  __init__: [ 'moveCanvas' ],\r\n  moveCanvas: [ 'type', require(332) ]\r\n};","module.exports = {\r\n  __depends__: [ require(324) ]\r\n};","'use strict';\r\n\r\nvar domEvent = require(536),\r\n    domClosest = require(533);\r\n\r\nvar hasPrimaryModifier = require(351).hasPrimaryModifier,\r\n    hasSecondaryModifier = require(351).hasSecondaryModifier;\r\n\r\nvar isMac = require(352).isMac;\r\n\r\nvar getStepRange = require(336).getStepRange,\r\n    cap = require(336).cap;\r\n\r\nvar log10 = require(350).log10;\r\n\r\nvar bind = require(396);\r\n\r\nvar RANGE = { min: 0.2, max: 4 },\r\n    NUM_STEPS = 10;\r\n\r\n\r\n/**\r\n * An implementation of zooming and scrolling within the\r\n * {@link Canvas} via the mouse wheel.\r\n *\r\n * Mouse wheel zooming / scrolling may be disabled using\r\n * the {@link toggle(enabled)} method.\r\n *\r\n * Additionally users can define the initial enabled state\r\n * by passing `{ zoomScroll: { enabled: false } }` at diagram\r\n * initialization.\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {Object} config\r\n */\r\nfunction ZoomScroll(eventBus, canvas, config) {\r\n\r\n  this._enabled = false;\r\n\r\n  this._canvas = canvas;\r\n  this._container = canvas._container;\r\n\r\n  this._handleWheel = bind(this._handleWheel, this);\r\n\r\n  var newEnabled = !config || config.enabled !== false;\r\n\r\n  var self = this;\r\n\r\n  eventBus.on('canvas.init', function(e) {\r\n    self._init(newEnabled);\r\n  });\r\n}\r\n\r\nZoomScroll.$inject = [ 'eventBus', 'canvas', 'config.zoomScroll' ];\r\n\r\nmodule.exports = ZoomScroll;\r\n\r\nZoomScroll.prototype.scroll = function scroll(delta) {\r\n  this._canvas.scroll(delta);\r\n};\r\n\r\n\r\nZoomScroll.prototype.reset = function reset() {\r\n  this._canvas.zoom('fit-viewport');\r\n};\r\n\r\n\r\nZoomScroll.prototype.zoom = function zoom(direction, position) {\r\n  var canvas = this._canvas;\r\n  var currentZoom = canvas.zoom(false);\r\n\r\n  var factor = Math.pow(1 + Math.abs(direction) , direction > 0 ? 1 : -1);\r\n\r\n  canvas.zoom(cap(RANGE, currentZoom * factor), position);\r\n};\r\n\r\n\r\nZoomScroll.prototype._handleWheel = function handleWheel(event) {\r\n  // event is already handled by '.djs-scrollable'\r\n  if (domClosest(event.target, '.djs-scrollable', true)) {\r\n    return;\r\n  }\r\n\r\n  var element = this._container;\r\n\r\n  event.preventDefault();\r\n\r\n  // mouse-event: SELECTION_KEY\r\n  // mouse-event: AND_KEY\r\n  var isVerticalScroll = hasPrimaryModifier(event),\r\n      isHorizontalScroll = hasSecondaryModifier(event);\r\n\r\n  var factor;\r\n\r\n  if (isVerticalScroll || isHorizontalScroll) {\r\n\r\n    if (isMac) {\r\n      factor = event.deltaMode === 0 ? 1.25 : 50;\r\n    } else {\r\n      factor = event.deltaMode === 0 ? 1/40 : 1/2;\r\n    }\r\n\r\n    var delta = {};\r\n\r\n    if (isHorizontalScroll) {\r\n      delta.dx = (factor * (event.deltaX || event.deltaY));\r\n    } else {\r\n      delta.dy = (factor * event.deltaY);\r\n    }\r\n    this.scroll(delta);\r\n  } else {\r\n    factor = (event.deltaMode === 0 ? 1/40 : 1/2);\r\n\r\n    var elementRect = element.getBoundingClientRect();\r\n\r\n    var offset =  {\r\n      x: event.clientX - elementRect.left,\r\n      y: event.clientY - elementRect.top\r\n    };\r\n\r\n    // zoom in relative to diagram {x,y} coordinates\r\n    this.zoom(event.deltaY * factor / (-5), offset);\r\n  }\r\n};\r\n\r\n/**\r\n * Zoom along fixed zoom steps\r\n *\r\n * @param {Integer} direction zoom direction (1 for zooming in, -1 for out)\r\n */\r\nZoomScroll.prototype.stepZoom = function stepZoom(direction, position) {\r\n\r\n  var canvas = this._canvas,\r\n      stepRange = getStepRange(RANGE, NUM_STEPS);\r\n\r\n  direction = direction > 0 ? 1 : -1;\r\n\r\n  var currentLinearZoomLevel = log10(canvas.zoom());\r\n\r\n  // snap to a proximate zoom step\r\n  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepRange) * stepRange;\r\n\r\n  // increase or decrease one zoom step in the given direction\r\n  newLinearZoomLevel += stepRange * direction;\r\n\r\n  // calculate the absolute logarithmic zoom level based on the linear zoom level\r\n  // (e.g. 2 for an absolute x2 zoom)\r\n  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);\r\n\r\n  canvas.zoom(cap(RANGE, newLogZoomLevel), position);\r\n};\r\n\r\n\r\n/**\r\n * Toggle the zoom scroll ability via mouse wheel.\r\n *\r\n * @param  {Boolean} [newEnabled] new enabled state\r\n */\r\nZoomScroll.prototype.toggle = function toggle(newEnabled) {\r\n\r\n  var element = this._container;\r\n  var handleWheel = this._handleWheel;\r\n\r\n  var oldEnabled = this._enabled;\r\n\r\n  if (typeof newEnabled === 'undefined') {\r\n    newEnabled = !oldEnabled;\r\n  }\r\n\r\n  // only react on actual changes\r\n  if (oldEnabled !== newEnabled) {\r\n\r\n    // add or remove wheel listener based on\r\n    // changed enabled state\r\n    domEvent[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);\r\n  }\r\n\r\n  this._enabled = newEnabled;\r\n\r\n  return newEnabled;\r\n};\r\n\r\n\r\nZoomScroll.prototype._init = function(newEnabled) {\r\n  this.toggle(newEnabled);\r\n};\r\n","'use strict';\r\n\r\n\r\nvar log10 = require(350).log10;\r\n\r\n/**\r\n * Get the linear range between two zoom steps based on the\r\n * total number of zoom steps (defined as NUM_STEPS)\r\n */\r\nmodule.exports.getStepRange = function(range, steps) {\r\n\r\n  var minLinearRange = log10(range.min),\r\n      maxLinearRange = log10(range.max);\r\n\r\n  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);\r\n\r\n  return absoluteLinearRange / steps;\r\n};\r\n\r\nmodule.exports.cap = function(range, scale) {\r\n  return Math.max(range.min, Math.min(range.max, scale));\r\n};\r\n","module.exports = {\r\n  __init__: [ 'zoomScroll' ],\r\n  zoomScroll: [ 'type', require(335) ]\r\n};","'use strict';\r\n\r\nvar roundPoint = require(329).roundPoint;\r\n\r\nvar center = require(353).center,\r\n    delta = require(353).delta;\r\n\r\n\r\n/**\r\n * Calculates the absolute point relative to the new element's position\r\n *\r\n * @param {point} point [absolute]\r\n * @param {bounds} oldBounds\r\n * @param {bounds} newBounds\r\n *\r\n * @return {point} point [absolute]\r\n */\r\nfunction getNewAttachPoint(point, oldBounds, newBounds) {\r\n  var oldCenter = center(oldBounds),\r\n      newCenter = center(newBounds),\r\n      oldDelta = delta(point, oldCenter);\r\n\r\n  var newDelta = {\r\n    x: oldDelta.x * (newBounds.width / oldBounds.width),\r\n    y: oldDelta.y * (newBounds.height / oldBounds.height)\r\n  };\r\n\r\n  return roundPoint({\r\n    x: newCenter.x + newDelta.x,\r\n    y: newCenter.y + newDelta.y\r\n  });\r\n}\r\n\r\nmodule.exports.getNewAttachPoint = getNewAttachPoint;\r\n\r\n\r\n/**\r\n * Calculates the shape's delta relative to a new position\r\n * of a certain element's bounds\r\n *\r\n * @param {djs.model.Shape} point [absolute]\r\n * @param {bounds} oldBounds\r\n * @param {bounds} newBounds\r\n *\r\n * @return {delta} delta\r\n */\r\nfunction getNewAttachShapeDelta(shape, oldBounds, newBounds) {\r\n  var shapeCenter = center(shape),\r\n      oldCenter = center(oldBounds),\r\n      newCenter = center(newBounds),\r\n      shapeDelta = delta(shape, shapeCenter),\r\n      oldCenterDelta = delta(shapeCenter, oldCenter);\r\n\r\n  var newCenterDelta = {\r\n    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),\r\n    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)\r\n  };\r\n\r\n  var newShapeCenter = {\r\n    x: newCenter.x + newCenterDelta.x,\r\n    y: newCenter.y + newCenterDelta.y\r\n  };\r\n\r\n  return roundPoint({\r\n    x: newShapeCenter.x + shapeDelta.x - shape.x,\r\n    y: newShapeCenter.y + shapeDelta.y - shape.y\r\n  });\r\n}\r\n\r\nmodule.exports.getNewAttachShapeDelta = getNewAttachShapeDelta;\r\n","'use strict';\r\n\r\nvar domEvent = require(536),\r\n    stopEvent = require(344).stopEvent;\r\n\r\nfunction trap(event) {\r\n  stopEvent(event);\r\n\r\n  toggle(false);\r\n}\r\n\r\nfunction toggle(active) {\r\n  domEvent[active ? 'bind' : 'unbind'](document.body, 'click', trap, true);\r\n}\r\n\r\n/**\r\n * Installs a click trap that prevents a ghost click following a dragging operation.\r\n *\r\n * @return {Function} a function to immediately remove the installed trap.\r\n */\r\nfunction install() {\r\n\r\n  toggle(true);\r\n\r\n  return function() {\r\n    toggle(false);\r\n  };\r\n}\r\n\r\nmodule.exports.install = install;","'use strict';\r\n\r\n/**\r\n * Failsafe remove an element from a collection\r\n *\r\n * @param  {Array<Object>} [collection]\r\n * @param  {Object} [element]\r\n *\r\n * @return {Number} the previous index of the element\r\n */\r\nmodule.exports.remove = function(collection, element) {\r\n\r\n  if (!collection || !element) {\r\n    return -1;\r\n  }\r\n\r\n  var idx = collection.indexOf(element);\r\n\r\n  if (idx !== -1) {\r\n    collection.splice(idx, 1);\r\n  }\r\n\r\n  return idx;\r\n};\r\n\r\n/**\r\n * Fail save add an element to the given connection, ensuring\r\n * it does not yet exist.\r\n *\r\n * @param {Array<Object>} collection\r\n * @param {Object} element\r\n * @param {Number} idx\r\n */\r\nmodule.exports.add = function(collection, element, idx) {\r\n\r\n  if (!collection || !element) {\r\n    return;\r\n  }\r\n\r\n  if (typeof idx !== 'number') {\r\n    idx = -1;\r\n  }\r\n\r\n  var currentIdx = collection.indexOf(element);\r\n\r\n  if (currentIdx !== -1) {\r\n\r\n    if (currentIdx === idx) {\r\n      // nothing to do, position has not changed\r\n      return;\r\n    } else {\r\n\r\n      if (idx !== -1) {\r\n        // remove from current position\r\n        collection.splice(currentIdx, 1);\r\n      } else {\r\n        // already exists in collection\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (idx !== -1) {\r\n    // insert at specified position\r\n    collection.splice(idx, 0, element);\r\n  } else {\r\n    // push to end\r\n    collection.push(element);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Fail save get the index of an element in a collection.\r\n *\r\n * @param {Array<Object>} collection\r\n * @param {Object} element\r\n *\r\n * @return {Number} the index or -1 if collection or element do\r\n *                  not exist or the element is not contained.\r\n */\r\nmodule.exports.indexOf = function(collection, element) {\r\n\r\n  if (!collection || !element) {\r\n    return -1;\r\n  }\r\n\r\n  return collection.indexOf(element);\r\n};\r\n","'use strict';\r\n\r\nvar forEach = require(386);\r\n\r\nfunction getTopLevel(elements) {\r\n  var topLevel = {},\r\n      parents = [],\r\n      result = [],\r\n      clearedParents = [];\r\n\r\n  forEach(elements, function(element) {\r\n    var parent = element.parent;\r\n\r\n    if (!topLevel[parent.id]) {\r\n      topLevel[parent.id] = [];\r\n    }\r\n\r\n    if (parents.indexOf(parent.id) === -1) {\r\n      parents.push(parent.id);\r\n    }\r\n\r\n    topLevel[parent.id].push(element);\r\n  });\r\n\r\n  forEach(parents, function(parent) {\r\n    forEach(topLevel[parent], function(element) {\r\n      if (topLevel[element.id]) {\r\n        clearedParents.push(element.id);\r\n      }\r\n    });\r\n  });\r\n\r\n  forEach(parents, function(parent) {\r\n    var idx = clearedParents.indexOf(parent);\r\n\r\n    if (idx === -1) {\r\n      result = result.concat(topLevel[parent]);\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.getTopLevel = getTopLevel;\r\n","'use strict';\r\n\r\nvar domClasses = require(531);\r\n\r\nvar CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;\r\n\r\n\r\nmodule.exports.set = function(mode) {\r\n  var classes = domClasses(document.body);\r\n\r\n  classes.removeMatching(CURSOR_CLS_PATTERN);\r\n\r\n  if (mode) {\r\n    classes.add('djs-cursor-' + mode);\r\n  }\r\n};\r\n\r\nmodule.exports.unset = function() {\r\n  this.set(null);\r\n};\r\n\r\nmodule.exports.has = function(mode) {\r\n  var classes = domClasses(document.body);\r\n\r\n  return classes.has('djs-cursor-' + mode);\r\n};\r\n","'use strict';\r\n\r\nvar isArray = require(506),\r\n    isNumber = require(510),\r\n    groupBy = require(387),\r\n    forEach = require(386);\r\n\r\n/**\r\n * Adds an element to a collection and returns true if the\r\n * element was added.\r\n *\r\n * @param {Array<Object>} elements\r\n * @param {Object} e\r\n * @param {Boolean} unique\r\n */\r\nfunction add(elements, e, unique) {\r\n  var canAdd = !unique || elements.indexOf(e) === -1;\r\n\r\n  if (canAdd) {\r\n    elements.push(e);\r\n  }\r\n\r\n  return canAdd;\r\n}\r\n\r\n/**\r\n * Iterate over each element in a collection, calling the iterator function `fn`\r\n * with (element, index, recursionDepth).\r\n *\r\n * Recurse into all elements that are returned by `fn`.\r\n *\r\n * @param  {Object|Array<Object>} elements\r\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\r\n * @param  {Number} [depth] maximum recursion depth\r\n */\r\nfunction eachElement(elements, fn, depth) {\r\n\r\n  depth = depth || 0;\r\n\r\n  if (!isArray(elements)) {\r\n    elements = [ elements ];\r\n  }\r\n\r\n  forEach(elements, function(s, i) {\r\n    var filter = fn(s, i, depth);\r\n\r\n    if (isArray(filter) && filter.length) {\r\n      eachElement(filter, fn, depth + 1);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Collects self + child elements up to a given depth from a list of elements.\r\n *\r\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\r\n * @param  {Boolean} unique whether to return a unique result set (no duplicates)\r\n * @param  {Number} maxDepth the depth to search through or -1 for infinite\r\n *\r\n * @return {Array<djs.model.Base>} found elements\r\n */\r\nfunction selfAndChildren(elements, unique, maxDepth) {\r\n  var result = [],\r\n      processedChildren = [];\r\n\r\n  eachElement(elements, function(element, i, depth) {\r\n    add(result, element, unique);\r\n\r\n    var children = element.children;\r\n\r\n    // max traversal depth not reached yet\r\n    if (maxDepth === -1 || depth < maxDepth) {\r\n\r\n      // children exist && children not yet processed\r\n      if (children && add(processedChildren, children, unique)) {\r\n        return children;\r\n      }\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Return self + direct children for a number of elements\r\n *\r\n * @param  {Array<djs.model.Base>} elements to query\r\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\r\n *\r\n * @return {Array<djs.model.Base>} the collected elements\r\n */\r\nfunction selfAndDirectChildren(elements, allowDuplicates) {\r\n  return selfAndChildren(elements, !allowDuplicates, 1);\r\n}\r\n\r\n/**\r\n * Return self + ALL children for a number of elements\r\n *\r\n * @param  {Array<djs.model.Base>} elements to query\r\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\r\n *\r\n * @return {Array<djs.model.Base>} the collected elements\r\n */\r\nfunction selfAndAllChildren(elements, allowDuplicates) {\r\n  return selfAndChildren(elements, !allowDuplicates, -1);\r\n}\r\n\r\n/**\r\n * Gets the the closure for all selected elements,\r\n * their connections and their attachment's connections\r\n *\r\n * @param {Array<djs.model.Base>} elements\r\n * @return {Object} enclosure\r\n */\r\nfunction getClosure(elements) {\r\n\r\n  // original elements passed to this function\r\n  var topLevel = groupBy(elements, function(e) { return e.id; });\r\n\r\n  var allShapes = {},\r\n      allConnections = {},\r\n      enclosedElements = {},\r\n      enclosedConnections = {};\r\n\r\n  function handleConnection(c) {\r\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\r\n      topLevel[c.id] = c;\r\n    }\r\n\r\n    // not enclosed as a child, but maybe logically\r\n    // (connecting two moved elements?)\r\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\r\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\r\n    }\r\n\r\n    allConnections[c.id] = c;\r\n  }\r\n\r\n  function handleElement(element) {\r\n\r\n    enclosedElements[element.id] = element;\r\n\r\n    if (element.waypoints) {\r\n      // remember connection\r\n      enclosedConnections[element.id] = allConnections[element.id] = element;\r\n    } else {\r\n      // remember shape\r\n      allShapes[element.id] = element;\r\n\r\n      // remember all connections\r\n      forEach(element.incoming, handleConnection);\r\n\r\n      forEach(element.outgoing, handleConnection);\r\n\r\n      // recurse into children\r\n      return element.children;\r\n    }\r\n  }\r\n\r\n  eachElement(elements, handleElement);\r\n\r\n  return {\r\n    allShapes: allShapes,\r\n    allConnections: allConnections,\r\n    topLevel: topLevel,\r\n    enclosedConnections: enclosedConnections,\r\n    enclosedElements: enclosedElements\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the surrounding bbox for all elements in\r\n * the array or the element primitive.\r\n *\r\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\r\n * @param {Boolean} stopRecursion\r\n */\r\nfunction getBBox(elements, stopRecursion) {\r\n\r\n  stopRecursion = !!stopRecursion;\r\n  if (!isArray(elements)) {\r\n    elements = [elements];\r\n  }\r\n\r\n  var minX,\r\n      minY,\r\n      maxX,\r\n      maxY;\r\n\r\n  forEach(elements, function(element) {\r\n\r\n    // If element is a connection the bbox must be computed first\r\n    var bbox = element;\r\n    if (element.waypoints && !stopRecursion) {\r\n      bbox = getBBox(element.waypoints, true);\r\n    }\r\n\r\n    var x = bbox.x,\r\n        y = bbox.y,\r\n        height = bbox.height || 0,\r\n        width  = bbox.width  || 0;\r\n\r\n    if (x < minX || minX === undefined) {\r\n      minX = x;\r\n    }\r\n    if (y < minY || minY === undefined) {\r\n      minY = y;\r\n    }\r\n\r\n    if ((x + width) > maxX || maxX === undefined) {\r\n      maxX = x + width;\r\n    }\r\n    if ((y + height) > maxY || maxY === undefined) {\r\n      maxY = y + height;\r\n    }\r\n  });\r\n\r\n  return {\r\n    x: minX,\r\n    y: minY,\r\n    height: maxY - minY,\r\n    width: maxX - minX\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Returns all elements that are enclosed from the bounding box.\r\n *\r\n *   * If bbox.(width|height) is not specified the method returns\r\n *     all elements with element.x/y > bbox.x/y\r\n *   * If only bbox.x or bbox.y is specified, method return all elements with\r\n *     e.x > bbox.x or e.y > bbox.y\r\n *\r\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\r\n * @param {djs.model.Shape} bbox the enclosing bbox.\r\n *\r\n * @return {Array<djs.model.Shape>} enclosed elements\r\n */\r\nfunction getEnclosedElements(elements, bbox) {\r\n\r\n  var filteredElements = {};\r\n\r\n  forEach(elements, function(element) {\r\n\r\n    var e = element;\r\n\r\n    if (e.waypoints) {\r\n      e = getBBox(e);\r\n    }\r\n\r\n    if (!isNumber(bbox.y) && (e.x > bbox.x)) {\r\n      filteredElements[element.id] = element;\r\n    }\r\n    if (!isNumber(bbox.x) && (e.y > bbox.y)) {\r\n      filteredElements[element.id] = element;\r\n    }\r\n    if (e.x > bbox.x && e.y > bbox.y) {\r\n      if (isNumber(bbox.width) && isNumber(bbox.height) &&\r\n          e.width  + e.x < bbox.width  + bbox.x &&\r\n          e.height + e.y < bbox.height + bbox.y) {\r\n\r\n        filteredElements[element.id] = element;\r\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\r\n        filteredElements[element.id] = element;\r\n      }\r\n    }\r\n  });\r\n\r\n  return filteredElements;\r\n}\r\n\r\n\r\nmodule.exports.add = add;\r\nmodule.exports.eachElement = eachElement;\r\nmodule.exports.selfAndDirectChildren = selfAndDirectChildren;\r\nmodule.exports.selfAndAllChildren = selfAndAllChildren;\r\nmodule.exports.getBBox = getBBox;\r\nmodule.exports.getEnclosedElements = getEnclosedElements;\r\n\r\nmodule.exports.getClosure = getClosure;\r\n\r\n\r\nfunction getElementType(element) {\r\n\r\n  if ('waypoints' in element) {\r\n    return 'connection';\r\n  }\r\n\r\n  if ('x' in element) {\r\n    return 'shape';\r\n  }\r\n\r\n  return 'root';\r\n}\r\n\r\nmodule.exports.getType = getElementType;","'use strict';\r\n\r\nfunction __preventDefault(event) {\r\n  return event && event.preventDefault();\r\n}\r\n\r\nfunction __stopPropagation(event, immediate) {\r\n  if (!event) {\r\n    return;\r\n  }\r\n\r\n  if (event.stopPropagation) {\r\n    event.stopPropagation();\r\n  }\r\n\r\n  if (immediate && event.stopImmediatePropagation) {\r\n    event.stopImmediatePropagation();\r\n  }\r\n}\r\n\r\n\r\nfunction getOriginal(event) {\r\n  return event.originalEvent || event.srcEvent;\r\n}\r\n\r\nmodule.exports.getOriginal = getOriginal;\r\n\r\n\r\nfunction stopEvent(event, immediate) {\r\n  stopPropagation(event, immediate);\r\n  preventDefault(event);\r\n}\r\n\r\nmodule.exports.stopEvent = stopEvent;\r\n\r\n\r\nfunction preventDefault(event) {\r\n  __preventDefault(event);\r\n  __preventDefault(getOriginal(event));\r\n}\r\n\r\nmodule.exports.preventDefault = preventDefault;\r\n\r\n\r\nfunction stopPropagation(event, immediate) {\r\n  __stopPropagation(event, immediate);\r\n  __stopPropagation(getOriginal(event), immediate);\r\n}\r\n\r\nmodule.exports.stopPropagation = stopPropagation;\r\n\r\n\r\nfunction toPoint(event) {\r\n\r\n  if (event.pointers && event.pointers.length) {\r\n    event = event.pointers[0];\r\n  }\r\n\r\n  if (event.touches && event.touches.length) {\r\n    event = event.touches[0];\r\n  }\r\n\r\n  return event ? {\r\n    x: event.clientX,\r\n    y: event.clientY\r\n  } : null;\r\n}\r\n\r\nmodule.exports.toPoint = toPoint;\r\n","'use strict';\r\n\r\n/**\r\n * Computes the distance between two points\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n *\r\n * @return {Number}  distance\r\n */\r\nfunction pointDistance(a, b) {\r\n  if (!a || !b) {\r\n    return -1;\r\n  }\r\n\r\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\r\n}\r\n\r\nmodule.exports.pointDistance = pointDistance;\r\n\r\n\r\n/**\r\n * Returns true if the point r is on the line between p and y\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n * @param  {Point}  r\r\n *\r\n * @return {Boolean}\r\n */\r\nmodule.exports.pointsOnLine = function(p, q, r) {\r\n\r\n  if (!p || !q || !r) {\r\n    return false;\r\n  }\r\n\r\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\r\n      dist = pointDistance(p, q);\r\n\r\n  // @see http://stackoverflow.com/a/907491/412190\r\n  return Math.abs(val / dist) < 5;\r\n};\r\n\r\n\r\nvar ALIGNED_THRESHOLD = 2;\r\n\r\n/**\r\n * Returns whether two points are in a horizontal or vertical line.\r\n *\r\n * @param {Point} a\r\n * @param {Point} b\r\n *\r\n * @return {String|Boolean} returns false if the points are not\r\n *                          aligned or 'h|v' if they are aligned\r\n *                          horizontally / vertically.\r\n */\r\nfunction pointsAligned(a, b) {\r\n  if (Math.abs(a.x - b.x) <= ALIGNED_THRESHOLD) {\r\n    return 'h';\r\n  }\r\n\r\n  if (Math.abs(a.y - b.y) <= ALIGNED_THRESHOLD) {\r\n    return 'v';\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nmodule.exports.pointsAligned = pointsAligned;\r\n\r\n\r\n/**\r\n * Returns true if the point p is inside the rectangle rect\r\n *\r\n * @param  {Point}  p\r\n * @param  {Rect}   rect\r\n * @param  {Number} tolerance\r\n *\r\n * @return {Boolean}\r\n */\r\nmodule.exports.pointInRect = function(p, rect, tolerance) {\r\n  tolerance = tolerance || 0;\r\n\r\n  return p.x > rect.x - tolerance &&\r\n         p.y > rect.y - tolerance &&\r\n         p.x < rect.x + rect.width + tolerance &&\r\n         p.y < rect.y + rect.height + tolerance;\r\n};\r\n\r\n/**\r\n * Returns a point in the middle of points p and q\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n *\r\n * @return {Point} middle point\r\n */\r\nmodule.exports.getMidPoint = function(p, q) {\r\n  return {\r\n    x: Math.round(p.x + ((q.x - p.x) / 2.0)),\r\n    y: Math.round(p.y + ((q.y - p.y) / 2.0))\r\n  };\r\n};\r\n","'use strict';\r\n\r\nvar domQuery = require(538);\r\n\r\n/**\r\n * SVGs for elements are generated by the {@link GraphicsFactory}.\r\n *\r\n * This utility gives quick access to the important semantic\r\n * parts of an element.\r\n */\r\n\r\n/**\r\n * Returns the visual part of a diagram element\r\n *\r\n * @param {Snap<SVGElement>} gfx\r\n *\r\n * @return {Snap<SVGElement>}\r\n */\r\nfunction getVisual(gfx) {\r\n  return domQuery('.djs-visual', gfx);\r\n}\r\n\r\n/**\r\n * Returns the children for a given diagram element.\r\n *\r\n * @param {Snap<SVGElement>} gfx\r\n * @return {Snap<SVGElement>}\r\n */\r\nfunction getChildren(gfx) {\r\n  return gfx.parentNode.childNodes[1];\r\n}\r\n\r\nmodule.exports.getVisual = getVisual;\r\nmodule.exports.getChildren = getChildren;\r\n","'use strict';\r\n\r\n/**\r\n * Util that provides unique IDs.\r\n *\r\n * @class djs.util.IdGenerator\r\n * @constructor\r\n * @memberOf djs.util\r\n *\r\n * The ids can be customized via a given prefix and contain a random value to avoid collisions.\r\n *\r\n * @param {String} prefix a prefix to prepend to generated ids (for better readability)\r\n */\r\nfunction IdGenerator(prefix) {\r\n\r\n  this._counter = 0;\r\n  this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';\r\n}\r\n\r\nmodule.exports = IdGenerator;\r\n\r\n/**\r\n * Returns a next unique ID.\r\n *\r\n * @method djs.util.IdGenerator#next\r\n *\r\n * @returns {String} the id\r\n */\r\nIdGenerator.prototype.next = function() {\r\n  return this._prefix + (++this._counter);\r\n};\r\n","/* eslint no-fallthrough: \"off\" */\r\n\r\n'use strict';\r\n\r\nvar has = 'hasOwnProperty',\r\n    p2s = /,?([a-z]),?/gi,\r\n    toFloat = parseFloat,\r\n    math = Math,\r\n    PI = math.PI,\r\n    mmin = math.min,\r\n    mmax = math.max,\r\n    pow = math.pow,\r\n    abs = math.abs,\r\n    pathCommand = /([a-z])[/s,]*((-?/d*/.?/d*(?:e[/-+]?/d+)?[/s]*,?[/s]*)+)/ig,\r\n    pathValues = /(-?/d*/.?/d*(?:e[/-+]?//d+)?)[/s]*,?[/s]*/ig;\r\n\r\nfunction is(o, type) {\r\n  type = String.prototype.toLowerCase.call(type);\r\n\r\n  if (type == 'finite') {\r\n    return isFinite(o);\r\n  }\r\n\r\n  if (type == 'array' && (o instanceof Array || Array.isArray && Array.isArray(o))) {\r\n    return true;\r\n  }\r\n\r\n  return  (type == 'null' && o === null) ||\r\n          (type == typeof o && o !== null) ||\r\n          (type == 'object' && o === Object(o)) ||\r\n          Object.prototype.toString.call(o).slice(8, -1).toLowerCase() == type;\r\n}\r\n\r\nfunction clone(obj) {\r\n\r\n  if (typeof obj == 'function' || Object(obj) !== obj) {\r\n    return obj;\r\n  }\r\n\r\n  var res = new obj.constructor;\r\n\r\n  for (var key in obj) if (obj[has](key)) {\r\n    res[key] = clone(obj[key]);\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\nfunction repush(array, item) {\r\n  for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\r\n    return array.push(array.splice(i, 1)[0]);\r\n  }\r\n}\r\n\r\nfunction cacher(f, scope, postprocessor) {\r\n\r\n  function newf() {\r\n\r\n    var arg = Array.prototype.slice.call(arguments, 0),\r\n        args = arg.join('/u2400'),\r\n        cache = newf.cache = newf.cache || {},\r\n        count = newf.count = newf.count || [];\r\n\r\n    if (cache[has](args)) {\r\n      repush(count, args);\r\n      return postprocessor ? postprocessor(cache[args]) : cache[args];\r\n    }\r\n\r\n    count.length >= 1e3 && delete cache[count.shift()];\r\n    count.push(args);\r\n    cache[args] = f.apply(scope, arg);\r\n\r\n    return postprocessor ? postprocessor(cache[args]) : cache[args];\r\n  }\r\n  return newf;\r\n}\r\n\r\nfunction parsePathString(pathString) {\r\n\r\n  if (!pathString) {\r\n    return null;\r\n  }\r\n\r\n  var pth = paths(pathString);\r\n\r\n  if (pth.arr) {\r\n    return clone(pth.arr);\r\n  }\r\n\r\n  var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 },\r\n      data = [];\r\n\r\n  if (is(pathString, 'array') && is(pathString[0], 'array')) { // rough assumption\r\n    data = clone(pathString);\r\n  }\r\n\r\n  if (!data.length) {\r\n\r\n    String(pathString).replace(pathCommand, function(a, b, c) {\r\n      var params = [],\r\n          name = b.toLowerCase();\r\n\r\n      c.replace(pathValues, function(a, b) {\r\n        b && params.push(+b);\r\n      });\r\n\r\n      if (name == 'm' && params.length > 2) {\r\n        data.push([b].concat(params.splice(0, 2)));\r\n        name = 'l';\r\n        b = b == 'm' ? 'l' : 'L';\r\n      }\r\n\r\n      if (name == 'o' && params.length == 1) {\r\n        data.push([b, params[0]]);\r\n      }\r\n\r\n      if (name == 'r') {\r\n        data.push([b].concat(params));\r\n      } else while (params.length >= paramCounts[name]) {\r\n        data.push([b].concat(params.splice(0, paramCounts[name])));\r\n        if (!paramCounts[name]) {\r\n          break;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  data.toString = paths.toString;\r\n  pth.arr = clone(data);\r\n\r\n  return data;\r\n}\r\n\r\nfunction paths(ps) {\r\n  var p = paths.ps = paths.ps || {};\r\n\r\n  if (p[ps]) {\r\n    p[ps].sleep = 100;\r\n  } else {\r\n    p[ps] = {\r\n      sleep: 100\r\n    };\r\n  }\r\n\r\n  setTimeout(function() {\r\n    for (var key in p) if (p[has](key) && key != ps) {\r\n      p[key].sleep--;\r\n      !p[key].sleep && delete p[key];\r\n    }\r\n  });\r\n\r\n  return p[ps];\r\n}\r\n\r\nfunction box(x, y, width, height) {\r\n  if (x == null) {\r\n    x = y = width = height = 0;\r\n  }\r\n\r\n  if (y == null) {\r\n    y = x.y;\r\n    width = x.width;\r\n    height = x.height;\r\n    x = x.x;\r\n  }\r\n\r\n  return {\r\n    x: x,\r\n    y: y,\r\n    width: width,\r\n    w: width,\r\n    height: height,\r\n    h: height,\r\n    x2: x + width,\r\n    y2: y + height,\r\n    cx: x + width / 2,\r\n    cy: y + height / 2,\r\n    r1: math.min(width, height) / 2,\r\n    r2: math.max(width, height) / 2,\r\n    r0: math.sqrt(width * width + height * height) / 2,\r\n    path: rectPath(x, y, width, height),\r\n    vb: [x, y, width, height].join(' ')\r\n  };\r\n}\r\n\r\nfunction toString() {\r\n  return this.join(',').replace(p2s, '$1');\r\n}\r\n\r\nfunction pathClone(pathArray) {\r\n  var res = clone(pathArray);\r\n  res.toString = toString;\r\n  return res;\r\n}\r\n\r\nfunction getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\r\n  if (length == null) {\r\n    return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\r\n  } else {\r\n    return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\r\n      getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\r\n  }\r\n}\r\n\r\nfunction getLengthFactory(istotal, subpath) {\r\n  function O(val) {\r\n    return +(+val).toFixed(3);\r\n  }\r\n\r\n  return cacher(function(path, length, onlystart) {\r\n\r\n    if (path instanceof Element) {\r\n      path = path.attr('d');\r\n    }\r\n\r\n    path = path2curve(path);\r\n\r\n    var x, y, p, l, sp = '', subpaths = {}, point,\r\n        len = 0;\r\n\r\n    for (var i = 0, ii = path.length; i < ii; i++) {\r\n      p = path[i];\r\n\r\n      if (p[0] == 'M') {\r\n        x = +p[1];\r\n        y = +p[2];\r\n      } else {\r\n        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\r\n\r\n        if (len + l > length) {\r\n\r\n          if (subpath && !subpaths.start) {\r\n            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\r\n\r\n            sp += [\r\n              'C' + O(point.start.x),\r\n              O(point.start.y),\r\n              O(point.m.x),\r\n              O(point.m.y),\r\n              O(point.x),\r\n              O(point.y)\r\n            ];\r\n\r\n            if (onlystart) {\r\n              return sp;\r\n            }\r\n\r\n            subpaths.start = sp;\r\n            sp = [\r\n              'M' + O(point.x),\r\n              O(point.y) + 'C' + O(point.n.x),\r\n              O(point.n.y),\r\n              O(point.end.x),\r\n              O(point.end.y),\r\n              O(p[5]),\r\n              O(p[6])\r\n            ].join();\r\n            len += l;\r\n            x = +p[5];\r\n            y = +p[6];\r\n            continue;\r\n          }\r\n\r\n          if (!istotal && !subpath) {\r\n            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\r\n            return point;\r\n          }\r\n        }\r\n\r\n        len += l;\r\n        x = +p[5];\r\n        y = +p[6];\r\n      }\r\n\r\n      sp += p.shift() + p;\r\n    }\r\n\r\n    subpaths.end = sp;\r\n    point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\r\n    return point;\r\n  }, null, clone);\r\n}\r\n\r\nvar getTotalLength = getLengthFactory(1),\r\n    getPointAtLength = getLengthFactory();\r\n\r\nfunction findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\r\n  var t1 = 1 - t,\r\n      t13 = pow(t1, 3),\r\n      t12 = pow(t1, 2),\r\n      t2 = t * t,\r\n      t3 = t2 * t,\r\n      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\r\n      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\r\n      mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\r\n      my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\r\n      nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\r\n      ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\r\n      ax = t1 * p1x + t * c1x,\r\n      ay = t1 * p1y + t * c1y,\r\n      cx = t1 * c2x + t * p2x,\r\n      cy = t1 * c2y + t * p2y,\r\n      alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\r\n\r\n  // (mx > nx || my < ny) && (alpha += 180);\r\n\r\n  return {\r\n    x: x,\r\n    y: y,\r\n    m: { x: mx, y: my },\r\n    n: { x: nx, y: ny },\r\n    start: { x: ax, y: ay },\r\n    end: { x: cx, y: cy },\r\n    alpha: alpha\r\n  };\r\n}\r\n\r\nfunction bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n\r\n  if (!is(p1x, 'array')) {\r\n    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\r\n  }\r\n\r\n  var bbox = curveDim.apply(null, p1x);\r\n\r\n  return box(\r\n    bbox.min.x,\r\n    bbox.min.y,\r\n    bbox.max.x - bbox.min.x,\r\n    bbox.max.y - bbox.min.y\r\n  );\r\n}\r\n\r\nfunction isPointInsideBBox(bbox, x, y) {\r\n  return x >= bbox.x &&\r\n    x <= bbox.x + bbox.width &&\r\n    y >= bbox.y &&\r\n    y <= bbox.y + bbox.height;\r\n}\r\n\r\nfunction isBBoxIntersect(bbox1, bbox2) {\r\n  bbox1 = box(bbox1);\r\n  bbox2 = box(bbox2);\r\n  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\r\n    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\r\n    || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\r\n    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\r\n    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\r\n    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\r\n    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\r\n    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\r\n    || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\r\n        || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\r\n    && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\r\n        || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\r\n}\r\n\r\nfunction base3(t, p1, p2, p3, p4) {\r\n  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\r\n      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\r\n  return t * t2 - 3 * p1 + 3 * p2;\r\n}\r\n\r\nfunction bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\r\n\r\n  if (z == null) {\r\n    z = 1;\r\n  }\r\n\r\n  z = z > 1 ? 1 : z < 0 ? 0 : z;\r\n\r\n  var z2 = z / 2,\r\n      n = 12,\r\n      Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\r\n      Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\r\n      sum = 0;\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    var ct = z2 * Tvalues[i] + z2,\r\n        xbase = base3(ct, x1, x2, x3, x4),\r\n        ybase = base3(ct, y1, y2, y3, y4),\r\n        comb = xbase * xbase + ybase * ybase;\r\n\r\n    sum += Cvalues[i] * math.sqrt(comb);\r\n  }\r\n\r\n  return z2 * sum;\r\n}\r\n\r\nfunction getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\r\n\r\n  if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\r\n    return;\r\n  }\r\n\r\n  var t = 1,\r\n      step = t / 2,\r\n      t2 = t - step,\r\n      l,\r\n      e = .01;\r\n\r\n  l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\r\n\r\n  while (abs(l - ll) > e) {\r\n    step /= 2;\r\n    t2 += (l < ll ? 1 : -1) * step;\r\n    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\r\n  }\r\n\r\n  return t2;\r\n}\r\n\r\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\r\n\r\n  if (\r\n      mmax(x1, x2) < mmin(x3, x4) ||\r\n      mmin(x1, x2) > mmax(x3, x4) ||\r\n      mmax(y1, y2) < mmin(y3, y4) ||\r\n      mmin(y1, y2) > mmax(y3, y4)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\r\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\r\n      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n  if (!denominator) {\r\n    return;\r\n  }\r\n\r\n  var px = nx / denominator,\r\n      py = ny / denominator,\r\n      px2 = +px.toFixed(2),\r\n      py2 = +py.toFixed(2);\r\n\r\n  if (\r\n      px2 < +mmin(x1, x2).toFixed(2) ||\r\n      px2 > +mmax(x1, x2).toFixed(2) ||\r\n      px2 < +mmin(x3, x4).toFixed(2) ||\r\n      px2 > +mmax(x3, x4).toFixed(2) ||\r\n      py2 < +mmin(y1, y2).toFixed(2) ||\r\n      py2 > +mmax(y1, y2).toFixed(2) ||\r\n      py2 < +mmin(y3, y4).toFixed(2) ||\r\n      py2 > +mmax(y3, y4).toFixed(2)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  return { x: px, y: py };\r\n}\r\n\r\nfunction interHelper(bez1, bez2, justCount) {\r\n  var bbox1 = bezierBBox(bez1),\r\n      bbox2 = bezierBBox(bez2);\r\n\r\n  if (!isBBoxIntersect(bbox1, bbox2)) {\r\n    return justCount ? 0 : [];\r\n  }\r\n\r\n  var l1 = bezlen.apply(0, bez1),\r\n      l2 = bezlen.apply(0, bez2),\r\n      n1 = ~~(l1 / 8),\r\n      n2 = ~~(l2 / 8),\r\n      dots1 = [],\r\n      dots2 = [],\r\n      xy = {},\r\n      res = justCount ? 0 : [];\r\n\r\n  for (var i = 0; i < n1 + 1; i++) {\r\n    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\r\n    dots1.push({ x: p.x, y: p.y, t: i / n1 });\r\n  }\r\n\r\n  for (i = 0; i < n2 + 1; i++) {\r\n    p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\r\n    dots2.push({ x: p.x, y: p.y, t: i / n2 });\r\n  }\r\n\r\n  for (i = 0; i < n1; i++) {\r\n\r\n    for (var j = 0; j < n2; j++) {\r\n      var di = dots1[i],\r\n          di1 = dots1[i + 1],\r\n          dj = dots2[j],\r\n          dj1 = dots2[j + 1],\r\n          ci = abs(di1.x - di.x) < .001 ? 'y' : 'x',\r\n          cj = abs(dj1.x - dj.x) < .001 ? 'y' : 'x',\r\n          is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\r\n\r\n      if (is) {\r\n\r\n        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\r\n          continue;\r\n        }\r\n\r\n        xy[is.x.toFixed(4)] = is.y.toFixed(4);\r\n\r\n        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\r\n            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\r\n\r\n        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\r\n\r\n          if (justCount) {\r\n            res++;\r\n          } else {\r\n            res.push({\r\n              x: is.x,\r\n              y: is.y,\r\n              t1: t1,\r\n              t2: t2\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\nfunction pathIntersection(path1, path2) {\r\n  return interPathHelper(path1, path2);\r\n}\r\n\r\nfunction pathIntersectionNumber(path1, path2) {\r\n  return interPathHelper(path1, path2, 1);\r\n}\r\n\r\nfunction interPathHelper(path1, path2, justCount) {\r\n  path1 = path2curve(path1);\r\n  path2 = path2curve(path2);\r\n\r\n  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\r\n      res = justCount ? 0 : [];\r\n\r\n  for (var i = 0, ii = path1.length; i < ii; i++) {\r\n    var pi = path1[i];\r\n\r\n    if (pi[0] == 'M') {\r\n      x1 = x1m = pi[1];\r\n      y1 = y1m = pi[2];\r\n    } else {\r\n\r\n      if (pi[0] == 'C') {\r\n        bez1 = [x1, y1].concat(pi.slice(1));\r\n        x1 = bez1[6];\r\n        y1 = bez1[7];\r\n      } else {\r\n        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\r\n        x1 = x1m;\r\n        y1 = y1m;\r\n      }\r\n\r\n      for (var j = 0, jj = path2.length; j < jj; j++) {\r\n        var pj = path2[j];\r\n\r\n        if (pj[0] == 'M') {\r\n          x2 = x2m = pj[1];\r\n          y2 = y2m = pj[2];\r\n        } else {\r\n\r\n          if (pj[0] == 'C') {\r\n            bez2 = [x2, y2].concat(pj.slice(1));\r\n            x2 = bez2[6];\r\n            y2 = bez2[7];\r\n          } else {\r\n            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\r\n            x2 = x2m;\r\n            y2 = y2m;\r\n          }\r\n\r\n          var intr = interHelper(bez1, bez2, justCount);\r\n\r\n          if (justCount) {\r\n            res += intr;\r\n          } else {\r\n\r\n            for (var k = 0, kk = intr.length; k < kk; k++) {\r\n              intr[k].segment1 = i;\r\n              intr[k].segment2 = j;\r\n              intr[k].bez1 = bez1;\r\n              intr[k].bez2 = bez2;\r\n            }\r\n\r\n            res = res.concat(intr);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\nfunction isPointInsidePath(path, x, y) {\r\n  var bbox = pathBBox(path);\r\n\r\n  return isPointInsideBBox(bbox, x, y) &&\r\n         interPathHelper(path, [['M', x, y], ['H', bbox.x2 + 10]], 1) % 2 == 1;\r\n}\r\n\r\nfunction pathBBox(path) {\r\n  var pth = paths(path);\r\n\r\n  if (pth.bbox) {\r\n    return clone(pth.bbox);\r\n  }\r\n\r\n  if (!path) {\r\n    return box();\r\n  }\r\n\r\n  path = path2curve(path);\r\n\r\n  var x = 0,\r\n      y = 0,\r\n      X = [],\r\n      Y = [],\r\n      p;\r\n\r\n  for (var i = 0, ii = path.length; i < ii; i++) {\r\n    p = path[i];\r\n\r\n    if (p[0] == 'M') {\r\n      x = p[1];\r\n      y = p[2];\r\n      X.push(x);\r\n      Y.push(y);\r\n    } else {\r\n      var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\r\n      X = X.concat(dim.min.x, dim.max.x);\r\n      Y = Y.concat(dim.min.y, dim.max.y);\r\n      x = p[5];\r\n      y = p[6];\r\n    }\r\n  }\r\n\r\n  var xmin = mmin.apply(0, X),\r\n      ymin = mmin.apply(0, Y),\r\n      xmax = mmax.apply(0, X),\r\n      ymax = mmax.apply(0, Y),\r\n      bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\r\n\r\n  pth.bbox = clone(bb);\r\n\r\n  return bb;\r\n}\r\n\r\nfunction rectPath(x, y, w, h, r) {\r\n  if (r) {\r\n    return [\r\n      ['M', +x + (+r), y],\r\n      ['l', w - r * 2, 0],\r\n      ['a', r, r, 0, 0, 1, r, r],\r\n      ['l', 0, h - r * 2],\r\n      ['a', r, r, 0, 0, 1, -r, r],\r\n      ['l', r * 2 - w, 0],\r\n      ['a', r, r, 0, 0, 1, -r, -r],\r\n      ['l', 0, r * 2 - h],\r\n      ['a', r, r, 0, 0, 1, r, -r],\r\n      ['z']\r\n    ];\r\n  }\r\n\r\n  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\r\n  res.toString = toString;\r\n\r\n  return res;\r\n}\r\n\r\nfunction ellipsePath(x, y, rx, ry, a) {\r\n  if (a == null && ry == null) {\r\n    ry = rx;\r\n  }\r\n\r\n  x = +x;\r\n  y = +y;\r\n  rx = +rx;\r\n  ry = +ry;\r\n\r\n  if (a != null) {\r\n    var rad = Math.PI / 180,\r\n        x1 = x + rx * Math.cos(-ry * rad),\r\n        x2 = x + rx * Math.cos(-a * rad),\r\n        y1 = y + rx * Math.sin(-ry * rad),\r\n        y2 = y + rx * Math.sin(-a * rad),\r\n        res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\r\n  } else {\r\n    res = [\r\n      ['M', x, y],\r\n      ['m', 0, -ry],\r\n      ['a', rx, ry, 0, 1, 1, 0, 2 * ry],\r\n      ['a', rx, ry, 0, 1, 1, 0, -2 * ry],\r\n      ['z']\r\n    ];\r\n  }\r\n\r\n  res.toString = toString;\r\n\r\n  return res;\r\n}\r\n\r\nfunction pathToRelative(pathArray) {\r\n  var pth = paths(pathArray),\r\n      lowerCase = String.prototype.toLowerCase;\r\n\r\n  if (pth.rel) {\r\n    return pathClone(pth.rel);\r\n  }\r\n\r\n  if (!is(pathArray, 'array') || !is(pathArray && pathArray[0], 'array')) {\r\n    pathArray = parsePathString(pathArray);\r\n  }\r\n\r\n  var res = [],\r\n      x = 0,\r\n      y = 0,\r\n      mx = 0,\r\n      my = 0,\r\n      start = 0;\r\n\r\n  if (pathArray[0][0] == 'M') {\r\n    x = pathArray[0][1];\r\n    y = pathArray[0][2];\r\n    mx = x;\r\n    my = y;\r\n    start++;\r\n    res.push(['M', x, y]);\r\n  }\r\n\r\n  for (var i = start, ii = pathArray.length; i < ii; i++) {\r\n    var r = res[i] = [],\r\n        pa = pathArray[i];\r\n\r\n    if (pa[0] != lowerCase.call(pa[0])) {\r\n      r[0] = lowerCase.call(pa[0]);\r\n\r\n      switch (r[0]) {\r\n      case 'a':\r\n        r[1] = pa[1];\r\n        r[2] = pa[2];\r\n        r[3] = pa[3];\r\n        r[4] = pa[4];\r\n        r[5] = pa[5];\r\n        r[6] = +(pa[6] - x).toFixed(3);\r\n        r[7] = +(pa[7] - y).toFixed(3);\r\n        break;\r\n      case 'v':\r\n        r[1] = +(pa[1] - y).toFixed(3);\r\n        break;\r\n      case 'm':\r\n        mx = pa[1];\r\n        my = pa[2];\r\n      default:\r\n        for (var j = 1, jj = pa.length; j < jj; j++) {\r\n          r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\r\n        }\r\n      }\r\n    } else {\r\n      r = res[i] = [];\r\n\r\n      if (pa[0] == 'm') {\r\n        mx = pa[1] + x;\r\n        my = pa[2] + y;\r\n      }\r\n\r\n      for (var k = 0, kk = pa.length; k < kk; k++) {\r\n        res[i][k] = pa[k];\r\n      }\r\n    }\r\n\r\n    var len = res[i].length;\r\n\r\n    switch (res[i][0]) {\r\n    case 'z':\r\n      x = mx;\r\n      y = my;\r\n      break;\r\n    case 'h':\r\n      x += +res[i][len - 1];\r\n      break;\r\n    case 'v':\r\n      y += +res[i][len - 1];\r\n      break;\r\n    default:\r\n      x += +res[i][len - 2];\r\n      y += +res[i][len - 1];\r\n    }\r\n  }\r\n\r\n  res.toString = toString;\r\n  pth.rel = pathClone(res);\r\n\r\n  return res;\r\n}\r\n\r\nfunction pathToAbsolute(pathArray) {\r\n  var pth = paths(pathArray);\r\n\r\n  if (pth.abs) {\r\n    return pathClone(pth.abs);\r\n  }\r\n\r\n  if (!is(pathArray, 'array') || !is(pathArray && pathArray[0], 'array')) { // rough assumption\r\n    pathArray = parsePathString(pathArray);\r\n  }\r\n\r\n  if (!pathArray || !pathArray.length) {\r\n    return [['M', 0, 0]];\r\n  }\r\n\r\n  var res = [],\r\n      x = 0,\r\n      y = 0,\r\n      mx = 0,\r\n      my = 0,\r\n      start = 0,\r\n      pa0;\r\n\r\n  if (pathArray[0][0] == 'M') {\r\n    x = +pathArray[0][1];\r\n    y = +pathArray[0][2];\r\n    mx = x;\r\n    my = y;\r\n    start++;\r\n    res[0] = ['M', x, y];\r\n  }\r\n\r\n  var crz = pathArray.length == 3 &&\r\n      pathArray[0][0] == 'M' &&\r\n      pathArray[1][0].toUpperCase() == 'R' &&\r\n      pathArray[2][0].toUpperCase() == 'Z';\r\n\r\n  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\r\n    res.push(r = []);\r\n    pa = pathArray[i];\r\n    pa0 = pa[0];\r\n\r\n    if (pa0 != pa0.toUpperCase()) {\r\n      r[0] = pa0.toUpperCase();\r\n\r\n      switch (r[0]) {\r\n      case 'A':\r\n        r[1] = pa[1];\r\n        r[2] = pa[2];\r\n        r[3] = pa[3];\r\n        r[4] = pa[4];\r\n        r[5] = pa[5];\r\n        r[6] = +pa[6] + x;\r\n        r[7] = +pa[7] + y;\r\n        break;\r\n      case 'V':\r\n        r[1] = +pa[1] + y;\r\n        break;\r\n      case 'H':\r\n        r[1] = +pa[1] + x;\r\n        break;\r\n      case 'R':\r\n        var dots = [x, y].concat(pa.slice(1));\r\n\r\n        for (var j = 2, jj = dots.length; j < jj; j++) {\r\n          dots[j] = +dots[j] + x;\r\n          dots[++j] = +dots[j] + y;\r\n        }\r\n\r\n        res.pop();\r\n        res = res.concat(catmullRom2bezier(dots, crz));\r\n        break;\r\n      case 'O':\r\n        res.pop();\r\n        dots = ellipsePath(x, y, pa[1], pa[2]);\r\n        dots.push(dots[0]);\r\n        res = res.concat(dots);\r\n        break;\r\n      case 'U':\r\n        res.pop();\r\n        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\r\n        r = ['U'].concat(res[res.length - 1].slice(-2));\r\n        break;\r\n      case 'M':\r\n        mx = +pa[1] + x;\r\n        my = +pa[2] + y;\r\n      default:\r\n\r\n        for (j = 1, jj = pa.length; j < jj; j++) {\r\n          r[j] = +pa[j] + ((j % 2) ? x : y);\r\n        }\r\n      }\r\n    } else if (pa0 == 'R') {\r\n      dots = [x, y].concat(pa.slice(1));\r\n      res.pop();\r\n      res = res.concat(catmullRom2bezier(dots, crz));\r\n      r = ['R'].concat(pa.slice(-2));\r\n    } else if (pa0 == 'O') {\r\n      res.pop();\r\n      dots = ellipsePath(x, y, pa[1], pa[2]);\r\n      dots.push(dots[0]);\r\n      res = res.concat(dots);\r\n    } else if (pa0 == 'U') {\r\n      res.pop();\r\n      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\r\n      r = ['U'].concat(res[res.length - 1].slice(-2));\r\n    } else {\r\n\r\n      for (var k = 0, kk = pa.length; k < kk; k++) {\r\n        r[k] = pa[k];\r\n      }\r\n    }\r\n    pa0 = pa0.toUpperCase();\r\n\r\n    if (pa0 != 'O') {\r\n      switch (r[0]) {\r\n      case 'Z':\r\n        x = +mx;\r\n        y = +my;\r\n        break;\r\n      case 'H':\r\n        x = r[1];\r\n        break;\r\n      case 'V':\r\n        y = r[1];\r\n        break;\r\n      case 'M':\r\n        mx = r[r.length - 2];\r\n        my = r[r.length - 1];\r\n      default:\r\n        x = r[r.length - 2];\r\n        y = r[r.length - 1];\r\n      }\r\n    }\r\n  }\r\n\r\n  res.toString = toString;\r\n  pth.abs = pathClone(res);\r\n\r\n  return res;\r\n}\r\n\r\nfunction l2c(x1, y1, x2, y2) {\r\n  return [x1, y1, x2, y2, x2, y2];\r\n}\r\n\r\nfunction q2c(x1, y1, ax, ay, x2, y2) {\r\n  var _13 = 1 / 3,\r\n      _23 = 2 / 3;\r\n\r\n  return [\r\n    _13 * x1 + _23 * ax,\r\n    _13 * y1 + _23 * ay,\r\n    _13 * x2 + _23 * ax,\r\n    _13 * y2 + _23 * ay,\r\n    x2,\r\n    y2\r\n  ];\r\n}\r\n\r\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\r\n\r\n  // for more information of where this math came from visit:\r\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n  var _120 = PI * 120 / 180,\r\n      rad = PI / 180 * (+angle || 0),\r\n      res = [],\r\n      xy,\r\n      rotate = cacher(function(x, y, rad) {\r\n        var X = x * math.cos(rad) - y * math.sin(rad),\r\n            Y = x * math.sin(rad) + y * math.cos(rad);\r\n\r\n        return { x: X, y: Y };\r\n      });\r\n\r\n  if (!recursive) {\r\n    xy = rotate(x1, y1, -rad);\r\n    x1 = xy.x;\r\n    y1 = xy.y;\r\n    xy = rotate(x2, y2, -rad);\r\n    x2 = xy.x;\r\n    y2 = xy.y;\r\n\r\n    var x = (x1 - x2) / 2,\r\n        y = (y1 - y2) / 2;\r\n\r\n    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\r\n\r\n    if (h > 1) {\r\n      h = math.sqrt(h);\r\n      rx = h * rx;\r\n      ry = h * ry;\r\n    }\r\n\r\n    var rx2 = rx * rx,\r\n        ry2 = ry * ry,\r\n        k = (large_arc_flag == sweep_flag ? -1 : 1) *\r\n            math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\r\n        cx = k * rx * y / ry + (x1 + x2) / 2,\r\n        cy = k * -ry * x / rx + (y1 + y2) / 2,\r\n        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\r\n        f2 = math.asin(((y2 - cy) / ry).toFixed(9));\r\n\r\n    f1 = x1 < cx ? PI - f1 : f1;\r\n    f2 = x2 < cx ? PI - f2 : f2;\r\n    f1 < 0 && (f1 = PI * 2 + f1);\r\n    f2 < 0 && (f2 = PI * 2 + f2);\r\n\r\n    if (sweep_flag && f1 > f2) {\r\n      f1 = f1 - PI * 2;\r\n    }\r\n    if (!sweep_flag && f2 > f1) {\r\n      f2 = f2 - PI * 2;\r\n    }\r\n  } else {\r\n    f1 = recursive[0];\r\n    f2 = recursive[1];\r\n    cx = recursive[2];\r\n    cy = recursive[3];\r\n  }\r\n\r\n  var df = f2 - f1;\r\n\r\n  if (abs(df) > _120) {\r\n    var f2old = f2,\r\n        x2old = x2,\r\n        y2old = y2;\r\n\r\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\r\n    x2 = cx + rx * math.cos(f2);\r\n    y2 = cy + ry * math.sin(f2);\r\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\r\n  }\r\n\r\n  df = f2 - f1;\r\n\r\n  var c1 = math.cos(f1),\r\n      s1 = math.sin(f1),\r\n      c2 = math.cos(f2),\r\n      s2 = math.sin(f2),\r\n      t = math.tan(df / 4),\r\n      hx = 4 / 3 * rx * t,\r\n      hy = 4 / 3 * ry * t,\r\n      m1 = [x1, y1],\r\n      m2 = [x1 + hx * s1, y1 - hy * c1],\r\n      m3 = [x2 + hx * s2, y2 - hy * c2],\r\n      m4 = [x2, y2];\r\n\r\n  m2[0] = 2 * m1[0] - m2[0];\r\n  m2[1] = 2 * m1[1] - m2[1];\r\n\r\n  if (recursive) {\r\n    return [m2, m3, m4].concat(res);\r\n  } else {\r\n    res = [m2, m3, m4].concat(res).join().split(',');\r\n    var newres = [];\r\n\r\n    for (var i = 0, ii = res.length; i < ii; i++) {\r\n      newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\r\n    }\r\n\r\n    return newres;\r\n  }\r\n}\r\n\r\n// Returns bounding box of cubic bezier curve.\r\n// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\r\n// Original version: NISHIO Hirokazu\r\n// Modifications: https://github.com/timo22345\r\nfunction curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n  var tvalues = [],\r\n      bounds = [[], []],\r\n      a, b, c, t, t1, t2, b2ac, sqrtb2ac;\r\n\r\n  for (var i = 0; i < 2; ++i) {\r\n\r\n    if (i == 0) {\r\n      b = 6 * x0 - 12 * x1 + 6 * x2;\r\n      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\r\n      c = 3 * x1 - 3 * x0;\r\n    } else {\r\n      b = 6 * y0 - 12 * y1 + 6 * y2;\r\n      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\r\n      c = 3 * y1 - 3 * y0;\r\n    }\r\n\r\n    if (abs(a) < 1e-12) {\r\n\r\n      if (abs(b) < 1e-12) {\r\n        continue;\r\n      }\r\n\r\n      t = -c / b;\r\n\r\n      if (0 < t && t < 1) {\r\n        tvalues.push(t);\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    b2ac = b * b - 4 * c * a;\r\n    sqrtb2ac = math.sqrt(b2ac);\r\n\r\n    if (b2ac < 0) {\r\n      continue;\r\n    }\r\n\r\n    t1 = (-b + sqrtb2ac) / (2 * a);\r\n\r\n    if (0 < t1 && t1 < 1) {\r\n      tvalues.push(t1);\r\n    }\r\n\r\n    t2 = (-b - sqrtb2ac) / (2 * a);\r\n\r\n    if (0 < t2 && t2 < 1) {\r\n      tvalues.push(t2);\r\n    }\r\n  }\r\n\r\n  var j = tvalues.length,\r\n      jlen = j,\r\n      mt;\r\n\r\n  while (j--) {\r\n    t = tvalues[j];\r\n    mt = 1 - t;\r\n    bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\r\n    bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\r\n  }\r\n\r\n  bounds[0][jlen] = x0;\r\n  bounds[1][jlen] = y0;\r\n  bounds[0][jlen + 1] = x3;\r\n  bounds[1][jlen + 1] = y3;\r\n  bounds[0].length = bounds[1].length = jlen + 2;\r\n\r\n  return {\r\n    min: { x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1]) },\r\n    max: { x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1]) }\r\n  };\r\n}\r\n\r\nfunction path2curve(path, path2) {\r\n  var pth = !path2 && paths(path);\r\n\r\n  if (!path2 && pth.curve) {\r\n    return pathClone(pth.curve);\r\n  }\r\n\r\n  var p = pathToAbsolute(path),\r\n      p2 = path2 && pathToAbsolute(path2),\r\n      attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },\r\n      attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },\r\n      processPath = function(path, d, pcom) {\r\n        var nx, ny;\r\n\r\n        if (!path) {\r\n          return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\r\n        }\r\n\r\n        !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);\r\n\r\n        switch (path[0]) {\r\n        case 'M':\r\n          d.X = path[1];\r\n          d.Y = path[2];\r\n          break;\r\n        case 'A':\r\n          path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\r\n          break;\r\n        case 'S':\r\n          if (pcom == 'C' || pcom == 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\r\n            nx = d.x * 2 - d.bx;          // And reflect the previous\r\n            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\r\n          }\r\n          else {                            // or some else or nothing\r\n            nx = d.x;\r\n            ny = d.y;\r\n          }\r\n          path = ['C', nx, ny].concat(path.slice(1));\r\n          break;\r\n        case 'T':\r\n          if (pcom == 'Q' || pcom == 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\r\n            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\r\n            d.qy = d.y * 2 - d.qy;        // to case 'S'.\r\n          }\r\n          else {                            // or something else or nothing\r\n            d.qx = d.x;\r\n            d.qy = d.y;\r\n          }\r\n          path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\r\n          break;\r\n        case 'Q':\r\n          d.qx = path[1];\r\n          d.qy = path[2];\r\n          path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\r\n          break;\r\n        case 'L':\r\n          path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\r\n          break;\r\n        case 'H':\r\n          path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\r\n          break;\r\n        case 'V':\r\n          path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\r\n          break;\r\n        case 'Z':\r\n          path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\r\n          break;\r\n        }\r\n\r\n        return path;\r\n      },\r\n\r\n      fixArc = function(pp, i) {\r\n\r\n        if (pp[i].length > 7) {\r\n          pp[i].shift();\r\n          var pi = pp[i];\r\n\r\n          while (pi.length) {\r\n            pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\r\n            p2 && (pcoms2[i] = 'A'); // the same as above\r\n            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\r\n          }\r\n\r\n          pp.splice(i, 1);\r\n          ii = mmax(p.length, p2 && p2.length || 0);\r\n        }\r\n      },\r\n\r\n      fixM = function(path1, path2, a1, a2, i) {\r\n\r\n        if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {\r\n          path2.splice(i, 0, ['M', a2.x, a2.y]);\r\n          a1.bx = 0;\r\n          a1.by = 0;\r\n          a1.x = path1[i][1];\r\n          a1.y = path1[i][2];\r\n          ii = mmax(p.length, p2 && p2.length || 0);\r\n        }\r\n      },\r\n\r\n      pcoms1 = [], // path commands of original path p\r\n      pcoms2 = [], // path commands of original path p2\r\n      pfirst = '', // temporary holder for original path command\r\n      pcom = ''; // holder for previous path command of original path\r\n\r\n  for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\r\n    p[i] && (pfirst = p[i][0]); // save current path command\r\n\r\n    if (pfirst != 'C') // C is not saved yet, because it may be result of conversion\r\n    {\r\n      pcoms1[i] = pfirst; // Save current path command\r\n      i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\r\n    }\r\n    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\r\n\r\n    if (pcoms1[i] != 'A' && pfirst == 'C') pcoms1[i] = 'C'; // A is the only command\r\n    // which may produce multiple C:s\r\n    // so we have to make sure that C is also C in original path\r\n\r\n    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\r\n\r\n    if (p2) { // the same procedures is done to p2\r\n      p2[i] && (pfirst = p2[i][0]);\r\n\r\n      if (pfirst != 'C') {\r\n        pcoms2[i] = pfirst;\r\n        i && (pcom = pcoms2[i - 1]);\r\n      }\r\n\r\n      p2[i] = processPath(p2[i], attrs2, pcom);\r\n\r\n      if (pcoms2[i] != 'A' && pfirst == 'C') {\r\n        pcoms2[i] = 'C';\r\n      }\r\n\r\n      fixArc(p2, i);\r\n    }\r\n\r\n    fixM(p, p2, attrs, attrs2, i);\r\n    fixM(p2, p, attrs2, attrs, i);\r\n\r\n    var seg = p[i],\r\n        seg2 = p2 && p2[i],\r\n        seglen = seg.length,\r\n        seg2len = p2 && seg2.length;\r\n\r\n    attrs.x = seg[seglen - 2];\r\n    attrs.y = seg[seglen - 1];\r\n    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\r\n    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\r\n    attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\r\n    attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\r\n    attrs2.x = p2 && seg2[seg2len - 2];\r\n    attrs2.y = p2 && seg2[seg2len - 1];\r\n  }\r\n\r\n  if (!p2) {\r\n    pth.curve = pathClone(p);\r\n  }\r\n\r\n  return p2 ? [p, p2] : p;\r\n}\r\n\r\nfunction mapPath(path, matrix) {\r\n\r\n  if (!matrix) {\r\n    return path;\r\n  }\r\n\r\n  var x, y, i, j, ii, jj, pathi;\r\n  path = path2curve(path);\r\n\r\n  for (i = 0, ii = path.length; i < ii; i++) {\r\n    pathi = path[i];\r\n\r\n    for (j = 1, jj = pathi.length; j < jj; j += 2) {\r\n      x = matrix.x(pathi[j], pathi[j + 1]);\r\n      y = matrix.y(pathi[j], pathi[j + 1]);\r\n      pathi[j] = x;\r\n      pathi[j + 1] = y;\r\n    }\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\n// http://schepers.cc/getting-to-the-point\r\nfunction catmullRom2bezier(crp, z) {\r\n  var d = [];\r\n\r\n  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\r\n    var p = [\r\n      { x: +crp[i - 2], y: +crp[i - 1] },\r\n      { x: +crp[i],     y: +crp[i + 1] },\r\n      { x: +crp[i + 2], y: +crp[i + 3] },\r\n      { x: +crp[i + 4], y: +crp[i + 5] }\r\n    ];\r\n\r\n    if (z) {\r\n\r\n      if (!i) {\r\n        p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };\r\n      } else if (iLen - 4 == i) {\r\n        p[3] = { x: +crp[0], y: +crp[1] };\r\n      } else if (iLen - 2 == i) {\r\n        p[2] = { x: +crp[0], y: +crp[1] };\r\n        p[3] = { x: +crp[2], y: +crp[3] };\r\n      }\r\n\r\n    } else {\r\n\r\n      if (iLen - 4 == i) {\r\n        p[3] = p[2];\r\n      } else if (!i) {\r\n        p[0] = { x: +crp[i], y: +crp[i + 1] };\r\n      }\r\n\r\n    }\r\n\r\n    d.push(['C',\r\n      (-p[0].x + 6 * p[1].x + p[2].x) / 6,\r\n      (-p[0].y + 6 * p[1].y + p[2].y) / 6,\r\n      (p[1].x + 6 * p[2].x - p[3].x) / 6,\r\n      (p[1].y + 6*p[2].y - p[3].y) / 6,\r\n      p[2].x,\r\n      p[2].y\r\n    ]);\r\n  }\r\n\r\n  return d;\r\n}\r\n\r\npaths.getTotalLength = getTotalLength;\r\npaths.getPointAtLength = getPointAtLength;\r\npaths.findDotsAtSegment = findDotsAtSegment;\r\npaths.bezierBBox = bezierBBox;\r\npaths.isPointInsideBBox = isPointInsideBBox;\r\npaths.isBBoxIntersect = isBBoxIntersect;\r\npaths.intersection = pathIntersection;\r\npaths.intersectionNumber = pathIntersectionNumber;\r\npaths.isPointInside = isPointInsidePath;\r\npaths.getBBox = pathBBox;\r\npaths.toRelative = pathToRelative;\r\npaths.toAbsolute = pathToAbsolute;\r\npaths.toCubic = path2curve;\r\npaths.map = mapPath;\r\npaths.toString = toString;\r\npaths.clone = pathClone;\r\n\r\nmodule.exports.intersection = pathIntersection;\r\n","'use strict';\r\n\r\nvar pointDistance = require(345).pointDistance;\r\n\r\nvar intersection = require(348).intersection;\r\n\r\nvar round = Math.round,\r\n    max = Math.max;\r\n\r\n\r\nfunction circlePath(center, r) {\r\n  var x = center.x,\r\n      y = center.y;\r\n\r\n  return [\r\n    ['M', x, y],\r\n    ['m', 0, -r],\r\n    ['a', r, r, 0, 1, 1, 0, 2 * r],\r\n    ['a', r, r, 0, 1, 1, 0, -2 * r],\r\n    ['z']\r\n  ];\r\n}\r\n\r\nfunction linePath(points) {\r\n  var segments = [];\r\n\r\n  points.forEach(function(p, idx) {\r\n    segments.push([ idx === 0 ? 'M' : 'L', p.x, p.y ]);\r\n  });\r\n\r\n  return segments;\r\n}\r\n\r\n\r\nvar INTERSECTION_THRESHOLD = 10;\r\n\r\nfunction getBendpointIntersection(waypoints, reference) {\r\n\r\n  var i, w;\r\n\r\n  for (i = 0; (w = waypoints[i]); i++) {\r\n\r\n    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {\r\n      return {\r\n        point: waypoints[i],\r\n        bendpoint: true,\r\n        index: i\r\n      };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getPathIntersection(waypoints, reference) {\r\n\r\n  var intersections = intersection(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));\r\n\r\n  var a = intersections[0],\r\n      b = intersections[intersections.length - 1],\r\n      idx;\r\n\r\n  if (!a) {\r\n    // no intersection\r\n    return null;\r\n  }\r\n\r\n  if (a !== b) {\r\n\r\n    if (a.segment2 !== b.segment2) {\r\n      // we use the bendpoint in between both segments\r\n      // as the intersection point\r\n\r\n      idx = max(a.segment2, b.segment2) - 1;\r\n\r\n      return {\r\n        point: waypoints[idx],\r\n        bendpoint: true,\r\n        index: idx\r\n      };\r\n    }\r\n\r\n    return {\r\n      point: {\r\n        x: (round(a.x + b.x) / 2),\r\n        y: (round(a.y + b.y) / 2)\r\n      },\r\n      index: a.segment2\r\n    };\r\n  }\r\n\r\n  return {\r\n    point: {\r\n      x: round(a.x),\r\n      y: round(a.y)\r\n    },\r\n    index: a.segment2\r\n  };\r\n}\r\n\r\n/**\r\n * Returns the closest point on the connection towards a given reference point.\r\n *\r\n * @param  {Array<Point>} waypoints\r\n * @param  {Point} reference\r\n *\r\n * @return {Object} intersection data (segment, point)\r\n */\r\nmodule.exports.getApproxIntersection = function(waypoints, reference) {\r\n  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);\r\n};\r\n","'use strict';\r\n\r\n/**\r\n * Get the logarithm of x with base 10\r\n * @param  {Integer} value\r\n */\r\nfunction log10(x) {\r\n  return Math.log(x) / Math.log(10);\r\n}\r\n\r\nmodule.exports.log10 = log10;\r\n\r\n\r\nfunction substract(p1, p2) {\r\n  return {\r\n    x: p1.x - p2.x,\r\n    y: p1.y - p2.y\r\n  };\r\n}\r\n\r\nmodule.exports.substract = substract;\r\n","'use strict';\r\n\r\nvar getOriginalEvent = require(344).getOriginal;\r\n\r\nvar isMac = require(352).isMac;\r\n\r\n\r\nfunction isPrimaryButton(event) {\r\n  // button === 0 -> left áka primary mouse button\r\n  return !(getOriginalEvent(event) || event).button;\r\n}\r\n\r\nmodule.exports.isPrimaryButton = isPrimaryButton;\r\n\r\nmodule.exports.isMac = isMac;\r\n\r\nmodule.exports.hasPrimaryModifier = function(event) {\r\n  var originalEvent = getOriginalEvent(event) || event;\r\n\r\n  if (!isPrimaryButton(event)) {\r\n    return false;\r\n  }\r\n\r\n  // Use alt as primary modifier key for mac OS\r\n  if (isMac()) {\r\n    return originalEvent.metaKey;\r\n  } else {\r\n    return originalEvent.ctrlKey;\r\n  }\r\n};\r\n\r\n\r\nmodule.exports.hasSecondaryModifier = function(event) {\r\n  var originalEvent = getOriginalEvent(event) || event;\r\n\r\n  return isPrimaryButton(event) && originalEvent.shiftKey;\r\n};\r\n","'use strict';\r\n\r\nmodule.exports.isMac = function isMac() {\r\n  return (/mac/i).test(navigator.platform);\r\n};","'use strict';\r\n\r\nfunction center(bounds) {\r\n  return {\r\n    x: bounds.x + (bounds.width / 2),\r\n    y: bounds.y + (bounds.height / 2)\r\n  };\r\n}\r\n\r\nmodule.exports.center = center;\r\n\r\n\r\nfunction delta(a, b) {\r\n  return {\r\n    x: a.x - b.x,\r\n    y: a.y - b.y\r\n  };\r\n}\r\n\r\nmodule.exports.delta = delta;\r\n","'use strict';\r\n\r\n\r\n/**\r\n * Remove from the beginning of a collection until it is empty.\r\n *\r\n * This is a null-safe operation that ensures elements\r\n * are being removed from the given collection until the\r\n * collection is empty.\r\n *\r\n * The implementation deals with the fact that a remove operation\r\n * may touch, i.e. remove multiple elements in the collection\r\n * at a time.\r\n *\r\n * @param {Array<Object>} [collection]\r\n * @param {Function} removeFn\r\n *\r\n * @return {Array<Object>} the cleared collection\r\n */\r\nmodule.exports.saveClear = function(collection, removeFn) {\r\n\r\n  if (typeof removeFn !== 'function') {\r\n    throw new Error('removeFn iterator must be a function');\r\n  }\r\n\r\n  if (!collection) {\r\n    return;\r\n  }\r\n\r\n  var e;\r\n\r\n  while ((e = collection[0])) {\r\n    removeFn(e);\r\n  }\r\n\r\n  return collection;\r\n};\r\n","'use strict';\r\n\r\nvar svgAttr = require(579),\r\n    svgCreate = require(583);\r\n\r\n\r\nmodule.exports.componentsToPath = function(elements) {\r\n  return elements.join(',').replace(/,?([A-z]),?/g, '$1');\r\n};\r\n\r\nfunction toSVGPoints(points) {\r\n  var result = '';\r\n\r\n  for (var i = 0, p; (p = points[i]); i++) {\r\n    result += p.x + ',' + p.y + ' ';\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.toSVGPoints = toSVGPoints;\r\n\r\nmodule.exports.createLine = function(points, attrs) {\r\n\r\n  var line = svgCreate('polyline');\r\n  svgAttr(line, { points: toSVGPoints(points) });\r\n\r\n  if (attrs) {\r\n    svgAttr(line, attrs);\r\n  }\r\n\r\n  return line;\r\n};\r\n\r\nmodule.exports.updateLine = function(gfx, points) {\r\n  svgAttr(gfx, { points: toSVGPoints(points) });\r\n\r\n  return gfx;\r\n};\r\n","'use strict';\r\n\r\nvar svgTransform = require(587);\r\n\r\nvar createTransform = require(584).createTransform;\r\n\r\n\r\n/**\r\n * @param {<SVGElement>} element\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} angle\r\n * @param {Number} amount\r\n */\r\nmodule.exports.transform = function(gfx, x, y, angle, amount) {\r\n  var translate = createTransform();\r\n  translate.setTranslate(x, y);\r\n\r\n  var rotate = createTransform();\r\n  rotate.setRotate(angle, 0, 0);\r\n\r\n  var scale = createTransform();\r\n  scale.setScale(amount || 1, amount || 1);\r\n\r\n  svgTransform(gfx, [ translate, rotate, scale ]);\r\n};\r\n\r\n\r\n/**\r\n * @param {SVGElement} element\r\n * @param {Number} x\r\n * @param {Number} y\r\n */\r\nmodule.exports.translate = function(gfx, x, y) {\r\n  var translate = createTransform();\r\n  translate.setTranslate(x, y);\r\n\r\n  svgTransform(gfx, translate);\r\n};\r\n\r\n\r\n/**\r\n * @param {SVGElement} element\r\n * @param {Number} angle\r\n */\r\nmodule.exports.rotate = function(gfx, angle) {\r\n  var rotate = createTransform();\r\n  rotate.setRotate(angle, 0, 0);\r\n\r\n  svgTransform(gfx, rotate);\r\n};\r\n\r\n\r\n/**\r\n * @param {SVGElement} element\r\n * @param {Number} amount\r\n */\r\nmodule.exports.scale = function(gfx, amount) {\r\n  var scale = createTransform();\r\n  scale.setScale(amount, amount);\r\n\r\n  svgTransform(gfx, scale);\r\n};\r\n","'use strict';\r\n\r\nvar isObject = require(511),\r\n    assign = require(516),\r\n    pick = require(524),\r\n    forEach = require(386),\r\n    reduce = require(390),\r\n    merge = require(521);\r\n\r\nvar svgAppend = require(577),\r\n    svgAttr = require(579),\r\n    svgCreate = require(583),\r\n    svgRemove = require(586);\r\n\r\nvar DEFAULT_BOX_PADDING = 0;\r\n\r\nvar DEFAULT_LABEL_SIZE = {\r\n  width: 150,\r\n  height: 50\r\n};\r\n\r\n\r\nfunction parseAlign(align) {\r\n\r\n  var parts = align.split('-');\r\n\r\n  return {\r\n    horizontal: parts[0] || 'center',\r\n    vertical: parts[1] || 'top'\r\n  };\r\n}\r\n\r\nfunction parsePadding(padding) {\r\n\r\n  if (isObject(padding)) {\r\n    return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);\r\n  } else {\r\n    return {\r\n      top: padding,\r\n      left: padding,\r\n      right: padding,\r\n      bottom: padding\r\n    };\r\n  }\r\n}\r\n\r\nfunction getTextBBox(text, fakeText) {\r\n\r\n  fakeText.textContent = text;\r\n\r\n  try {\r\n    var bbox,\r\n        emptyLine = text === '';\r\n\r\n    // add dummy text, when line is empty to determine correct height\r\n    fakeText.textContent = emptyLine ? 'dummy' : text;\r\n\r\n    bbox = pick(fakeText.getBBox(), [ 'width', 'height' ]);\r\n\r\n    if (emptyLine) {\r\n      // correct width\r\n      bbox.width = 0;\r\n    }\r\n\r\n    return bbox;\r\n  } catch (e) {\r\n    return { width: 0, height: 0 };\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Layout the next line and return the layouted element.\r\n *\r\n * Alters the lines passed.\r\n *\r\n * @param  {Array<String>} lines\r\n * @return {Object} the line descriptor, an object { width, height, text }\r\n */\r\nfunction layoutNext(lines, maxWidth, fakeText) {\r\n\r\n  var originalLine = lines.shift(),\r\n      fitLine = originalLine;\r\n\r\n  var textBBox;\r\n\r\n  for (;;) {\r\n    textBBox = getTextBBox(fitLine, fakeText);\r\n\r\n    textBBox.width = fitLine ? textBBox.width : 0;\r\n\r\n    // try to fit\r\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\r\n      return fit(lines, fitLine, originalLine, textBBox);\r\n    }\r\n\r\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\r\n  }\r\n}\r\n\r\nfunction fit(lines, fitLine, originalLine, textBBox) {\r\n  if (fitLine.length < originalLine.length) {\r\n    var remainder = originalLine.slice(fitLine.length).trim();\r\n\r\n    lines.unshift(remainder);\r\n  }\r\n  return { width: textBBox.width, height: textBBox.height, text: fitLine };\r\n}\r\n\r\n\r\n/**\r\n * Shortens a line based on spacing and hyphens.\r\n * Returns the shortened result on success.\r\n *\r\n * @param  {String} line\r\n * @param  {Number} maxLength the maximum characters of the string\r\n * @return {String} the shortened string\r\n */\r\nfunction semanticShorten(line, maxLength) {\r\n  var parts = line.split(/(/s|-)/g),\r\n      part,\r\n      shortenedParts = [],\r\n      length = 0;\r\n\r\n  // try to shorten via spaces + hyphens\r\n  if (parts.length > 1) {\r\n    while ((part = parts.shift())) {\r\n      if (part.length + length < maxLength) {\r\n        shortenedParts.push(part);\r\n        length += part.length;\r\n      } else {\r\n        // remove previous part, too if hyphen does not fit anymore\r\n        if (part === '-') {\r\n          shortenedParts.pop();\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return shortenedParts.join('');\r\n}\r\n\r\n\r\nfunction shortenLine(line, width, maxWidth) {\r\n  var length = Math.max(line.length * (maxWidth / width), 1);\r\n\r\n  // try to shorten semantically (i.e. based on spaces and hyphens)\r\n  var shortenedLine = semanticShorten(line, length);\r\n\r\n  if (!shortenedLine) {\r\n\r\n    // force shorten by cutting the long word\r\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\r\n  }\r\n\r\n  return shortenedLine;\r\n}\r\n\r\n\r\nfunction getHelperSvg() {\r\n  var helperSvg = document.getElementById('helper-svg');\r\n\r\n  if (!helperSvg) {\r\n    helperSvg = svgCreate('svg');\r\n\r\n    svgAttr(helperSvg, {\r\n      id: 'helper-svg',\r\n      width: 0,\r\n      height: 0,\r\n      style: 'visibility: hidden; position: fixed'\r\n    });\r\n\r\n    document.body.appendChild(helperSvg);\r\n  }\r\n\r\n  return helperSvg;\r\n}\r\n\r\n\r\n/**\r\n * Creates a new label utility\r\n *\r\n * @param {Object} config\r\n * @param {Dimensions} config.size\r\n * @param {Number} config.padding\r\n * @param {Object} config.style\r\n * @param {String} config.align\r\n */\r\nfunction Text(config) {\r\n\r\n  this._config = assign({}, {\r\n    size: DEFAULT_LABEL_SIZE,\r\n    padding: DEFAULT_BOX_PADDING,\r\n    style: {},\r\n    align: 'center-top'\r\n  }, config || {});\r\n}\r\n\r\n/**\r\n * Returns the layouted text as an SVG element.\r\n *\r\n * @param {String} text\r\n * @param {Object} options\r\n *\r\n * @return {SVGText}\r\n */\r\nText.prototype.createText = function(text, options) {\r\n  return this.layoutText(text, options).element;\r\n};\r\n\r\n/**\r\n * Returns a labels layouted dimensions.\r\n *\r\n * @param {String} text to layout\r\n * @param {Object} options\r\n *\r\n * @return {Dimensions}\r\n */\r\nText.prototype.getDimensions = function(text, options) {\r\n  return this.layoutText(text, options).dimensions;\r\n};\r\n\r\n/**\r\n * Creates and returns a label and its bounding box.\r\n *\r\n * @method Text#createText\r\n *\r\n * @param {String} text the text to render on the label\r\n * @param {Object} options\r\n * @param {String} options.align how to align in the bounding box.\r\n *                               Any of { 'center-middle', 'center-top' },\r\n *                               defaults to 'center-top'.\r\n * @param {String} options.style style to be applied to the text\r\n * @param {boolean} options.fitBox indicates if box will be recalculated to\r\n *                                 fit text\r\n *\r\n * @return {Object} { element, dimensions }\r\n */\r\nText.prototype.layoutText = function(text, options) {\r\n  var box = merge({}, this._config.size, options.box || {}),\r\n      style = merge({}, this._config.style, options.style || {}),\r\n      align = parseAlign(options.align || this._config.align),\r\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\r\n      fitBox = options.fitBox || false;\r\n\r\n  var lines = text.split(//r?/n/g),\r\n      layouted = [];\r\n\r\n  var maxWidth = box.width - padding.left - padding.right;\r\n\r\n  // ensure correct rendering by attaching helper text node to invisible SVG\r\n  var helperText = svgCreate('text');\r\n  svgAttr(helperText, { x: 0, y: 0 });\r\n  svgAttr(helperText, style);\r\n\r\n  var helperSvg = getHelperSvg();\r\n\r\n  svgAppend(helperSvg, helperText);\r\n\r\n  while (lines.length) {\r\n    layouted.push(layoutNext(lines, maxWidth, helperText));\r\n  }\r\n\r\n  var totalHeight = reduce(layouted, function(sum, line, idx) {\r\n    return sum + line.height;\r\n  }, 0);\r\n\r\n  var maxLineWidth = reduce(layouted, function(sum, line, idx) {\r\n    return line.width > sum ? line.width : sum;\r\n  }, 0);\r\n\r\n  // the y position of the next line\r\n  var y, x;\r\n\r\n  switch (align.vertical) {\r\n  case 'middle':\r\n    y = (box.height - totalHeight) / 2 - layouted[0].height / 4;\r\n    break;\r\n\r\n  default:\r\n    y = padding.top;\r\n  }\r\n\r\n  var textElement = svgCreate('text');\r\n\r\n  svgAttr(textElement, style);\r\n\r\n  // layout each line taking into account that parent\r\n  // shape might resize to fit text size\r\n  forEach(layouted, function(line) {\r\n    y += line.height;\r\n\r\n    switch (align.horizontal) {\r\n    case 'left':\r\n      x = padding.left;\r\n      break;\r\n\r\n    case 'right':\r\n      x = ((fitBox ? maxLineWidth : maxWidth)\r\n        - padding.right - line.width);\r\n      break;\r\n\r\n    default:\r\n      // aka center\r\n      x = Math.max((((fitBox ? maxLineWidth : maxWidth)\r\n        - line.width) / 2 + padding.left), 0);\r\n    }\r\n\r\n    var tspan = svgCreate('tspan');\r\n    svgAttr(tspan, { x: x, y: y });\r\n\r\n    tspan.textContent = line.text;\r\n\r\n    svgAppend(textElement, tspan);\r\n  });\r\n\r\n  svgRemove(helperText);\r\n\r\n  var dimensions = {\r\n    width: maxLineWidth,\r\n    height: totalHeight\r\n  };\r\n\r\n  return {\r\n    dimensions: dimensions,\r\n    element: textElement\r\n  };\r\n};\r\n\r\nmodule.exports = Text;\r\n","\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar annotate = function() {\n  var args = Array.prototype.slice.call(arguments);\n  \n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n};\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n\nvar FN_ARGS = /^function/s*[^/(]*/(/s*([^/)]*)/)/m;\nvar FN_ARG = ////*([^/*]*)/*///m;\n\nvar parse = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(FN_ARGS);\n  return match[1] && match[1].split(',').map(function(arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n};\n\n\nexports.annotate = annotate;\nexports.parse = parse;\nexports.isArray = isArray;\n","module.exports = {\n  annotate: require(358).annotate,\n  Module: require(361),\n  Injector: require(360)\n};\n","var Module = require(361);\nvar autoAnnotate = require(358).parse;\nvar annotate = require(358).annotate;\nvar isArray = require(358).isArray;\n\n\nvar Injector = function(modules, parent) {\n  parent = parent || {\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while(parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var instantiate = function(Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function(fn, context) {\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function(dep) {\n      return get(dep);\n    });\n\n    // TODO(vojta): optimize without apply\n    return fn.apply(context, dependencies);\n  };\n\n\n  var createPrivateInjectorFactory = function(privateChildInjector) {\n    return annotate(function(key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /*jshint -W083 */\n          forceNewInstances.forEach(function(scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function(scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function(m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function(key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function(key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function(name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;\n","var Module = function() {\n  var providers = [];\n\n  this.factory = function(name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function(name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function(name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function(iterator) {\n    providers.forEach(iterator);\n  };\n};\n\nmodule.exports = Module;\n","\n/**\n * Expose `parse`.\n */\n\nmodule.exports = parse;\n\n/**\n * Tests for browser support.\n */\n\nvar innerHTMLBug = false;\nvar bugTestDiv;\nif (typeof document !== 'undefined') {\n  bugTestDiv = document.createElement('div');\n  // Setup\n  bugTestDiv.innerHTML = '  <link/><table></table><a href=\"/a\">a</a><input type=\"checkbox\"/>';\n  // Make sure that link elements get serialized correctly by innerHTML\n  // This requires a wrapper element in IE\n  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;\n  bugTestDiv = undefined;\n}\n\n/**\n * Wrap map from jquery.\n */\n\nvar map = {\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  // for script/link/style tags to work in IE6-8, you have to wrap\n  // in a div with a non-whitespace character in front, ha!\n  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']\n};\n\nmap.td =\nmap.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option =\nmap.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>'];\n\nmap.polyline =\nmap.ellipse =\nmap.polygon =\nmap.circle =\nmap.text =\nmap.line =\nmap.path =\nmap.rect =\nmap.g = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">','</svg>'];\n\n/**\n * Parse `html` and return a DOM Node instance, which could be a TextNode,\n * HTML DOM Node of some kind (<div> for example), or a DocumentFragment\n * instance, depending on the contents of the `html` string.\n *\n * @param {String} html - HTML string to \"domify\"\n * @param {Document} doc - The `document` instance to create the Node for\n * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance\n * @api private\n */\n\nfunction parse(html, doc) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n\n  // default to the global `document` object\n  if (!doc) doc = document;\n\n  // tag name\n  var m = /<([/w:]+)/.exec(html);\n  if (!m) return doc.createTextNode(html);\n\n  html = html.replace(/^/s+|/s+$/g, ''); // Remove leading/trailing whitespace\n\n  var tag = m[1];\n\n  // body support\n  if (tag == 'body') {\n    var el = doc.createElement('html');\n    el.innerHTML = html;\n    return el.removeChild(el.lastChild);\n  }\n\n  // wrap map\n  var wrap = map[tag] || map._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  var el = doc.createElement('div');\n  el.innerHTML = prefix + html + suffix;\n  while (depth--) el = el.lastChild;\n\n  // one element\n  if (el.firstChild == el.lastChild) {\n    return el.removeChild(el.firstChild);\n  }\n\n  // several elements\n  var fragment = doc.createDocumentFragment();\n  while (el.firstChild) {\n    fragment.appendChild(el.removeChild(el.firstChild));\n  }\n\n  return fragment;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '/n' + message + ' AT /n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^/(]+?[/n$]/gm, '')\n            .replace(/^/s+at/s+/gm, '')\n            .replace(/^Object.<anonymous>/s*/(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(//s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n","var hat = module.exports = function (bits, base) {\n    if (!base) base = 16;\n    if (bits === undefined) bits = 128;\n    if (bits <= 0) return '0';\n    \n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    for (var i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n    \n    var rem = digits - Math.floor(digits);\n    \n    var res = '';\n    \n    for (var i = 0; i < Math.floor(digits); i++) {\n        var x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n    \n    if (rem) {\n        var b = Math.pow(base, rem);\n        var x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n    \n    var parsed = parseInt(res, base);\n    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n        return hat(bits, base)\n    }\n    else return res;\n};\n\nhat.rack = function (bits, base, expandBy) {\n    var fn = function (data) {\n        var iters = 0;\n        do {\n            if (iters ++ > 10) {\n                if (expandBy) bits += expandBy;\n                else throw new Error('too many ID collisions, use more bits')\n            }\n            \n            var id = hat(bits, base);\n        } while (Object.hasOwnProperty.call(hats, id));\n        \n        hats[id] = data;\n        return id;\n    };\n    var hats = fn.hats = {};\n    \n    fn.get = function (id) {\n        return fn.hats[id];\n    };\n    \n    fn.set = function (id, value) {\n        fn.hats[id] = value;\n        return fn;\n    };\n    \n    fn.bits = bits || 128;\n    fn.base = base || 16;\n    return fn;\n};\n","'use strict';\n\nvar hat = require(365);\n\n\n/**\n * Create a new id generator / cache instance.\n *\n * You may optionally provide a seed that is used internally.\n *\n * @param {Seed} seed\n */\nfunction Ids(seed) {\n\n  if (!(this instanceof Ids)) {\n    return new Ids(seed);\n  }\n\n  seed = seed || [ 128, 36, 1 ];\n  this._seed = seed.length ? hat.rack(seed[0], seed[1], seed[2]) : seed;\n}\n\nmodule.exports = Ids;\n\n/**\n * Generate a next id.\n *\n * @param {Object} [element] element to bind the id to\n *\n * @return {String} id\n */\nIds.prototype.next = function(element) {\n  return this._seed(element || true);\n};\n\n/**\n * Generate a next id with a given prefix.\n *\n * @param {Object} [element] element to bind the id to\n *\n * @return {String} id\n */\nIds.prototype.nextPrefixed = function(prefix, element) {\n  var id;\n\n  do {\n    id = prefix + this.next(true);\n  } while (this.assigned(id));\n\n  // claim {prefix}{random}\n  this.claim(id, element);\n\n  // return\n  return id;\n};\n\n/**\n * Manually claim an existing id.\n *\n * @param {String} id\n * @param {String} [element] element the id is claimed by\n */\nIds.prototype.claim = function(id, element) {\n  this._seed.set(id, element || true);\n};\n\n/**\n * Returns true if the given id has already been assigned.\n *\n * @param  {String} id\n * @return {Boolean}\n */\nIds.prototype.assigned = function(id) {\n  return this._seed.get(id) || false;\n};\n\n/**\n * Unclaim an id.\n *\n * @param  {String} id the id to unclaim\n */\nIds.prototype.unclaim = function(id) {\n  delete this._seed.hats[id];\n};\n\n\n/**\n * Clear all claimed ids.\n */\nIds.prototype.clear = function() {\n\n  var hats = this._seed.hats,\n      id;\n\n  for (id in hats) {\n    this.unclaim(id);\n  }\n};","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","var createFindIndex = require(465);\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to search.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(chr) {\n *   return chr.user == 'barney';\n * });\n * // => 0\n *\n * // using the `_.matches` callback shorthand\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.findIndex(users, 'active', false);\n * // => 0\n *\n * // using the `_.property` callback shorthand\n * _.findIndex(users, 'active');\n * // => 2\n */\nvar findIndex = createFindIndex();\n\nmodule.exports = findIndex;\n","var baseFlatten = require(425),\n    isIterateeCall = require(485);\n\n/**\n * Flattens a nested array. If `isDeep` is `true` the array is recursively\n * flattened, otherwise it's only flattened a single level.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to flatten.\n * @param {boolean} [isDeep] Specify a deep flatten.\n * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, 3, [4]]]);\n * // => [1, 2, 3, [4]]\n *\n * // using `isDeep`\n * _.flatten([1, [2, 3, [4]]], true);\n * // => [1, 2, 3, 4]\n */\nfunction flatten(array, isDeep, guard) {\n  var length = array ? array.length : 0;\n  if (guard && isIterateeCall(array, isDeep, guard)) {\n    isDeep = false;\n  }\n  return length ? baseFlatten(array, isDeep) : [];\n}\n\nmodule.exports = flatten;\n","var baseFlatten = require(425);\n\n/**\n * Recursively flattens a nested array.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to recursively flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flattenDeep([1, [2, 3, [4]]]);\n * // => [1, 2, 3, 4]\n */\nfunction flattenDeep(array) {\n  var length = array ? array.length : 0;\n  return length ? baseFlatten(array, true) : [];\n}\n\nmodule.exports = flattenDeep;\n","var baseIndexOf = require(430),\n    cacheIndexOf = require(452),\n    createCache = require(462),\n    isArrayLike = require(483),\n    restParam = require(399);\n\n/**\n * Creates an array of unique values that are included in all of the provided\n * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of shared values.\n * @example\n * _.intersection([1, 2], [4, 2], [2, 1]);\n * // => [2]\n */\nvar intersection = restParam(function(arrays) {\n  var othLength = arrays.length,\n      othIndex = othLength,\n      caches = Array(length),\n      indexOf = baseIndexOf,\n      isCommon = true,\n      result = [];\n\n  while (othIndex--) {\n    var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];\n    caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;\n  }\n  var array = arrays[0],\n      index = -1,\n      length = array ? array.length : 0,\n      seen = caches[0];\n\n  outer:\n  while (++index < length) {\n    value = array[index];\n    if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {\n      var othIndex = othLength;\n      while (--othIndex) {\n        var cache = caches[othIndex];\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {\n          continue outer;\n        }\n      }\n      if (seen) {\n        seen.push(value);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n});\n\nmodule.exports = intersection;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array ? array.length : 0;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var baseFlatten = require(425),\n    baseUniq = require(448),\n    restParam = require(399);\n\n/**\n * Creates an array of unique values, in order, from all of the provided arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([1, 2], [4, 2], [2, 1]);\n * // => [1, 2, 4]\n */\nvar union = restParam(function(arrays) {\n  return baseUniq(baseFlatten(arrays, false, true));\n});\n\nmodule.exports = union;\n","var baseCallback = require(413),\n    baseUniq = require(448),\n    isIterateeCall = require(485),\n    sortedUniq = require(500);\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurence of each element\n * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n * for sorted arrays. If an iteratee function is provided it's invoked for\n * each element in the array to generate the criterion by which uniqueness\n * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n * arguments: (value, index, array).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias unique\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {boolean} [isSorted] Specify the array is sorted.\n * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array} Returns the new duplicate-value-free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n *\n * // using `isSorted`\n * _.uniq([1, 1, 2], true);\n * // => [1, 2]\n *\n * // using an iteratee function\n * _.uniq([1, 2.5, 1.5, 2], function(n) {\n *   return this.floor(n);\n * }, Math);\n * // => [1, 2.5]\n *\n * // using the `_.property` callback shorthand\n * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniq(array, isSorted, iteratee, thisArg) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  if (isSorted != null && typeof isSorted != 'boolean') {\n    thisArg = iteratee;\n    iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n    isSorted = false;\n  }\n  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);\n  return (isSorted)\n    ? sortedUniq(array, iteratee)\n    : baseUniq(array, iteratee);\n}\n\nmodule.exports = uniq;\n","module.exports = require(377);\n","var baseDifference = require(419),\n    isArrayLike = require(483),\n    restParam = require(399);\n\n/**\n * Creates an array excluding all provided values using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to filter.\n * @param {...*} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.without([1, 2, 1, 3], 1, 2);\n * // => [3]\n */\nvar without = restParam(function(array, values) {\n  return isArrayLike(array)\n    ? baseDifference(array, values)\n    : [];\n});\n\nmodule.exports = without;\n","var arrayPush = require(408),\n    baseDifference = require(419),\n    baseUniq = require(448),\n    isArrayLike = require(483);\n\n/**\n * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n * of the provided arrays.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of values.\n * @example\n *\n * _.xor([1, 2], [4, 2]);\n * // => [1, 4]\n */\nfunction xor() {\n  var index = -1,\n      length = arguments.length;\n\n  while (++index < length) {\n    var array = arguments[index];\n    if (isArrayLike(array)) {\n      var result = result\n        ? arrayPush(baseDifference(result, array), baseDifference(array, result))\n        : array;\n    }\n  }\n  return result ? baseUniq(result) : [];\n}\n\nmodule.exports = xor;\n","var LazyWrapper = require(400),\n    LodashWrapper = require(401),\n    baseLodash = require(434),\n    isArray = require(506),\n    isObjectLike = require(489),\n    wrapperClone = require(503);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n * Methods that operate on and return arrays, collections, and functions can\n * be chained together. Methods that retrieve a single value or may return a\n * primitive value will automatically end the chain returning the unwrapped\n * value. Explicit chaining may be enabled using `_.chain`. The execution of\n * chained methods is lazy, that is, execution is deferred until `_#value`\n * is implicitly or explicitly called.\n *\n * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n * fusion is an optimization strategy which merge iteratee calls; this can help\n * to avoid the creation of intermediate data structures and greatly reduce the\n * number of iteratee executions.\n *\n * Chaining is supported in custom builds as long as the `_#value` method is\n * directly or indirectly included in the build.\n *\n * In addition to lodash methods, wrappers have `Array` and `String` methods.\n *\n * The wrapper `Array` methods are:\n * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n * `splice`, and `unshift`\n *\n * The wrapper `String` methods are:\n * `replace` and `split`\n *\n * The wrapper methods that support shortcut fusion are:\n * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n * and `where`\n *\n * The chainable wrapper methods are:\n * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\n * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\n * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\n * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\n * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\n * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\n * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\n * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\n * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\n * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\n * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\n *\n * The wrapper methods that are **not** chainable by default are:\n * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\n * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\n * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\n * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\n * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\n * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\n * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\n * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\n * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\n * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\n * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\n * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\n * `unescape`, `uniqueId`, `value`, and `words`\n *\n * The wrapper method `sample` will return a wrapped value when `n` is provided,\n * otherwise an unwrapped value is returned.\n *\n * @name _\n * @constructor\n * @category Chain\n * @param {*} value The value to wrap in a `lodash` instance.\n * @returns {Object} Returns the new `lodash` wrapper instance.\n * @example\n *\n * var wrapped = _([1, 2, 3]);\n *\n * // returns an unwrapped value\n * wrapped.reduce(function(total, n) {\n *   return total + n;\n * });\n * // => 6\n *\n * // returns a wrapped value\n * var squares = wrapped.map(function(n) {\n *   return n * n;\n * });\n *\n * _.isArray(squares);\n * // => false\n *\n * _.isArray(squares.value());\n * // => true\n */\nfunction lodash(value) {\n  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n    if (value instanceof LodashWrapper) {\n      return value;\n    }\n    if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n      return wrapperClone(value);\n    }\n  }\n  return new LodashWrapper(value);\n}\n\n// Ensure wrappers are instances of `baseLodash`.\nlodash.prototype = baseLodash.prototype;\n\nmodule.exports = lodash;\n","module.exports = require(393);\n","var arrayEvery = require(405),\n    baseCallback = require(413),\n    baseEvery = require(421),\n    isArray = require(506),\n    isIterateeCall = require(485);\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * The predicate is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias all\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'active': false },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.every(users, 'active', false);\n * // => true\n *\n * // using the `_.property` callback shorthand\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n    predicate = undefined;\n  }\n  if (typeof predicate != 'function' || thisArg !== undefined) {\n    predicate = baseCallback(predicate, thisArg, 3);\n  }\n  return func(collection, predicate);\n}\n\nmodule.exports = every;\n","var arrayFilter = require(406),\n    baseCallback = require(413),\n    baseFilter = require(422),\n    isArray = require(506);\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n * invoked with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias select\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Array} Returns the new filtered array.\n * @example\n *\n * _.filter([4, 5, 6], function(n) {\n *   return n % 2 == 0;\n * });\n * // => [4, 6]\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n * // => ['barney']\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.pluck(_.filter(users, 'active', false), 'user');\n * // => ['fred']\n *\n * // using the `_.property` callback shorthand\n * _.pluck(_.filter(users, 'active'), 'user');\n * // => ['barney']\n */\nfunction filter(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  predicate = baseCallback(predicate, thisArg, 3);\n  return func(collection, predicate);\n}\n\nmodule.exports = filter;\n","var baseEach = require(420),\n    createFind = require(464);\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n * invoked with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias detect\n * @category Collection\n * @param {Array|Object|string} collection The collection to search.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.result(_.find(users, function(chr) {\n *   return chr.age < 40;\n * }), 'user');\n * // => 'barney'\n *\n * // using the `_.matches` callback shorthand\n * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n * // => 'pebbles'\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.result(_.find(users, 'active', false), 'user');\n * // => 'fred'\n *\n * // using the `_.property` callback shorthand\n * _.result(_.find(users, 'active'), 'user');\n * // => 'barney'\n */\nvar find = createFind(baseEach);\n\nmodule.exports = find;\n","var arrayEach = require(404),\n    baseEach = require(420),\n    createForEach = require(466);\n\n/**\n * Iterates over elements of `collection` invoking `iteratee` for each element.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection). Iteratee functions may exit iteration early\n * by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n * may be used for object iteration.\n *\n * @static\n * @memberOf _\n * @alias each\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array|Object|string} Returns `collection`.\n * @example\n *\n * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n * // => logs each value from left to right and returns the array\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n */\nvar forEach = createForEach(arrayEach, baseEach);\n\nmodule.exports = forEach;\n","var createAggregator = require(457);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` through `iteratee`. The corresponding value\n * of each key is an array of the elements responsible for generating the key.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([4.2, 6.1, 6.4], function(n) {\n *   return Math.floor(n);\n * });\n * // => { '4': [4.2], '6': [6.1, 6.4] }\n *\n * _.groupBy([4.2, 6.1, 6.4], function(n) {\n *   return this.floor(n);\n * }, Math);\n * // => { '4': [4.2], '6': [6.1, 6.4] }\n *\n * // using the `_.property` callback shorthand\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    result[key] = [value];\n  }\n});\n\nmodule.exports = groupBy;\n","var createAggregator = require(457);\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` through `iteratee`. The corresponding value\n * of each key is the last element responsible for generating the key. The\n * iteratee function is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * var keyData = [\n *   { 'dir': 'left', 'code': 97 },\n *   { 'dir': 'right', 'code': 100 }\n * ];\n *\n * _.indexBy(keyData, 'dir');\n * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n *\n * _.indexBy(keyData, function(object) {\n *   return String.fromCharCode(object.code);\n * });\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n *\n * _.indexBy(keyData, function(object) {\n *   return this.fromCharCode(object.code);\n * }, String);\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n */\nvar indexBy = createAggregator(function(result, value, key) {\n  result[key] = value;\n});\n\nmodule.exports = indexBy;\n","var arrayMap = require(407),\n    baseCallback = require(413),\n    baseMap = require(435),\n    isArray = require(506);\n\n/**\n * Creates an array of values by running each element in `collection` through\n * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n * arguments: (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\n * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\n * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\n * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\n * `sum`, `uniq`, and `words`\n *\n * @static\n * @memberOf _\n * @alias collect\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function timesThree(n) {\n *   return n * 3;\n * }\n *\n * _.map([1, 2], timesThree);\n * // => [3, 6]\n *\n * _.map({ 'a': 1, 'b': 2 }, timesThree);\n * // => [3, 6] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // using the `_.property` callback shorthand\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee, thisArg) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  iteratee = baseCallback(iteratee, thisArg, 3);\n  return func(collection, iteratee);\n}\n\nmodule.exports = map;\n","var arrayReduce = require(409),\n    baseEach = require(420),\n    createReduce = require(469);\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` through `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not provided the first element of `collection` is used as the initial\n * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\n * and `sortByOrder`\n *\n * @static\n * @memberOf _\n * @alias foldl, inject\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.reduce([1, 2], function(total, n) {\n *   return total + n;\n * });\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n *   result[key] = n * 3;\n *   return result;\n * }, {});\n * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n */\nvar reduce = createReduce(arrayReduce, baseEach);\n\nmodule.exports = reduce;\n","var arrayFilter = require(406),\n    baseCallback = require(413),\n    baseFilter = require(422),\n    isArray = require(506);\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Array} Returns the new filtered array.\n * @example\n *\n * _.reject([1, 2, 3, 4], function(n) {\n *   return n % 2 == 0;\n * });\n * // => [1, 3]\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n * // => ['barney']\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.pluck(_.reject(users, 'active', false), 'user');\n * // => ['fred']\n *\n * // using the `_.property` callback shorthand\n * _.pluck(_.reject(users, 'active'), 'user');\n * // => ['barney']\n */\nfunction reject(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  predicate = baseCallback(predicate, thisArg, 3);\n  return func(collection, function(value, index, collection) {\n    return !predicate(value, index, collection);\n  });\n}\n\nmodule.exports = reject;\n","var getLength = require(476),\n    isLength = require(488),\n    keys = require(519);\n\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable properties for objects.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the size of `collection`.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */\nfunction size(collection) {\n  var length = collection ? getLength(collection) : 0;\n  return isLength(length) ? length : keys(collection).length;\n}\n\nmodule.exports = size;\n","var arraySome = require(410),\n    baseCallback = require(413),\n    baseSome = require(445),\n    isArray = require(506),\n    isIterateeCall = require(485);\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * The function returns as soon as it finds a passing value and does not iterate\n * over the entire collection. The predicate is bound to `thisArg` and invoked\n * with three arguments: (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias any\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.some(users, 'active', false);\n * // => true\n *\n * // using the `_.property` callback shorthand\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n    predicate = undefined;\n  }\n  if (typeof predicate != 'function' || thisArg !== undefined) {\n    predicate = baseCallback(predicate, thisArg, 3);\n  }\n  return func(collection, predicate);\n}\n\nmodule.exports = some;\n","var baseCallback = require(413),\n    baseMap = require(435),\n    baseSortBy = require(446),\n    compareAscending = require(454),\n    isIterateeCall = require(485);\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection through `iteratee`. This method performs\n * a stable sort, that is, it preserves the original sort order of equal elements.\n * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `iteratee` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `iteratee` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * _.sortBy([1, 2, 3], function(n) {\n *   return Math.sin(n);\n * });\n * // => [3, 1, 2]\n *\n * _.sortBy([1, 2, 3], function(n) {\n *   return this.sin(n);\n * }, Math);\n * // => [3, 1, 2]\n *\n * var users = [\n *   { 'user': 'fred' },\n *   { 'user': 'pebbles' },\n *   { 'user': 'barney' }\n * ];\n *\n * // using the `_.property` callback shorthand\n * _.pluck(_.sortBy(users, 'user'), 'user');\n * // => ['barney', 'fred', 'pebbles']\n */\nfunction sortBy(collection, iteratee, thisArg) {\n  if (collection == null) {\n    return [];\n  }\n  if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n    iteratee = undefined;\n  }\n  var index = -1;\n  iteratee = baseCallback(iteratee, thisArg, 3);\n\n  var result = baseMap(collection, function(value, key, collection) {\n    return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\n  });\n  return baseSortBy(result, compareAscending);\n}\n\nmodule.exports = sortBy;\n","var getNative = require(478);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeNow = getNative(Date, 'now');\n\n/**\n * Gets the number of milliseconds that have elapsed since the Unix epoch\n * (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @category Date\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => logs the number of milliseconds it took for the deferred function to be invoked\n */\nvar now = nativeNow || function() {\n  return new Date().getTime();\n};\n\nmodule.exports = now;\n","var createWrapper = require(470),\n    replaceHolders = require(497),\n    restParam = require(399);\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    PARTIAL_FLAG = 32;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg`\n * and prepends any additional `_.bind` arguments to those provided to the\n * bound function.\n *\n * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n * may be used as a placeholder for partially applied arguments.\n *\n * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\n * property of bound functions.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {...*} [partials] The arguments to be partially applied.\n * @returns {Function} Returns the new bound function.\n * @example\n *\n * var greet = function(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * };\n *\n * var object = { 'user': 'fred' };\n *\n * var bound = _.bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * // using placeholders\n * var bound = _.bind(greet, object, _, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nvar bind = restParam(function(func, thisArg, partials) {\n  var bitmask = BIND_FLAG;\n  if (partials.length) {\n    var holders = replaceHolders(partials, bind.placeholder);\n    bitmask |= PARTIAL_FLAG;\n  }\n  return createWrapper(func, bitmask, thisArg, partials, holders);\n});\n\n// Assign default placeholders.\nbind.placeholder = {};\n\nmodule.exports = bind;\n","var isObject = require(511),\n    now = require(395);\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed invocations. Provide an options object to indicate that `func`\n * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n * on the trailing edge of the timeout only if the the debounced function is\n * invoked more than once during the `wait` timeout.\n *\n * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.leading=false] Specify invoking on the leading\n *  edge of the timeout.\n * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n *  delayed before it's invoked.\n * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n *  edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // avoid costly calculations while the window size is in flux\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // ensure `batchLog` is invoked once after 1 second of debounced calls\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', _.debounce(batchLog, 250, {\n *   'maxWait': 1000\n * }));\n *\n * // cancel a debounced call\n * var todoChanges = _.debounce(batchLog, 1000);\n * Object.observe(models.todo, todoChanges);\n *\n * Object.observe(models, function(changes) {\n *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n *     todoChanges.cancel();\n *   }\n * }, ['delete']);\n *\n * // ...at some point `models.todo` is changed\n * models.todo.completed = true;\n *\n * // ...before 1 second has passed `models.todo` is deleted\n * // which cancels the debounced `todoChanges` call\n * delete models.todo;\n */\nfunction debounce(func, wait, options) {\n  var args,\n      maxTimeoutId,\n      result,\n      stamp,\n      thisArg,\n      timeoutId,\n      trailingCall,\n      lastCalled = 0,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = wait < 0 ? 0 : (+wait || 0);\n  if (options === true) {\n    var leading = true;\n    trailing = false;\n  } else if (isObject(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    if (maxTimeoutId) {\n      clearTimeout(maxTimeoutId);\n    }\n    lastCalled = 0;\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n  }\n\n  function complete(isCalled, id) {\n    if (id) {\n      clearTimeout(id);\n    }\n    maxTimeoutId = timeoutId = trailingCall = undefined;\n    if (isCalled) {\n      lastCalled = now();\n      result = func.apply(thisArg, args);\n      if (!timeoutId && !maxTimeoutId) {\n        args = thisArg = undefined;\n      }\n    }\n  }\n\n  function delayed() {\n    var remaining = wait - (now() - stamp);\n    if (remaining <= 0 || remaining > wait) {\n      complete(trailingCall, maxTimeoutId);\n    } else {\n      timeoutId = setTimeout(delayed, remaining);\n    }\n  }\n\n  function maxDelayed() {\n    complete(trailing, timeoutId);\n  }\n\n  function debounced() {\n    args = arguments;\n    stamp = now();\n    thisArg = this;\n    trailingCall = trailing && (timeoutId || !leading);\n\n    if (maxWait === false) {\n      var leadingCall = leading && !timeoutId;\n    } else {\n      if (!maxTimeoutId && !leading) {\n        lastCalled = stamp;\n      }\n      var remaining = maxWait - (stamp - lastCalled),\n          isCalled = remaining <= 0 || remaining > maxWait;\n\n      if (isCalled) {\n        if (maxTimeoutId) {\n          maxTimeoutId = clearTimeout(maxTimeoutId);\n        }\n        lastCalled = stamp;\n        result = func.apply(thisArg, args);\n      }\n      else if (!maxTimeoutId) {\n        maxTimeoutId = setTimeout(maxDelayed, remaining);\n      }\n    }\n    if (isCalled && timeoutId) {\n      timeoutId = clearTimeout(timeoutId);\n    }\n    else if (!timeoutId && wait !== maxWait) {\n      timeoutId = setTimeout(delayed, wait);\n    }\n    if (leadingCall) {\n      isCalled = true;\n      result = func.apply(thisArg, args);\n    }\n    if (isCalled && !timeoutId && !maxTimeoutId) {\n      args = thisArg = undefined;\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var baseDelay = require(418),\n    restParam = require(399);\n\n/**\n * Defers invoking the `func` until the current call stack has cleared. Any\n * additional arguments are provided to `func` when it's invoked.\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to defer.\n * @param {...*} [args] The arguments to invoke the function with.\n * @returns {number} Returns the timer id.\n * @example\n *\n * _.defer(function(text) {\n *   console.log(text);\n * }, 'deferred');\n * // logs 'deferred' after one or more milliseconds\n */\nvar defer = restParam(function(func, args) {\n  return baseDelay(func, 1, args);\n});\n\nmodule.exports = defer;\n","/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of the\n * created function and arguments from `start` and beyond provided as an array.\n *\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var say = _.restParam(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n *\n * say('hello', 'fred', 'barney', 'pebbles');\n * // => 'hello fred, barney, & pebbles'\n */\nfunction restParam(func, start) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        rest = Array(length);\n\n    while (++index < length) {\n      rest[index] = args[start + index];\n    }\n    switch (start) {\n      case 0: return func.call(this, rest);\n      case 1: return func.call(this, args[0], rest);\n      case 2: return func.call(this, args[0], args[1], rest);\n    }\n    var otherArgs = Array(start + 1);\n    index = -1;\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = rest;\n    return func.apply(this, otherArgs);\n  };\n}\n\nmodule.exports = restParam;\n","var baseCreate = require(417),\n    baseLodash = require(434);\n\n/** Used as references for `-Infinity` and `Infinity`. */\nvar POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\n/**\n * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n *\n * @private\n * @param {*} value The value to wrap.\n */\nfunction LazyWrapper(value) {\n  this.__wrapped__ = value;\n  this.__actions__ = [];\n  this.__dir__ = 1;\n  this.__filtered__ = false;\n  this.__iteratees__ = [];\n  this.__takeCount__ = POSITIVE_INFINITY;\n  this.__views__ = [];\n}\n\nLazyWrapper.prototype = baseCreate(baseLodash.prototype);\nLazyWrapper.prototype.constructor = LazyWrapper;\n\nmodule.exports = LazyWrapper;\n","var baseCreate = require(417),\n    baseLodash = require(434);\n\n/**\n * The base constructor for creating `lodash` wrapper objects.\n *\n * @private\n * @param {*} value The value to wrap.\n * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n */\nfunction LodashWrapper(value, chainAll, actions) {\n  this.__wrapped__ = value;\n  this.__actions__ = actions || [];\n  this.__chain__ = !!chainAll;\n}\n\nLodashWrapper.prototype = baseCreate(baseLodash.prototype);\nLodashWrapper.prototype.constructor = LodashWrapper;\n\nmodule.exports = LodashWrapper;\n","var cachePush = require('./cachePush'),\n    getNative = require('./getNative');\n\n/** Native method references. */\nvar Set = getNative(global, 'Set');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeCreate = getNative(Object, 'create');\n\n/**\n *\n * Creates a cache object to store unique values.\n *\n * @private\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var length = values ? values.length : 0;\n\n  this.data = { 'hash': nativeCreate(null), 'set': new Set };\n  while (length--) {\n    this.push(values[length]);\n  }\n}\n\n// Add functions to the `Set` cache.\nSetCache.prototype.push = cachePush;\n\nmodule.exports = SetCache;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction arrayCopy(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayCopy;\n","/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.every` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n","/**\n * A specialized version of `_.filter` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array.length,\n      resIndex = -1,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[++resIndex] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * A specialized version of `_.map` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.reduce` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initFromArray] Specify using the first element of `array`\n *  as the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initFromArray) {\n  var index = -1,\n      length = array.length;\n\n  if (initFromArray && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var keys = require(519);\n\n/**\n * A specialized version of `_.assign` for customizing assigned values without\n * support for argument juggling, multiple sources, and `this` binding `customizer`\n * functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n */\nfunction assignWith(object, source, customizer) {\n  var index = -1,\n      props = keys(source),\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? (result !== value) : (value === value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\nmodule.exports = assignWith;\n","var baseCopy = require(416),\n    keys = require(519);\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var baseMatches = require(436),\n    baseMatchesProperty = require(437),\n    bindCallback = require(450),\n    identity = require(527),\n    property = require(529);\n\n/**\n * The base implementation of `_.callback` which supports specifying the\n * number of arguments to provide to `func`.\n *\n * @private\n * @param {*} [func=_.identity] The value to convert to a callback.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction baseCallback(func, thisArg, argCount) {\n  var type = typeof func;\n  if (type == 'function') {\n    return thisArg === undefined\n      ? func\n      : bindCallback(func, thisArg, argCount);\n  }\n  if (func == null) {\n    return identity;\n  }\n  if (type == 'object') {\n    return baseMatches(func);\n  }\n  return thisArg === undefined\n    ? property(func)\n    : baseMatchesProperty(func, thisArg);\n}\n\nmodule.exports = baseCallback;\n","var arrayCopy = require(403),\n    arrayEach = require(404),\n    baseAssign = require(412),\n    baseForOwn = require(428),\n    initCloneArray = require(480),\n    initCloneByTag = require(481),\n    initCloneObject = require(482),\n    isArray = require(506),\n    isObject = require(511);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\ncloneableTags[dateTag] = cloneableTags[float32Tag] =\ncloneableTags[float64Tag] = cloneableTags[int8Tag] =\ncloneableTags[int16Tag] = cloneableTags[int32Tag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[stringTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[mapTag] = cloneableTags[setTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * The base implementation of `_.clone` without support for argument juggling\n * and `this` binding `customizer` functions.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {Function} [customizer] The function to customize cloning values.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The object `value` belongs to.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates clones with source counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return arrayCopy(value, result);\n    }\n  } else {\n    var tag = objToString.call(value),\n        isFunc = tag == funcTag;\n\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return baseAssign(result, value);\n      }\n    } else {\n      return cloneableTags[tag]\n        ? initCloneByTag(value, tag, isDeep)\n        : (object ? value : {});\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == value) {\n      return stackB[length];\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate it with its clone.\n  stackA.push(value);\n  stackB.push(result);\n\n  // Recursively populate clone (susceptible to call stack limits).\n  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","/**\n * The base implementation of `compareAscending` which compares values and\n * sorts them in ascending order without guaranteeing a stable sort.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction baseCompareAscending(value, other) {\n  if (value !== other) {\n    var valIsNull = value === null,\n        valIsUndef = value === undefined,\n        valIsReflexive = value === value;\n\n    var othIsNull = other === null,\n        othIsUndef = other === undefined,\n        othIsReflexive = other === other;\n\n    if ((value > other && !othIsNull) || !valIsReflexive ||\n        (valIsNull && !othIsUndef && othIsReflexive) ||\n        (valIsUndef && othIsReflexive)) {\n      return 1;\n    }\n    if ((value < other && !valIsNull) || !othIsReflexive ||\n        (othIsNull && !valIsUndef && valIsReflexive) ||\n        (othIsUndef && valIsReflexive)) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = baseCompareAscending;\n","/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n","var isObject = require(511);\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(prototype) {\n    if (isObject(prototype)) {\n      object.prototype = prototype;\n      var result = new object;\n      object.prototype = undefined;\n    }\n    return result || {};\n  };\n}());\n\nmodule.exports = baseCreate;\n","/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * The base implementation of `_.delay` and `_.defer` which accepts an index\n * of where to slice the arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to delay.\n * @param {number} wait The number of milliseconds to delay invocation.\n * @param {Object} args The arguments provide to `func`.\n * @returns {number} Returns the timer id.\n */\nfunction baseDelay(func, wait, args) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return setTimeout(function() { func.apply(undefined, args); }, wait);\n}\n\nmodule.exports = baseDelay;\n","var baseIndexOf = require(430),\n    cacheIndexOf = require(452),\n    createCache = require(462);\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.difference` which accepts a single array\n * of values to exclude.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values) {\n  var length = array ? array.length : 0,\n      result = [];\n\n  if (!length) {\n    return result;\n  }\n  var index = -1,\n      indexOf = baseIndexOf,\n      isCommon = true,\n      cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\n      valuesLength = values.length;\n\n  if (cache) {\n    indexOf = cacheIndexOf;\n    isCommon = false;\n    values = cache;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index];\n\n    if (isCommon && value === value) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === value) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (indexOf(values, value, 0) < 0) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseDifference;\n","var baseForOwn = require(428),\n    createBaseEach = require(459);\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var baseEach = require(420);\n\n/**\n * The base implementation of `_.every` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n","var baseEach = require(420);\n\n/**\n * The base implementation of `_.filter` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","/**\n * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n * without support for callback shorthands and `this` binding, which iterates\n * over `collection` using the provided `eachFunc`.\n *\n * @private\n * @param {Array|Object|string} collection The collection to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @param {boolean} [retKey] Specify returning the key of the found element\n *  instead of the element itself.\n * @returns {*} Returns the found element or its key, else `undefined`.\n */\nfunction baseFind(collection, predicate, eachFunc, retKey) {\n  var result;\n  eachFunc(collection, function(value, key, collection) {\n    if (predicate(value, key, collection)) {\n      result = retKey ? key : value;\n      return false;\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFind;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for callback shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {Function} predicate The function invoked per iteration.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromRight) {\n  var length = array.length,\n      index = fromRight ? length : -1;\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var arrayPush = require(408),\n    isArguments = require(505),\n    isArray = require(506),\n    isArrayLike = require(483),\n    isObjectLike = require(489);\n\n/**\n * The base implementation of `_.flatten` with added support for restricting\n * flattening and specifying the start index.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {boolean} [isDeep] Specify a deep flatten.\n * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, isDeep, isStrict, result) {\n  result || (result = []);\n\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    if (isObjectLike(value) && isArrayLike(value) &&\n        (isStrict || isArray(value) || isArguments(value))) {\n      if (isDeep) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, isDeep, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var createBaseFor = require(460);\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require(426),\n    keysIn = require(520);\n\n/**\n * The base implementation of `_.forIn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForIn(object, iteratee) {\n  return baseFor(object, iteratee, keysIn);\n}\n\nmodule.exports = baseForIn;\n","var baseFor = require(426),\n    keys = require(519);\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var toObject = require(501);\n\n/**\n * The base implementation of `get` without support for string paths\n * and default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path of the property to get.\n * @param {string} [pathKey] The key representation of path.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path, pathKey) {\n  if (object == null) {\n    return;\n  }\n  if (pathKey !== undefined && pathKey in toObject(object)) {\n    path = [pathKey];\n  }\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[path[index++]];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var indexOfNaN = require(479);\n\n/**\n * The base implementation of `_.indexOf` without support for binary searches.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return indexOfNaN(array, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseIndexOf;\n","var baseIsEqualDeep = require(432),\n    isObject = require(511),\n    isObjectLike = require(489);\n\n/**\n * The base implementation of `_.isEqual` without support for `this` binding\n * `customizer` functions.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n}\n\nmodule.exports = baseIsEqual;\n","var equalArrays = require(471),\n    equalByTag = require(472),\n    equalObjects = require(473),\n    isArray = require(506),\n    isTypedArray = require(514);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag == argsTag) {\n      objTag = objectTag;\n    } else if (objTag != objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag == argsTag) {\n      othTag = objectTag;\n    } else if (othTag != objectTag) {\n      othIsArr = isTypedArray(other);\n    }\n  }\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  if (!isLoose) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  // For more information on detecting circular references see https://es5.github.io/#JO.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == object) {\n      return stackB[length] == other;\n    }\n  }\n  // Add `object` and `other` to the stack of traversed objects.\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nmodule.exports = baseIsEqualDeep;\n","var baseIsEqual = require(431),\n    toObject = require(501);\n\n/**\n * The base implementation of `_.isMatch` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Array} matchData The propery names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = toObject(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","/**\n * The function whose prototype all chaining wrappers inherit from.\n *\n * @private\n */\nfunction baseLodash() {\n  // No operation performed.\n}\n\nmodule.exports = baseLodash;\n","var baseEach = require(420),\n    isArrayLike = require(483);\n\n/**\n * The base implementation of `_.map` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseIsMatch = require(433),\n    getMatchData = require(477),\n    toObject = require(501);\n\n/**\n * The base implementation of `_.matches` which does not clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    var key = matchData[0][0],\n        value = matchData[0][1];\n\n    return function(object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === value && (value !== undefined || (key in toObject(object)));\n    };\n  }\n  return function(object) {\n    return baseIsMatch(object, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseGet = require(429),\n    baseIsEqual = require(431),\n    baseSlice = require(444),\n    isArray = require(506),\n    isKey = require(486),\n    isStrictComparable = require(490),\n    last = require(375),\n    toObject = require(501),\n    toPath = require(502);\n\n/**\n * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to compare.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  var isArr = isArray(path),\n      isCommon = isKey(path) && isStrictComparable(srcValue),\n      pathKey = (path + '');\n\n  path = toPath(path);\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    var key = pathKey;\n    object = toObject(object);\n    if ((isArr || !isCommon) && !(key in object)) {\n      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n      if (object == null) {\n        return false;\n      }\n      key = last(path);\n      object = toObject(object);\n    }\n    return object[key] === srcValue\n      ? (srcValue !== undefined || (key in object))\n      : baseIsEqual(srcValue, object[key], undefined, true);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var arrayEach = require(404),\n    baseMergeDeep = require(439),\n    isArray = require(506),\n    isArrayLike = require(483),\n    isObject = require(511),\n    isObjectLike = require(489),\n    isTypedArray = require(514),\n    keys = require(519);\n\n/**\n * The base implementation of `_.merge` without support for argument juggling,\n * multiple sources, and `this` binding `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {Object} Returns `object`.\n */\nfunction baseMerge(object, source, customizer, stackA, stackB) {\n  if (!isObject(object)) {\n    return object;\n  }\n  var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n      props = isSrcArr ? undefined : keys(source);\n\n  arrayEach(props || source, function(srcValue, key) {\n    if (props) {\n      key = srcValue;\n      srcValue = source[key];\n    }\n    if (isObjectLike(srcValue)) {\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n      baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n    }\n    else {\n      var value = object[key],\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n          isCommon = result === undefined;\n\n      if (isCommon) {\n        result = srcValue;\n      }\n      if ((result !== undefined || (isSrcArr && !(key in object))) &&\n          (isCommon || (result === result ? (result !== value) : (value === value)))) {\n        object[key] = result;\n      }\n    }\n  });\n  return object;\n}\n\nmodule.exports = baseMerge;\n","var arrayCopy = require(403),\n    isArguments = require(505),\n    isArray = require(506),\n    isArrayLike = require(483),\n    isPlainObject = require(512),\n    isTypedArray = require(514),\n    toPlainObject = require(515);\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates values with source counterparts.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n  var length = stackA.length,\n      srcValue = source[key];\n\n  while (length--) {\n    if (stackA[length] == srcValue) {\n      object[key] = stackB[length];\n      return;\n    }\n  }\n  var value = object[key],\n      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n      isCommon = result === undefined;\n\n  if (isCommon) {\n    result = srcValue;\n    if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n      result = isArray(value)\n        ? value\n        : (isArrayLike(value) ? arrayCopy(value) : []);\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      result = isArguments(value)\n        ? toPlainObject(value)\n        : (isPlainObject(value) ? value : {});\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate\n  // it with its merged value.\n  stackA.push(srcValue);\n  stackB.push(result);\n\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n  } else if (result === result ? (result !== value) : (value === value)) {\n    object[key] = result;\n  }\n}\n\nmodule.exports = baseMergeDeep;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require(429),\n    toPath = require(502);\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction basePropertyDeep(path) {\n  var pathKey = (path + '');\n  path = toPath(path);\n  return function(object) {\n    return baseGet(object, path, pathKey);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.reduce` and `_.reduceRight` without support\n * for callback shorthands and `this` binding, which iterates over `collection`\n * using the provided `eachFunc`.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initFromCollection Specify using the first or last element\n *  of `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initFromCollection\n      ? (initFromCollection = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n","var identity = require(527),\n    metaMap = require(492);\n\n/**\n * The base implementation of `setData` without support for hot loop detection.\n *\n * @private\n * @param {Function} func The function to associate metadata with.\n * @param {*} data The metadata.\n * @returns {Function} Returns `func`.\n */\nvar baseSetData = !metaMap ? identity : function(func, data) {\n  metaMap.set(func, data);\n  return func;\n};\n\nmodule.exports = baseSetData;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  start = start == null ? 0 : (+start || 0);\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = (end === undefined || end > length) ? length : (+end || 0);\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var baseEach = require(420);\n\n/**\n * The base implementation of `_.some` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nmodule.exports = baseSome;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define\n * the sort order of `array` and replaces criteria objects with their\n * corresponding values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","/**\n * Converts `value` to a string if it's not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n","var baseIndexOf = require(430),\n    cacheIndexOf = require(452),\n    createCache = require(462);\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniq` without support for callback shorthands\n * and `this` binding.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The function invoked per iteration.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee) {\n  var index = -1,\n      indexOf = baseIndexOf,\n      length = array.length,\n      isCommon = true,\n      isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n      seen = isLarge ? createCache() : null,\n      result = [];\n\n  if (seen) {\n    indexOf = cacheIndexOf;\n    isCommon = false;\n  } else {\n    isLarge = false;\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value, index, array) : value;\n\n    if (isCommon && value === value) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (indexOf(seen, computed, 0) < 0) {\n      if (iteratee || isLarge) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  var index = -1,\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = object[props[index]];\n  }\n  return result;\n}\n\nmodule.exports = baseValues;\n","var identity = require(527);\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n","/** Native method references. */\nvar ArrayBuffer = global.ArrayBuffer,\n    Uint8Array = global.Uint8Array;\n\n/**\n * Creates a clone of the given array buffer.\n *\n * @private\n * @param {ArrayBuffer} buffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction bufferClone(buffer) {\n  var result = new ArrayBuffer(buffer.byteLength),\n      view = new Uint8Array(result);\n\n  view.set(new Uint8Array(buffer));\n  return result;\n}\n\nmodule.exports = bufferClone;\n","var isObject = require(511);\n\n/**\n * Checks if `value` is in `cache` mimicking the return signature of\n * `_.indexOf` by returning `0` if the value is found, else `-1`.\n *\n * @private\n * @param {Object} cache The cache to search.\n * @param {*} value The value to search for.\n * @returns {number} Returns `0` if `value` is found, else `-1`.\n */\nfunction cacheIndexOf(cache, value) {\n  var data = cache.data,\n      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\n  return result ? 0 : -1;\n}\n\nmodule.exports = cacheIndexOf;\n","var isObject = require(511);\n\n/**\n * Adds `value` to the cache.\n *\n * @private\n * @name push\n * @memberOf SetCache\n * @param {*} value The value to cache.\n */\nfunction cachePush(value) {\n  var data = this.data;\n  if (typeof value == 'string' || isObject(value)) {\n    data.set.add(value);\n  } else {\n    data.hash[value] = true;\n  }\n}\n\nmodule.exports = cachePush;\n","var baseCompareAscending = require(415);\n\n/**\n * Used by `_.sortBy` to compare transformed elements of a collection and stable\n * sort them in ascending order.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareAscending(object, other) {\n  return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n}\n\nmodule.exports = compareAscending;\n","/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array|Object} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders) {\n  var holdersLength = holders.length,\n      argsIndex = -1,\n      argsLength = nativeMax(args.length - holdersLength, 0),\n      leftIndex = -1,\n      leftLength = partials.length,\n      result = Array(leftLength + argsLength);\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    result[holders[argsIndex]] = args[argsIndex];\n  }\n  while (argsLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgs;\n","/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This function is like `composeArgs` except that the arguments composition\n * is tailored for `_.partialRight`.\n *\n * @private\n * @param {Array|Object} args The provided arguments.\n * @param {Array} partials The arguments to append to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgsRight(args, partials, holders) {\n  var holdersIndex = -1,\n      holdersLength = holders.length,\n      argsIndex = -1,\n      argsLength = nativeMax(args.length - holdersLength, 0),\n      rightIndex = -1,\n      rightLength = partials.length,\n      result = Array(argsLength + rightLength);\n\n  while (++argsIndex < argsLength) {\n    result[argsIndex] = args[argsIndex];\n  }\n  var offset = argsIndex;\n  while (++rightIndex < rightLength) {\n    result[offset + rightIndex] = partials[rightIndex];\n  }\n  while (++holdersIndex < holdersLength) {\n    result[offset + holders[holdersIndex]] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgsRight;\n","var baseCallback = require(413),\n    baseEach = require(420),\n    isArray = require(506);\n\n/**\n * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\n *\n * @private\n * @param {Function} setter The function to set keys and values of the accumulator object.\n * @param {Function} [initializer] The function to initialize the accumulator object.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee, thisArg) {\n    var result = initializer ? initializer() : {};\n    iteratee = baseCallback(iteratee, thisArg, 3);\n\n    if (isArray(collection)) {\n      var index = -1,\n          length = collection.length;\n\n      while (++index < length) {\n        var value = collection[index];\n        setter(result, value, iteratee(value, index, collection), collection);\n      }\n    } else {\n      baseEach(collection, function(value, key, collection) {\n        setter(result, value, iteratee(value, key, collection), collection);\n      });\n    }\n    return result;\n  };\n}\n\nmodule.exports = createAggregator;\n","var bindCallback = require(450),\n    isIterateeCall = require(485),\n    restParam = require(399);\n\n/**\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return restParam(function(object, sources) {\n    var index = -1,\n        length = object == null ? 0 : sources.length,\n        customizer = length > 2 ? sources[length - 2] : undefined,\n        guard = length > 2 ? sources[2] : undefined,\n        thisArg = length > 1 ? sources[length - 1] : undefined;\n\n    if (typeof customizer == 'function') {\n      customizer = bindCallback(customizer, thisArg, 5);\n      length -= 2;\n    } else {\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\n      length -= (customizer ? 1 : 0);\n    }\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var getLength = require(476),\n    isLength = require(488),\n    toObject = require(501);\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var toObject = require(501);\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createCtorWrapper = require('./createCtorWrapper');\n\n/**\n * Creates a function that wraps `func` and invokes it with the `this`\n * binding of `thisArg`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @returns {Function} Returns the new bound function.\n */\nfunction createBindWrapper(func, thisArg) {\n  var Ctor = createCtorWrapper(func);\n\n  function wrapper() {\n    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;\n    return fn.apply(thisArg, arguments);\n  }\n  return wrapper;\n}\n\nmodule.exports = createBindWrapper;\n","var SetCache = require('./SetCache'),\n    getNative = require('./getNative');\n\n/** Native method references. */\nvar Set = getNative(global, 'Set');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a `Set` cache object to optimize linear searches of large arrays.\n *\n * @private\n * @param {Array} [values] The values to cache.\n * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n */\nfunction createCache(values) {\n  return (nativeCreate && Set) ? new SetCache(values) : null;\n}\n\nmodule.exports = createCache;\n","var baseCreate = require(417),\n    isObject = require(511);\n\n/**\n * Creates a function that produces an instance of `Ctor` regardless of\n * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n *\n * @private\n * @param {Function} Ctor The constructor to wrap.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createCtorWrapper(Ctor) {\n  return function() {\n    // Use a `switch` statement to work with class constructors.\n    // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n    // for more details.\n    var args = arguments;\n    switch (args.length) {\n      case 0: return new Ctor;\n      case 1: return new Ctor(args[0]);\n      case 2: return new Ctor(args[0], args[1]);\n      case 3: return new Ctor(args[0], args[1], args[2]);\n      case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n    }\n    var thisBinding = baseCreate(Ctor.prototype),\n        result = Ctor.apply(thisBinding, args);\n\n    // Mimic the constructor's `return` behavior.\n    // See https://es5.github.io/#x13.2.2 for more details.\n    return isObject(result) ? result : thisBinding;\n  };\n}\n\nmodule.exports = createCtorWrapper;\n","var baseCallback = require(413),\n    baseFind = require(423),\n    baseFindIndex = require(424),\n    isArray = require(506);\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(eachFunc, fromRight) {\n  return function(collection, predicate, thisArg) {\n    predicate = baseCallback(predicate, thisArg, 3);\n    if (isArray(collection)) {\n      var index = baseFindIndex(collection, predicate, fromRight);\n      return index > -1 ? collection[index] : undefined;\n    }\n    return baseFind(collection, predicate, eachFunc);\n  };\n}\n\nmodule.exports = createFind;\n","var baseCallback = require(413),\n    baseFindIndex = require(424);\n\n/**\n * Creates a `_.findIndex` or `_.findLastIndex` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new find function.\n */\nfunction createFindIndex(fromRight) {\n  return function(array, predicate, thisArg) {\n    if (!(array && array.length)) {\n      return -1;\n    }\n    predicate = baseCallback(predicate, thisArg, 3);\n    return baseFindIndex(array, predicate, fromRight);\n  };\n}\n\nmodule.exports = createFindIndex;\n","var bindCallback = require(450),\n    isArray = require(506);\n\n/**\n * Creates a function for `_.forEach` or `_.forEachRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createForEach(arrayFunc, eachFunc) {\n  return function(collection, iteratee, thisArg) {\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee)\n      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n  };\n}\n\nmodule.exports = createForEach;\n","var arrayCopy = require('./arrayCopy'),\n    composeArgs = require('./composeArgs'),\n    composeArgsRight = require('./composeArgsRight'),\n    createCtorWrapper = require('./createCtorWrapper'),\n    isLaziable = require('./isLaziable'),\n    reorder = require('./reorder'),\n    replaceHolders = require('./replaceHolders'),\n    setData = require('./setData');\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    BIND_KEY_FLAG = 2,\n    CURRY_BOUND_FLAG = 4,\n    CURRY_FLAG = 8,\n    CURRY_RIGHT_FLAG = 16,\n    PARTIAL_FLAG = 32,\n    PARTIAL_RIGHT_FLAG = 64,\n    ARY_FLAG = 128;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that wraps `func` and invokes it with optional `this`\n * binding of, partial application, and currying.\n *\n * @private\n * @param {Function|string} func The function or method name to reference.\n * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n  var isAry = bitmask & ARY_FLAG,\n      isBind = bitmask & BIND_FLAG,\n      isBindKey = bitmask & BIND_KEY_FLAG,\n      isCurry = bitmask & CURRY_FLAG,\n      isCurryBound = bitmask & CURRY_BOUND_FLAG,\n      isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n      Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\n  function wrapper() {\n    // Avoid `arguments` object use disqualifying optimizations by\n    // converting it to an array before providing it to other functions.\n    var length = arguments.length,\n        index = length,\n        args = Array(length);\n\n    while (index--) {\n      args[index] = arguments[index];\n    }\n    if (partials) {\n      args = composeArgs(args, partials, holders);\n    }\n    if (partialsRight) {\n      args = composeArgsRight(args, partialsRight, holdersRight);\n    }\n    if (isCurry || isCurryRight) {\n      var placeholder = wrapper.placeholder,\n          argsHolders = replaceHolders(args, placeholder);\n\n      length -= argsHolders.length;\n      if (length < arity) {\n        var newArgPos = argPos ? arrayCopy(argPos) : undefined,\n            newArity = nativeMax(arity - length, 0),\n            newsHolders = isCurry ? argsHolders : undefined,\n            newHoldersRight = isCurry ? undefined : argsHolders,\n            newPartials = isCurry ? args : undefined,\n            newPartialsRight = isCurry ? undefined : args;\n\n        bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n        if (!isCurryBound) {\n          bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n        }\n        var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n            result = createHybridWrapper.apply(undefined, newData);\n\n        if (isLaziable(func)) {\n          setData(result, newData);\n        }\n        result.placeholder = placeholder;\n        return result;\n      }\n    }\n    var thisBinding = isBind ? thisArg : this,\n        fn = isBindKey ? thisBinding[func] : func;\n\n    if (argPos) {\n      args = reorder(args, argPos);\n    }\n    if (isAry && ary < args.length) {\n      args.length = ary;\n    }\n    if (this && this !== global && this instanceof wrapper) {\n      fn = Ctor || createCtorWrapper(func);\n    }\n    return fn.apply(thisBinding, args);\n  }\n  return wrapper;\n}\n\nmodule.exports = createHybridWrapper;\n","var createCtorWrapper = require('./createCtorWrapper');\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1;\n\n/**\n * Creates a function that wraps `func` and invokes it with the optional `this`\n * binding of `thisArg` and the `partials` prepended to those provided to\n * the wrapper.\n *\n * @private\n * @param {Function} func The function to partially apply arguments to.\n * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} partials The arguments to prepend to those provided to the new function.\n * @returns {Function} Returns the new bound function.\n */\nfunction createPartialWrapper(func, bitmask, thisArg, partials) {\n  var isBind = bitmask & BIND_FLAG,\n      Ctor = createCtorWrapper(func);\n\n  function wrapper() {\n    // Avoid `arguments` object use disqualifying optimizations by\n    // converting it to an array before providing it `func`.\n    var argsIndex = -1,\n        argsLength = arguments.length,\n        leftIndex = -1,\n        leftLength = partials.length,\n        args = Array(leftLength + argsLength);\n\n    while (++leftIndex < leftLength) {\n      args[leftIndex] = partials[leftIndex];\n    }\n    while (argsLength--) {\n      args[leftIndex++] = arguments[++argsIndex];\n    }\n    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;\n    return fn.apply(isBind ? thisArg : this, args);\n  }\n  return wrapper;\n}\n\nmodule.exports = createPartialWrapper;\n","var baseCallback = require(413),\n    baseReduce = require(442),\n    isArray = require(506);\n\n/**\n * Creates a function for `_.reduce` or `_.reduceRight`.\n *\n * @private\n * @param {Function} arrayFunc The function to iterate over an array.\n * @param {Function} eachFunc The function to iterate over a collection.\n * @returns {Function} Returns the new each function.\n */\nfunction createReduce(arrayFunc, eachFunc) {\n  return function(collection, iteratee, accumulator, thisArg) {\n    var initFromArray = arguments.length < 3;\n    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n      ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n      : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n  };\n}\n\nmodule.exports = createReduce;\n","var baseSetData = require(443),\n    createBindWrapper = require(461),\n    createHybridWrapper = require(467),\n    createPartialWrapper = require(468),\n    getData = require(474),\n    mergeData = require(491),\n    setData = require(498);\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    BIND_KEY_FLAG = 2,\n    PARTIAL_FLAG = 32,\n    PARTIAL_RIGHT_FLAG = 64;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that either curries or invokes `func` with optional\n * `this` binding and partially applied arguments.\n *\n * @private\n * @param {Function|string} func The function or method name to reference.\n * @param {number} bitmask The bitmask of flags.\n *  The bitmask may be composed of the following flags:\n *     1 - `_.bind`\n *     2 - `_.bindKey`\n *     4 - `_.curry` or `_.curryRight` of a bound function\n *     8 - `_.curry`\n *    16 - `_.curryRight`\n *    32 - `_.partial`\n *    64 - `_.partialRight`\n *   128 - `_.rearg`\n *   256 - `_.ary`\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to be partially applied.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n  var isBindKey = bitmask & BIND_KEY_FLAG;\n  if (!isBindKey && typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var length = partials ? partials.length : 0;\n  if (!length) {\n    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n    partials = holders = undefined;\n  }\n  length -= (holders ? holders.length : 0);\n  if (bitmask & PARTIAL_RIGHT_FLAG) {\n    var partialsRight = partials,\n        holdersRight = holders;\n\n    partials = holders = undefined;\n  }\n  var data = isBindKey ? undefined : getData(func),\n      newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n  if (data) {\n    mergeData(newData, data);\n    bitmask = newData[1];\n    arity = newData[9];\n  }\n  newData[9] = arity == null\n    ? (isBindKey ? 0 : func.length)\n    : (nativeMax(arity - length, 0) || 0);\n\n  if (bitmask == BIND_FLAG) {\n    var result = createBindWrapper(newData[0], newData[2]);\n  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n    result = createPartialWrapper.apply(undefined, newData);\n  } else {\n    result = createHybridWrapper.apply(undefined, newData);\n  }\n  var setter = data ? baseSetData : setData;\n  return setter(result, newData);\n}\n\nmodule.exports = createWrapper;\n","var arraySome = require(410);\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing arrays.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n    return false;\n  }\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index],\n        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\n    if (result !== undefined) {\n      if (result) {\n        continue;\n      }\n      return false;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (isLoose) {\n      if (!arraySome(other, function(othValue) {\n            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n          })) {\n        return false;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalArrays;\n","/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      // Treat `NaN` vs. `NaN` as equal.\n      return (object != +object)\n        ? other != +other\n        : object == +other;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings primitives and string\n      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n      return object == (other + '');\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var keys = require(519);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isLoose) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  var skipCtor = isLoose;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key],\n        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n      return false;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (!skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;\n","var metaMap = require(492),\n    noop = require(528);\n\n/**\n * Gets metadata for `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {*} Returns the metadata for `func`.\n */\nvar getData = !metaMap ? noop : function(func) {\n  return metaMap.get(func);\n};\n\nmodule.exports = getData;\n","var realNames = require(495);\n\n/**\n * Gets the name of `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {string} Returns the function name.\n */\nfunction getFuncName(func) {\n  var result = (func.name + ''),\n      array = realNames[result],\n      length = array ? array.length : 0;\n\n  while (length--) {\n    var data = array[length],\n        otherFunc = data.func;\n    if (otherFunc == null || otherFunc == func) {\n      return data.name;\n    }\n  }\n  return result;\n}\n\nmodule.exports = getFuncName;\n","var baseProperty = require(440);\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n","var isStrictComparable = require(490),\n    pairs = require(523);\n\n/**\n * Gets the propery names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = pairs(object),\n      length = result.length;\n\n  while (length--) {\n    result[length][2] = isStrictComparable(result[length][1]);\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var isNative = require(509);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","/**\n * Gets the index at which the first occurrence of `NaN` is found in `array`.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n */\nfunction indexOfNaN(array, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 0 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    var other = array[index];\n    if (other !== other) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = indexOfNaN;\n","/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add array properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var bufferClone = require(451);\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = //w*$/;\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return bufferClone(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      var buffer = object.buffer;\n      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      var result = new Ctor(object.source, reFlags.exec(object));\n      result.lastIndex = object.lastIndex;\n  }\n  return result;\n}\n\nmodule.exports = initCloneByTag;\n","/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  var Ctor = object.constructor;\n  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n    Ctor = Object;\n  }\n  return new Ctor;\n}\n\nmodule.exports = initCloneObject;\n","var getLength = require(476),\n    isLength = require(488);\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n","/** Used to detect unsigned integer values. */\nvar reIsUint = /^/d+$/;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n","var isArrayLike = require(483),\n    isIndex = require(484),\n    isObject = require(511);\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var isArray = require(506),\n    toObject = require(501);\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = //.|/[(?:[^[/]]*|([\"'])(?:(?!/1)[^/n//]|//.)*?/1)/]/,\n    reIsPlainProp = /^/w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  var type = typeof value;\n  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n    return true;\n  }\n  if (isArray(value)) {\n    return false;\n  }\n  var result = !reIsDeepProp.test(value);\n  return result || (object != null && value in toObject(object));\n}\n\nmodule.exports = isKey;\n","var LazyWrapper = require(400),\n    getData = require(474),\n    getFuncName = require(475),\n    lodash = require(381);\n\n/**\n * Checks if `func` has a lazy counterpart.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n */\nfunction isLaziable(func) {\n  var funcName = getFuncName(func),\n      other = lodash[funcName];\n\n  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n    return false;\n  }\n  if (func === other) {\n    return true;\n  }\n  var data = getData(other);\n  return !!data && func === data[0];\n}\n\nmodule.exports = isLaziable;\n","/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var isObject = require(511);\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","var arrayCopy = require(403),\n    composeArgs = require(455),\n    composeArgsRight = require(456),\n    replaceHolders = require(497);\n\n/** Used to compose bitmasks for wrapper metadata. */\nvar BIND_FLAG = 1,\n    CURRY_BOUND_FLAG = 4,\n    CURRY_FLAG = 8,\n    ARY_FLAG = 128,\n    REARG_FLAG = 256;\n\n/** Used as the internal argument placeholder. */\nvar PLACEHOLDER = '__lodash_placeholder__';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Merges the function metadata of `source` into `data`.\n *\n * Merging metadata reduces the number of wrappers required to invoke a function.\n * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n * augment function arguments, making the order in which they are executed important,\n * preventing the merging of metadata. However, we make an exception for a safe\n * common case where curried functions have `_.ary` and or `_.rearg` applied.\n *\n * @private\n * @param {Array} data The destination metadata.\n * @param {Array} source The source metadata.\n * @returns {Array} Returns `data`.\n */\nfunction mergeData(data, source) {\n  var bitmask = data[1],\n      srcBitmask = source[1],\n      newBitmask = bitmask | srcBitmask,\n      isCommon = newBitmask < ARY_FLAG;\n\n  var isCombo =\n    (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n    (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n    (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\n  // Exit early if metadata can't be merged.\n  if (!(isCommon || isCombo)) {\n    return data;\n  }\n  // Use source `thisArg` if available.\n  if (srcBitmask & BIND_FLAG) {\n    data[2] = source[2];\n    // Set when currying a bound function.\n    newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n  }\n  // Compose partial arguments.\n  var value = source[3];\n  if (value) {\n    var partials = data[3];\n    data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n  }\n  // Compose partial right arguments.\n  value = source[5];\n  if (value) {\n    partials = data[5];\n    data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n  }\n  // Use source `argPos` if available.\n  value = source[7];\n  if (value) {\n    data[7] = arrayCopy(value);\n  }\n  // Use source `ary` if it's smaller.\n  if (srcBitmask & ARY_FLAG) {\n    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n  }\n  // Use source `arity` if one is not provided.\n  if (data[9] == null) {\n    data[9] = source[9];\n  }\n  // Use source `func` and merge bitmasks.\n  data[0] = source[0];\n  data[1] = newBitmask;\n\n  return data;\n}\n\nmodule.exports = mergeData;\n","var getNative = require('./getNative');\n\n/** Native method references. */\nvar WeakMap = getNative(global, 'WeakMap');\n\n/** Used to store function metadata. */\nvar metaMap = WeakMap && new WeakMap;\n\nmodule.exports = metaMap;\n","var toObject = require(501);\n\n/**\n * A specialized version of `_.pick` which picks `object` properties specified\n * by `props`.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} props The property names to pick.\n * @returns {Object} Returns the new object.\n */\nfunction pickByArray(object, props) {\n  object = toObject(object);\n\n  var index = -1,\n      length = props.length,\n      result = {};\n\n  while (++index < length) {\n    var key = props[index];\n    if (key in object) {\n      result[key] = object[key];\n    }\n  }\n  return result;\n}\n\nmodule.exports = pickByArray;\n","var baseForIn = require(427);\n\n/**\n * A specialized version of `_.pick` which picks `object` properties `predicate`\n * returns truthy for.\n *\n * @private\n * @param {Object} object The source object.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Object} Returns the new object.\n */\nfunction pickByCallback(object, predicate) {\n  var result = {};\n  baseForIn(object, function(value, key, object) {\n    if (predicate(value, key, object)) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\n\nmodule.exports = pickByCallback;\n","/** Used to lookup unminified function names. */\nvar realNames = {};\n\nmodule.exports = realNames;\n","var arrayCopy = require(403),\n    isIndex = require(484);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Reorder `array` according to the specified indexes where the element at\n * the first index is assigned as the first element, the element at\n * the second index is assigned as the second element, and so on.\n *\n * @private\n * @param {Array} array The array to reorder.\n * @param {Array} indexes The arranged array indexes.\n * @returns {Array} Returns `array`.\n */\nfunction reorder(array, indexes) {\n  var arrLength = array.length,\n      length = nativeMin(indexes.length, arrLength),\n      oldArray = arrayCopy(array);\n\n  while (length--) {\n    var index = indexes[length];\n    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n  }\n  return array;\n}\n\nmodule.exports = reorder;\n","/** Used as the internal argument placeholder. */\nvar PLACEHOLDER = '__lodash_placeholder__';\n\n/**\n * Replaces all `placeholder` elements in `array` with an internal placeholder\n * and returns an array of their indexes.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {*} placeholder The placeholder to replace.\n * @returns {Array} Returns the new array of placeholder indexes.\n */\nfunction replaceHolders(array, placeholder) {\n  var index = -1,\n      length = array.length,\n      resIndex = -1,\n      result = [];\n\n  while (++index < length) {\n    if (array[index] === placeholder) {\n      array[index] = PLACEHOLDER;\n      result[++resIndex] = index;\n    }\n  }\n  return result;\n}\n\nmodule.exports = replaceHolders;\n","var baseSetData = require(443),\n    now = require(395);\n\n/** Used to detect when a function becomes hot. */\nvar HOT_COUNT = 150,\n    HOT_SPAN = 16;\n\n/**\n * Sets metadata for `func`.\n *\n * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n * period of time, it will trip its breaker and transition to an identity function\n * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n * for more details.\n *\n * @private\n * @param {Function} func The function to associate metadata with.\n * @param {*} data The metadata.\n * @returns {Function} Returns `func`.\n */\nvar setData = (function() {\n  var count = 0,\n      lastCalled = 0;\n\n  return function(key, value) {\n    var stamp = now(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return key;\n      }\n    } else {\n      count = 0;\n    }\n    return baseSetData(key, value);\n  };\n}());\n\nmodule.exports = setData;\n","var isArguments = require(505),\n    isArray = require(506),\n    isIndex = require(484),\n    isLength = require(488),\n    keysIn = require(520);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n","/**\n * An implementation of `_.uniq` optimized for sorted arrays without support\n * for callback shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The function invoked per iteration.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction sortedUniq(array, iteratee) {\n  var seen,\n      index = -1,\n      length = array.length,\n      resIndex = -1,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value, index, array) : value;\n\n    if (!index || seen !== computed) {\n      seen = computed;\n      result[++resIndex] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = sortedUniq;\n","var isObject = require(511);\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n","var baseToString = require(447),\n    isArray = require(506);\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[/]]+|/[(?:(-?/d+(?:/./d+)?)|([\"'])((?:(?!/2)[^/n//]|//.)*?)/2)/]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = ///(//)?/g;\n\n/**\n * Converts `value` to property path array if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Array} Returns the property path array.\n */\nfunction toPath(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  var result = [];\n  baseToString(value).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n}\n\nmodule.exports = toPath;\n","var LazyWrapper = require(400),\n    LodashWrapper = require(401),\n    arrayCopy = require(403);\n\n/**\n * Creates a clone of `wrapper`.\n *\n * @private\n * @param {Object} wrapper The wrapper to clone.\n * @returns {Object} Returns the cloned wrapper.\n */\nfunction wrapperClone(wrapper) {\n  return wrapper instanceof LazyWrapper\n    ? wrapper.clone()\n    : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n}\n\nmodule.exports = wrapperClone;\n","var baseClone = require(414),\n    bindCallback = require(450),\n    isIterateeCall = require(485);\n\n/**\n * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n * otherwise they are assigned by reference. If `customizer` is provided it's\n * invoked to produce the cloned values. If `customizer` returns `undefined`\n * cloning is handled by the method instead. The `customizer` is bound to\n * `thisArg` and invoked with up to three argument; (value [, index|key, object]).\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n * The enumerable properties of `arguments` objects and objects created by\n * constructors other than `Object` are cloned to plain `Object` objects. An\n * empty object is returned for uncloneable values such as functions, DOM nodes,\n * Maps, Sets, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {Function} [customizer] The function to customize cloning values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {*} Returns the cloned value.\n * @example\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * var shallow = _.clone(users);\n * shallow[0] === users[0];\n * // => true\n *\n * var deep = _.clone(users, true);\n * deep[0] === users[0];\n * // => false\n *\n * // using a customizer callback\n * var el = _.clone(document.body, function(value) {\n *   if (_.isElement(value)) {\n *     return value.cloneNode(false);\n *   }\n * });\n *\n * el === document.body\n * // => false\n * el.nodeName\n * // => BODY\n * el.childNodes.length;\n * // => 0\n */\nfunction clone(value, isDeep, customizer, thisArg) {\n  if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n    isDeep = false;\n  }\n  else if (typeof isDeep == 'function') {\n    thisArg = customizer;\n    customizer = isDeep;\n    isDeep = false;\n  }\n  return typeof customizer == 'function'\n    ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))\n    : baseClone(value, isDeep);\n}\n\nmodule.exports = clone;\n","var isArrayLike = require(483),\n    isObjectLike = require(489);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n","var getNative = require(478),\n    isLength = require(488),\n    isObjectLike = require(489);\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n","var isArguments = require(505),\n    isArray = require(506),\n    isArrayLike = require(483),\n    isFunction = require(508),\n    isObjectLike = require(489),\n    isString = require(513),\n    keys = require(519);\n\n/**\n * Checks if `value` is empty. A value is considered empty unless it's an\n * `arguments` object, array, string, or jQuery-like collection with a length\n * greater than `0` or an object with own enumerable properties.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {Array|Object|string} value The value to inspect.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\n      (isObjectLike(value) && isFunction(value.splice)))) {\n    return !value.length;\n  }\n  return !keys(value).length;\n}\n\nmodule.exports = isEmpty;\n","var isObject = require(511);\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 which returns 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\nmodule.exports = isFunction;\n","var isFunction = require(508),\n    isObjectLike = require(489);\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^/[object .+?Constructor/]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[//^$.*+?()[/]{}|]/g, '//$&')\n  .replace(/hasOwnProperty|(function).*?(?=///()| for .+?(?=///])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n","var isObjectLike = require(489);\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n * as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isNumber(8.4);\n * // => true\n *\n * _.isNumber(NaN);\n * // => true\n *\n * _.isNumber('8.4');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n","/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseForIn = require(427),\n    isArguments = require(505),\n    isObjectLike = require(489);\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * **Note:** This method assumes objects created by the `Object` constructor\n * have no inherited enumerable properties.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  var Ctor;\n\n  // Exit early for non `Object` objects.\n  if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\n      (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n    return false;\n  }\n  // IE < 9 iterates inherited properties before own properties. If the first\n  // iterated property is an object's own property then there are no inherited\n  // enumerable properties.\n  var result;\n  // In most environments an object's own properties are iterated before\n  // its inherited properties. If the last iterated property is an object's\n  // own property then there are no inherited enumerable properties.\n  baseForIn(value, function(subValue, key) {\n    result = key;\n  });\n  return result === undefined || hasOwnProperty.call(value, result);\n}\n\nmodule.exports = isPlainObject;\n","var isObjectLike = require(489);\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n","var isLength = require(488),\n    isObjectLike = require(489);\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nfunction isTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n}\n\nmodule.exports = isTypedArray;\n","var baseCopy = require(416),\n    keysIn = require(520);\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable\n * properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return baseCopy(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var assignWith = require(411),\n    baseAssign = require(412),\n    createAssigner = require(458);\n\n/**\n * Assigns own enumerable properties of source object(s) to the destination\n * object. Subsequent sources overwrite property assignments of previous sources.\n * If `customizer` is provided it's invoked to produce the assigned values.\n * The `customizer` is bound to `thisArg` and invoked with five arguments:\n * (objectValue, sourceValue, key, object, source).\n *\n * **Note:** This method mutates `object` and is based on\n * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n *\n * @static\n * @memberOf _\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n * // => { 'user': 'fred', 'age': 40 }\n *\n * // using a customizer callback\n * var defaults = _.partialRight(_.assign, function(value, other) {\n *   return _.isUndefined(value) ? other : value;\n * });\n *\n * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n * // => { 'user': 'barney', 'age': 36 }\n */\nvar assign = createAssigner(function(object, source, customizer) {\n  return customizer\n    ? assignWith(object, source, customizer)\n    : baseAssign(object, source);\n});\n\nmodule.exports = assign;\n","var baseGet = require(429),\n    toPath = require(502);\n\n/**\n * Gets the property value at `path` of `object`. If the resolved value is\n * `undefined` the `defaultValue` is used in its place.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseGet = require(429),\n    baseSlice = require(444),\n    isArguments = require(505),\n    isArray = require(506),\n    isIndex = require(484),\n    isKey = require(486),\n    isLength = require(488),\n    last = require(375),\n    toPath = require(502);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `path` is a direct property.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': { 'c': 3 } } };\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b.c');\n * // => true\n *\n * _.has(object, ['a', 'b', 'c']);\n * // => true\n */\nfunction has(object, path) {\n  if (object == null) {\n    return false;\n  }\n  var result = hasOwnProperty.call(object, path);\n  if (!result && !isKey(path)) {\n    path = toPath(path);\n    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n    if (object == null) {\n      return false;\n    }\n    path = last(path);\n    result = hasOwnProperty.call(object, path);\n  }\n  return result || (isLength(object.length) && isIndex(path, object.length) &&\n    (isArray(object) || isArguments(object)));\n}\n\nmodule.exports = has;\n","var getNative = require(478),\n    isArrayLike = require(483),\n    isObject = require(511),\n    shimKeys = require(499);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n","var isArguments = require(505),\n    isArray = require(506),\n    isIndex = require(484),\n    isLength = require(488),\n    isObject = require(511);\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n","var baseMerge = require(438),\n    createAssigner = require(458);\n\n/**\n * Recursively merges own enumerable properties of the source object(s), that\n * don't resolve to `undefined` into the destination object. Subsequent sources\n * overwrite property assignments of previous sources. If `customizer` is\n * provided it's invoked to produce the merged values of the destination and\n * source properties. If `customizer` returns `undefined` merging is handled\n * by the method instead. The `customizer` is bound to `thisArg` and invoked\n * with five arguments: (objectValue, sourceValue, key, object, source).\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var users = {\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n * };\n *\n * var ages = {\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\n * };\n *\n * _.merge(users, ages);\n * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n *\n * // using a customizer callback\n * var object = {\n *   'fruits': ['apple'],\n *   'vegetables': ['beet']\n * };\n *\n * var other = {\n *   'fruits': ['banana'],\n *   'vegetables': ['carrot']\n * };\n *\n * _.merge(object, other, function(a, b) {\n *   if (_.isArray(a)) {\n *     return a.concat(b);\n *   }\n * });\n * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n */\nvar merge = createAssigner(baseMerge);\n\nmodule.exports = merge;\n","var arrayMap = require(407),\n    baseDifference = require(419),\n    baseFlatten = require(425),\n    bindCallback = require(450),\n    keysIn = require(520),\n    pickByArray = require(493),\n    pickByCallback = require(494),\n    restParam = require(399);\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable properties of `object` that are not omitted.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {Function|...(string|string[])} [predicate] The function invoked per\n *  iteration or property names to omit, specified as individual property\n *  names or arrays of property names.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'user': 'fred', 'age': 40 };\n *\n * _.omit(object, 'age');\n * // => { 'user': 'fred' }\n *\n * _.omit(object, _.isNumber);\n * // => { 'user': 'fred' }\n */\nvar omit = restParam(function(object, props) {\n  if (object == null) {\n    return {};\n  }\n  if (typeof props[0] != 'function') {\n    var props = arrayMap(baseFlatten(props), String);\n    return pickByArray(object, baseDifference(keysIn(object), props));\n  }\n  var predicate = bindCallback(props[0], props[1], 3);\n  return pickByCallback(object, function(value, key, object) {\n    return !predicate(value, key, object);\n  });\n});\n\nmodule.exports = omit;\n","var keys = require(519),\n    toObject = require(501);\n\n/**\n * Creates a two dimensional array of the key-value pairs for `object`,\n * e.g. `[[key1, value1], [key2, value2]]`.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the new array of key-value pairs.\n * @example\n *\n * _.pairs({ 'barney': 36, 'fred': 40 });\n * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n */\nfunction pairs(object) {\n  object = toObject(object);\n\n  var index = -1,\n      props = keys(object),\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    var key = props[index];\n    result[index] = [key, object[key]];\n  }\n  return result;\n}\n\nmodule.exports = pairs;\n","var baseFlatten = require(425),\n    bindCallback = require(450),\n    pickByArray = require(493),\n    pickByCallback = require(494),\n    restParam = require(399);\n\n/**\n * Creates an object composed of the picked `object` properties. Property\n * names may be specified as individual arguments or as arrays of property\n * names. If `predicate` is provided it's invoked for each property of `object`\n * picking the properties `predicate` returns truthy for. The predicate is\n * bound to `thisArg` and invoked with three arguments: (value, key, object).\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {Function|...(string|string[])} [predicate] The function invoked per\n *  iteration or property names to pick, specified as individual property\n *  names or arrays of property names.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'user': 'fred', 'age': 40 };\n *\n * _.pick(object, 'user');\n * // => { 'user': 'fred' }\n *\n * _.pick(object, _.isString);\n * // => { 'user': 'fred' }\n */\nvar pick = restParam(function(object, props) {\n  if (object == null) {\n    return {};\n  }\n  return typeof props[0] == 'function'\n    ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n    : pickByArray(object, baseFlatten(props));\n});\n\nmodule.exports = pick;\n","var arrayEach = require(404),\n    baseCallback = require(413),\n    baseCreate = require(417),\n    baseForOwn = require(428),\n    isArray = require(506),\n    isFunction = require(508),\n    isObject = require(511),\n    isTypedArray = require(514);\n\n/**\n * An alternative to `_.reduce`; this method transforms `object` to a new\n * `accumulator` object which is the result of running each of its own enumerable\n * properties through `iteratee`, with each invocation potentially mutating\n * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n * with four arguments: (accumulator, value, key, object). Iteratee functions\n * may exit iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Array|Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The custom accumulator value.\n * @param {*} [thisArg] The `this` binding of `iteratee`.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.transform([2, 3, 4], function(result, n) {\n *   result.push(n *= n);\n *   return n % 2 == 0;\n * });\n * // => [4, 9]\n *\n * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\n *   result[key] = n * 3;\n * });\n * // => { 'a': 3, 'b': 6 }\n */\nfunction transform(object, iteratee, accumulator, thisArg) {\n  var isArr = isArray(object) || isTypedArray(object);\n  iteratee = baseCallback(iteratee, thisArg, 4);\n\n  if (accumulator == null) {\n    if (isArr || isObject(object)) {\n      var Ctor = object.constructor;\n      if (isArr) {\n        accumulator = isArray(object) ? new Ctor : [];\n      } else {\n        accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n      }\n    } else {\n      accumulator = {};\n    }\n  }\n  (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n    return iteratee(accumulator, value, index, object);\n  });\n  return accumulator;\n}\n\nmodule.exports = transform;\n","var baseValues = require(449),\n    keys = require(519);\n\n/**\n * Creates an array of the own enumerable property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n","/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","/**\n * A no-operation function that returns `undefined` regardless of the\n * arguments it receives.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.noop(object) === undefined;\n * // => true\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseProperty = require(440),\n    basePropertyDeep = require(441),\n    isKey = require(486);\n\n/**\n * Creates a function that returns the property value at `path` on a\n * given object.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': { 'c': 2 } } },\n *   { 'a': { 'b': { 'c': 1 } } }\n * ];\n *\n * _.map(objects, _.property('a.b.c'));\n * // => [2, 1]\n *\n * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * Set attribute `name` to `val`, or get attr `name`.\n *\n * @param {Element} el\n * @param {String} name\n * @param {String} [val]\n * @api public\n */\n\nmodule.exports = function(el, name, val) {\n  // get\n  if (arguments.length == 2) {\n    return el.getAttribute(name);\n  }\n\n  // remove\n  if (val === null) {\n    return el.removeAttribute(name);\n  }\n\n  // set\n  el.setAttribute(name, val);\n\n  return el;\n};","module.exports = require(181);","module.exports = function(el) {\n\n  var c;\n\n  while (el.childNodes.length) {\n    c = el.childNodes[0];\n    el.removeChild(c);\n  }\n\n  return el;\n};","module.exports = require(182);","module.exports = require(183);","module.exports = require(362);","module.exports = require(186);","module.exports = require(188);","module.exports = require(189);","module.exports = function(el) {\n  el.parentNode && el.parentNode.removeChild(el);\n};","'use strict';\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\n\nmodule.exports.aliasToName = function(alias, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return capitalize(alias);\n  } else {\n    return alias;\n  }\n};\n\nmodule.exports.nameToAlias = function(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n};\n\nmodule.exports.DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance'\n};\n\nvar XSI_TYPE = module.exports.XSI_TYPE = 'xsi:type';\n\nfunction serializeFormat(element) {\n  return element.xml && element.xml.serialize;\n}\n\nmodule.exports.serializeAsType = function(element) {\n  return serializeFormat(element) === XSI_TYPE;\n};\n\nmodule.exports.serializeAsProperty = function(element) {\n  return serializeFormat(element) === 'property';\n};","'use strict';\n\nvar reduce = require(390),\n    forEach = require(386),\n    find = require(385),\n    assign = require(516),\n    defer = require(398);\n\nvar Stack = require(576),\n    SaxParser = require(571).parser,\n    Moddle = require(543),\n    parseNameNs = require(548).parseName,\n    Types = require(551),\n    coerceType = Types.coerceType,\n    isSimpleType = Types.isSimple,\n    common = require(540),\n    XSI_TYPE = common.XSI_TYPE,\n    XSI_URI = common.DEFAULT_NS_MAP.xsi,\n    serializeAsType = common.serializeAsType,\n    aliasToName = common.aliasToName;\n\nfunction parseNodeAttributes(node) {\n  var nodeAttrs = node.attributes;\n\n  return reduce(nodeAttrs, function(result, v, k) {\n    var name, ns;\n\n    if (!v.local) {\n      name = v.prefix;\n    } else {\n      ns = parseNameNs(v.name, v.prefix);\n      name = ns.name;\n    }\n\n    result[name] = v.value;\n    return result;\n  }, {});\n}\n\nfunction normalizeType(node, attr, model) {\n  var nameNs = parseNameNs(attr.value);\n\n  var uri = node.ns[nameNs.prefix || ''],\n      localName = nameNs.localName,\n      pkg = uri && model.getPackage(uri),\n      typePrefix;\n\n  if (pkg) {\n    typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n    if (typePrefix && localName.indexOf(typePrefix) === 0) {\n      localName = localName.slice(typePrefix.length);\n    }\n\n    attr.value = pkg.prefix + ':' + localName;\n  }\n}\n\n/**\n * Normalizes namespaces for a node given an optional default namespace and a\n * number of mappings from uris to default prefixes.\n *\n * @param  {XmlNode} node\n * @param  {Model} model the model containing all registered namespaces\n * @param  {Uri} defaultNsUri\n */\nfunction normalizeNamespaces(node, model, defaultNsUri) {\n  var uri, prefix;\n\n  uri = node.uri || defaultNsUri;\n\n  if (uri) {\n    var pkg = model.getPackage(uri);\n\n    if (pkg) {\n      prefix = pkg.prefix;\n    } else {\n      prefix = node.prefix;\n    }\n\n    node.prefix = prefix;\n    node.uri = uri;\n  }\n\n  forEach(node.attributes, function(attr) {\n\n    // normalize xsi:type attributes because the\n    // assigned type may or may not be namespace prefixed\n    if (attr.uri === XSI_URI && attr.local === 'type') {\n      normalizeType(node, attr, model);\n    }\n\n    normalizeNamespaces(attr, model, null);\n  });\n}\n\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class XMLReader.ElementHandler\n *\n */\nfunction ElementHandler(model, type, context) {\n  this.model = model;\n  this.type = model.getType(type);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = parseNodeAttributes(node),\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({});\n\n  forEach(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        forEach(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var nameNs = parseNameNs(node.local, node.prefix);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName],\n      elementTypeName,\n      elementType,\n      typeAnnotation;\n\n  // search for properties by name first\n\n  if (property) {\n\n    if (serializeAsType(property)) {\n      typeAnnotation = node.attributes[XSI_TYPE];\n\n      // xsi type is optional, if it does not exists the\n      // default type is assumed\n      if (typeAnnotation) {\n\n        elementTypeName = typeAnnotation.value;\n\n        // TODO: extract real name from attribute\n        elementType = model.getType(elementTypeName);\n\n        return assign({}, property, { effectiveType: getModdleDescriptor(elementType).name });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    elementTypeName = nameNs.prefix + ':' + aliasToName(nameNs.localName, descriptor.$pkg);\n    elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, { effectiveType: getModdleDescriptor(elementType).name });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n\nfunction GenericElementHandler(model, type, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      prefix = node.prefix,\n      uri = node.ns[prefix],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleText = function(text) {\n  this.body = this.body || '' + text;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction XMLReader(options) {\n\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, { lax: false }, options);\n}\n\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n * @param  {Function} done\n */\nXMLReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n      parser = new SaxParser(true, { xmlns: true, trim: true }),\n      stack = new Stack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose(tagName) {\n    stack.pop().handleEnd();\n  }\n\n  function handleOpen(node) {\n    var handler = stack.peek();\n\n    normalizeNamespaces(node, model);\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (e) {\n\n      var line = this.line,\n          column = this.column;\n\n      var message =\n        'unparsable content <' + node.name + '> detected/n/t' +\n          'line: ' + line + '/n/t' +\n          'column: ' + column + '/n/t' +\n          'nested error: ' + e.message;\n\n      if (lax) {\n        context.addWarning({\n          message: message,\n          error: e\n        });\n\n        console.warn('could not parse node');\n        console.warn(e);\n\n        stack.push(new NoopHandler());\n      } else {\n        console.error('could not parse document');\n        console.error(e);\n\n        throw error(message);\n      }\n    }\n  }\n\n  function handleText(text) {\n    stack.peek().handleText(text);\n  }\n\n  parser.onopentag = handleOpen;\n  parser.oncdata = parser.ontext = handleText;\n  parser.onclosetag = handleClose;\n  parser.onend = resolveReferences;\n\n  // deferred parse XML to make loading really ascnchronous\n  // this ensures the execution environment (node or browser)\n  // is kept responsive and that certain optimization strategies\n  // can kick in\n  defer(function() {\n    var error;\n\n    try {\n      parser.write(xml).close();\n    } catch (e) {\n      error = e;\n    }\n\n    done(error, error ? undefined : rootHandler.element, context);\n  });\n};\n\nXMLReader.prototype.handler = function(name) {\n  return new ElementHandler(this.model, name);\n};\n\nmodule.exports = XMLReader;\nmodule.exports.ElementHandler = ElementHandler;","'use strict';\n\nvar map = require(389),\n    forEach = require(386),\n    isString = require(513),\n    filter = require(384),\n    assign = require(516);\n\nvar Types = require(551),\n    parseNameNs = require(548).parseName,\n    common = require(540),\n    nameToAlias = common.nameToAlias,\n    serializeAsType = common.serializeAsType,\n    serializeAsProperty = common.serializeAsProperty;\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>/n',\n    ESCAPE_CHARS = /(<|>|'|\"|&|/n/r|/n)/g,\n    DEFAULT_NS_MAP = common.DEFAULT_NS_MAP,\n    XSI_TYPE = common.XSI_TYPE;\n\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  function isUsed(ns) {\n    return namespaces.used[ns.uri];\n  }\n\n  function toAttr(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  }\n\n  var allNs = [].concat(namespaces.wellknown, namespaces.custom);\n\n  return map(filter(allNs, isUsed), toAttr);\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return descriptor.name;\n  } else {\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return filter(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!element.hasOwnProperty(name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_MAP = {\n  '/n': '10',\n  '/n/r': '10',\n  '\"': '34',\n  '/'': '39',\n  '<': '60',\n  '>': '62',\n  '&': '38'\n};\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n\n  return str.replace(ESCAPE_CHARS, function(str) {\n    return '&#' + ESCAPE_MAP[str] + ';';\n  });\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return filter(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(parent, ns) {\n  this.ns = ns;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + nsName(this.ns) + '>' + this.element.id + '</' + nsName(this.ns) + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {\n  var escape = this.escape;\n\n  if (escape) {\n    writer.append('<![CDATA[');\n  }\n\n  writer.append(this.value);\n\n  if (escape) {\n    writer.append(']]>');\n  }\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(ns) {\n  this.ns = ns;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + nsName(this.ns) + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + nsName(this.ns) + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, ns) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.ns = ns;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var otherAttrs = this.parseNsAttributes(element);\n\n  if (!this.ns) {\n    this.ns = this.nsTagName(element.$descriptor);\n  }\n\n  if (element.$descriptor.isGeneric) {\n    this.parseGeneric(element);\n  } else {\n    var properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n\n    this.parseGenericAttributes(element, otherAttrs);\n  }\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNs(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return assign({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGeneric = function(element) {\n\n  var self = this,\n      body = this.body,\n      attrs = this.attrs;\n\n  forEach(element, function(val, key) {\n\n    if (key === '$body') {\n      body.push(new BodySerializer().build({ type: 'String' }, val));\n    } else\n    if (key === '$children') {\n      forEach(val, function(child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else\n    if (key.indexOf('$') !== 0) {\n      attrs.push({ name: key, value: escapeAttr(val) });\n    }\n  });\n};\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var model = element.$model;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function(value, name) {\n    var nameNs = parseNameNs(name);\n\n    var ns;\n\n    // parse xmlns:foo=\"http://foo.bar\"\n    if (nameNs.prefix === 'xmlns') {\n      ns = { prefix: nameNs.localName, uri: value };\n    }\n\n    // parse xmlns=\"http://foo.bar\"\n    if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n      ns = { uri: value };\n    }\n\n    if (ns) {\n      if (model.getPackage(value)) {\n        // register well known namespace\n        self.logNamespace(ns, true);\n      } else {\n        // log custom namespace directly as used\n        self.logNamespaceUsed(ns);\n      }\n    } else {\n      attributes.push({ name: name, value: value });\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  forEach(attributes, function(attr) {\n\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn(\n        'missing namespace information for ',\n        attr.name, '=', attr.value, 'on', element,\n        e);\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  forEach(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    var ns = self.nsPropertyTagName(p);\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else\n    if (Types.isSimple(p.type)) {\n      forEach(value, function(v) {\n        body.push(new ValueSerializer(ns).build(p, v));\n      });\n    } else\n    if (isReference) {\n      forEach(value, function(v) {\n        body.push(new ReferenceSerializer(self, ns).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n          asProperty = serializeAsProperty(p);\n\n      forEach(value, function(v) {\n        var serializer;\n\n        if (asType) {\n          serializer = new TypeSerializer(self, ns);\n        } else\n        if (asProperty) {\n          serializer = new ElementSerializer(self, ns);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function() {\n\n  var namespaces = this.namespaces,\n      parent = this.parent;\n\n  if (!namespaces) {\n    namespaces = this.namespaces = parent ? parent.getNamespaces() : {\n      prefixMap: {},\n      uriMap: {},\n      used: {},\n      wellknown: [],\n      custom: []\n    };\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown) {\n  var namespaces = this.getNamespaces();\n\n  var nsUri = ns.uri;\n\n  var existing = namespaces.uriMap[nsUri];\n\n  if (!existing) {\n    namespaces.uriMap[nsUri] = ns;\n\n    if (wellknown) {\n      namespaces.wellknown.push(ns);\n    } else {\n      namespaces.custom.push(ns);\n    }\n  }\n\n  namespaces.prefixMap[ns.prefix] = nsUri;\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns) {\n  var element = this.element,\n      model = element.$model,\n      namespaces = this.getNamespaces();\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n\n  var prefix = ns.prefix;\n\n  var wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n\n  var uri = ns.uri || namespaces.prefixMap[prefix] || wellknownUri;\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + ns.prefix + '>');\n  }\n\n  ns = namespaces.uriMap[uri];\n\n  if (!ns) {\n    ns = this.logNamespace({ prefix: prefix, uri: uri }, wellknownUri);\n  }\n\n  if (!namespaces.used[ns.uri]) {\n    namespaces.used[ns.uri] = ns;\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  forEach(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      }\n      else {\n        var values = [];\n        forEach(value, function(v) {\n          values.push(v.id);\n        });\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  attrs.push({ name: name, value: value });\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      root = !this.parent;\n\n  if (root) {\n    attrs = getNsAttrs(this.namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + nsName(this.ns));\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    forEach(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + nsName(this.ns) + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, ns) {\n  ElementSerializer.call(this, parent, ns);\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.build = function(element) {\n  var descriptor = element.$descriptor;\n\n  this.element = element;\n\n  this.typeNs = this.nsTagName(descriptor);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var typeNs = this.typeNs,\n      pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(this.nsAttributeName(XSI_TYPE),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') +\n    typePrefix + descriptor.ns.localName);\n\n  // do the usual stuff\n  return ElementSerializer.prototype.build.call(this, element);\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.typeNs.uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [''];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('/n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction XMLWriter(options) {\n\n  options = assign({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\nmodule.exports = XMLWriter;\n","module.exports = require(547);","'use strict';\n\nfunction Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n\nmodule.exports = Base;","'use strict';\n\nvar pick = require(524),\n    assign = require(516),\n    forEach = require(386);\n\nvar parseNameNs = require(548).parseName;\n\n\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\nmodule.exports = DescriptorBuilder;\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseNameNs(parts[0], nsPrefix);\n  var attrName = parseNameNs(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  var allTypes = this.allTypes;\n\n  if (allTypes.indexOf(t) !== -1) {\n    return;\n  }\n\n  forEach(t.properties, function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this);\n\n  allTypes.push(t);\n};\n","'use strict';\n\nvar forEach = require(386);\n\nvar Base = require(544);\n\n\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\nmodule.exports = Factory;\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    forEach(attrs, function(val, key) {\n      this.set(key, val);\n    }, this);\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};","'use strict';\n\nvar isString = require(513),\n    isObject = require(511),\n    forEach = require(386),\n    find = require(385);\n\n\nvar Factory = require(546),\n    Registry = require(550),\n    Properties = require(549);\n\nvar parseNameNs = require(548).parseName;\n\n\n//// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\nfunction Moddle(packages) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n}\n\nmodule.exports = Moddle;\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseNameNs(name);\n\n  var element = {\n    $type: name\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return !!find(descriptor.allTypes, function(t) {\n    return t.name === type;\n  });\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};\n","'use strict';\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nmodule.exports.parseName = function(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  } else\n  // prefix + local name\n  if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  } else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n};","'use strict';\n\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\nmodule.exports = Properties;\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}","'use strict';\n\nvar assign = require(516),\n    forEach = require(386);\n\nvar Types = require(551),\n    DescriptorBuilder = require(545);\n\nvar parseNameNs = require(548).parseName,\n    isBuiltInType = Types.isBuiltIn;\n\n\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, this.registerPackage, this);\n}\n\nmodule.exports = Registry;\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  // register types\n  forEach(pkg.types, function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this);\n\n  this.packageMap[pkg.uri] = this.packageMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(({}, type.meta || {}))\n  });\n\n  var ns = parseNameNs(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, function(p) {\n\n    // namespace property names\n    var propertyNs = parseNameNs(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltInType(p.type)) {\n      p.type = parseNameNs(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  });\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, function(extendsName) {\n    var extended = this.typeMap[extendsName];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this);\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltInType(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverseSuper(cls, trait) {\n    var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseNameNs(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n","'use strict';\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s, 10); }\n};\n\n/**\n * Convert a type to its real representation\n */\nmodule.exports.coerceType = function(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n};\n\n/**\n * Return whether the given type is built-in\n */\nmodule.exports.isBuiltIn = function(type) {\n  return !!BUILTINS[type];\n};\n\n/**\n * Return whether the given type is simple\n */\nmodule.exports.isSimple = function(type) {\n  return !!TYPE_CONVERTERS[type];\n};","module.exports = require(554);\n\nmodule.exports.Collection = require(553);","'use strict';\n\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function(element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function(element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function(element) {\n\n      if (!this.contains(element)) {\n        this.push(element);\n\n        // set inverse\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n\n  return collection;\n}\n\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\n\nmodule.exports.isExtended = isExtended;","'use strict';\n\nvar Collection = require(553);\n\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\n\nfunction defineCollectionProperty(ref, property, target) {\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: Collection.extend(target[property.name] || [], ref, property, target)\n  });\n}\n\n\nfunction defineProperty(ref, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  var _value = target[property.name];\n\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n\n    get: function() {\n      return _value;\n    },\n\n    set: function(value) {\n\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function(target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\n\nRefs.prototype.ensureRefsCollection = function(target, property) {\n\n  var collection = target[property.name];\n\n  if (!Collection.isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n\n  return collection;\n};\n\nRefs.prototype.ensureBound = function(target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\n\nRefs.prototype.unset = function(target, property, value) {\n\n  if (target) {\n    this.ensureBound(target, property);\n\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\n\nRefs.prototype.set = function(target, property, value) {\n\n  if (target) {\n    this.ensureBound(target, property);\n\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\nmodule.exports = Refs;\n\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n","module.exports = require(557);\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require(555);\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require(190);\nutil.inherits = require(368);\n/*</replacement>*/\n\nvar Readable = require(559);\nvar Writable = require(561);\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  processNextTick(cb, err);\n};\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require(560);\n\n/*<replacement>*/\nvar util = require(190);\nutil.inherits = require(368);\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n// TODO(bmeurer): Change this back to const once hole checks are\n// properly optimized away early in Ignition+TurboFan.\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require(557);\n\n/*<replacement>*/\nvar util = require(190);\nutil.inherits = require(368);\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return stream.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = _isUint8Array(chunk) && !state.objectMode;\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    processNextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    processNextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      processNextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\n/*<replacement>*/\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require(570).Buffer;\n/*</replacement>*/\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();","'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require(555);\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      processNextTick(emitErrorNT, this, err);\n    }\n    return;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      processNextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require(363).EventEmitter;\n","'use strict';\n\nvar Buffer = require(570).Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('/ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '/ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '/ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '/ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '/ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","module.exports = require(567).PassThrough\n","exports = module.exports = require(559);\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require(561);\nexports.Duplex = require(557);\nexports.Transform = require(560);\nexports.PassThrough = require(558);\n","module.exports = require(567).Transform\n","module.exports = require(561);\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require(180)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// wrapper for non-node envs\n;(function (sax) {\n\nsax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\nsax.SAXParser = SAXParser\nsax.SAXStream = SAXStream\nsax.createStream = createStream\n\n// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n// since that's the earliest that a buffer overrun could occur.  This way, checks are\n// as rare as required, but as often as necessary to ensure never crossing this bound.\n// Furthermore, buffers are only tested at most once per write(), so passing a very\n// large string into write() might have undesirable effects, but this is manageable by\n// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n// edge case, result in creating at most one complete copy of the string passed in.\n// Set to Infinity to have unlimited buffers.\nsax.MAX_BUFFER_LENGTH = 64 * 1024\n\nvar buffers = [\n  \"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\",\n  \"procInstName\", \"procInstBody\", \"entity\", \"attribName\",\n  \"attribValue\", \"cdata\", \"script\"\n]\n\nsax.EVENTS = // for discoverability.\n  [ \"text\"\n  , \"processinginstruction\"\n  , \"sgmldeclaration\"\n  , \"doctype\"\n  , \"comment\"\n  , \"attribute\"\n  , \"opentag\"\n  , \"closetag\"\n  , \"opencdata\"\n  , \"cdata\"\n  , \"closecdata\"\n  , \"error\"\n  , \"end\"\n  , \"ready\"\n  , \"script\"\n  , \"opennamespace\"\n  , \"closenamespace\"\n  ]\n\nfunction SAXParser (strict, opt) {\n  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)\n\n  var parser = this\n  clearBuffers(parser)\n  parser.q = parser.c = \"\"\n  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n  parser.opt = opt || {}\n  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n  parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\"\n  parser.tags = []\n  parser.closed = parser.closedRoot = parser.sawRoot = false\n  parser.tag = parser.error = null\n  parser.strict = !!strict\n  parser.noscript = !!(strict || parser.opt.noscript)\n  parser.state = S.BEGIN\n  parser.ENTITIES = Object.create(sax.ENTITIES)\n  parser.attribList = []\n\n  // namespaces form a prototype chain.\n  // it always points at the current tag,\n  // which protos to its parent tag.\n  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)\n\n  // mostly just for error reporting\n  parser.trackPosition = parser.opt.position !== false\n  if (parser.trackPosition) {\n    parser.position = parser.line = parser.column = 0\n  }\n  emit(parser, \"onready\")\n}\n\nif (!Object.create) Object.create = function (o) {\n  function f () { this.__proto__ = o }\n  f.prototype = o\n  return new f\n}\n\nif (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n  return o.__proto__\n}\n\nif (!Object.keys) Object.keys = function (o) {\n  var a = []\n  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n  return a\n}\n\nfunction checkBufferLength (parser) {\n  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    , maxActual = 0\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    var len = parser[buffers[i]].length\n    if (len > maxAllowed) {\n      // Text/cdata nodes can get big, and since they're buffered,\n      // we can get here under normal conditions.\n      // Avoid issues by emitting the text node now,\n      // so at least it won't get any bigger.\n      switch (buffers[i]) {\n        case \"textNode\":\n          closeText(parser)\n        break\n\n        case \"cdata\":\n          emitNode(parser, \"oncdata\", parser.cdata)\n          parser.cdata = \"\"\n        break\n\n        case \"script\":\n          emitNode(parser, \"onscript\", parser.script)\n          parser.script = \"\"\n        break\n\n        default:\n          error(parser, \"Max buffer length exceeded: \"+buffers[i])\n      }\n    }\n    maxActual = Math.max(maxActual, len)\n  }\n  // schedule the next check for the earliest possible buffer overrun.\n  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)\n                             + parser.position\n}\n\nfunction clearBuffers (parser) {\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    parser[buffers[i]] = \"\"\n  }\n}\n\nfunction flushBuffers (parser) {\n  closeText(parser)\n  if (parser.cdata !== \"\") {\n    emitNode(parser, \"oncdata\", parser.cdata)\n    parser.cdata = \"\"\n  }\n  if (parser.script !== \"\") {\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n}\n\nSAXParser.prototype =\n  { end: function () { end(this) }\n  , write: write\n  , resume: function () { this.error = null; return this }\n  , close: function () { return this.write(null) }\n  , flush: function () { flushBuffers(this) }\n  }\n\ntry {\n  var Stream = require(\"stream\").Stream\n} catch (ex) {\n  var Stream = function () {}\n}\n\n\nvar streamWraps = sax.EVENTS.filter(function (ev) {\n  return ev !== \"error\" && ev !== \"end\"\n})\n\nfunction createStream (strict, opt) {\n  return new SAXStream(strict, opt)\n}\n\nfunction SAXStream (strict, opt) {\n  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)\n\n  Stream.apply(this)\n\n  this._parser = new SAXParser(strict, opt)\n  this.writable = true\n  this.readable = true\n\n\n  var me = this\n\n  this._parser.onend = function () {\n    me.emit(\"end\")\n  }\n\n  this._parser.onerror = function (er) {\n    me.emit(\"error\", er)\n\n    // if didn't throw, then means error was handled.\n    // go ahead and clear error, so we can write again.\n    me._parser.error = null\n  }\n\n  this._decoder = null;\n\n  streamWraps.forEach(function (ev) {\n    Object.defineProperty(me, \"on\" + ev, {\n      get: function () { return me._parser[\"on\" + ev] },\n      set: function (h) {\n        if (!h) {\n          me.removeAllListeners(ev)\n          return me._parser[\"on\"+ev] = h\n        }\n        me.on(ev, h)\n      },\n      enumerable: true,\n      configurable: false\n    })\n  })\n}\n\nSAXStream.prototype = Object.create(Stream.prototype,\n  { constructor: { value: SAXStream } })\n\nSAXStream.prototype.write = function (data) {\n  if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n    if (!this._decoder) {\n      var SD = require('string_decoder').StringDecoder\n      this._decoder = new SD('utf8')\n    }\n    data = this._decoder.write(data);\n  }\n\n  this._parser.write(data.toString())\n  this.emit(\"data\", data)\n  return true\n}\n\nSAXStream.prototype.end = function (chunk) {\n  if (chunk && chunk.length) this.write(chunk)\n  this._parser.end()\n  return true\n}\n\nSAXStream.prototype.on = function (ev, handler) {\n  var me = this\n  if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n    me._parser[\"on\"+ev] = function () {\n      var args = arguments.length === 1 ? [arguments[0]]\n               : Array.apply(null, arguments)\n      args.splice(0, 0, ev)\n      me.emit.apply(me, args)\n    }\n  }\n\n  return Stream.prototype.on.call(me, ev, handler)\n}\n\n\n\n// character classes and tokens\nvar whitespace = \"/r/n/t \"\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  , number = \"0124356789\"\n  , letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  // (Letter | \"_\" | \":\")\n  , quote = \"'/\"\"\n  , entity = number+letter+\"#\"\n  , attribEnd = whitespace + \">\"\n  , CDATA = \"[CDATA[\"\n  , DOCTYPE = \"DOCTYPE\"\n  , XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\n  , XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\n  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n// turn all the string character sets into character class objects.\nwhitespace = charClass(whitespace)\nnumber = charClass(number)\nletter = charClass(letter)\n\n// http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n// This implementation works on strings, a single character at a time\n// as such, it cannot ever support astral-plane characters (10000-EFFFF)\n// without a significant breaking change to either this  parser, or the\n// JavaScript language.  Implementation of an emoji-capable xml parser\n// is left as an exercise for the reader.\nvar nameStart = /[:_A-Za-z/u00C0-/u00D6/u00D8-/u00F6/u00F8-/u02FF/u0370-/u037D/u037F-/u1FFF/u200C-/u200D/u2070-/u218F/u2C00-/u2FEF/u3001-/uD7FF/uF900-/uFDCF/uFDF0-/uFFFD]/\n\nvar nameBody = /[:_A-Za-z/u00C0-/u00D6/u00D8-/u00F6/u00F8-/u02FF/u0370-/u037D/u037F-/u1FFF/u200C-/u200D/u2070-/u218F/u2C00-/u2FEF/u3001-/uD7FF/uF900-/uFDCF/uFDF0-/uFFFD/u00B7/u0300-/u036F/u203F-/u2040/./d-]/\n\nquote = charClass(quote)\nentity = charClass(entity)\nattribEnd = charClass(attribEnd)\n\nfunction charClass (str) {\n  return str.split(\"\").reduce(function (s, c) {\n    s[c] = true\n    return s\n  }, {})\n}\n\nfunction isRegExp (c) {\n  return Object.prototype.toString.call(c) === '[object RegExp]'\n}\n\nfunction is (charclass, c) {\n  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n}\n\nfunction not (charclass, c) {\n  return !is(charclass, c)\n}\n\nvar S = 0\nsax.STATE =\n{ BEGIN                     : S++\n, TEXT                      : S++ // general stuff\n, TEXT_ENTITY               : S++ // &amp and such.\n, OPEN_WAKA                 : S++ // <\n, SGML_DECL                 : S++ // <!BLARG\n, SGML_DECL_QUOTED          : S++ // <!BLARG foo \"bar\n, DOCTYPE                   : S++ // <!DOCTYPE\n, DOCTYPE_QUOTED            : S++ // <!DOCTYPE \"//blah\n, DOCTYPE_DTD               : S++ // <!DOCTYPE \"//blah\" [ ...\n, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE \"//blah\" [ \"foo\n, COMMENT_STARTING          : S++ // <!-\n, COMMENT                   : S++ // <!--\n, COMMENT_ENDING            : S++ // <!-- blah -\n, COMMENT_ENDED             : S++ // <!-- blah --\n, CDATA                     : S++ // <![CDATA[ something\n, CDATA_ENDING              : S++ // ]\n, CDATA_ENDING_2            : S++ // ]]\n, PROC_INST                 : S++ // <?hi\n, PROC_INST_BODY            : S++ // <?hi there\n, PROC_INST_ENDING          : S++ // <?hi \"there\" ?\n, OPEN_TAG                  : S++ // <strong\n, OPEN_TAG_SLASH            : S++ // <strong /\n, ATTRIB                    : S++ // <a\n, ATTRIB_NAME               : S++ // <a foo\n, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _\n, ATTRIB_VALUE              : S++ // <a foo=\n, ATTRIB_VALUE_QUOTED       : S++ // <a foo=\"bar\n, ATTRIB_VALUE_CLOSED       : S++ // <a foo=\"bar\"\n, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar\n, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar=\"&quot;\"\n, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;\n, CLOSE_TAG                 : S++ // </a\n, CLOSE_TAG_SAW_WHITE       : S++ // </a   >\n, SCRIPT                    : S++ // <script> ...\n, SCRIPT_ENDING             : S++ // <script> ... <\n}\n\nsax.ENTITIES =\n{ \"amp\" : \"&\"\n, \"gt\" : \">\"\n, \"lt\" : \"<\"\n, \"quot\" : \"/\"\"\n, \"apos\" : \"'\"\n, \"AElig\" : 198\n, \"Aacute\" : 193\n, \"Acirc\" : 194\n, \"Agrave\" : 192\n, \"Aring\" : 197\n, \"Atilde\" : 195\n, \"Auml\" : 196\n, \"Ccedil\" : 199\n, \"ETH\" : 208\n, \"Eacute\" : 201\n, \"Ecirc\" : 202\n, \"Egrave\" : 200\n, \"Euml\" : 203\n, \"Iacute\" : 205\n, \"Icirc\" : 206\n, \"Igrave\" : 204\n, \"Iuml\" : 207\n, \"Ntilde\" : 209\n, \"Oacute\" : 211\n, \"Ocirc\" : 212\n, \"Ograve\" : 210\n, \"Oslash\" : 216\n, \"Otilde\" : 213\n, \"Ouml\" : 214\n, \"THORN\" : 222\n, \"Uacute\" : 218\n, \"Ucirc\" : 219\n, \"Ugrave\" : 217\n, \"Uuml\" : 220\n, \"Yacute\" : 221\n, \"aacute\" : 225\n, \"acirc\" : 226\n, \"aelig\" : 230\n, \"agrave\" : 224\n, \"aring\" : 229\n, \"atilde\" : 227\n, \"auml\" : 228\n, \"ccedil\" : 231\n, \"eacute\" : 233\n, \"ecirc\" : 234\n, \"egrave\" : 232\n, \"eth\" : 240\n, \"euml\" : 235\n, \"iacute\" : 237\n, \"icirc\" : 238\n, \"igrave\" : 236\n, \"iuml\" : 239\n, \"ntilde\" : 241\n, \"oacute\" : 243\n, \"ocirc\" : 244\n, \"ograve\" : 242\n, \"oslash\" : 248\n, \"otilde\" : 245\n, \"ouml\" : 246\n, \"szlig\" : 223\n, \"thorn\" : 254\n, \"uacute\" : 250\n, \"ucirc\" : 251\n, \"ugrave\" : 249\n, \"uuml\" : 252\n, \"yacute\" : 253\n, \"yuml\" : 255\n, \"copy\" : 169\n, \"reg\" : 174\n, \"nbsp\" : 160\n, \"iexcl\" : 161\n, \"cent\" : 162\n, \"pound\" : 163\n, \"curren\" : 164\n, \"yen\" : 165\n, \"brvbar\" : 166\n, \"sect\" : 167\n, \"uml\" : 168\n, \"ordf\" : 170\n, \"laquo\" : 171\n, \"not\" : 172\n, \"shy\" : 173\n, \"macr\" : 175\n, \"deg\" : 176\n, \"plusmn\" : 177\n, \"sup1\" : 185\n, \"sup2\" : 178\n, \"sup3\" : 179\n, \"acute\" : 180\n, \"micro\" : 181\n, \"para\" : 182\n, \"middot\" : 183\n, \"cedil\" : 184\n, \"ordm\" : 186\n, \"raquo\" : 187\n, \"frac14\" : 188\n, \"frac12\" : 189\n, \"frac34\" : 190\n, \"iquest\" : 191\n, \"times\" : 215\n, \"divide\" : 247\n, \"OElig\" : 338\n, \"oelig\" : 339\n, \"Scaron\" : 352\n, \"scaron\" : 353\n, \"Yuml\" : 376\n, \"fnof\" : 402\n, \"circ\" : 710\n, \"tilde\" : 732\n, \"Alpha\" : 913\n, \"Beta\" : 914\n, \"Gamma\" : 915\n, \"Delta\" : 916\n, \"Epsilon\" : 917\n, \"Zeta\" : 918\n, \"Eta\" : 919\n, \"Theta\" : 920\n, \"Iota\" : 921\n, \"Kappa\" : 922\n, \"Lambda\" : 923\n, \"Mu\" : 924\n, \"Nu\" : 925\n, \"Xi\" : 926\n, \"Omicron\" : 927\n, \"Pi\" : 928\n, \"Rho\" : 929\n, \"Sigma\" : 931\n, \"Tau\" : 932\n, \"Upsilon\" : 933\n, \"Phi\" : 934\n, \"Chi\" : 935\n, \"Psi\" : 936\n, \"Omega\" : 937\n, \"alpha\" : 945\n, \"beta\" : 946\n, \"gamma\" : 947\n, \"delta\" : 948\n, \"epsilon\" : 949\n, \"zeta\" : 950\n, \"eta\" : 951\n, \"theta\" : 952\n, \"iota\" : 953\n, \"kappa\" : 954\n, \"lambda\" : 955\n, \"mu\" : 956\n, \"nu\" : 957\n, \"xi\" : 958\n, \"omicron\" : 959\n, \"pi\" : 960\n, \"rho\" : 961\n, \"sigmaf\" : 962\n, \"sigma\" : 963\n, \"tau\" : 964\n, \"upsilon\" : 965\n, \"phi\" : 966\n, \"chi\" : 967\n, \"psi\" : 968\n, \"omega\" : 969\n, \"thetasym\" : 977\n, \"upsih\" : 978\n, \"piv\" : 982\n, \"ensp\" : 8194\n, \"emsp\" : 8195\n, \"thinsp\" : 8201\n, \"zwnj\" : 8204\n, \"zwj\" : 8205\n, \"lrm\" : 8206\n, \"rlm\" : 8207\n, \"ndash\" : 8211\n, \"mdash\" : 8212\n, \"lsquo\" : 8216\n, \"rsquo\" : 8217\n, \"sbquo\" : 8218\n, \"ldquo\" : 8220\n, \"rdquo\" : 8221\n, \"bdquo\" : 8222\n, \"dagger\" : 8224\n, \"Dagger\" : 8225\n, \"bull\" : 8226\n, \"hellip\" : 8230\n, \"permil\" : 8240\n, \"prime\" : 8242\n, \"Prime\" : 8243\n, \"lsaquo\" : 8249\n, \"rsaquo\" : 8250\n, \"oline\" : 8254\n, \"frasl\" : 8260\n, \"euro\" : 8364\n, \"image\" : 8465\n, \"weierp\" : 8472\n, \"real\" : 8476\n, \"trade\" : 8482\n, \"alefsym\" : 8501\n, \"larr\" : 8592\n, \"uarr\" : 8593\n, \"rarr\" : 8594\n, \"darr\" : 8595\n, \"harr\" : 8596\n, \"crarr\" : 8629\n, \"lArr\" : 8656\n, \"uArr\" : 8657\n, \"rArr\" : 8658\n, \"dArr\" : 8659\n, \"hArr\" : 8660\n, \"forall\" : 8704\n, \"part\" : 8706\n, \"exist\" : 8707\n, \"empty\" : 8709\n, \"nabla\" : 8711\n, \"isin\" : 8712\n, \"notin\" : 8713\n, \"ni\" : 8715\n, \"prod\" : 8719\n, \"sum\" : 8721\n, \"minus\" : 8722\n, \"lowast\" : 8727\n, \"radic\" : 8730\n, \"prop\" : 8733\n, \"infin\" : 8734\n, \"ang\" : 8736\n, \"and\" : 8743\n, \"or\" : 8744\n, \"cap\" : 8745\n, \"cup\" : 8746\n, \"int\" : 8747\n, \"there4\" : 8756\n, \"sim\" : 8764\n, \"cong\" : 8773\n, \"asymp\" : 8776\n, \"ne\" : 8800\n, \"equiv\" : 8801\n, \"le\" : 8804\n, \"ge\" : 8805\n, \"sub\" : 8834\n, \"sup\" : 8835\n, \"nsub\" : 8836\n, \"sube\" : 8838\n, \"supe\" : 8839\n, \"oplus\" : 8853\n, \"otimes\" : 8855\n, \"perp\" : 8869\n, \"sdot\" : 8901\n, \"lceil\" : 8968\n, \"rceil\" : 8969\n, \"lfloor\" : 8970\n, \"rfloor\" : 8971\n, \"lang\" : 9001\n, \"rang\" : 9002\n, \"loz\" : 9674\n, \"spades\" : 9824\n, \"clubs\" : 9827\n, \"hearts\" : 9829\n, \"diams\" : 9830\n}\n\nObject.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n})\n\nfor (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S\n\n// shorthand\nS = sax.STATE\n\nfunction emit (parser, event, data) {\n  parser[event] && parser[event](data)\n}\n\nfunction emitNode (parser, nodeType, data) {\n  if (parser.textNode) closeText(parser)\n  emit(parser, nodeType, data)\n}\n\nfunction closeText (parser) {\n  parser.textNode = textopts(parser.opt, parser.textNode)\n  if (parser.textNode) emit(parser, \"ontext\", parser.textNode)\n  parser.textNode = \"\"\n}\n\nfunction textopts (opt, text) {\n  if (opt.trim) text = text.trim()\n  if (opt.normalize) text = text.replace(//s+/g, \" \")\n  return text\n}\n\nfunction error (parser, er) {\n  closeText(parser)\n  if (parser.trackPosition) {\n    er += \"/nLine: \"+parser.line+\n          \"/nColumn: \"+parser.column+\n          \"/nChar: \"+parser.c\n  }\n  er = new Error(er)\n  parser.error = er\n  emit(parser, \"onerror\", er)\n  return parser\n}\n\nfunction end (parser) {\n  if (!parser.closedRoot) strictFail(parser, \"Unclosed root tag\")\n  if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, \"Unexpected end\")\n  closeText(parser)\n  parser.c = \"\"\n  parser.closed = true\n  emit(parser, \"onend\")\n  SAXParser.call(parser, parser.strict, parser.opt)\n  return parser\n}\n\nfunction strictFail (parser, message) {\n  if (typeof parser !== 'object' || !(parser instanceof SAXParser))\n    throw new Error('bad call to strictFail');\n  if (parser.strict) error(parser, message)\n}\n\nfunction newTag (parser) {\n  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n  var parent = parser.tags[parser.tags.length - 1] || parser\n    , tag = parser.tag = { name : parser.tagName, attributes : {} }\n\n  // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n  if (parser.opt.xmlns) tag.ns = parent.ns\n  parser.attribList.length = 0\n}\n\nfunction qname (name, attribute) {\n  var i = name.indexOf(\":\")\n    , qualName = i < 0 ? [ \"\", name ] : name.split(\":\")\n    , prefix = qualName[0]\n    , local = qualName[1]\n\n  // <x \"xmlns\"=\"http://foo\">\n  if (attribute && name === \"xmlns\") {\n    prefix = \"xmlns\"\n    local = \"\"\n  }\n\n  return { prefix: prefix, local: local }\n}\n\nfunction attrib (parser) {\n  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()\n\n  if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n    return parser.attribName = parser.attribValue = \"\"\n  }\n\n  if (parser.opt.xmlns) {\n    var qn = qname(parser.attribName, true)\n      , prefix = qn.prefix\n      , local = qn.local\n\n    if (prefix === \"xmlns\") {\n      // namespace binding attribute; push the binding into scope\n      if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n        strictFail( parser\n                  , \"xml: prefix must be bound to \" + XML_NAMESPACE + \"/n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n        strictFail( parser\n                  , \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"/n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else {\n        var tag = parser.tag\n          , parent = parser.tags[parser.tags.length - 1] || parser\n        if (tag.ns === parent.ns) {\n          tag.ns = Object.create(parent.ns)\n        }\n        tag.ns[local] = parser.attribValue\n      }\n    }\n\n    // defer onattribute events until all attributes have been seen\n    // so any new bindings can take effect; preserve attribute order\n    // so deferred events can be emitted in document order\n    parser.attribList.push([parser.attribName, parser.attribValue])\n  } else {\n    // in non-xmlns mode, we can emit the event right away\n    parser.tag.attributes[parser.attribName] = parser.attribValue\n    emitNode( parser\n            , \"onattribute\"\n            , { name: parser.attribName\n              , value: parser.attribValue } )\n  }\n\n  parser.attribName = parser.attribValue = \"\"\n}\n\nfunction openTag (parser, selfClosing) {\n  if (parser.opt.xmlns) {\n    // emit namespace binding events\n    var tag = parser.tag\n\n    // add namespace info to tag\n    var qn = qname(parser.tagName)\n    tag.prefix = qn.prefix\n    tag.local = qn.local\n    tag.uri = tag.ns[qn.prefix] || \"\"\n\n    if (tag.prefix && !tag.uri) {\n      strictFail(parser, \"Unbound namespace prefix: \"\n                       + JSON.stringify(parser.tagName))\n      tag.uri = qn.prefix\n    }\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (tag.ns && parent.ns !== tag.ns) {\n      Object.keys(tag.ns).forEach(function (p) {\n        emitNode( parser\n                , \"onopennamespace\"\n                , { prefix: p , uri: tag.ns[p] } )\n      })\n    }\n\n    // handle deferred onattribute events\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (var i = 0, l = parser.attribList.length; i < l; i ++) {\n      var nv = parser.attribList[i]\n      var name = nv[0]\n        , value = nv[1]\n        , qualName = qname(name, true)\n        , prefix = qualName.prefix\n        , local = qualName.local\n        , uri = prefix == \"\" ? \"\" : (tag.ns[prefix] || \"\")\n        , a = { name: name\n              , value: value\n              , prefix: prefix\n              , local: local\n              , uri: uri\n              }\n\n      // if there's any attributes with an undefined namespace,\n      // then fail on them now.\n      if (prefix && prefix != \"xmlns\" && !uri) {\n        strictFail(parser, \"Unbound namespace prefix: \"\n                         + JSON.stringify(prefix))\n        a.uri = prefix\n      }\n      parser.tag.attributes[name] = a\n      emitNode(parser, \"onattribute\", a)\n    }\n    parser.attribList.length = 0\n  }\n\n  parser.tag.isSelfClosing = !!selfClosing\n\n  // process the tag\n  parser.sawRoot = true\n  parser.tags.push(parser.tag)\n  emitNode(parser, \"onopentag\", parser.tag)\n  if (!selfClosing) {\n    // special case for <script> in non-strict mode.\n    if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n      parser.state = S.SCRIPT\n    } else {\n      parser.state = S.TEXT\n    }\n    parser.tag = null\n    parser.tagName = \"\"\n  }\n  parser.attribName = parser.attribValue = \"\"\n  parser.attribList.length = 0\n}\n\nfunction closeTag (parser) {\n  if (!parser.tagName) {\n    strictFail(parser, \"Weird empty close tag.\")\n    parser.textNode += \"</>\"\n    parser.state = S.TEXT\n    return\n  }\n\n  if (parser.script) {\n    if (parser.tagName !== \"script\") {\n      parser.script += \"</\" + parser.tagName + \">\"\n      parser.tagName = \"\"\n      parser.state = S.SCRIPT\n      return\n    }\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n\n  // first make sure that the closing tag actually exists.\n  // <a><b></c></b></a> will close everything, otherwise.\n  var t = parser.tags.length\n  var tagName = parser.tagName\n  if (!parser.strict) tagName = tagName[parser.looseCase]()\n  var closeTo = tagName\n  while (t --) {\n    var close = parser.tags[t]\n    if (close.name !== closeTo) {\n      // fail the first time in strict mode\n      strictFail(parser, \"Unexpected close tag\")\n    } else break\n  }\n\n  // didn't find it.  we already failed for strict, so just abort.\n  if (t < 0) {\n    strictFail(parser, \"Unmatched closing tag: \"+parser.tagName)\n    parser.textNode += \"</\" + parser.tagName + \">\"\n    parser.state = S.TEXT\n    return\n  }\n  parser.tagName = tagName\n  var s = parser.tags.length\n  while (s --> t) {\n    var tag = parser.tag = parser.tags.pop()\n    parser.tagName = parser.tag.name\n    emitNode(parser, \"onclosetag\", parser.tagName)\n\n    var x = {}\n    for (var i in tag.ns) x[i] = tag.ns[i]\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (parser.opt.xmlns && tag.ns !== parent.ns) {\n      // remove namespace bindings introduced by tag\n      Object.keys(tag.ns).forEach(function (p) {\n        var n = tag.ns[p]\n        emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n })\n      })\n    }\n  }\n  if (t === 0) parser.closedRoot = true\n  parser.tagName = parser.attribValue = parser.attribName = \"\"\n  parser.attribList.length = 0\n  parser.state = S.TEXT\n}\n\nfunction parseEntity (parser) {\n  var entity = parser.entity\n    , entityLC = entity.toLowerCase()\n    , num\n    , numStr = \"\"\n  if (parser.ENTITIES[entity])\n    return parser.ENTITIES[entity]\n  if (parser.ENTITIES[entityLC])\n    return parser.ENTITIES[entityLC]\n  entity = entityLC\n  if (entity.charAt(0) === \"#\") {\n    if (entity.charAt(1) === \"x\") {\n      entity = entity.slice(2)\n      num = parseInt(entity, 16)\n      numStr = num.toString(16)\n    } else {\n      entity = entity.slice(1)\n      num = parseInt(entity, 10)\n      numStr = num.toString(10)\n    }\n  }\n  entity = entity.replace(/^0+/, \"\")\n  if (numStr.toLowerCase() !== entity) {\n    strictFail(parser, \"Invalid character entity\")\n    return \"&\"+parser.entity + \";\"\n  }\n\n  return String.fromCodePoint(num)\n}\n\nfunction write (chunk) {\n  var parser = this\n  if (this.error) throw this.error\n  if (parser.closed) return error(parser,\n    \"Cannot write after close. Assign an onready handler.\")\n  if (chunk === null) return end(parser)\n  var i = 0, c = \"\"\n  while (parser.c = c = chunk.charAt(i++)) {\n    if (parser.trackPosition) {\n      parser.position ++\n      if (c === \"/n\") {\n        parser.line ++\n        parser.column = 0\n      } else parser.column ++\n    }\n    switch (parser.state) {\n\n      case S.BEGIN:\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else if (not(whitespace,c)) {\n          // have to process this as a text node.\n          // weird, but happens.\n          strictFail(parser, \"Non-whitespace before first tag.\")\n          parser.textNode = c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.TEXT:\n        if (parser.sawRoot && !parser.closedRoot) {\n          var starti = i-1\n          while (c && c!==\"<\" && c!==\"&\") {\n            c = chunk.charAt(i++)\n            if (c && parser.trackPosition) {\n              parser.position ++\n              if (c === \"/n\") {\n                parser.line ++\n                parser.column = 0\n              } else parser.column ++\n            }\n          }\n          parser.textNode += chunk.substring(starti, i-1)\n        }\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else {\n          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))\n            strictFail(parser, \"Text data outside of root node.\")\n          if (c === \"&\") parser.state = S.TEXT_ENTITY\n          else parser.textNode += c\n        }\n      continue\n\n      case S.SCRIPT:\n        // only non-strict\n        if (c === \"<\") {\n          parser.state = S.SCRIPT_ENDING\n        } else parser.script += c\n      continue\n\n      case S.SCRIPT_ENDING:\n        if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n        } else {\n          parser.script += \"<\" + c\n          parser.state = S.SCRIPT\n        }\n      continue\n\n      case S.OPEN_WAKA:\n        // either a /, ?, !, or text is coming next.\n        if (c === \"!\") {\n          parser.state = S.SGML_DECL\n          parser.sgmlDecl = \"\"\n        } else if (is(whitespace, c)) {\n          // wait for it...\n        } else if (is(nameStart,c)) {\n          parser.state = S.OPEN_TAG\n          parser.tagName = c\n        } else if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n          parser.tagName = \"\"\n        } else if (c === \"?\") {\n          parser.state = S.PROC_INST\n          parser.procInstName = parser.procInstBody = \"\"\n        } else {\n          strictFail(parser, \"Unencoded <\")\n          // if there was some whitespace, then add that in.\n          if (parser.startTagPosition + 1 < parser.position) {\n            var pad = parser.position - parser.startTagPosition\n            c = new Array(pad).join(\" \") + c\n          }\n          parser.textNode += \"<\" + c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.SGML_DECL:\n        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {\n          emitNode(parser, \"onopencdata\")\n          parser.state = S.CDATA\n          parser.sgmlDecl = \"\"\n          parser.cdata = \"\"\n        } else if (parser.sgmlDecl+c === \"--\") {\n          parser.state = S.COMMENT\n          parser.comment = \"\"\n          parser.sgmlDecl = \"\"\n        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {\n          parser.state = S.DOCTYPE\n          if (parser.doctype || parser.sawRoot) strictFail(parser,\n            \"Inappropriately located doctype declaration\")\n          parser.doctype = \"\"\n          parser.sgmlDecl = \"\"\n        } else if (c === \">\") {\n          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl)\n          parser.sgmlDecl = \"\"\n          parser.state = S.TEXT\n        } else if (is(quote, c)) {\n          parser.state = S.SGML_DECL_QUOTED\n          parser.sgmlDecl += c\n        } else parser.sgmlDecl += c\n      continue\n\n      case S.SGML_DECL_QUOTED:\n        if (c === parser.q) {\n          parser.state = S.SGML_DECL\n          parser.q = \"\"\n        }\n        parser.sgmlDecl += c\n      continue\n\n      case S.DOCTYPE:\n        if (c === \">\") {\n          parser.state = S.TEXT\n          emitNode(parser, \"ondoctype\", parser.doctype)\n          parser.doctype = true // just remember that we saw it.\n        } else {\n          parser.doctype += c\n          if (c === \"[\") parser.state = S.DOCTYPE_DTD\n          else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_QUOTED\n            parser.q = c\n          }\n        }\n      continue\n\n      case S.DOCTYPE_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.q = \"\"\n          parser.state = S.DOCTYPE\n        }\n      continue\n\n      case S.DOCTYPE_DTD:\n        parser.doctype += c\n        if (c === \"]\") parser.state = S.DOCTYPE\n        else if (is(quote,c)) {\n          parser.state = S.DOCTYPE_DTD_QUOTED\n          parser.q = c\n        }\n      continue\n\n      case S.DOCTYPE_DTD_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.state = S.DOCTYPE_DTD\n          parser.q = \"\"\n        }\n      continue\n\n      case S.COMMENT:\n        if (c === \"-\") parser.state = S.COMMENT_ENDING\n        else parser.comment += c\n      continue\n\n      case S.COMMENT_ENDING:\n        if (c === \"-\") {\n          parser.state = S.COMMENT_ENDED\n          parser.comment = textopts(parser.opt, parser.comment)\n          if (parser.comment) emitNode(parser, \"oncomment\", parser.comment)\n          parser.comment = \"\"\n        } else {\n          parser.comment += \"-\" + c\n          parser.state = S.COMMENT\n        }\n      continue\n\n      case S.COMMENT_ENDED:\n        if (c !== \">\") {\n          strictFail(parser, \"Malformed comment\")\n          // allow <!-- blah -- bloo --> in non-strict mode,\n          // which is a comment of \" blah -- bloo \"\n          parser.comment += \"--\" + c\n          parser.state = S.COMMENT\n        } else parser.state = S.TEXT\n      continue\n\n      case S.CDATA:\n        if (c === \"]\") parser.state = S.CDATA_ENDING\n        else parser.cdata += c\n      continue\n\n      case S.CDATA_ENDING:\n        if (c === \"]\") parser.state = S.CDATA_ENDING_2\n        else {\n          parser.cdata += \"]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.CDATA_ENDING_2:\n        if (c === \">\") {\n          if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata)\n          emitNode(parser, \"onclosecdata\")\n          parser.cdata = \"\"\n          parser.state = S.TEXT\n        } else if (c === \"]\") {\n          parser.cdata += \"]\"\n        } else {\n          parser.cdata += \"]]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.PROC_INST:\n        if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY\n        else parser.procInstName += c\n      continue\n\n      case S.PROC_INST_BODY:\n        if (!parser.procInstBody && is(whitespace, c)) continue\n        else if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else parser.procInstBody += c\n      continue\n\n      case S.PROC_INST_ENDING:\n        if (c === \">\") {\n          emitNode(parser, \"onprocessinginstruction\", {\n            name : parser.procInstName,\n            body : parser.procInstBody\n          })\n          parser.procInstName = parser.procInstBody = \"\"\n          parser.state = S.TEXT\n        } else {\n          parser.procInstBody += \"?\" + c\n          parser.state = S.PROC_INST_BODY\n        }\n      continue\n\n      case S.OPEN_TAG:\n        if (is(nameBody, c)) parser.tagName += c\n        else {\n          newTag(parser)\n          if (c === \">\") openTag(parser)\n          else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n          else {\n            if (not(whitespace, c)) strictFail(\n              parser, \"Invalid character in tag name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.OPEN_TAG_SLASH:\n        if (c === \">\") {\n          openTag(parser, true)\n          closeTag(parser)\n        } else {\n          strictFail(parser, \"Forward-slash in opening tag not followed by >\")\n          parser.state = S.ATTRIB\n        }\n      continue\n\n      case S.ATTRIB:\n        // haven't read the attribute name yet.\n        if (is(whitespace, c)) continue\n        else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (c === \">\") {\n          strictFail(parser, \"Attribute without value\")\n          parser.attribValue = parser.attribName\n          attrib(parser)\n          openTag(parser)\n        }\n        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE\n        else if (is(nameBody, c)) parser.attribName += c\n        else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME_SAW_WHITE:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) continue\n        else {\n          strictFail(parser, \"Attribute without value\")\n          parser.tag.attributes[parser.attribName] = \"\"\n          parser.attribValue = \"\"\n          emitNode(parser, \"onattribute\",\n                   { name : parser.attribName, value : \"\" })\n          parser.attribName = \"\"\n          if (c === \">\") openTag(parser)\n          else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, \"Invalid attribute name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.ATTRIB_VALUE:\n        if (is(whitespace, c)) continue\n        else if (is(quote, c)) {\n          parser.q = c\n          parser.state = S.ATTRIB_VALUE_QUOTED\n        } else {\n          strictFail(parser, \"Unquoted attribute value\")\n          parser.state = S.ATTRIB_VALUE_UNQUOTED\n          parser.attribValue = c\n        }\n      continue\n\n      case S.ATTRIB_VALUE_QUOTED:\n        if (c !== parser.q) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        parser.q = \"\"\n        parser.state = S.ATTRIB_VALUE_CLOSED\n      continue\n\n      case S.ATTRIB_VALUE_CLOSED:\n        if (is(whitespace, c)) {\n          parser.state = S.ATTRIB\n        } else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          strictFail(parser, \"No whitespace between attributes\")\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_VALUE_UNQUOTED:\n        if (not(attribEnd,c)) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        if (c === \">\") openTag(parser)\n        else parser.state = S.ATTRIB\n      continue\n\n      case S.CLOSE_TAG:\n        if (!parser.tagName) {\n          if (is(whitespace, c)) continue\n          else if (not(nameStart, c)) {\n            if (parser.script) {\n              parser.script += \"</\" + c\n              parser.state = S.SCRIPT\n            } else {\n              strictFail(parser, \"Invalid tagname in closing tag.\")\n            }\n          } else parser.tagName = c\n        }\n        else if (c === \">\") closeTag(parser)\n        else if (is(nameBody, c)) parser.tagName += c\n        else if (parser.script) {\n          parser.script += \"</\" + parser.tagName\n          parser.tagName = \"\"\n          parser.state = S.SCRIPT\n        } else {\n          if (not(whitespace, c)) strictFail(parser,\n            \"Invalid tagname in closing tag\")\n          parser.state = S.CLOSE_TAG_SAW_WHITE\n        }\n      continue\n\n      case S.CLOSE_TAG_SAW_WHITE:\n        if (is(whitespace, c)) continue\n        if (c === \">\") closeTag(parser)\n        else strictFail(parser, \"Invalid characters in closing tag\")\n      continue\n\n      case S.TEXT_ENTITY:\n      case S.ATTRIB_VALUE_ENTITY_Q:\n      case S.ATTRIB_VALUE_ENTITY_U:\n        switch(parser.state) {\n          case S.TEXT_ENTITY:\n            var returnState = S.TEXT, buffer = \"textNode\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_Q:\n            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = \"attribValue\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = \"attribValue\"\n          break\n        }\n        if (c === \";\") {\n          parser[buffer] += parseEntity(parser)\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n        else if (is(entity, c)) parser.entity += c\n        else {\n          strictFail(parser, \"Invalid character entity\")\n          parser[buffer] += \"&\" + parser.entity + c\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n      continue\n\n      default:\n        throw new Error(parser, \"Unknown state: \" + parser.state)\n    }\n  } // while\n  // cdata blocks can get very big under normal conditions. emit and move on.\n  // if (parser.state === S.CDATA && parser.cdata) {\n  //   emitNode(parser, \"oncdata\", parser.cdata)\n  //   parser.cdata = \"\"\n  // }\n  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)\n  return parser\n}\n\n/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\nif (!String.fromCodePoint) {\n        (function() {\n                var stringFromCharCode = String.fromCharCode;\n                var floor = Math.floor;\n                var fromCodePoint = function() {\n                        var MAX_SIZE = 0x4000;\n                        var codeUnits = [];\n                        var highSurrogate;\n                        var lowSurrogate;\n                        var index = -1;\n                        var length = arguments.length;\n                        if (!length) {\n                                return '';\n                        }\n                        var result = '';\n                        while (++index < length) {\n                                var codePoint = Number(arguments[index]);\n                                if (\n                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                                        codePoint < 0 || // not a valid Unicode code point\n                                        codePoint > 0x10FFFF || // not a valid Unicode code point\n                                        floor(codePoint) != codePoint // not an integer\n                                ) {\n                                        throw RangeError('Invalid code point: ' + codePoint);\n                                }\n                                if (codePoint <= 0xFFFF) { // BMP code point\n                                        codeUnits.push(codePoint);\n                                } else { // Astral code point; split in surrogate halves\n                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                                        codePoint -= 0x10000;\n                                        highSurrogate = (codePoint >> 10) + 0xD800;\n                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n                                        codeUnits.push(highSurrogate, lowSurrogate);\n                                }\n                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n                                        result += stringFromCharCode.apply(null, codeUnits);\n                                        codeUnits.length = 0;\n                                }\n                        }\n                        return result;\n                };\n                if (Object.defineProperty) {\n                        Object.defineProperty(String, 'fromCodePoint', {\n                                'value': fromCodePoint,\n                                'configurable': true,\n                                'writable': true\n                        });\n                } else {\n                        String.fromCodePoint = fromCodePoint;\n                }\n        }());\n}\n\n})(typeof exports === \"undefined\" ? sax = {} : exports);\n","'use strict';\n\nvar domify = require(535),\n    domClasses = require(531),\n    domMatches = require(537),\n    domDelegate = require(534),\n    domQuery = require(538),\n    domEvent = require(536),\n    domAttr = require(530);\n\nvar filter = require(384),\n    assign = require(516);\n\nvar inherits = require(368);\n\nvar EventEmitter = require(363);\n\nvar DEFAULT_OPTIONS = {\n  scrollSymbolLeft: '‹',\n  scrollSymbolRight: '›'\n};\n\n\n/**\n * This component adds the functionality to scroll over a list of tabs.\n *\n * It adds scroll buttons on the left and right side of the tabs container\n * if not all tabs are visible. It also adds a mouse wheel listener on the\n * container.\n *\n * If either a button is clicked or the mouse wheel is used over the tabs,\n * a 'scroll' event is being fired. This event contains the node elements\n * of the new and old active tab, and the direction in which the tab has\n * changed relative to the old active tab.\n *\n * @example:\n * (1) provide a tabs-container:\n *\n * var $el = (\n *   <div>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-left\"></span>\n *     <ul class=\"my-tabs-container\">\n *       <li class=\"my-tab i-am-active\"></li>\n *       <li class=\"my-tab\"></li>\n *       <li class=\"my-tab ignore-me\"></li>\n *     </ul>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-right\"></span>\n *   </div>\n * );\n *\n *\n * (2) initialize scrollTabs:\n *\n *  var scroller = scrollTabs(tabBarNode, {\n *    selectors: {\n *      tabsContainer: '.my-tabs-container',\n *      tab: '.my-tab',\n *      ignore: '.ignore-me',\n *      active: '.i-am-active'\n *    }\n *  });\n *\n *\n * (3) listen to the scroll event:\n *\n * scroller.on('scroll', function(newActiveNode, oldActiveNode, direction) {\n *   // direction is any of (-1: left, 1: right)\n *   // activate the new active tab\n * });\n *\n *\n * (4) update the scroller if tabs change and or the tab container resizes:\n *\n * scroller.update();\n *\n *\n * @param  {DOMElement} el\n * @param  {Object} options\n * @param  {Object} options.selectors\n * @param  {String} options.selectors.tabsContainer the container all tabs are contained in\n * @param  {String} options.selectors.tab a single tab inside the tab container\n * @param  {String} options.selectors.ignore tabs that should be ignored during scroll left/right\n * @param  {String} options.selectors.active selector for the current active tab\n * @param  {String} [options.scrollSymbolLeft]\n * @param  {String} [options.scrollSymbolRight]\n */\nfunction ScrollTabs($el, options) {\n\n  // we are an event emitter\n  EventEmitter.call(this);\n\n  this.options = options = assign({}, DEFAULT_OPTIONS, options);\n  this.container = $el;\n\n  this._createScrollButtons($el, options);\n\n  this._bindEvents($el);\n}\n\ninherits(ScrollTabs, EventEmitter);\n\n\n/**\n * Create a clickable scroll button\n *\n * @param {Object} options\n * @param {String} options.className\n * @param {String} options.label\n * @param {Number} options.direction\n *\n * @return {DOMElement} The created scroll button node\n */\nScrollTabs.prototype._createButton = function(parentNode, options) {\n\n  var className = options.className,\n      direction = options.direction;\n\n\n  var button = domQuery('.' + className, parentNode);\n\n  if (!button) {\n    button = domify('<span class=\"scroll-tabs-button ' + className + '\">' +\n                                options.label +\n                              '</span>');\n\n    parentNode.insertBefore(button, parentNode.childNodes[0]);\n  }\n\n  domAttr(button, 'data-direction', direction);\n\n  return button;\n};\n\n/**\n * Create both scroll buttons\n *\n * @param  {DOMElement} parentNode\n * @param  {Object} options\n * @param  {String} options.scrollSymbolLeft\n * @param  {String} options.scrollSymbolRight\n */\nScrollTabs.prototype._createScrollButtons = function(parentNode, options) {\n\n  // Create a button that scrolls to the tab left to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-left',\n    label: options.scrollSymbolLeft,\n    direction: -1\n  });\n\n  // Create a button that scrolls to the tab right to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-right',\n    label: options.scrollSymbolRight,\n    direction: 1\n  });\n};\n\n/**\n * Get the current active tab\n *\n * @return {DOMElement}\n */\nScrollTabs.prototype.getActiveTabNode = function() {\n  return domQuery(this.options.selectors.active, this.container);\n};\n\n\n/**\n * Get the container all tabs are contained in\n *\n * @return {DOMElement}\n */\nScrollTabs.prototype.getTabsContainerNode = function () {\n  return domQuery(this.options.selectors.tabsContainer, this.container);\n};\n\n\n/**\n * Get all tabs (visible and invisible ones)\n *\n * @return {Array<DOMElement>}\n */\nScrollTabs.prototype.getAllTabNodes = function () {\n  return domQuery.all(this.options.selectors.tab, this.container);\n};\n\n\n/**\n * Gets all tabs that don't have the ignore class set\n *\n * @return {Array<DOMElement>}\n */\nScrollTabs.prototype.getVisibleTabs = function() {\n  var allTabs = this.getAllTabNodes();\n\n  var ignore = this.options.selectors.ignore;\n\n  return filter(allTabs, function(tabNode) {\n    return !domMatches(tabNode, ignore);\n  });\n};\n\n\n/**\n * Get a tab relative to a reference tab.\n *\n * @param  {DOMElement} referenceTabNode\n * @param  {Number} n gets the nth tab next or previous to the reference tab\n *\n * @return {DOMElement}\n *\n * @example:\n * Visible tabs: [ A | B | C | D | E ]\n * Assume tab 'C' is the reference tab:\n * If direction === -1, it returns tab 'B',\n * if direction ===  2, it returns tab 'E'\n */\nScrollTabs.prototype.getAdjacentTab = function(referenceTabNode, n) {\n  var visibleTabs = this.getVisibleTabs();\n\n  var index = visibleTabs.indexOf(referenceTabNode);\n\n  return visibleTabs[index + n];\n};\n\nScrollTabs.prototype._bindEvents = function(node) {\n  this._bindWheelEvent(node);\n  this._bindTabClickEvents(node);\n  this._bindScrollButtonEvents(node);\n};\n\n/**\n *  Bind a click listener to a DOM node.\n *  Make sure a tab link is entirely visible after onClick.\n *\n * @param {DOMElement} node\n */\nScrollTabs.prototype._bindTabClickEvents = function(node) {\n  var selector = this.options.selectors.tab;\n\n  var self = this;\n\n  domDelegate.bind(node, selector, 'click', function onClick(event) {\n    self.scrollToTabNode(event.delegateTarget);\n  });\n};\n\n\n/**\n * Bind the wheel event listener to a DOM node\n *\n * @param {DOMElement} node\n */\nScrollTabs.prototype._bindWheelEvent = function(node) {\n  var self = this;\n\n  domEvent.bind(node, 'wheel', function(e) {\n\n    // scroll direction (-1: left, 1: right)\n    var direction = Math.sign(e.deltaY);\n\n    var oldActiveTab = self.getActiveTabNode();\n\n    var newActiveTab = self.getAdjacentTab(oldActiveTab, direction);\n\n    if (newActiveTab) {\n      self.scrollToTabNode(newActiveTab);\n      self.emit('scroll', newActiveTab, oldActiveTab, direction);\n    }\n\n    e.preventDefault();\n  });\n};\n\n/**\n * Bind scroll button events to a DOM node\n *\n * @param  {DOMElement} node\n */\nScrollTabs.prototype._bindScrollButtonEvents = function(node) {\n\n  var self = this;\n\n  domDelegate.bind(node, '.scroll-tabs-button', 'click', function(event) {\n\n    var target = event.delegateTarget;\n\n    // data-direction is either -1 or 1\n    var direction = parseInt(domAttr(target, 'data-direction'), 10);\n\n    var oldActiveTabNode = self.getActiveTabNode();\n\n    var newActiveTabNode = self.getAdjacentTab(oldActiveTabNode, direction);\n\n    if (newActiveTabNode) {\n      self.scrollToTabNode(newActiveTabNode);\n      self.emit('scroll', newActiveTabNode, oldActiveTabNode, direction);\n    }\n\n    event.preventDefault();\n  });\n};\n\n\n/**\n* Scroll to a tab if it is not entirely visible\n*\n* @param  {DOMElement} tabNode tab node to scroll to\n*/\nScrollTabs.prototype.scrollToTabNode = function(tabNode) {\n  if (!tabNode) {\n    return;\n  }\n\n  var tabsContainerNode = tabNode.parentNode;\n\n  var tabWidth = tabNode.offsetWidth,\n      tabOffsetLeft = tabNode.offsetLeft,\n      tabOffsetRight = tabOffsetLeft + tabWidth,\n      containerWidth = tabsContainerNode.offsetWidth,\n      containerScrollLeft = tabsContainerNode.scrollLeft;\n\n  if (containerScrollLeft > tabOffsetLeft) {\n    // scroll to the left, if the tab is overflowing on the left side\n    tabsContainerNode.scrollLeft = 0;\n  } else if (tabOffsetRight > containerWidth) {\n    // scroll to the right, if the tab is overflowing on the right side\n    tabsContainerNode.scrollLeft = tabOffsetRight - containerWidth;\n  }\n};\n\n\n/**\n * React on tab changes from outside (resize/show/hide/add/remove),\n * update scroll button visibility.\n */\nScrollTabs.prototype.update = function() {\n\n  var tabsContainerNode = this.getTabsContainerNode();\n\n  // check if tabs fit in container\n  var overflow = tabsContainerNode.scrollWidth > tabsContainerNode.offsetWidth;\n\n  // TODO(nikku): distinguish overflow left / overflow right?\n  var overflowClass = 'scroll-tabs-overflow';\n\n  domClasses(this.container).toggle(overflowClass, overflow);\n\n  if (overflow) {\n    // make sure the current active tab is always visible\n    this.scrollToTabNode(this.getActiveTabNode());\n  }\n};\n\n\n////// module exports /////////////////////////////////////////\n\n/**\n * Create a scrollTabs instance on the given element.\n *\n * @param {DOMElement} $el\n * @param {Object} options\n *\n * @return {ScrollTabs}\n */\nfunction create($el, options) {\n\n  var scrollTabs = get($el);\n\n  if (!scrollTabs) {\n    scrollTabs = new ScrollTabs($el, options);\n\n    $el.__scrollTabs = scrollTabs;\n  }\n\n  return scrollTabs;\n}\n\n/**\n * Factory function to get or create a new scroll tabs instance.\n */\nmodule.exports = create;\n\n\n/**\n * Return the scrollTabs instance that has been previously\n * initialized on the element.\n *\n * @param {DOMElement} $el\n * @return {ScrollTabs}\n */\nfunction get($el) {\n  return $el.__scrollTabs;\n}\n\n/**\n * Getter to retrieve an already initialized scroll tabs instance.\n */\nmodule.exports.get = get;","'use strict';\n\n/**\n * Calculate the selection update for the given\n * current and new input values.\n *\n * @param {Object} currentSelection as {start, end}\n * @param {String} currentValue\n * @param {String} newValue\n *\n * @return {Object} newSelection as {start, end}\n */\nfunction calculateUpdate(currentSelection, currentValue, newValue) {\n\n  var currentCursor = currentSelection.start,\n      newCursor = currentCursor,\n      diff = newValue.length - currentValue.length,\n      idx;\n\n  var lengthDelta = newValue.length - currentValue.length;\n\n  var currentTail = currentValue.substring(currentCursor);\n\n  // check if we can remove common ending from the equation\n  // to be able to properly detect a selection change for\n  // the following scenarios:\n  //\n  //  * (AAATTT|TF) => (AAAT|TF)\n  //  * (AAAT|TF) =>  (AAATTT|TF)\n  //\n  if (newValue.lastIndexOf(currentTail) === newValue.length - currentTail.length) {\n    currentValue = currentValue.substring(0, currentValue.length - currentTail.length);\n    newValue = newValue.substring(0, newValue.length - currentTail.length);\n  }\n\n  // diff\n  var diff = createDiff(currentValue, newValue);\n\n  if (diff) {\n    if (diff.type === 'remove') {\n      newCursor = diff.newStart;\n    } else {\n      newCursor = diff.newEnd;\n    }\n  }\n\n  return range(newCursor);\n}\n\nmodule.exports = calculateUpdate;\n\n\nfunction createDiff(currentValue, newValue) {\n\n  var insert;\n\n  var l_str, l_char, l_idx = 0,\n      s_str, s_char, s_idx = 0;\n\n  if (newValue.length > currentValue.length) {\n    l_str = newValue;\n    s_str = currentValue;\n  } else {\n    l_str = currentValue;\n    s_str = newValue;\n  }\n\n  // assume there will be only one insert / remove and\n  // detect that _first_ edit operation only\n  while (l_idx < l_str.length) {\n\n    l_char = l_str.charAt(l_idx);\n    s_char = s_str.charAt(s_idx);\n\n    // chars no not equal\n    if (l_char !== s_char) {\n\n      if (!insert) {\n        insert = {\n          l_start: l_idx,\n          s_start: s_idx\n        };\n      }\n\n      l_idx++;\n    }\n\n    // chars equal (again?)\n    else {\n\n      if (insert && !insert.complete) {\n        insert.l_end = l_idx;\n        insert.s_end = s_idx;\n        insert.complete = true;\n      }\n\n      s_idx++;\n      l_idx++;\n    }\n  }\n\n  if (insert && !insert.complete) {\n    insert.complete = true;\n    insert.s_end = s_str.length;\n    insert.l_end = l_str.length;\n  }\n\n  // no diff\n  if (!insert) {\n    return;\n  }\n\n  if (newValue.length > currentValue.length) {\n    return {\n      newStart: insert.l_start,\n      newEnd: insert.l_end,\n      type: 'add'\n    };\n  } else {\n    return {\n      newStart: insert.s_start,\n      newEnd: insert.s_end,\n      type: newValue.length < currentValue.length ? 'remove' : 'replace'\n    };\n  }\n}\n\n/**\n * Utility method for creating a new selection range {start, end} object.\n *\n * @param {Number} start\n * @param {Number} [end]\n *\n * @return {Object} selection range as {start, end}\n */\nfunction range(start, end) {\n  return {\n    start: start,\n    end: end === undefined ? start : end\n  };\n}\n\nmodule.exports.range = range;\n\n\nfunction splitStr(str, position) {\n  return {\n    before: str.substring(0, position),\n    after: str.substring(position)\n  };\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require(363).EventEmitter;\nvar inherits = require(368);\n\ninherits(Stream, EE);\nStream.Readable = require(567);\nStream.Writable = require(569);\nStream.Duplex = require(556);\nStream.Transform = require(568);\nStream.PassThrough = require(566);\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require(180).Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","/**\n * Tiny stack for browser or server\n *\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\n * @copyright 2014 Jason Mulligan\n * @license BSD-3 <https://raw.github.com/avoidwork/tiny-stack/master/LICENSE>\n * @link http://avoidwork.github.io/tiny-stack\n * @module tiny-stack\n * @version 0.1.0\n */\n\n( function ( global ) {\n\n\"use strict\";\n\n/**\n * TinyStack\n *\n * @constructor\n */\nfunction TinyStack () {\n\tthis.data = [null];\n\tthis.top  = 0;\n}\n\n/**\n * Clears the stack\n *\n * @method clear\n * @memberOf TinyStack\n * @return {Object} {@link TinyStack}\n */\nTinyStack.prototype.clear = function clear () {\n\tthis.data = [null];\n\tthis.top  = 0;\n\n\treturn this;\n};\n\n/**\n * Gets the size of the stack\n *\n * @method length\n * @memberOf TinyStack\n * @return {Number} Size of stack\n */\nTinyStack.prototype.length = function length () {\n\treturn this.top;\n};\n\n/**\n * Gets the item at the top of the stack\n *\n * @method peek\n * @memberOf TinyStack\n * @return {Mixed} Item at the top of the stack\n */\nTinyStack.prototype.peek = function peek () {\n\treturn this.data[this.top];\n};\n\n/**\n * Gets & removes the item at the top of the stack\n *\n * @method pop\n * @memberOf TinyStack\n * @return {Mixed} Item at the top of the stack\n */\nTinyStack.prototype.pop = function pop () {\n\tif ( this.top > 0 ) {\n\t\tthis.top--;\n\n\t\treturn this.data.pop();\n\t}\n\telse {\n\t\treturn undefined;\n\t}\n};\n\n/**\n * Pushes an item onto the stack\n *\n * @method push\n * @memberOf TinyStack\n * @return {Object} {@link TinyStack}\n */\nTinyStack.prototype.push = function push ( arg ) {\n\tthis.data[++this.top] = arg;\n\n\treturn this;\n};\n\n/**\n * TinyStack factory\n *\n * @method factory\n * @return {Object} {@link TinyStack}\n */\nfunction factory () {\n\treturn new TinyStack();\n}\n\n// Node, AMD & window supported\nif ( typeof exports != \"undefined\" ) {\n\tmodule.exports = factory;\n}\nelse if ( typeof define == \"function\" ) {\n\tdefine( function () {\n\t\treturn factory;\n\t} );\n}\nelse {\n\tglobal.stack = factory;\n}\n} )( this );\n","/**\n * append utility\n */\n\nmodule.exports = append;\n\nvar appendTo = require(578);\n\n/**\n * Append a node to an element\n *\n * @param  {SVGElement} element\n * @param  {SVGElement} node\n *\n * @return {SVGElement} the element\n */\nfunction append(element, node) {\n  appendTo(node, element);\n  return element;\n}","/**\n * appendTo utility\n */\nmodule.exports = appendTo;\n\nvar ensureImported = require(588);\n\n/**\n * Append a node to a target element and return the appended node.\n *\n * @param  {SVGElement} element\n * @param  {SVGElement} node\n *\n * @return {SVGElement} the appended node\n */\nfunction appendTo(element, target) {\n  target.appendChild(ensureImported(element, target));\n  return element;\n}","/**\n * attribute accessor utility\n */\n\nmodule.exports = attr;\n\n\nvar LENGTH_ATTR = 2;\n\nvar CSS_PROPERTIES = {\n  'alignment-baseline': 1,\n  'baseline-shift': 1,\n  'clip': 1,\n  'clip-path': 1,\n  'clip-rule': 1,\n  'color': 1,\n  'color-interpolation': 1,\n  'color-interpolation-filters': 1,\n  'color-profile': 1,\n  'color-rendering': 1,\n  'cursor': 1,\n  'direction': 1,\n  'display': 1,\n  'dominant-baseline': 1,\n  'enable-background': 1,\n  'fill': 1,\n  'fill-opacity': 1,\n  'fill-rule': 1,\n  'filter': 1,\n  'flood-color': 1,\n  'flood-opacity': 1,\n  'font': 1,\n  'font-family': 1,\n  'font-size': LENGTH_ATTR,\n  'font-size-adjust': 1,\n  'font-stretch': 1,\n  'font-style': 1,\n  'font-variant': 1,\n  'font-weight': 1,\n  'glyph-orientation-horizontal': 1,\n  'glyph-orientation-vertical': 1,\n  'image-rendering': 1,\n  'kerning': 1,\n  'letter-spacing': 1,\n  'lighting-color': 1,\n  'marker': 1,\n  'marker-end': 1,\n  'marker-mid': 1,\n  'marker-start': 1,\n  'mask': 1,\n  'opacity': 1,\n  'overflow': 1,\n  'pointer-events': 1,\n  'shape-rendering': 1,\n  'stop-color': 1,\n  'stop-opacity': 1,\n  'stroke': 1,\n  'stroke-dasharray': 1,\n  'stroke-dashoffset': 1,\n  'stroke-linecap': 1,\n  'stroke-linejoin': 1,\n  'stroke-miterlimit': 1,\n  'stroke-opacity': 1,\n  'stroke-width': LENGTH_ATTR,\n  'text-anchor': 1,\n  'text-decoration': 1,\n  'text-rendering': 1,\n  'unicode-bidi': 1,\n  'visibility': 1,\n  'word-spacing': 1,\n  'writing-mode': 1\n};\n\n\nfunction getAttribute(node, name) {\n  if (CSS_PROPERTIES[name]) {\n    return node.style[name];\n  } else {\n    return node.getAttributeNS(null, name);\n  }\n}\n\nfunction setAttribute(node, name, value) {\n  var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n  var type = CSS_PROPERTIES[hyphenated];\n\n  if (type) {\n    // append pixel unit, unless present\n    if (type === LENGTH_ATTR && typeof value === 'number') {\n      value = String(value) + 'px';\n    }\n\n    node.style[hyphenated] = value;\n  } else {\n    node.setAttributeNS(null, name, value);\n  }\n}\n\nfunction setAttributes(node, attrs) {\n\n  var names = Object.keys(attrs), i, name;\n\n  for (i = 0, name; (name = names[i]); i++) {\n    setAttribute(node, name, attrs[name]);\n  }\n}\n\n/**\n * Gets or sets raw attributes on a node.\n *\n * @param  {SVGElement} node\n * @param  {Object} [attrs]\n * @param  {String} [name]\n * @param  {String} [value]\n *\n * @return {String}\n */\nfunction attr(node, name, value) {\n  if (typeof name === 'string') {\n    if (value !== undefined) {\n      setAttribute(node, name, value);\n    } else {\n      return getAttribute(node, name);\n    }\n  } else {\n    setAttributes(node, name);\n  }\n\n  return node;\n}\n","/**\r\n * Clear utility\r\n */\r\nmodule.exports = classes;\r\n\r\nvar index = function(arr, obj) {\r\n  if (arr.indexOf) {\r\n    return arr.indexOf(obj);\r\n  }\r\n\r\n\r\n  for (var i = 0; i < arr.length; ++i) {\r\n    if (arr[i] === obj) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n};\r\n\r\nvar re = //s+/;\r\n\r\nvar toString = Object.prototype.toString;\r\n\r\nfunction defined(o) {\r\n  return typeof o !== 'undefined';\r\n}\r\n\r\n/**\r\n * Wrap `el` in a `ClassList`.\r\n *\r\n * @param {Element} el\r\n * @return {ClassList}\r\n * @api public\r\n */\r\n\r\nfunction classes(el) {\r\n  return new ClassList(el);\r\n}\r\n\r\nfunction ClassList(el) {\r\n  if (!el || !el.nodeType) {\r\n    throw new Error('A DOM element reference is required');\r\n  }\r\n  this.el = el;\r\n  this.list = el.classList;\r\n}\r\n\r\n/**\r\n * Add class `name` if not already present.\r\n *\r\n * @param {String} name\r\n * @return {ClassList}\r\n * @api public\r\n */\r\n\r\nClassList.prototype.add = function(name) {\r\n\r\n  // classList\r\n  if (this.list) {\r\n    this.list.add(name);\r\n    return this;\r\n  }\r\n\r\n  // fallback\r\n  var arr = this.array();\r\n  var i = index(arr, name);\r\n  if (!~i) {\r\n    arr.push(name);\r\n  }\r\n\r\n  if (defined(this.el.className.baseVal)) {\r\n    this.el.className.baseVal = arr.join(' ');\r\n  } else {\r\n    this.el.className = arr.join(' ');\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove class `name` when present, or\r\n * pass a regular expression to remove\r\n * any which match.\r\n *\r\n * @param {String|RegExp} name\r\n * @return {ClassList}\r\n * @api public\r\n */\r\n\r\nClassList.prototype.remove = function(name) {\r\n  if ('[object RegExp]' === toString.call(name)) {\r\n    return this.removeMatching(name);\r\n  }\r\n\r\n  // classList\r\n  if (this.list) {\r\n    this.list.remove(name);\r\n    return this;\r\n  }\r\n\r\n  // fallback\r\n  var arr = this.array();\r\n  var i = index(arr, name);\r\n  if (~i) {\r\n    arr.splice(i, 1);\r\n  }\r\n  this.el.className.baseVal = arr.join(' ');\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove all classes matching `re`.\r\n *\r\n * @param {RegExp} re\r\n * @return {ClassList}\r\n * @api private\r\n */\r\n\r\nClassList.prototype.removeMatching = function(re) {\r\n  var arr = this.array();\r\n  for (var i = 0; i < arr.length; i++) {\r\n    if (re.test(arr[i])) {\r\n      this.remove(arr[i]);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Toggle class `name`, can force state via `force`.\r\n *\r\n * For browsers that support classList, but do not support `force` yet,\r\n * the mistake will be detected and corrected.\r\n *\r\n * @param {String} name\r\n * @param {Boolean} force\r\n * @return {ClassList}\r\n * @api public\r\n */\r\n\r\nClassList.prototype.toggle = function(name, force) {\r\n  // classList\r\n  if (this.list) {\r\n    if (defined(force)) {\r\n      if (force !== this.list.toggle(name, force)) {\r\n        this.list.toggle(name); // toggle again to correct\r\n      }\r\n    } else {\r\n      this.list.toggle(name);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  // fallback\r\n  if (defined(force)) {\r\n    if (!force) {\r\n      this.remove(name);\r\n    } else {\r\n      this.add(name);\r\n    }\r\n  } else {\r\n    if (this.has(name)) {\r\n      this.remove(name);\r\n    } else {\r\n      this.add(name);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return an array of classes.\r\n *\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nClassList.prototype.array = function() {\r\n  var className = this.el.getAttribute('class') || '';\r\n  var str = className.replace(/^/s+|/s+$/g, '');\r\n  var arr = str.split(re);\r\n  if ('' === arr[0]) {\r\n    arr.shift();\r\n  }\r\n  return arr;\r\n};\r\n\r\n/**\r\n * Check if class `name` is present.\r\n *\r\n * @param {String} name\r\n * @return {ClassList}\r\n * @api public\r\n */\r\n\r\nClassList.prototype.has =\r\nClassList.prototype.contains = function(name) {\r\n  return (\r\n    this.list ?\r\n      this.list.contains(name) :\r\n      !! ~index(this.array(), name)\r\n  );\r\n};\r\n","/**\n * Clear utility\n */\n\nmodule.exports = clear;\n\n\nvar remove = require(586);\n\n/**\n * Removes all children from the given element\n *\n * @param  {DOMElement} element\n * @return {DOMElement} the element (for chaining)\n */\nfunction clear(element) {\n  var child;\n\n  while ((child = element.firstChild)) {\n    remove(child);\n  }\n\n  return element;\n}","module.exports = clone;\n\nfunction clone(element) {\n  return element.cloneNode(true);\n}","/**\n * Create utility for SVG elements\n */\n\nmodule.exports = create;\n\n\nvar attr = require(579);\nvar parse = require(590);\nvar ns = require(589);\n\n\n/**\n * Create a specific type from name or SVG markup.\n *\n * @param {String} name the name or markup of the element\n * @param {Object} [attrs] attributes to set on the element\n *\n * @returns {SVGElement}\n */\nfunction create(name, attrs) {\n  var element;\n\n  if (name.charAt(0) === '<') {\n    element = parse(name).firstChild;\n    element = document.importNode(element, true);\n  } else {\n    element = document.createElementNS(ns.svg, name);\n  }\n\n  if (attrs) {\n    attr(element, attrs);\n  }\n\n  return element;\n}","/**\n * Geometry helpers\n */\n\n\nvar create = require(583);\n\n// fake node used to instantiate svg geometry elements\nvar node = create('svg');\n\nfunction extend(object, props) {\n  var i, k, keys = Object.keys(props);\n\n  for (i = 0; (k = keys[i]); i++) {\n    object[k] = props[k];\n  }\n\n  return object;\n}\n\n\nfunction createPoint(x, y) {\n  var point = node.createSVGPoint();\n\n  switch (arguments.length) {\n  case 0:\n    return point;\n  case 2:\n    x = {\n      x: x,\n      y: y\n    };\n    break;\n  }\n\n  return extend(point, x);\n}\n\nfunction createMatrix(a, b, c, d, e, f) {\n  var matrix = node.createSVGMatrix();\n\n  switch (arguments.length) {\n  case 0:\n    return matrix;\n  case 6:\n    a = {\n      a: a,\n      b: b,\n      c: c,\n      d: d,\n      e: e,\n      f: f\n    };\n    break;\n  }\n\n  return extend(matrix, a);\n}\n\nfunction createTransform(matrix) {\n  if (matrix) {\n    return node.createSVGTransformFromMatrix(matrix);\n  } else {\n    return node.createSVGTransform();\n  }\n}\n\n\nmodule.exports.createTransform = createTransform;\nmodule.exports.createMatrix = createMatrix;\nmodule.exports.createPoint = createPoint;","/**\n * innerHTML like functionality for SVG elements.\n * based on innerSVG (https://code.google.com/p/innersvg)\n */\n\nmodule.exports = innerSVG;\n\n\nvar clear = require(581);\nvar appendTo = require(578);\nvar parse = require(590);\nvar serialize = require(591);\n\n\nfunction set(element, svg) {\n\n  var node,\n      documentElement = parse(svg).documentElement;\n\n  // clear element contents\n  clear(element);\n\n  if (!svg) {\n    return;\n  }\n\n  // import + append each node\n  node = documentElement.firstChild;\n\n  while (node) {\n    appendTo(node, element);\n    node = node.nextSibling;\n  }\n}\n\nfunction get(element) {\n  var child = element.firstChild,\n      output = [];\n\n  while (child) {\n    serialize(child, output);\n    child = child.nextSibling;\n  }\n\n  return output.join('');\n}\n\nfunction innerSVG(element, svg) {\n\n  if (svg !== undefined) {\n\n    try {\n      set(element, svg);\n    } catch (e) {\n      throw new Error('error parsing SVG: ' + e.message);\n    }\n\n    return element;\n  } else {\n    return get(element);\n  }\n}","module.exports = remove;\n\nfunction remove(element) {\n  var parent = element.parentNode;\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n\n  return element;\n}","/**\n * transform accessor utility\n */\n\nmodule.exports = transform;\n\nfunction wrapMatrix(transformList, transform) {\n  if (transform instanceof SVGMatrix) {\n    return transformList.createSVGTransformFromMatrix(transform);\n  } else {\n    return transform;\n  }\n}\n\nfunction setTransforms(transformList, transforms) {\n  var i, t;\n\n  transformList.clear();\n\n  for (i = 0; (t = transforms[i]); i++) {\n    transformList.appendItem(wrapMatrix(transformList, t));\n  }\n\n  transformList.consolidate();\n}\n\nfunction transform(node, transforms) {\n  var transformList = node.transform.baseVal;\n\n  if (arguments.length === 1) {\n    return transformList.consolidate();\n  } else {\n    if (transforms.length) {\n      setTransforms(transformList, transforms);\n    } else {\n      transformList.initialize(wrapMatrix(transformList, transforms));\n    }\n  }\n}","module.exports = ensureImported;\n\nfunction ensureImported(element, target) {\n\n  if (element.ownerDocument !== target.ownerDocument) {\n    try {\n      // may fail on webkit\n      return target.ownerDocument.importNode(element, true);\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  return element;\n}","var ns = {\n  svg: 'http://www.w3.org/2000/svg'\n};\n\nmodule.exports = ns;","/**\n * DOM parsing utility\n */\n\nmodule.exports = parse;\n\n\nvar ns = require(589);\n\nvar SVG_START = '<svg xmlns=\"' + ns.svg + '\"';\n\nfunction parse(svg) {\n\n  // ensure we import a valid svg document\n  if (svg.substring(0, 4) === '<svg') {\n    if (svg.indexOf(ns.svg) === -1) {\n      svg = SVG_START + svg.substring(4);\n    }\n  } else {\n    // namespace svg\n    svg = SVG_START + '>' + svg + '</svg>';\n  }\n\n  return parseDocument(svg);\n}\n\nfunction parseDocument(svg) {\n\n  var parser;\n\n  // parse\n  parser = new DOMParser();\n  parser.async = false;\n\n  return parser.parseFromString(svg, 'text/xml');\n}","/**\n * Serialization util\n */\n\nmodule.exports = serialize;\n\n\nvar TEXT_ENTITIES = /([&<>]{1})/g;\nvar ATTR_ENTITIES = /([/n/r\"]{1})/g;\n\nvar ENTITY_REPLACEMENT = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '/''\n};\n\nfunction escape(str, pattern) {\n\n  function replaceFn(match, entity) {\n    return ENTITY_REPLACEMENT[entity] || entity;\n  }\n\n  return str.replace(pattern, replaceFn);\n}\n\nfunction serialize(node, output) {\n\n  var i, len, attrMap, attrNode, childNodes;\n\n  switch (node.nodeType) {\n  // TEXT\n  case 3:\n    // replace special XML characters\n    output.push(escape(node.textContent, TEXT_ENTITIES));\n    break;\n\n  // ELEMENT\n  case 1:\n    output.push('<', node.tagName);\n\n    if (node.hasAttributes()) {\n      attrMap = node.attributes;\n      for (i = 0, len = attrMap.length; i < len; ++i) {\n        attrNode = attrMap.item(i);\n        output.push(' ', attrNode.name, '=\"', escape(attrNode.value, ATTR_ENTITIES), '\"');\n      }\n    }\n\n    if (node.hasChildNodes()) {\n      output.push('>');\n      childNodes = node.childNodes;\n      for (i = 0, len = childNodes.length; i < len; ++i) {\n        serialize(childNodes.item(i), output);\n      }\n      output.push('</', node.tagName, '>');\n    } else {\n      output.push('/>');\n    }\n    break;\n\n  // COMMENT\n  case 8:\n    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');\n    break;\n\n  // CDATA\n  case 4:\n    output.push('<![CDATA[', node.nodeValue, ']]>');\n    break;\n\n  default:\n    throw new Error('unable to handle node ' + node.nodeType);\n  }\n\n  return output;\n}","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n"]}